<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>Java8 Stream 教程 | ihadu</title><meta name="author" content="ihadu"><meta name="copyright" content="ihadu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java 8 数据流教程 数据流如何工作 数据流表示元素的序列，并支持不同种类的操作来执行元素上的计算： List&lt;String&gt; myList &#x3D;    Arrays.asList(&quot;a1&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;c2&quot;, &quot;c1&quot;);myList    .stream()"><meta property="og:type" content="article"><meta property="og:title" content="Java8 Stream 教程"><meta property="og:url" content="https://nivbi.com/posts/1c02b8ff.html"><meta property="og:site_name" content="ihadu"><meta property="og:description" content="Java 8 数据流教程 数据流如何工作 数据流表示元素的序列，并支持不同种类的操作来执行元素上的计算： List&lt;String&gt; myList &#x3D;    Arrays.asList(&quot;a1&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;c2&quot;, &quot;c1&quot;);myList    .stream()"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://oss.kiscloud.net/image/user/anime/Chainsaw/wallhaven-jxy6vp_1920x1080.webp"><meta property="article:published_time" content="2023-08-29T09:05:29.000Z"><meta property="article:modified_time" content="2023-08-31T03:01:27.615Z"><meta property="article:author" content="ihadu"><meta property="article:tag" content="blog"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://oss.kiscloud.net/image/user/anime/Chainsaw/wallhaven-jxy6vp_1920x1080.webp"><link rel="shortcut icon" href="/images/dog.png"><link rel="canonical" href="https://nivbi.com/posts/1c02b8ff.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="h-TVRSWVCnbA8LDyXZkYIrIJ4pr1OUAgVfR5h2H4Eok"><meta name="baidu-site-verification" content="codeva-V4Yhtugi3b"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?546017bccd857b94cdaba2806f36802a",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)}()</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"bottom-left"},source:{justifiedGallery:{js:"https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js",css:"https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Java8 Stream 教程",isPost:!0,isHome:!1,isHighlightShrink:!0,isToc:!0,postUpdate:"2023-08-31 11:01:27"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,t={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(t)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.getCSS=(o,n=!1)=>new Promise((t,e)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=o,n&&(a.id=n),a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><script>window.paceOptions={restartOnPushState:!1},document.addEventListener("pjax:send",()=>{Pace.restart()})</script><link rel="stylesheet" href="/assets/css/flash.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://oss.kiscloud.net/image/user/anime/Chainsaw/qiu.webp" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">236</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">35</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/nav/"><i class="fa-fw fa fa-paper-plane"></i><span> 导航</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-book"></i><span> 教程</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/python/"><i class="fa-fw fa-brands fa-python"></i><span> python教程</span></a></li><li><a class="site-page child" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"><i class="fa-fw fa-solid fa-database"></i><span> 大数据教程</span></a></li><li><a class="site-page child" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><i class="fa-fw fa-solid fa-desktop"></i><span> 机器学习教程</span></a></li><li><a class="site-page child" href="/DeepLearning/"><i class="fa-fw fas fa-video"></i><span> 深度学习教程</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="ihadu"><img class="site-icon" src="/images/sports.webp"></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/nav/"><i class="fa-fw fa fa-paper-plane"></i><span> 导航</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-book"></i><span> 教程</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/python/"><i class="fa-fw fa-brands fa-python"></i><span> python教程</span></a></li><li><a class="site-page child" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"><i class="fa-fw fa-solid fa-database"></i><span> 大数据教程</span></a></li><li><a class="site-page child" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><i class="fa-fw fa-solid fa-desktop"></i><span> 机器学习教程</span></a></li><li><a class="site-page child" href="/DeepLearning/"><i class="fa-fw fas fa-video"></i><span> 深度学习教程</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Java8 Stream 教程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-29T09:05:29.000Z" title="发表于 2023-08-29 17:05:29">2023-08-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-31T03:01:27.615Z" title="更新于 2023-08-31 11:01:27">2023-08-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>24分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="Java8 Stream 教程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/1c02b8ff.html#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/posts/1c02b8ff.html" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div><article class="post-content" id="article-container"><h1>Java 8 数据流教程</h1><h2 id="数据流如何工作">数据流如何工作</h2><p>数据流表示元素的序列，并支持不同种类的操作来执行元素上的计算：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; myList =</span><br><span class="line">    Arrays.asList(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;c2&quot;</span>, <span class="string">&quot;c1&quot;</span>);</span><br><span class="line"></span><br><span class="line">myList</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(s -&gt; s.startsWith(<span class="string">&quot;c&quot;</span>))</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .sorted()</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// C1</span></span><br><span class="line"><span class="comment">// C2</span></span><br></pre></td></tr></table></figure><p>数据流操作要么是衔接操作，要么是终止操作。衔接操作返回数据流，所以我们可以把多个衔接操作不使用分号来链接到一起。终止操作无返回值，或者返回一个不是流的结果。在上面的例子中，<code>filter</code>、<code>map</code>和<code>sorted</code>都是衔接操作，而<code>forEach</code>是终止操作。列表上的所有流式操作请见<a target="_blank" rel="noopener external nofollow noreferrer" href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">数据流的Javadoc</a>。你在上面例子中看到的这种数据流的链式操作也叫作操作流水线。</p><p>多数数据流操作都接受一些lambda表达式参数，函数式接口用来指定操作的具体行为。这些操作的大多数必须是无干扰而且是无状态的。它们是什么意思呢？</p><p>当一个函数不修改数据流的底层数据源，它就是<a target="_blank" rel="noopener external nofollow noreferrer" href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#NonInterference">无干扰的</a>。例如，在上面的例子中，没有任何lambda表达式通过添加或删除集合元素修改<code>myList</code>。</p><p>当一个函数的操作的执行是确定性的，它就是<a target="_blank" rel="noopener external nofollow noreferrer" href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#Statelessness">无状态的</a>。例如，在上面的例子中，没有任何lambda表达式依赖于外部作用域中任何在操作过程中可变的变量或状态。</p><h2 id="数据流的不同类型">数据流的不同类型</h2><p>数据流可以从多种数据源创建，尤其是集合。<code>List</code>和<code>Set</code>支持新方法<code>stream()</code> 和 <code>parallelStream()</code>，来创建串行流或并行流。并行流能够在多个线程上执行操作，它们会在之后的章节中讲到。我们现在来看看串行流：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.asList(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;a3&quot;</span>)</span><br><span class="line">    .stream()</span><br><span class="line">    .findFirst()</span><br><span class="line">    .ifPresent(System.out::println);  <span class="comment">// a1</span></span><br></pre></td></tr></table></figure><p>在对象列表上调用<code>stream()</code>方法会返回一个通常的对象流。但是我们不需要创建一个集合来创建数据流，就像下面那样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;a3&quot;</span>)</span><br><span class="line">    .findFirst()</span><br><span class="line">    .ifPresent(System.out::println);  <span class="comment">// a1</span></span><br></pre></td></tr></table></figure><p>只要使用<code>Stream.of()</code>，就可以从一系列对象引用中创建数据流。</p><p>除了普通的对象数据流，Java8还自带了特殊种类的流，用于处理基本数据类型<code>int</code>、<code>long</code> 和 <code>double</code>。你可能已经猜到了它是<code>IntStream</code>、<code>LongStream</code> 和 <code>DoubleStream</code>。</p><p><code>IntStream</code>可以使用<code>IntStream.range()</code>替换通常的<code>for</code>循环：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>所有这些基本数据流都像通常的对象数据流一样，但有一些不同。基本的数据流使用特殊的lambda表达式，例如，<code>IntFunction</code>而不是<code>Function</code>，<code>IntPredicate</code>而不是<code>Predicate</code>。而且基本数据流支持额外的聚合终止操作<code>sum()</code>和<code>average()</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.stream(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)</span><br><span class="line">    .map(n -&gt; <span class="number">2</span> * n + <span class="number">1</span>)</span><br><span class="line">    .average()</span><br><span class="line">    .ifPresent(System.out::println);  <span class="comment">// 5.0</span></span><br></pre></td></tr></table></figure><p>有时需要将通常的对象数据流转换为基本数据流，或者相反。出于这种目的，对象数据流支持特殊的映射操作<code>mapToInt()</code>、<code>mapToLong()</code> 和 <code>mapToDouble()</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;a3&quot;</span>)</span><br><span class="line">    .map(s -&gt; s.substring(<span class="number">1</span>))</span><br><span class="line">    .mapToInt(Integer::parseInt)</span><br><span class="line">    .max()</span><br><span class="line">    .ifPresent(System.out::println);  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>基本数据流可以通过<code>mapToObj()</code>转换为对象数据流：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    .mapToObj(i -&gt; <span class="string">&quot;a&quot;</span> + i)</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a1</span></span><br><span class="line"><span class="comment">// a2</span></span><br><span class="line"><span class="comment">// a3</span></span><br></pre></td></tr></table></figure><p>下面是组合示例：浮点数据流首先映射为整数数据流，之后映射为字符串的对象数据流：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>)</span><br><span class="line">    .mapToInt(Double::intValue)</span><br><span class="line">    .mapToObj(i -&gt; <span class="string">&quot;a&quot;</span> + i)</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a1</span></span><br><span class="line"><span class="comment">// a2</span></span><br><span class="line"><span class="comment">// a3</span></span><br></pre></td></tr></table></figure><h2 id="处理顺序">处理顺序</h2><p>既然我们已经了解了如何创建并使用不同种类的数据流，让我们深入了解数据流操作在背后如何执行吧。</p><p>衔接操作的一个重要特性就是延迟性。观察下面没有终止操作的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filter: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>执行这段代码时，不向控制台打印任何东西。这是因为衔接操作只在终止操作调用时被执行。</p><p>让我们通过添加终止操作<code>forEach</code>来扩展这个例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filter: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.println(<span class="string">&quot;forEach: &quot;</span> + s));</span><br></pre></td></tr></table></figure><p>执行这段代码会得到如下输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filter:  d2</span><br><span class="line">forEach: d2</span><br><span class="line">filter:  a2</span><br><span class="line">forEach: a2</span><br><span class="line">filter:  b1</span><br><span class="line">forEach: b1</span><br><span class="line">filter:  b3</span><br><span class="line">forEach: b3</span><br><span class="line">filter:  c</span><br><span class="line">forEach: c</span><br></pre></td></tr></table></figure><p>结果的顺序可能出人意料。原始的方法会在数据流的所有元素上，一个接一个地水平执行所有操作。但是每个元素在调用链上垂直移动。第一个字符串<code>&quot;d2&quot;</code>首先经过<code>filter</code>然后是<code>forEach</code>，执行完后才开始处理第二个字符串<code>&quot;a2&quot;</code>。</p><p>这种行为可以减少每个元素上所执行的实际操作数量，就像我们在下个例子中看到的那样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;map: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .anyMatch(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;anyMatch: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.startsWith(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// map:      d2</span></span><br><span class="line"><span class="comment">// anyMatch: D2</span></span><br><span class="line"><span class="comment">// map:      a2</span></span><br><span class="line"><span class="comment">// anyMatch: A2</span></span><br></pre></td></tr></table></figure><p>只要提供的数据元素满足了谓词，<code>anyMatch</code>操作就会返回<code>true</code>。对于第二个传递<code>&quot;A2&quot;</code>的元素，它的结果为真。由于数据流的链式调用是垂直执行的，<code>map</code>这里只需要执行两次。所以<code>map</code>会执行尽可能少的次数，而不是把所有元素都映射一遍。</p><h3 id="为什么顺序如此重要">为什么顺序如此重要</h3><p>下面的例子由两个衔接操作<code>map</code>和<code>filter</code>，以及一个终止操作<code>forEach</code>组成。让我们再来看看这些操作如何执行：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;map: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filter: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.startsWith(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.println(<span class="string">&quot;forEach: &quot;</span> + s));</span><br><span class="line"></span><br><span class="line"><span class="comment">// map:     d2</span></span><br><span class="line"><span class="comment">// filter:  D2</span></span><br><span class="line"><span class="comment">// map:     a2</span></span><br><span class="line"><span class="comment">// filter:  A2</span></span><br><span class="line"><span class="comment">// forEach: A2</span></span><br><span class="line"><span class="comment">// map:     b1</span></span><br><span class="line"><span class="comment">// filter:  B1</span></span><br><span class="line"><span class="comment">// map:     b3</span></span><br><span class="line"><span class="comment">// filter:  B3</span></span><br><span class="line"><span class="comment">// map:     c</span></span><br><span class="line"><span class="comment">// filter:  C</span></span><br></pre></td></tr></table></figure><p>就像你可能猜到的那样，<code>map</code>和<code>filter</code>会对底层集合的每个字符串调用五次，而<code>forEach</code>只会调用一次。</p><p>如果我们调整操作顺序，将<code>filter</code>移动到调用链的顶端，就可以极大减少操作的执行次数:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filter: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.startsWith(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;map: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.println(<span class="string">&quot;forEach: &quot;</span> + s));</span><br><span class="line"></span><br><span class="line"><span class="comment">// filter:  d2</span></span><br><span class="line"><span class="comment">// filter:  a2</span></span><br><span class="line"><span class="comment">// map:     a2</span></span><br><span class="line"><span class="comment">// forEach: A2</span></span><br><span class="line"><span class="comment">// filter:  b1</span></span><br><span class="line"><span class="comment">// filter:  b3</span></span><br><span class="line"><span class="comment">// filter:  c</span></span><br></pre></td></tr></table></figure><p>现在，<code>map</code>只会调用一次，所以操作流水线对于更多的输入元素会执行更快。在整合复杂的方法链时，要记住这一点。</p><p>让我们通过添加额外的方法<code>sorted</code>来扩展上面的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">    .sorted((s1, s2) -&gt; &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;sort: %s; %s\n&quot;</span>, s1, s2);</span><br><span class="line">        <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">    &#125;)</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filter: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.startsWith(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;map: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.println(<span class="string">&quot;forEach: &quot;</span> + s));</span><br></pre></td></tr></table></figure><p>排序是一类特殊的衔接操作。它是有状态的操作，因为你需要在处理中保存状态来对集合中的元素排序。</p><p>执行这个例子会得到如下输入：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sort:    a2; d2</span><br><span class="line">sort:    b1; a2</span><br><span class="line">sort:    b1; d2</span><br><span class="line">sort:    b1; a2</span><br><span class="line">sort:    b3; b1</span><br><span class="line">sort:    b3; d2</span><br><span class="line">sort:    c; b3</span><br><span class="line">sort:    c; d2</span><br><span class="line">filter:  a2</span><br><span class="line">map:     a2</span><br><span class="line">forEach: A2</span><br><span class="line">filter:  b1</span><br><span class="line">filter:  b3</span><br><span class="line">filter:  c</span><br><span class="line">filter:  d2</span><br></pre></td></tr></table></figure><p>首先，排序操作在整个输入集合上执行。也就是说，<code>sorted</code>以水平方式执行。所以这里<code>sorted</code>对输入集合中每个元素的多种组合调用了八次。</p><p>我们同样可以通过重排调用链来优化性能：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filter: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.startsWith(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .sorted((s1, s2) -&gt; &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;sort: %s; %s\n&quot;</span>, s1, s2);</span><br><span class="line">        <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;map: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.println(<span class="string">&quot;forEach: &quot;</span> + s));</span><br><span class="line"></span><br><span class="line"><span class="comment">// filter:  d2</span></span><br><span class="line"><span class="comment">// filter:  a2</span></span><br><span class="line"><span class="comment">// filter:  b1</span></span><br><span class="line"><span class="comment">// filter:  b3</span></span><br><span class="line"><span class="comment">// filter:  c</span></span><br><span class="line"><span class="comment">// map:     a2</span></span><br><span class="line"><span class="comment">// forEach: A2</span></span><br></pre></td></tr></table></figure><p>这个例子中<code>sorted</code>永远不会调用，因为<code>filter</code>把输入集合减少至只有一个元素。所以对于更大的输入集合会极大提升性能。</p><h2 id="复用数据流">复用数据流</h2><p>Java8的数据流不能被复用。一旦你调用了任何终止操作，数据流就关闭了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream =</span><br><span class="line">    Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">        .filter(s -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line">stream.anyMatch(s -&gt; <span class="literal">true</span>);    <span class="comment">// ok</span></span><br><span class="line">stream.noneMatch(s -&gt; <span class="literal">true</span>);   <span class="comment">// exception</span></span><br></pre></td></tr></table></figure><p>在相同数据流上，在<code>anyMatch</code>之后调用<code>noneMatch</code>会产生下面的异常：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalStateException: stream has already been operated upon or closed</span><br><span class="line">    at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:229)</span><br><span class="line">    at java.util.stream.ReferencePipeline.noneMatch(ReferencePipeline.java:459)</span><br><span class="line">    at com.winterbe.java8.Streams5.test7(Streams5.java:38)</span><br><span class="line">    at com.winterbe.java8.Streams5.main(Streams5.java:28)</span><br></pre></td></tr></table></figure><p>要克服这个限制，我们需要为每个我们想要执行的终止操作创建新的数据流调用链。例如，我们创建一个数据流供应器，来构建新的数据流，并且设置好所有衔接操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Supplier&lt;Stream&lt;String&gt;&gt; streamSupplier =</span><br><span class="line">    () -&gt; Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">            .filter(s -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line">streamSupplier.get().anyMatch(s -&gt; <span class="literal">true</span>);   <span class="comment">// ok</span></span><br><span class="line">streamSupplier.get().noneMatch(s -&gt; <span class="literal">true</span>);  <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>每次对<code>get()</code>的调用都构造了一个新的数据流，我们将其保存来调用终止操作。</p><h2 id="高级操作">高级操作</h2><p>数据流执行大量的不同操作。我们已经了解了一些最重要的操作，例如<code>filter</code>和<code>map</code>。我将它们留给你来探索所有其他的可用操作（请见<a target="_blank" rel="noopener external nofollow noreferrer" href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">数据流的Javadoc</a>）。下面让我们深入了解一些更复杂的操作：<code>collect</code>、<code>flatMap</code>和<code>reduce</code>。</p><p>这一节的大部分代码示例使用下面的<code>Person</code>列表来演示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    Person(String name, <span class="type">int</span> age) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; persons =</span><br><span class="line">    Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Max&quot;</span>, <span class="number">18</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Peter&quot;</span>, <span class="number">23</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Pamela&quot;</span>, <span class="number">23</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;David&quot;</span>, <span class="number">12</span>));</span><br></pre></td></tr></table></figure><h3 id="collect"><code>collect</code></h3><p><code>collect</code>是非常有用的终止操作，将流中的元素存放在不同类型的结果中，例如<code>List</code>、<code>Set</code>或者<code>Map</code>。<code>collect</code>接受收集器（Collector），它由四个不同的操作组成：供应器（supplier）、累加器（accumulator）、组合器（combiner）和终止器（finisher）。这在开始听起来十分复杂，但是Java8通过内置的<code>Collectors</code>类支持多种内置的收集器。所以对于大部分常见操作，你并不需要自己实现收集器。</p><p>让我们以一个非常常见的用例来开始：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; filtered =</span><br><span class="line">    persons</span><br><span class="line">        .stream()</span><br><span class="line">        .filter(p -&gt; p.name.startsWith(<span class="string">&quot;P&quot;</span>))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(filtered);    <span class="comment">// [Peter, Pamela]</span></span><br></pre></td></tr></table></figure><p>就像你看到的那样，它非常简单，只是从流的元素中构造了一个列表。如果需要以<code>Set</code>来替代<code>List</code>，只需要使用<code>Collectors.toSet()</code>就好了。</p><p>下面的例子按照年龄对所有人进行分组：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, List&lt;Person&gt;&gt; personsByAge = persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(Collectors.groupingBy(p -&gt; p.age));</span><br><span class="line"></span><br><span class="line">personsByAge</span><br><span class="line">    .forEach((age, p) -&gt; System.out.format(<span class="string">&quot;age %s: %s\n&quot;</span>, age, p));</span><br><span class="line"></span><br><span class="line"><span class="comment">// age 18: [Max]</span></span><br><span class="line"><span class="comment">// age 23: [Peter, Pamela]</span></span><br><span class="line"><span class="comment">// age 12: [David]</span></span><br></pre></td></tr></table></figure><p>收集器十分灵活。你也可以在流的元素上执行聚合，例如，计算所有人的平均年龄：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Double</span> <span class="variable">averageAge</span> <span class="operator">=</span> persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(Collectors.averagingInt(p -&gt; p.age));</span><br><span class="line"></span><br><span class="line">System.out.println(averageAge);     <span class="comment">// 19.0</span></span><br></pre></td></tr></table></figure><p>如果你对更多统计学方法感兴趣，概要收集器返回一个特殊的内置概要统计对象，所以我们可以简单计算最小年龄、最大年龄、算术平均年龄、总和和数量。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">IntSummaryStatistics</span> <span class="variable">ageSummary</span> <span class="operator">=</span></span><br><span class="line">    persons</span><br><span class="line">        .stream()</span><br><span class="line">        .collect(Collectors.summarizingInt(p -&gt; p.age));</span><br><span class="line"></span><br><span class="line">System.out.println(ageSummary);</span><br><span class="line"><span class="comment">// IntSummaryStatistics&#123;count=4, sum=76, min=12, average=19.000000, max=23&#125;</span></span><br></pre></td></tr></table></figure><p>下面的例子将所有人连接为一个字符串：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">phrase</span> <span class="operator">=</span> persons</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(p -&gt; p.age &gt;= <span class="number">18</span>)</span><br><span class="line">    .map(p -&gt; p.name)</span><br><span class="line">    .collect(Collectors.joining(<span class="string">&quot; and &quot;</span>, <span class="string">&quot;In Germany &quot;</span>, <span class="string">&quot; are of legal age.&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(phrase);</span><br><span class="line"><span class="comment">// In Germany Max and Peter and Pamela are of legal age.</span></span><br></pre></td></tr></table></figure><p>连接收集器接受分隔符，以及可选的前缀和后缀。</p><p>为了将数据流中的元素转换为映射，我们需要指定键和值如何被映射。要记住键必须是唯一的，否则会抛出<code>IllegalStateException</code>异常。你可以选择传递一个合并函数作为额外的参数来避免这个异常。</p><p>既然我们知道了一些最强大的内置收集器，让我们来尝试构建自己的特殊收集器吧。我们希望将流中的所有人转换为一个字符串，包含所有大写的名称，并以<code>|</code>分割。为了完成它，我们通过<code>Collector.of()</code>创建了一个新的收集器。我们需要传递一个收集器的四个组成部分：供应器、累加器、组合器和终止器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collector&lt;Person, StringJoiner, String&gt; personNameCollector =</span><br><span class="line">    Collector.of(</span><br><span class="line">        () -&gt; <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot; | &quot;</span>),          <span class="comment">// supplier</span></span><br><span class="line">        (j, p) -&gt; j.add(p.name.toUpperCase()),  <span class="comment">// accumulator</span></span><br><span class="line">        (j1, j2) -&gt; j1.merge(j2),               <span class="comment">// combiner</span></span><br><span class="line">        StringJoiner::toString);                <span class="comment">// finisher</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">names</span> <span class="operator">=</span> persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(personNameCollector);</span><br><span class="line"></span><br><span class="line">System.out.println(names);  <span class="comment">// MAX | PETER | PAMELA | DAVID</span></span><br></pre></td></tr></table></figure><p>由于Java中的字符串是不可变的，我们需要一个助手类<code>StringJointer</code>。让收集器构造我们的字符串。供应器最开始使用相应的分隔符构造了这样一个<code>StringJointer</code>。累加器用于将每个人的大写名称加到<code>StringJointer</code>中。组合器知道如何把两个<code>StringJointer</code>合并为一个。最后一步，终结器从<code>StringJointer</code>构造出预期的字符串。</p><h3 id="flatMap"><code>flatMap</code></h3><p>我们已经了解了如何通过使用<code>map</code>操作，将流中的对象转换为另一种类型。<code>map</code>有时十分受限，因为每个对象只能映射为一个其它对象。但如何我希望将一个对象转换为多个或零个其他对象呢？<code>flatMap</code>这时就会派上用场。</p><p><code>flatMap</code>将流中的每个元素，转换为其它对象的流。所以每个对象会被转换为零个、一个或多个其它对象，以流的形式返回。这些流的内容之后会放进<code>flatMap</code>所返回的流中。</p><p>在我们了解<code>flatMap</code>如何使用之前，我们需要相应的类型体系：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    List&lt;Bar&gt; bars = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Foo(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Bar(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们使用我们自己的关于流的知识来实例化一些对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Foo&gt; foos = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// create foos</span></span><br><span class="line">IntStream</span><br><span class="line">    .range(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    .forEach(i -&gt; foos.add(<span class="keyword">new</span> <span class="title class_">Foo</span>(<span class="string">&quot;Foo&quot;</span> + i)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// create bars</span></span><br><span class="line">foos.forEach(f -&gt;</span><br><span class="line">    IntStream</span><br><span class="line">        .range(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">        .forEach(i -&gt; f.bars.add(<span class="keyword">new</span> <span class="title class_">Bar</span>(<span class="string">&quot;Bar&quot;</span> + i + <span class="string">&quot; &lt;- &quot;</span> + f.name))));</span><br></pre></td></tr></table></figure><p>现在我们拥有了含有三个<code>foo</code>的列表，每个都含有三个<code>bar</code>。</p><p><code>flatMap</code>接受返回对象流的函数。所以为了处理每个<code>foo</code>上的<code>bar</code>对象，我们需要传递相应的函数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">foos.stream()</span><br><span class="line">    .flatMap(f -&gt; f.bars.stream())</span><br><span class="line">    .forEach(b -&gt; System.out.println(b.name));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bar1 &lt;- Foo1</span></span><br><span class="line"><span class="comment">// Bar2 &lt;- Foo1</span></span><br><span class="line"><span class="comment">// Bar3 &lt;- Foo1</span></span><br><span class="line"><span class="comment">// Bar1 &lt;- Foo2</span></span><br><span class="line"><span class="comment">// Bar2 &lt;- Foo2</span></span><br><span class="line"><span class="comment">// Bar3 &lt;- Foo2</span></span><br><span class="line"><span class="comment">// Bar1 &lt;- Foo3</span></span><br><span class="line"><span class="comment">// Bar2 &lt;- Foo3</span></span><br><span class="line"><span class="comment">// Bar3 &lt;- Foo3</span></span><br></pre></td></tr></table></figure><p>像你看到的那样，我们成功地将含有三个<code>foo</code>对象中的流转换为含有九个<code>bar</code>对象的流。</p><p>最后，上面的代码示例可以简化为流式操作的单一流水线：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    .mapToObj(i -&gt; <span class="keyword">new</span> <span class="title class_">Foo</span>(<span class="string">&quot;Foo&quot;</span> + i))</span><br><span class="line">    .peek(f -&gt; IntStream.range(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">        .mapToObj(i -&gt; <span class="keyword">new</span> <span class="title class_">Bar</span>(<span class="string">&quot;Bar&quot;</span> + i + <span class="string">&quot; &lt;- &quot;</span> + f.name))</span><br><span class="line">        .forEach(f.bars::add))</span><br><span class="line">    .flatMap(f -&gt; f.bars.stream())</span><br><span class="line">    .forEach(b -&gt; System.out.println(b.name));</span><br></pre></td></tr></table></figure><p><code>flatMap</code>也可用于Java8引入的<code>Optional</code>类。<code>Optional</code>的<code>flatMap</code>操作返回一个<code>Optional</code>或其他类型的对象。所以它可以用于避免烦人的<code>null</code>检查。</p><p>考虑像这样更复杂的层次结构：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    Nested nested;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Nested</span> &#123;</span><br><span class="line">    Inner inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">    String foo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了处理外层示例上的内层字符串<code>foo</code>，你需要添加多个<code>null</code>检查来避免潜在的<code>NullPointerException</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line"><span class="keyword">if</span> (outer != <span class="literal">null</span> &amp;&amp; outer.nested != <span class="literal">null</span> &amp;&amp; outer.nested.inner != <span class="literal">null</span>) &#123;</span><br><span class="line">    System.out.println(outer.nested.inner.foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用<code>Optional</code>的<code>flatMap</code>操作来完成相同的行为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional.of(<span class="keyword">new</span> <span class="title class_">Outer</span>())</span><br><span class="line">    .flatMap(o -&gt; Optional.ofNullable(o.nested))</span><br><span class="line">    .flatMap(n -&gt; Optional.ofNullable(n.inner))</span><br><span class="line">    .flatMap(i -&gt; Optional.ofNullable(i.foo))</span><br><span class="line">    .ifPresent(System.out::println);</span><br></pre></td></tr></table></figure><p>如果存在的话，每个<code>flatMap</code>的调用都会返回预期对象的<code>Optional</code>包装，否则为<code>null</code>的<code>Optional</code>包装。</p><h3 id="reduce-2"><code>reduce</code></h3><p>归约操作将所有流中的元素组合为单一结果。Java8支持三种不同类型的<code>reduce</code>方法。第一种将流中的元素归约为流中的一个元素。让我们看看我们如何使用这个方法来计算出最老的人：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .reduce((p1, p2) -&gt; p1.age &gt; p2.age ? p1 : p2)</span><br><span class="line">    .ifPresent(System.out::println);    <span class="comment">// Pamela</span></span><br></pre></td></tr></table></figure><p><code>reduce</code>方法接受<code>BinaryOperator</code>积累函数。它实际上是两个操作数类型相同的<code>BiFunction</code>。<code>BiFunction</code>就像是<code>Function</code>，但是接受两个参数。示例中的函数比较两个人的年龄，来返回年龄较大的人。</p><p>第二个<code>reduce</code>方法接受一个初始值，和一个<code>BinaryOperator</code>累加器。这个方法可以用于从流中的其它<code>Person</code>对象中构造带有聚合后名称和年龄的新<code>Person</code>对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">result</span> <span class="operator">=</span></span><br><span class="line">    persons</span><br><span class="line">        .stream()</span><br><span class="line">        .reduce(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>), (p1, p2) -&gt; &#123;</span><br><span class="line">            p1.age += p2.age;</span><br><span class="line">            p1.name += p2.name;</span><br><span class="line">            <span class="keyword">return</span> p1;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">System.out.format(<span class="string">&quot;name=%s; age=%s&quot;</span>, result.name, result.age);</span><br><span class="line"><span class="comment">// name=MaxPeterPamelaDavid; age=76</span></span><br></pre></td></tr></table></figure><p>第三个<code>reduce</code>对象接受三个参数：初始值，<code>BiFunction</code>累加器和<code>BinaryOperator</code>类型的组合器函数。由于初始值的类型不一定为<code>Person</code>，我们可以使用这个归约函数来计算所有人的年龄总和。：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">ageSum</span> <span class="operator">=</span> persons</span><br><span class="line">    .stream()</span><br><span class="line">    .reduce(<span class="number">0</span>, (sum, p) -&gt; sum += p.age, (sum1, sum2) -&gt; sum1 + sum2);</span><br><span class="line"></span><br><span class="line">System.out.println(ageSum);  <span class="comment">// 76</span></span><br></pre></td></tr></table></figure><p>你可以看到结果是76。但是背后发生了什么？让我们通过添加一些调试输出来扩展上面的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">ageSum</span> <span class="operator">=</span> persons</span><br><span class="line">    .stream()</span><br><span class="line">    .reduce(<span class="number">0</span>,</span><br><span class="line">        (sum, p) -&gt; &#123;</span><br><span class="line">            System.out.format(<span class="string">&quot;accumulator: sum=%s; person=%s\n&quot;</span>, sum, p);</span><br><span class="line">            <span class="keyword">return</span> sum += p.age;</span><br><span class="line">        &#125;,</span><br><span class="line">        (sum1, sum2) -&gt; &#123;</span><br><span class="line">            System.out.format(<span class="string">&quot;combiner: sum1=%s; sum2=%s\n&quot;</span>, sum1, sum2);</span><br><span class="line">            <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// accumulator: sum=0; person=Max</span></span><br><span class="line"><span class="comment">// accumulator: sum=18; person=Peter</span></span><br><span class="line"><span class="comment">// accumulator: sum=41; person=Pamela</span></span><br><span class="line"><span class="comment">// accumulator: sum=64; person=David</span></span><br></pre></td></tr></table></figure><p>你可以看到，累加器函数做了所有工作。它首先使用初始值<code>0</code>和第一个人Max来调用累加器。接下来的三步中<code>sum</code>会持续增加，直到76。</p><p>等一下。好像组合器从来没有调用过？以并行方式执行相同的流会揭开这个秘密：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">ageSum</span> <span class="operator">=</span> persons</span><br><span class="line">    .parallelStream()</span><br><span class="line">    .reduce(<span class="number">0</span>,</span><br><span class="line">        (sum, p) -&gt; &#123;</span><br><span class="line">            System.out.format(<span class="string">&quot;accumulator: sum=%s; person=%s\n&quot;</span>, sum, p);</span><br><span class="line">            <span class="keyword">return</span> sum += p.age;</span><br><span class="line">        &#125;,</span><br><span class="line">        (sum1, sum2) -&gt; &#123;</span><br><span class="line">            System.out.format(<span class="string">&quot;combiner: sum1=%s; sum2=%s\n&quot;</span>, sum1, sum2);</span><br><span class="line">            <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// accumulator: sum=0; person=Pamela</span></span><br><span class="line"><span class="comment">// accumulator: sum=0; person=David</span></span><br><span class="line"><span class="comment">// accumulator: sum=0; person=Max</span></span><br><span class="line"><span class="comment">// accumulator: sum=0; person=Peter</span></span><br><span class="line"><span class="comment">// combiner: sum1=18; sum2=23</span></span><br><span class="line"><span class="comment">// combiner: sum1=23; sum2=12</span></span><br><span class="line"><span class="comment">// combiner: sum1=41; sum2=35</span></span><br></pre></td></tr></table></figure><p>这个流的并行执行行为会完全不同。现在实际上调用了组合器。由于累加器被并行调用，组合器需要用于计算部分累加值的总和。</p><p>下一节我们会深入了解并行流。</p><h2 id="并行流">并行流</h2><p>流可以并行执行，在大量输入元素上可以提升运行时的性能。并行流使用公共的<code>ForkJoinPool</code>，由<code>ForkJoinPool.commonPool()</code>方法提供。底层线程池的大小最大为五个线程 – 取决于CPU的物理核数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ForkJoinPool</span> <span class="variable">commonPool</span> <span class="operator">=</span> ForkJoinPool.commonPool();</span><br><span class="line">System.out.println(commonPool.getParallelism());    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>在我的机器上，公共池默认初始化为3。这个值可以通过设置下列JVM参数来增减：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Djava.util.concurrent.ForkJoinPool.common.parallelism=5</span><br></pre></td></tr></table></figure><p>集合支持<code>parallelStream()</code>方法来创建元素的并行流。或者你可以在已存在的数据流上调用衔接方法<code>parallel()</code>，将串行流转换为并行流。</p><p>为了描述并行流的执行行为，下面的例子向<code>sout</code>打印了当前线程的信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.asList(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;c2&quot;</span>, <span class="string">&quot;c1&quot;</span>)</span><br><span class="line">    .parallelStream()</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.format(<span class="string">&quot;filter: %s [%s]\n&quot;</span>,</span><br><span class="line">            s, Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.format(<span class="string">&quot;map: %s [%s]\n&quot;</span>,</span><br><span class="line">            s, Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.format(<span class="string">&quot;forEach: %s [%s]\n&quot;</span>,</span><br><span class="line">        s, Thread.currentThread().getName()));</span><br></pre></td></tr></table></figure><p>通过分析调试输出，我们可以对哪个线程用于执行流式操作拥有更深入的理解：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filter:  b1 [main]</span><br><span class="line">filter:  a2 [ForkJoinPool.commonPool-worker-1]</span><br><span class="line">map:     a2 [ForkJoinPool.commonPool-worker-1]</span><br><span class="line">filter:  c2 [ForkJoinPool.commonPool-worker-3]</span><br><span class="line">map:     c2 [ForkJoinPool.commonPool-worker-3]</span><br><span class="line">filter:  c1 [ForkJoinPool.commonPool-worker-2]</span><br><span class="line">map:     c1 [ForkJoinPool.commonPool-worker-2]</span><br><span class="line">forEach: C2 [ForkJoinPool.commonPool-worker-3]</span><br><span class="line">forEach: A2 [ForkJoinPool.commonPool-worker-1]</span><br><span class="line">map:     b1 [main]</span><br><span class="line">forEach: B1 [main]</span><br><span class="line">filter:  a1 [ForkJoinPool.commonPool-worker-3]</span><br><span class="line">map:     a1 [ForkJoinPool.commonPool-worker-3]</span><br><span class="line">forEach: A1 [ForkJoinPool.commonPool-worker-3]</span><br><span class="line">forEach: C1 [ForkJoinPool.commonPool-worker-2]</span><br></pre></td></tr></table></figure><p>就像你看到的那样，并行流使用了所有公共的<code>ForkJoinPool</code>中的可用线程来执行流式操作。在连续的运行中输出可能有所不同，因为所使用的特定线程是非特定的。</p><p>让我们通过添加额外的流式操作<code>sort</code>来扩展这个示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.asList(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;c2&quot;</span>, <span class="string">&quot;c1&quot;</span>)</span><br><span class="line">    .parallelStream()</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.format(<span class="string">&quot;filter: %s [%s]\n&quot;</span>,</span><br><span class="line">            s, Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.format(<span class="string">&quot;map: %s [%s]\n&quot;</span>,</span><br><span class="line">            s, Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .sorted((s1, s2) -&gt; &#123;</span><br><span class="line">        System.out.format(<span class="string">&quot;sort: %s &lt;&gt; %s [%s]\n&quot;</span>,</span><br><span class="line">            s1, s2, Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.format(<span class="string">&quot;forEach: %s [%s]\n&quot;</span>,</span><br><span class="line">        s, Thread.currentThread().getName()));</span><br></pre></td></tr></table></figure><p>结果起初可能比较奇怪：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filter:  c2 [ForkJoinPool.commonPool-worker-3]</span><br><span class="line">filter:  c1 [ForkJoinPool.commonPool-worker-2]</span><br><span class="line">map:     c1 [ForkJoinPool.commonPool-worker-2]</span><br><span class="line">filter:  a2 [ForkJoinPool.commonPool-worker-1]</span><br><span class="line">map:     a2 [ForkJoinPool.commonPool-worker-1]</span><br><span class="line">filter:  b1 [main]</span><br><span class="line">map:     b1 [main]</span><br><span class="line">filter:  a1 [ForkJoinPool.commonPool-worker-2]</span><br><span class="line">map:     a1 [ForkJoinPool.commonPool-worker-2]</span><br><span class="line">map:     c2 [ForkJoinPool.commonPool-worker-3]</span><br><span class="line">sort:    A2 &lt;&gt; A1 [main]</span><br><span class="line">sort:    B1 &lt;&gt; A2 [main]</span><br><span class="line">sort:    C2 &lt;&gt; B1 [main]</span><br><span class="line">sort:    C1 &lt;&gt; C2 [main]</span><br><span class="line">sort:    C1 &lt;&gt; B1 [main]</span><br><span class="line">sort:    C1 &lt;&gt; C2 [main]</span><br><span class="line">forEach: A1 [ForkJoinPool.commonPool-worker-1]</span><br><span class="line">forEach: C2 [ForkJoinPool.commonPool-worker-3]</span><br><span class="line">forEach: B1 [main]</span><br><span class="line">forEach: A2 [ForkJoinPool.commonPool-worker-2]</span><br><span class="line">forEach: C1 [ForkJoinPool.commonPool-worker-1]</span><br></pre></td></tr></table></figure><p><code>sort</code>看起来只在主线程上串行执行。实际上，并行流上的<code>sort</code>在背后使用了Java8中新的方法<code>Arrays.parallelSort()</code>。如<a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#parallelSort-T:A-">javadoc</a>所说，这个方法会参照数据长度来决定以串行或并行来执行。</p><blockquote><p>如果指定数据的长度小于最小粒度，它使用相应的<code>Arrays.sort</code>方法来排序。</p></blockquote><p>返回上一节中<code>reduce</code>的例子。我们已经发现了组合器函数只在并行流中调用，而不在串行流中调用。让我们来观察实际上涉及到哪个线程：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; persons = Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Max&quot;</span>, <span class="number">18</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Peter&quot;</span>, <span class="number">23</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Pamela&quot;</span>, <span class="number">23</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;David&quot;</span>, <span class="number">12</span>));</span><br><span class="line"></span><br><span class="line">persons</span><br><span class="line">    .parallelStream()</span><br><span class="line">    .reduce(<span class="number">0</span>,</span><br><span class="line">        (sum, p) -&gt; &#123;</span><br><span class="line">            System.out.format(<span class="string">&quot;accumulator: sum=%s; person=%s [%s]\n&quot;</span>,</span><br><span class="line">                sum, p, Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">return</span> sum += p.age;</span><br><span class="line">        &#125;,</span><br><span class="line">        (sum1, sum2) -&gt; &#123;</span><br><span class="line">            System.out.format(<span class="string">&quot;combiner: sum1=%s; sum2=%s [%s]\n&quot;</span>,</span><br><span class="line">                sum1, sum2, Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>控制台的输出表明，累加器和组合器都在所有可用的线程上并行执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">accumulator: sum=0; person=Pamela; [main]</span><br><span class="line">accumulator: sum=0; person=Max;    [ForkJoinPool.commonPool-worker-3]</span><br><span class="line">accumulator: sum=0; person=David;  [ForkJoinPool.commonPool-worker-2]</span><br><span class="line">accumulator: sum=0; person=Peter;  [ForkJoinPool.commonPool-worker-1]</span><br><span class="line">combiner:    sum1=18; sum2=23;     [ForkJoinPool.commonPool-worker-1]</span><br><span class="line">combiner:    sum1=23; sum2=12;     [ForkJoinPool.commonPool-worker-2]</span><br><span class="line">combiner:    sum1=41; sum2=35;     [ForkJoinPool.commonPool-worker-2]</span><br></pre></td></tr></table></figure><p>总之，并行流对拥有大量输入元素的数据流具有极大的性能提升。但是要记住一些并行流的操作，例如<code>reduce</code>和<code>collect</code>需要额外的计算（组合操作），这在串行执行时并不需要。</p><p>此外我们已经了解，所有并行流操作都共享相同的JVM相关的公共<code>ForkJoinPool</code>。所以你可能需要避免实现又慢又卡的流式操作，因为它可能会拖慢你应用中严重依赖并行流的其它部分。</p><blockquote><p>原文：<a target="_blank" rel="noopener external nofollow noreferrer" href="http://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/">Java 8 Stream Tutorial</a></p></blockquote></article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://oss.kiscloud.net/image/user/anime/Chainsaw/wallhaven-jxy6vp_1920x1080.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/images/wechat.jpg" alt="wechat"></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/images/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/images/alipay.jpg" alt="alipay"></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/7e39f321.html" title="Java 8 并发教程：线程和执行器"><img class="cover" src="https://oss.kiscloud.net/image/user/anime/Chainsaw/wallhaven-vqd9qm_1920x1080.webp" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java 8 并发教程：线程和执行器</div></div></a></div><div class="next-post pull-right"><a href="/posts/a12dc1dc.html" title="Java 8 教程"><img class="cover" src="https://oss.kiscloud.net/image/user/anime/Chainsaw/wallhaven-yxj6jx_1920x1080.webp" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java 8 教程</div></div></a></div></nav><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://oss.kiscloud.net/image/user/anime/Chainsaw/qiu.webp" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">ihadu</div><div class="author-info__description">黑暗中大雪纷飞的人</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">236</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">35</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/ihadu"><i class="fab fa-github"></i><span>look Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ihadu" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:ihadyou@qq.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://weibo.com/u/5992742619" rel="external nofollow noreferrer" target="_blank"><i class="fa-brands fa-weibo"></i></a><a class="social-icon" href="https://www.cnblogs.com/ihadu/post-categories/#/c/subject/category/default.html" rel="external nofollow noreferrer" target="_blank"><i class="fa-solid fa-blog"></i></a><a class="social-icon" href="/nav/" target="_blank"><i class="fa fa-paper-plane"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Have you found your way home yet</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Java 8 数据流教程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.1.</span> <span class="toc-text">数据流如何工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">数据流的不同类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.3.</span> <span class="toc-text">处理顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%A1%BA%E5%BA%8F%E5%A6%82%E6%AD%A4%E9%87%8D%E8%A6%81"><span class="toc-number">1.3.1.</span> <span class="toc-text">为什么顺序如此重要</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E7%94%A8%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">1.4.</span> <span class="toc-text">复用数据流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.</span> <span class="toc-text">高级操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#collect"><span class="toc-number">1.5.1.</span> <span class="toc-text">collect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flatMap"><span class="toc-number">1.5.2.</span> <span class="toc-text">flatMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reduce-2"><span class="toc-number">1.5.3.</span> <span class="toc-text">reduce</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E6%B5%81"><span class="toc-number">1.6.</span> <span class="toc-text">并行流</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/c9036b1c.html" title="人工智能中的搜索算法"><img src="https://oss.kiscloud.net/image/user/anime/Chainsaw/wallhaven-1pk851_1920x1080.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="人工智能中的搜索算法"></a><div class="content"><a class="title" href="/posts/c9036b1c.html" title="人工智能中的搜索算法">人工智能中的搜索算法</a><time datetime="2023-09-06T11:34:15.000Z" title="发表于 2023-09-06 19:34:15">2023-09-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/549bc4b6.html" title="深入解读 MongoDB CDC 的设计与实现"><img src="https://oss.kiscloud.net/image/user/anime/Chainsaw/wallhaven-rr7ldm_1920x1080.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="深入解读 MongoDB CDC 的设计与实现"></a><div class="content"><a class="title" href="/posts/549bc4b6.html" title="深入解读 MongoDB CDC 的设计与实现">深入解读 MongoDB CDC 的设计与实现</a><time datetime="2023-09-04T14:38:54.000Z" title="发表于 2023-09-04 22:38:54">2023-09-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4121201d.html" title="Java 8 并发教程：原子变量和 ConcurrentMap"><img src="https://oss.kiscloud.net/image/user/anime/Chainsaw/wallhaven-vqm6qm_1920x1080.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Java 8 并发教程：原子变量和 ConcurrentMap"></a><div class="content"><a class="title" href="/posts/4121201d.html" title="Java 8 并发教程：原子变量和 ConcurrentMap">Java 8 并发教程：原子变量和 ConcurrentMap</a><time datetime="2023-08-29T09:19:26.000Z" title="发表于 2023-08-29 17:19:26">2023-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4c4d17bf.html" title="Java 8 并发教程：同步和锁"><img src="https://oss.kiscloud.net/image/user/anime/Chainsaw/wallhaven-l8qxqy_1920x1080.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Java 8 并发教程：同步和锁"></a><div class="content"><a class="title" href="/posts/4c4d17bf.html" title="Java 8 并发教程：同步和锁">Java 8 并发教程：同步和锁</a><time datetime="2023-08-29T09:17:57.000Z" title="发表于 2023-08-29 17:17:57">2023-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/7e39f321.html" title="Java 8 并发教程：线程和执行器"><img src="https://oss.kiscloud.net/image/user/anime/Chainsaw/wallhaven-vqd9qm_1920x1080.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Java 8 并发教程：线程和执行器"></a><div class="content"><a class="title" href="/posts/7e39f321.html" title="Java 8 并发教程：线程和执行器">Java 8 并发教程：线程和执行器</a><time datetime="2023-08-29T09:15:52.000Z" title="发表于 2023-08-29 17:15:52">2023-08-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By ihadu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><img src="https://haiyong.site/img/icp.png"><a href="https://beian.miit.gov.cn/#/Integrated/index" rel="external nofollow noreferrer" style="color:#fff" target="_blank">皖ICP备19024061号-4</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.umd.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/instant.page/5.2.0/instantpage.min.js" type="module"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js").then(()=>{pangu.autoSpacingPage()})}function panguInit(){GLOBAL_CONFIG_SITE.isPost&&panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><div class="js-pjax"><script>function loadValine(){function n(){new Valine(Object.assign({el:"#vcomment",appId:"kriIEcS9Jj1uTpNoV1sFu2Rk-gzGzoHsz",appKey:"mnmRNJ7HtlpE7664tpn7Kfmy",avatar:"monsterid",serverURLs:"",emojiMaps:"",path:window.location.pathname,visitor:!1},null))}"function"==typeof Valine?n():getScript("https://cdnjs.cloudflare.com/ajax/libs/valine/1.5.1/Valine.min.js").then(n)}function loadOtherComment(){loadValine()}setTimeout(loadValine,0)</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/fireworks.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!0,document.body.addEventListener("input",POWERMODE)</script><script src="https://cdnjs.cloudflare.com/ajax/libs/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors=["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"]):not([href="/music/"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",function(){if(window.tocScrollFn&&window.removeEventListener("scroll",window.tocScrollFn),window.scrollCollect&&window.removeEventListener("scroll",scrollCollect),document.getElementById("rightside").style.cssText="opacity: ''; transform: ''",window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();var e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode"),"object"==typeof disqusjs&&disqusjs.destroy()}),document.addEventListener("pjax:complete",function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script");var o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll()}),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{scale:1,hHeadPos:.5,vHeadPos:.618,jsonPath:"/live2d_models/gun/95type_405/normal/model.json"},display:{superSample:2,position:"left",width:200,height:400,hOffset:30,vOffset:-80},mobile:{show:!1,scale:1},react:{opacityDefault:.3,opacityOnHover:.3,opacity:.95},dialog:{enable:!0,hitokoto:!0},log:!1})</script></body></html>