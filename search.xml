<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hive CLI和Beeline命令行的基本使用</title>
    <url>/posts/d9ec48a1.html</url>
    <content><![CDATA[<h2 id="一、Hive-CLI">一、Hive CLI</h2>
<h3 id="1-1-Help">1.1 Help</h3>
<p>使用 <code>hive -H</code> 或者 <code>hive --help</code> 命令可以查看所有命令的帮助，显示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">usage: hive</span><br><span class="line"> -d,--define &lt;key=value&gt;          Variable subsitution to apply to hive </span><br><span class="line">                                  commands. e.g. -d A=B or --define A=B  --定义用户自定义变量</span><br><span class="line">    --database &lt;databasename&gt;     Specify the database to use  -- 指定使用的数据库</span><br><span class="line"> -e &lt;quoted-query-string&gt;         SQL from command line   -- 执行指定的 SQL</span><br><span class="line"> -f &lt;filename&gt;                    SQL from files   --执行 SQL 脚本</span><br><span class="line"> -H,--help                        Print help information  -- 打印帮助信息</span><br><span class="line">    --hiveconf &lt;property=value&gt;   Use value for given property    --自定义配置</span><br><span class="line">    --hivevar &lt;key=value&gt;         Variable subsitution to apply to hive  --自定义变量</span><br><span class="line">                                  commands. e.g. --hivevar A=B</span><br><span class="line"> -i &lt;filename&gt;                    Initialization SQL file  --在进入交互模式之前运行初始化脚本</span><br><span class="line"> -S,--silent                      Silent mode in interactive shell    --静默模式</span><br><span class="line"> -v,--verbose                     Verbose mode (echo executed SQL to the  console)  --详细模式</span><br></pre></td></tr></table></figure>
<h3 id="1-2-交互式命令行">1.2 交互式命令行</h3>
<p>直接使用 <code>Hive</code> 命令，不加任何参数，即可进入交互式命令行。</p>
<h3 id="1-3-执行SQL命令">1.3 执行SQL命令</h3>
<p>在不进入交互式命令行的情况下，可以使用 <code>hive -e </code> 执行 SQL 命令。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">hive <span class="operator">-</span>e <span class="string">&#x27;select * from emp&#x27;</span>;</span><br></pre></td></tr></table></figure>
<div align="center"> <img width='700px' src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-e.png"/> </div>
<p>hexo</p>
<h3 id="1-4-执行SQL脚本">1.4 执行SQL脚本</h3>
<p>用于执行的 sql 脚本可以在本地文件系统，也可以在 HDFS 上。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">本地文件系统</span></span><br><span class="line">hive -f /usr/file/simple.sql;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">HDFS文件系统</span></span><br><span class="line">hive -f hdfs://hadoop001:8020/tmp/simple.sql;</span><br></pre></td></tr></table></figure>
<p>其中 <code>simple.sql</code> 内容如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>
<h3 id="1-5-配置Hive变量">1.5 配置Hive变量</h3>
<p>可以使用 <code>--hiveconf</code> 设置 Hive 运行时的变量。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">hive <span class="operator">-</span>e <span class="string">&#x27;select * from emp&#x27;</span> \</span><br><span class="line"><span class="comment">--hiveconf hive.exec.scratchdir=/tmp/hive_scratch  \</span></span><br><span class="line"><span class="comment">--hiveconf mapred.reduce.tasks=4;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>hive.exec.scratchdir：指定 HDFS 上目录位置，用于存储不同 map/reduce 阶段的执行计划和这些阶段的中间输出结果。</p>
</blockquote>
<h3 id="1-6-配置文件启动">1.6 配置文件启动</h3>
<p>使用 <code>-i</code> 可以在进入交互模式之前运行初始化脚本，相当于指定配置文件启动。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hive -i /usr/file/hive-init.conf;</span><br></pre></td></tr></table></figure>
<p>其中 <code>hive-init.conf</code> 的内容如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.exec.mode.local.auto <span class="operator">=</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>hive.exec.mode.local.auto 默认值为 false，这里设置为 true ，代表开启本地模式。</p>
</blockquote>
<h3 id="1-7-用户自定义变量">1.7 用户自定义变量</h3>
<p><code>--define &lt;key=value&gt; </code> 和 <code>--hivevar &lt;key=value&gt;  </code> 在功能上是等价的，都是用来实现自定义变量，这里给出一个示例:</p>
<p>定义变量：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">hive  <span class="comment">--define  n=ename --hiveconf  --hivevar j=job;</span></span><br></pre></td></tr></table></figure>
<p>在查询中引用自定义变量：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 以下两条语句等价</span><br><span class="line">hive <span class="operator">&gt;</span> <span class="keyword">select</span> $&#123;n&#125; <span class="keyword">from</span> emp;</span><br><span class="line">hive <span class="operator">&gt;</span>  <span class="keyword">select</span> $&#123;hivevar:n&#125; <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"># 以下两条语句等价</span><br><span class="line">hive <span class="operator">&gt;</span> <span class="keyword">select</span> $&#123;j&#125; <span class="keyword">from</span> emp;</span><br><span class="line">hive <span class="operator">&gt;</span>  <span class="keyword">select</span> $&#123;hivevar:j&#125; <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<div align="center"> <img width='700px' src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-n-j.png"/> </div>
<h2 id="二、Beeline">二、Beeline</h2>
<h3 id="2-1-HiveServer2">2.1 HiveServer2</h3>
<p>Hive 内置了 HiveServer 和 HiveServer2 服务，两者都允许客户端使用多种编程语言进行连接，但是 HiveServer 不能处理多个客户端的并发请求，所以产生了 HiveServer2。</p>
<p>HiveServer2（HS2）允许远程客户端可以使用各种编程语言向 Hive 提交请求并检索结果，支持多客户端并发访问和身份验证。HS2 是由多个服务组成的单个进程，其包括基于 Thrift 的 Hive 服务（TCP 或 HTTP）和用于 Web UI 的 Jetty Web 服务器。</p>
<p>HiveServer2 拥有自己的 CLI(Beeline)，Beeline 是一个基于 SQLLine 的 JDBC 客户端。由于 HiveServer2 是 Hive 开发维护的重点 (Hive0.15 后就不再支持 hiveserver)，所以 Hive CLI 已经不推荐使用了，官方更加推荐使用 Beeline。</p>
<h3 id="2-1-Beeline">2.1 Beeline</h3>
<p>Beeline 拥有更多可使用参数，可以使用 <code>beeline --help</code> 查看，完整参数如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">Usage</span>: <span class="string">java org.apache.hive.cli.beeline.BeeLine</span></span><br><span class="line">   <span class="attr">-u</span> <span class="string">&lt;database url&gt;               the JDBC URL to connect to</span></span><br><span class="line">   <span class="attr">-r</span>                              <span class="string">reconnect to last saved connect url (in conjunction with !save)</span></span><br><span class="line">   <span class="attr">-n</span> <span class="string">&lt;username&gt;                   the username to connect as</span></span><br><span class="line">   <span class="attr">-p</span> <span class="string">&lt;password&gt;                   the password to connect as</span></span><br><span class="line">   <span class="attr">-d</span> <span class="string">&lt;driver class&gt;               the driver class to use</span></span><br><span class="line">   <span class="attr">-i</span> <span class="string">&lt;init file&gt;                  script file for initialization</span></span><br><span class="line">   <span class="attr">-e</span> <span class="string">&lt;query&gt;                      query that should be executed</span></span><br><span class="line">   <span class="attr">-f</span> <span class="string">&lt;exec file&gt;                  script file that should be executed</span></span><br><span class="line">   <span class="attr">-w</span> <span class="string">(or) --password-file &lt;password file&gt;  the password file to read password from</span></span><br><span class="line">   <span class="attr">--hiveconf</span> <span class="string">property=value       Use value for given property</span></span><br><span class="line">   <span class="attr">--hivevar</span> <span class="string">name=value            hive variable name and value</span></span><br><span class="line">                                   <span class="attr">This</span> <span class="string">is Hive specific settings in which variables</span></span><br><span class="line">                                   <span class="attr">can</span> <span class="string">be set at session level and referenced in Hive</span></span><br><span class="line">                                   <span class="attr">commands</span> <span class="string">or queries.</span></span><br><span class="line">   <span class="attr">--property-file</span>=<span class="string">&lt;property-file&gt; the file to read connection properties (url, driver, user, password) from</span></span><br><span class="line">   <span class="attr">--color</span>=<span class="string">[true/false]            control whether color is used for display</span></span><br><span class="line">   <span class="attr">--showHeader</span>=<span class="string">[true/false]       show column names in query results</span></span><br><span class="line">   <span class="attr">--headerInterval</span>=<span class="string">ROWS;          the interval between which heades are displayed</span></span><br><span class="line">   <span class="attr">--fastConnect</span>=<span class="string">[true/false]      skip building table/column list for tab-completion</span></span><br><span class="line">   <span class="attr">--autoCommit</span>=<span class="string">[true/false]       enable/disable automatic transaction commit</span></span><br><span class="line">   <span class="attr">--verbose</span>=<span class="string">[true/false]          show verbose error messages and debug info</span></span><br><span class="line">   <span class="attr">--showWarnings</span>=<span class="string">[true/false]     display connection warnings</span></span><br><span class="line">   <span class="attr">--showNestedErrs</span>=<span class="string">[true/false]   display nested errors</span></span><br><span class="line">   <span class="attr">--numberFormat</span>=<span class="string">[pattern]        format numbers using DecimalFormat pattern</span></span><br><span class="line">   <span class="attr">--force</span>=<span class="string">[true/false]            continue running script even after errors</span></span><br><span class="line">   <span class="attr">--maxWidth</span>=<span class="string">MAXWIDTH             the maximum width of the terminal</span></span><br><span class="line">   <span class="attr">--maxColumnWidth</span>=<span class="string">MAXCOLWIDTH    the maximum width to use when displaying columns</span></span><br><span class="line">   <span class="attr">--silent</span>=<span class="string">[true/false]           be more silent</span></span><br><span class="line">   <span class="attr">--autosave</span>=<span class="string">[true/false]         automatically save preferences</span></span><br><span class="line">   <span class="attr">--outputformat</span>=<span class="string">[table/vertical/csv2/tsv2/dsv/csv/tsv]  format mode for result display</span></span><br><span class="line">   <span class="attr">--incrementalBufferRows</span>=<span class="string">NUMROWS the number of rows to buffer when printing rows on stdout,</span></span><br><span class="line">                                   <span class="attr">defaults</span> <span class="string">to 1000; only applicable if --incremental=true</span></span><br><span class="line">                                   <span class="attr">and</span> <span class="string">--outputformat=table</span></span><br><span class="line">   <span class="attr">--truncateTable</span>=<span class="string">[true/false]    truncate table column when it exceeds length</span></span><br><span class="line">   <span class="attr">--delimiterForDSV</span>=<span class="string">DELIMITER     specify the delimiter for delimiter-separated values output format (default: |)</span></span><br><span class="line">   <span class="attr">--isolation</span>=<span class="string">LEVEL               set the transaction isolation level</span></span><br><span class="line">   <span class="attr">--nullemptystring</span>=<span class="string">[true/false]  set to true to get historic behavior of printing null as empty string</span></span><br><span class="line">   <span class="attr">--maxHistoryRows</span>=<span class="string">MAXHISTORYROWS The maximum number of rows to store beeline history.</span></span><br><span class="line">   <span class="attr">--convertBinaryArrayToString</span>=<span class="string">[true/false]    display binary column data as string or as byte array</span></span><br><span class="line">   <span class="attr">--help</span>                          <span class="string">display this message</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-3-常用参数">2.3 常用参数</h3>
<p>在 Hive CLI 中支持的参数，Beeline 都支持，常用的参数如下。更多参数说明可以参见官方文档 <a href="https://cwiki.apache.org/confluence/display/Hive/HiveServer2+Clients#HiveServer2Clients-Beeline%E2%80%93NewCommandLineShell">Beeline Command Options</a></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>-u &lt;database URL&gt;</strong></td>
<td>数据库地址</td>
</tr>
<tr>
<td><strong>-n &lt;username&gt;</strong></td>
<td>用户名</td>
</tr>
<tr>
<td><strong>-p &lt;password&gt;</strong></td>
<td>密码</td>
</tr>
<tr>
<td><strong>-d &lt;driver class&gt;</strong></td>
<td>驱动 (可选)</td>
</tr>
<tr>
<td><strong>-e &lt;query&gt;</strong></td>
<td>执行 SQL 命令</td>
</tr>
<tr>
<td><strong>-f &lt;file&gt;</strong></td>
<td>执行 SQL 脚本</td>
</tr>
<tr>
<td><strong>-i  (or)–init  &lt;file or files&gt;</strong></td>
<td>在进入交互模式之前运行初始化脚本</td>
</tr>
<tr>
<td><strong>–property-file &lt;file&gt;</strong></td>
<td>指定配置文件</td>
</tr>
<tr>
<td><strong>–hiveconf</strong> <em>property</em>*=*<em>value</em></td>
<td>指定配置属性</td>
</tr>
<tr>
<td><strong>–hivevar</strong> <em>name</em>*=*<em>value</em></td>
<td>用户自定义属性，在会话级别有效</td>
</tr>
</tbody>
</table>
<p>示例： 使用用户名和密码连接 Hive</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">beeline -u jdbc:hive2://localhost:10000  -n username -p password</span> </span><br></pre></td></tr></table></figure>
<p>​</p>
<h2 id="三、Hive配置">三、Hive配置</h2>
<p>可以通过三种方式对 Hive 的相关属性进行配置，分别介绍如下：</p>
<h3 id="3-1-配置文件">3.1 配置文件</h3>
<p>方式一为使用配置文件，使用配置文件指定的配置是永久有效的。Hive 有以下三个可选的配置文件：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>hive-site.xml ：Hive 的主要配置文件；</p>
</li>
<li class="lvl-2">
<p>hivemetastore-site.xml： 关于元数据的配置；</p>
</li>
<li class="lvl-2">
<p>hiveserver2-site.xml：关于 HiveServer2 的配置。</p>
</li>
</ul>
<p>示例如下,在 hive-site.xml 配置 <code>hive.exec.scratchdir</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.exec.scratchdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">value</span>&gt;</span>/tmp/mydir<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">description</span>&gt;</span>Scratch space for Hive jobs<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-hiveconf">3.2 hiveconf</h3>
<p>方式二为在启动命令行 (Hive CLI / Beeline) 的时候使用 <code>--hiveconf</code> 指定配置，这种方式指定的配置作用于整个 Session。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive --hiveconf hive.exec.scratchdir=/tmp/mydir</span><br></pre></td></tr></table></figure>
<h3 id="3-3-set">3.3 set</h3>
<p>方式三为在交互式环境下 (Hive CLI / Beeline)，使用 set 命令指定。这种设置的作用范围也是 Session 级别的，配置对于执行该命令后的所有命令生效。set 兼具设置参数和查看参数的功能。如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0: jdbc:hive2://hadoop001:10000&gt; set hive.exec.scratchdir=/tmp/mydir;</span><br><span class="line">No rows affected (0.025 seconds)</span><br><span class="line">0: jdbc:hive2://hadoop001:10000&gt; set hive.exec.scratchdir;</span><br><span class="line">+----------------------------------+--+</span><br><span class="line">|               set                |</span><br><span class="line">+----------------------------------+--+</span><br><span class="line">| hive.exec.scratchdir=/tmp/mydir  |</span><br><span class="line">+----------------------------------+--+</span><br></pre></td></tr></table></figure>
<h3 id="3-4-配置优先级">3.4 配置优先级</h3>
<p>配置的优先顺序如下 (由低到高)：<br>
<code>hive-site.xml</code> - &gt;<code>hivemetastore-site.xml</code>- &gt; <code>hiveserver2-site.xml</code> - &gt;<code> -- hiveconf</code>- &gt; <code>set</code></p>
<h3 id="3-5-配置参数">3.5 配置参数</h3>
<p>Hive 可选的配置参数非常多，在用到时查阅官方文档即可<a href="https://cwiki.apache.org/confluence/display/Hive/AdminManual+Configuration">AdminManual Configuration</a></p>
<h2 id="参考资料">参考资料</h2>
<ol>
<li class="lvl-3">
<p><a href="https://cwiki.apache.org/confluence/display/Hive/HiveServer2+Clients">HiveServer2 Clients</a></p>
</li>
<li class="lvl-3">
<p><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Cli">LanguageManual Cli</a></p>
</li>
<li class="lvl-3">
<p><a href="https://cwiki.apache.org/confluence/display/Hive/AdminManual+Configuration">AdminManual Configuration</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>hive</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink-Broadcast-State</title>
    <url>/posts/6baec425.html</url>
    <content><![CDATA[<h3 id="背景">背景</h3>
<p>有这样一个需求：flink或者spark任务需要访问数据库，或者用到表schema信息。但此时数据库中的字段有添加或者修改时(schama发生改变的时候)，这时候任务就会失败。最直接的做法就是重启flink或spark任务，但该做法会对业务数据造成一定的影响。</p>
<p>方案：<strong>将改动的schema信息放入redis中，再通过broadcast广播的方式传送给数据流。</strong></p>
<h3 id="flink-broadcast-state">flink broadcast state</h3>
<p>Broadcast State是Flink支持的一种Operator State。使用Broadcast State，可以在Flink程序的一个Stream中输入数据记录，然后将这些数据记录广播（Broadcast）到下游的每个Task中，使得这些数据记录能够为所有的Task所共享，比如一些用于配置的数据记录。这样，每个Task在处理其所对应的Stream中记录的时候，读取这些配置，来满足实际数据处理需要。</p>
<p>步骤：</p>
<ol>
<li class="lvl-3">
<p>定义一个MapStateDescriptor来描述要广播数据的地址</p>
</li>
<li class="lvl-3">
<p>添加数据源，并注册为广播流</p>
</li>
<li class="lvl-3">
<p>连接广播流和处理数据的流</p>
</li>
<li class="lvl-3">
<p>实现连接的处理方法</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MapStateDescriptor&lt;String, TableSchema&gt; mapStateDescriptor =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">MapStateDescriptor</span>&lt;&gt;(</span><br><span class="line">                    <span class="string">&quot;broadcast&quot;</span>,</span><br><span class="line">                    BasicTypeInfo.STRING_TYPE_INFO,</span><br><span class="line">                    TypeInformation.of(<span class="keyword">new</span> <span class="title class_">TypeHint</span>&lt;TableSchema&gt;() &#123;</span><br><span class="line">                    &#125;));</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	首先从redis中得到最新的table schema信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">TableSchema</span> <span class="variable">meta</span> <span class="operator">=</span> getLatestMeta(..);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	数据流</span></span><br><span class="line"><span class="comment">    	生成KeyedStream的流</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    KeyedStream&lt;String,String&gt; keyedStream = env.addSource(..)</span><br><span class="line">        .map(..)</span><br><span class="line">        .returns(String.class)</span><br><span class="line">        .keyby(<span class="keyword">new</span> <span class="title class_">KeySelector</span>&lt;String, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">getKey</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	广播流</span></span><br><span class="line"><span class="comment">    	该流主要存储了table schema的信息，数据量小，广播到各个Task</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    BroadcastStream&lt;TableSchema&gt; broadcastStream = env.addSource(..)</span><br><span class="line">        .map(..)</span><br><span class="line">        .returns(TableSchema.class)</span><br><span class="line">        .broadcast(mapStateDescriptor);</span><br><span class="line">        </span><br><span class="line">    keyedStream.connect(broadcastStream)</span><br><span class="line">        .process(<span class="keyword">new</span> <span class="title class_">KeyedBroadcastProcessFunction</span>&lt;String, String, TableSchema, String&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processBroadcastElement</span><span class="params">(TableSchema value, Context ctx, Collector&lt;String&gt; out)</span>&#123;</span><br><span class="line">            <span class="comment">//获取旧的值</span></span><br><span class="line">            <span class="type">TableSchema</span> <span class="variable">old</span> <span class="operator">=</span> ctx.getBroadcastState(mapStateDescriptor).get(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;old value:&quot;</span>+old+<span class="string">&quot;,new value:&quot;</span>+value);</span><br><span class="line">            <span class="comment">//更新新的值</span></span><br><span class="line">            state.put(<span class="string">&quot;id&quot;</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processElement</span><span class="params">(String value, ReadOnlyContext ctx,</span></span><br><span class="line"><span class="params">                                   Collector&lt;String&gt; out)</span> &#123;</span><br><span class="line">            <span class="comment">//获取上述更新后的最新值</span></span><br><span class="line">            <span class="type">TableSchema</span> <span class="variable">meta</span> <span class="operator">=</span> ctx.getBroadcastState(mapStateDescriptor).get(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            	具体处理逻辑...</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spark-streaming-broadcast">spark streaming broadcast</h3>
<p>我们知道spark的广播变量允许换成一个只读的变量在每台机器上面，而不是每个任务保存一份。常见于spark在一些全局统计的场景中应用。通过广播变量，能够以一种更有效率的方式将一个大数据量输入集合的副本分配给每个节点。Spark也尝试着利用有效的广播算法去分配广播变量，以减少通信的成本</p>
<p>一个广播变量可以通过调用sparkContext.broadcast(v)方法从一个初始变量v中创建。广播变量是v的一个包装变量，它的值可以通过value方法访问，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">JavaStreamingContext</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavaStreamingContext</span>(conf);</span><br><span class="line">    JavaPairInputDStream&lt;String,String&gt; kafka = KafkaUtils.createStream(...);</span><br><span class="line">    kafka.repartition(<span class="number">30</span>)</span><br><span class="line">        .transform(...)</span><br><span class="line">        .foreachRDD(<span class="keyword">new</span> <span class="title class_">VoidFunction</span>&lt;JavaRDD&lt;String&gt;&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">(JavaRDD&lt;String&gt; rdd)</span> &#123;</span><br><span class="line">                <span class="comment">// 广播变量的注册一定要放在这里，否则不会广播到各个节点的task，这种方式可以做到自动更新</span></span><br><span class="line">                <span class="keyword">final</span> Broadcast&lt;String&gt; cast = JavaSparkContext</span><br><span class="line">                    	.fromSparkContext(rdd.context())</span><br><span class="line">                        .broadcast(<span class="string">&quot;broadcast value&quot;</span>);</span><br><span class="line">                rdd.foreach(<span class="keyword">new</span> <span class="title class_">VoidFunction</span>&lt;String&gt;() &#123;</span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">(String v)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        System.out.println(cast.value());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">	sc.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大数据组件</category>
        <category>flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink_Data_Sink</title>
    <url>/posts/ab463d9c.html</url>
    <content><![CDATA[<h2 id="一、Data-Sinks">一、Data Sinks</h2>
<p>在使用 Flink 进行数据处理时，数据经 Data Source 流入，然后通过系列 Transformations 的转化，最终可以通过 Sink 将计算结果进行输出，Flink Data Sinks 就是用于定义数据流最终的输出位置。Flink 提供了几个较为简单的 Sink API 用于日常的开发，具体如下：</p>
<h3 id="1-1-writeAsText">1.1 writeAsText</h3>
<p><code>writeAsText</code> 用于将计算结果以文本的方式并行地写入到指定文件夹下，除了路径参数是必选外，该方法还可以通过指定第二个参数来定义输出模式，它有以下两个可选值：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>WriteMode.NO_OVERWRITE</strong>：当指定路径上不存在任何文件时，才执行写出操作；</p>
</li>
<li class="lvl-2">
<p><strong>WriteMode.OVERWRITE</strong>：不论指定路径上是否存在文件，都执行写出操作；如果原来已有文件，则进行覆盖。</p>
</li>
</ul>
<p>使用示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">streamSource.writeAsText(<span class="string">&quot;D:\\out&quot;</span>, FileSystem.WriteMode.OVERWRITE);</span><br></pre></td></tr></table></figure>
<p>以上写出是以并行的方式写出到多个文件，如果想要将输出结果全部写出到一个文件，需要设置其并行度为 1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">streamSource.writeAsText(<span class="string">&quot;D:\\out&quot;</span>, FileSystem.WriteMode.OVERWRITE).setParallelism(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="1-2-writeAsCsv">1.2 writeAsCsv</h3>
<p><code>writeAsCsv</code> 用于将计算结果以 CSV 的文件格式写出到指定目录，除了路径参数是必选外，该方法还支持传入输出模式，行分隔符，和字段分隔符三个额外的参数，其方法定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">writeAsCsv(String path, WriteMode writeMode, String rowDelimiter, String fieldDelimiter) </span><br></pre></td></tr></table></figure>
<h3 id="1-3-print-printToErr">1.3 print \ printToErr</h3>
<p><code>print \ printToErr</code> 是测试当中最常用的方式，用于将计算结果以标准输出流或错误输出流的方式打印到控制台上。</p>
<h3 id="1-4-writeUsingOutputFormat">1.4 writeUsingOutputFormat</h3>
<p>采用自定义的输出格式将计算结果写出，上面介绍的 <code>writeAsText</code> 和 <code>writeAsCsv</code> 其底层调用的都是该方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DataStreamSink&lt;T&gt; <span class="title function_">writeAsText</span><span class="params">(String path, WriteMode writeMode)</span> &#123;</span><br><span class="line">    TextOutputFormat&lt;T&gt; tof = <span class="keyword">new</span> <span class="title class_">TextOutputFormat</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Path</span>(path));</span><br><span class="line">    tof.setWriteMode(writeMode);</span><br><span class="line">    <span class="keyword">return</span> writeUsingOutputFormat(tof);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-5-writeToSocket">1.5 writeToSocket</h3>
<p><code>writeToSocket</code> 用于将计算结果以指定的格式写出到 Socket 中，使用示例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">streamSource.writeToSocket(&quot;192.168.0.226&quot;, 9999, new SimpleStringSchema());</span><br></pre></td></tr></table></figure>
<h2 id="二、Streaming-Connectors">二、Streaming Connectors</h2>
<p>除了上述 API 外，Flink 中还内置了系列的 Connectors 连接器，用于将计算结果输入到常用的存储系统或者消息中间件中，具体如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Apache Kafka (支持 source 和 sink)</p>
</li>
<li class="lvl-2">
<p>Apache Cassandra (sink)</p>
</li>
<li class="lvl-2">
<p>Amazon Kinesis Streams (source/sink)</p>
</li>
<li class="lvl-2">
<p>Elasticsearch (sink)</p>
</li>
<li class="lvl-2">
<p>Hadoop FileSystem (sink)</p>
</li>
<li class="lvl-2">
<p>RabbitMQ (source/sink)</p>
</li>
<li class="lvl-2">
<p>Apache NiFi (source/sink)</p>
</li>
<li class="lvl-2">
<p>Google PubSub (source/sink)</p>
</li>
</ul>
<p>除了内置的连接器外，你还可以通过 Apache Bahir 的连接器扩展 Flink。Apache Bahir 旨在为分布式数据分析系统 (如 Spark，Flink) 等提供功能上的扩展，当前其支持的与 Flink Sink 相关的连接器如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Apache ActiveMQ (source/sink)</p>
</li>
<li class="lvl-2">
<p>Apache Flume (sink)</p>
</li>
<li class="lvl-2">
<p>Redis (sink)</p>
</li>
<li class="lvl-2">
<p>Akka (sink)</p>
</li>
</ul>
<p>这里接着在 Data Sources 章节介绍的整合 Kafka Source 的基础上，将 Kafka Sink 也一并进行整合，具体步骤如下。</p>
<h2 id="三、整合-Kafka-Sink">三、整合 Kafka Sink</h2>
<h3 id="3-1-addSink">3.1 addSink</h3>
<p>Flink 提供了 addSink 方法用来调用自定义的 Sink 或者第三方的连接器，想要将计算结果写出到 Kafka，需要使用该方法来调用 Kafka 的生产者 FlinkKafkaProducer，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.指定Kafka的相关配置属性</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;192.168.200.0:9092&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.接收Kafka上的数据</span></span><br><span class="line">DataStream&lt;String&gt; stream = env</span><br><span class="line">    .addSource(<span class="keyword">new</span> <span class="title class_">FlinkKafkaConsumer</span>&lt;&gt;(<span class="string">&quot;flink-stream-in-topic&quot;</span>, <span class="keyword">new</span> <span class="title class_">SimpleStringSchema</span>(), properties));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.定义计算结果到 Kafka ProducerRecord 的转换</span></span><br><span class="line">KafkaSerializationSchema&lt;String&gt; kafkaSerializationSchema = <span class="keyword">new</span> <span class="title class_">KafkaSerializationSchema</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ProducerRecord&lt;<span class="type">byte</span>[], <span class="type">byte</span>[]&gt; serialize(String element, <span class="meta">@Nullable</span> Long timestamp) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;flink-stream-out-topic&quot;</span>, element.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 4. 定义Flink Kafka生产者</span></span><br><span class="line">FlinkKafkaProducer&lt;String&gt; kafkaProducer = <span class="keyword">new</span> <span class="title class_">FlinkKafkaProducer</span>&lt;&gt;(<span class="string">&quot;flink-stream-out-topic&quot;</span>,</span><br><span class="line">                                                                    kafkaSerializationSchema,</span><br><span class="line">                                                                    properties,</span><br><span class="line">                                               FlinkKafkaProducer.Semantic.AT_LEAST_ONCE, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 5. 将接收到输入元素*2后写出到Kafka</span></span><br><span class="line">stream.map((MapFunction&lt;String, String&gt;) value -&gt; value + value).addSink(kafkaProducer);</span><br><span class="line">env.execute(<span class="string">&quot;Flink Streaming&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="3-2-创建输出主题">3.2 创建输出主题</h3>
<p>创建用于输出测试的主题：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --create \</span><br><span class="line">                    --bootstrap-server hadoop001:9092 \</span><br><span class="line">                    --replication-factor 1 \</span><br><span class="line">                    --partitions 1  \</span><br><span class="line">                    --topic flink-stream-out-topic</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看所有主题</span></span><br><span class="line"> bin/kafka-topics.sh --list --bootstrap-server hadoop001:9092</span><br></pre></td></tr></table></figure>
<h3 id="3-3-启动消费者">3.3 启动消费者</h3>
<p>启动一个 Kafka 消费者，用于查看 Flink 程序的输出情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server hadoop001:<span class="number">9092</span> --topic flink-stream-out-topic</span><br></pre></td></tr></table></figure>
<h3 id="3-4-测试结果">3.4 测试结果</h3>
<p>在 Kafka 生产者上发送消息到 Flink 程序，观察 Flink 程序转换后的输出情况，具体如下：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-kafka-producer-consumer.png"/> </div>
<p>可以看到 Kafka 生成者发出的数据已经被 Flink 程序正常接收到，并经过转换后又输出到 Kafka 对应的 Topic 上。</p>
<h2 id="四、自定义-Sink">四、自定义 Sink</h2>
<p>除了使用内置的第三方连接器外，Flink 还支持使用自定义的 Sink 来满足多样化的输出需求。想要实现自定义的 Sink ，需要直接或者间接实现 SinkFunction 接口。通常情况下，我们都是实现其抽象类 RichSinkFunction，相比于 SinkFunction ，其提供了更多的与生命周期相关的方法。两者间的关系如下：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-richsink.png"/> </div>
<p>这里我们以自定义一个 FlinkToMySQLSink 为例，将计算结果写出到 MySQL 数据库中，具体步骤如下：</p>
<h3 id="4-1-导入依赖">4.1 导入依赖</h3>
<p>首先需要导入 MySQL 相关的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-自定义-Sink">4.2 自定义 Sink</h3>
<p>继承自 RichSinkFunction，实现自定义的 Sink ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlinkToMySQLSink</span> <span class="keyword">extends</span> <span class="title class_">RichSinkFunction</span>&lt;Employee&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PreparedStatement stmt;</span><br><span class="line">    <span class="keyword">private</span> Connection conn;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://192.168.0.229:3306/employees&quot;</span> +</span><br><span class="line">                                           <span class="string">&quot;?characterEncoding=UTF-8&amp;serverTimezone=UTC&amp;useSSL=false&quot;</span>, </span><br><span class="line">                                           <span class="string">&quot;root&quot;</span>, </span><br><span class="line">                                           <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into emp(name, age, birthday) values(?, ?, ?)&quot;</span>;</span><br><span class="line">        stmt = conn.prepareStatement(sql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Employee value, Context context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        stmt.setString(<span class="number">1</span>, value.getName());</span><br><span class="line">        stmt.setInt(<span class="number">2</span>, value.getAge());</span><br><span class="line">        stmt.setDate(<span class="number">3</span>, value.getBirthday());</span><br><span class="line">        stmt.executeUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">super</span>.close();</span><br><span class="line">        <span class="keyword">if</span> (stmt != <span class="literal">null</span>) &#123;</span><br><span class="line">            stmt.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-使用自定义-Sink">4.3 使用自定义 Sink</h3>
<p>想要使用自定义的 Sink，同样是需要调用 addSink 方法，具体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis());</span><br><span class="line">DataStreamSource&lt;Employee&gt; streamSource = env.fromElements(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;hei&quot;</span>, <span class="number">10</span>, date),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;bai&quot;</span>, <span class="number">20</span>, date),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;ying&quot;</span>, <span class="number">30</span>, date));</span><br><span class="line">streamSource.addSink(<span class="keyword">new</span> <span class="title class_">FlinkToMySQLSink</span>());</span><br><span class="line">env.execute();</span><br></pre></td></tr></table></figure>
<h3 id="4-4-测试结果">4.4 测试结果</h3>
<p>启动程序，观察数据库写入情况：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-mysql-sink.png"/> </div>
<p>数据库成功写入，代表自定义 Sink 整合成功。</p>
<blockquote>
<p>以上所有用例的源码见本仓库：<a href="https://github.com/oicio/BigData-Notes/tree/master/code/Flink/flink-kafka-integration">flink-kafka-integration</a></p>
</blockquote>
<h2 id="参考资料-2">参考资料</h2>
<ol>
<li class="lvl-3">
<p>data-sinks： <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/datastream_api.html#data-sinks">https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/datastream_api.html#data-sinks</a></p>
</li>
<li class="lvl-3">
<p>Streaming Connectors：<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/connectors/index.html">https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/connectors/index.html</a></p>
</li>
<li class="lvl-3">
<p>Apache Kafka Connector： <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/connectors/kafka.html">https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/connectors/kafka.html</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink Data Source</title>
    <url>/posts/e01c9e8b.html</url>
    <content><![CDATA[<h2 id="一、内置-Data-Source">一、内置 Data Source</h2>
<p>Flink Data Source 用于定义 Flink 程序的数据来源，Flink 官方提供了多种数据获取方法，用于帮助开发者简单快速地构建输入流，具体如下：</p>
<h3 id="1-1-基于文件构建">1.1 基于文件构建</h3>
<p><strong>1. readTextFile(path)</strong>：按照 TextInputFormat 格式读取文本文件，并将其内容以字符串的形式返回。示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">env.readTextFile(filePath).print();</span><br></pre></td></tr></table></figure>
<p><strong>2. readFile(fileInputFormat, path)</strong> ：按照指定格式读取文件。</p>
<p><strong>3. readFile(inputFormat, filePath, watchType, interval, typeInformation)</strong>：按照指定格式周期性的读取文件。其中各个参数的含义如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>inputFormat</strong>：数据流的输入格式。</p>
</li>
<li class="lvl-2">
<p><strong>filePath</strong>：文件路径，可以是本地文件系统上的路径，也可以是 HDFS 上的文件路径。</p>
</li>
<li class="lvl-2">
<p><strong>watchType</strong>：读取方式，它有两个可选值，分别是 <code>FileProcessingMode.PROCESS_ONCE</code> 和 <code>FileProcessingMode.PROCESS_CONTINUOUSLY</code>：前者表示对指定路径上的数据只读取一次，然后退出；后者表示对路径进行定期地扫描和读取。需要注意的是如果 watchType 被设置为 <code>PROCESS_CONTINUOUSLY</code>，那么当文件被修改时，其所有的内容 (包含原有的内容和新增的内容) 都将被重新处理，因此这会打破 Flink 的 <em>exactly-once</em> 语义。</p>
</li>
<li class="lvl-2">
<p><strong>interval</strong>：定期扫描的时间间隔。</p>
</li>
<li class="lvl-2">
<p><strong>typeInformation</strong>：输入流中元素的类型。</p>
</li>
</ul>
<p>使用示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\log4j.properties&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">env.readFile(<span class="keyword">new</span> <span class="title class_">TextInputFormat</span>(<span class="keyword">new</span> <span class="title class_">Path</span>(filePath)),</span><br><span class="line">             filePath,</span><br><span class="line">             FileProcessingMode.PROCESS_ONCE,</span><br><span class="line">             <span class="number">1</span>,</span><br><span class="line">             BasicTypeInfo.STRING_TYPE_INFO).print();</span><br><span class="line">env.execute();</span><br></pre></td></tr></table></figure>
<h3 id="1-2-基于集合构建">1.2 基于集合构建</h3>
<p><strong>1. fromCollection(Collection)</strong>：基于集合构建，集合中的所有元素必须是同一类型。示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">env.fromCollection(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)).print();</span><br></pre></td></tr></table></figure>
<p><strong>2. fromElements(T …)</strong>： 基于元素构建，所有元素必须是同一类型。示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">env.fromElements(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).print();</span><br></pre></td></tr></table></figure>
<p><strong>3. generateSequence(from, to)</strong>：基于给定的序列区间进行构建。示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">env.generateSequence(<span class="number">0</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p><strong>4. fromCollection(Iterator, Class)</strong>：基于迭代器进行构建。第一个参数用于定义迭代器，第二个参数用于定义输出元素的类型。使用示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">env.fromCollection(<span class="keyword">new</span> <span class="title class_">CustomIterator</span>(), BasicTypeInfo.INT_TYPE_INFO).print();</span><br></pre></td></tr></table></figure>
<p>其中 CustomIterator 为自定义的迭代器，这里以产生 1 到 100 区间内的数据为例，源码如下。需要注意的是自定义迭代器除了要实现 Iterator 接口外，还必须要实现序列化接口 Serializable ，否则会抛出序列化失败的异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;Integer&gt;, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i &lt; <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5. fromParallelCollection(SplittableIterator, Class)</strong>：方法接收两个参数，第二个参数用于定义输出元素的类型，第一个参数 SplittableIterator 是迭代器的抽象基类，它用于将原始迭代器的值拆分到多个不相交的迭代器中。</p>
<h3 id="1-3-基于-Socket-构建">1.3  基于 Socket 构建</h3>
<p>Flink 提供了 socketTextStream 方法用于构建基于 Socket 的数据流，socketTextStream 方法有以下四个主要参数：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>hostname</strong>：主机名；</p>
</li>
<li class="lvl-2">
<p><strong>port</strong>：端口号，设置为 0 时，表示端口号自动分配；</p>
</li>
<li class="lvl-2">
<p><strong>delimiter</strong>：用于分隔每条记录的分隔符；</p>
</li>
<li class="lvl-2">
<p><strong>maxRetry</strong>：当 Socket 临时关闭时，程序的最大重试间隔，单位为秒。设置为 0 时表示不进行重试；设置为负值则表示一直重试。示例如下：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">env.socketTextStream(&quot;192.168.0.229&quot;, 9999, &quot;\n&quot;, 3).print();</span><br></pre></td></tr></table></figure>
<h2 id="二、自定义-Data-Source">二、自定义 Data Source</h2>
<h3 id="2-1-SourceFunction">2.1 SourceFunction</h3>
<p>除了内置的数据源外，用户还可以使用 <code>addSource</code> 方法来添加自定义的数据源。自定义的数据源必须要实现 SourceFunction 接口，这里以产生 [0 , 1000) 区间内的数据为例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">env.addSource(<span class="keyword">new</span> <span class="title class_">SourceFunction</span>&lt;Long&gt;() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">isRunning</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(SourceContext&lt;Long&gt; ctx)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isRunning &amp;&amp; count &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过collect将输入发送出去 </span></span><br><span class="line">            ctx.collect(count);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span> &#123;</span><br><span class="line">        isRunning = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;).print();</span><br><span class="line">env.execute();</span><br></pre></td></tr></table></figure>
<h3 id="2-2-ParallelSourceFunction-和-RichParallelSourceFunction">2.2 ParallelSourceFunction 和 RichParallelSourceFunction</h3>
<p>上面通过 SourceFunction 实现的数据源是不具有并行度的，即不支持在得到的 DataStream 上调用 <code>setParallelism(n)</code> 方法，此时会抛出如下的异常：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Source: 1 is not a parallel source</span><br></pre></td></tr></table></figure>
<p>如果你想要实现具有并行度的输入流，则需要实现 ParallelSourceFunction 或 RichParallelSourceFunction 接口，其与 SourceFunction 的关系如下图：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-RichParallelSourceFunction.png"/> </div>
ParallelSourceFunction 直接继承自 ParallelSourceFunction，具有并行度的功能。RichParallelSourceFunction 则继承自 AbstractRichFunction，同时实现了 ParallelSourceFunction 接口，所以其除了具有并行度的功能外，还提供了额外的与生命周期相关的方法，如 open() ，closen() 。
<h2 id="三、Streaming-Connectors">三、Streaming Connectors</h2>
<h3 id="3-1-内置连接器">3.1 内置连接器</h3>
<p>除了自定义数据源外， Flink 还内置了多种连接器，用于满足大多数的数据收集场景。当前内置连接器的支持情况如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Apache Kafka (支持 source 和 sink)</p>
</li>
<li class="lvl-2">
<p>Apache Cassandra (sink)</p>
</li>
<li class="lvl-2">
<p>Amazon Kinesis Streams (source/sink)</p>
</li>
<li class="lvl-2">
<p>Elasticsearch (sink)</p>
</li>
<li class="lvl-2">
<p>Hadoop FileSystem (sink)</p>
</li>
<li class="lvl-2">
<p>RabbitMQ (source/sink)</p>
</li>
<li class="lvl-2">
<p>Apache NiFi (source/sink)</p>
</li>
<li class="lvl-2">
<p>Twitter Streaming API (source)</p>
</li>
<li class="lvl-2">
<p>Google PubSub (source/sink)</p>
</li>
</ul>
<p>除了上述的连接器外，你还可以通过 Apache Bahir 的连接器扩展 Flink。Apache Bahir 旨在为分布式数据分析系统 (如 Spark，Flink) 等提供功能上的扩展，当前其支持的与 Flink 相关的连接器如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Apache ActiveMQ (source/sink)</p>
</li>
<li class="lvl-2">
<p>Apache Flume (sink)</p>
</li>
<li class="lvl-2">
<p>Redis (sink)</p>
</li>
<li class="lvl-2">
<p>Akka (sink)</p>
</li>
<li class="lvl-2">
<p>Netty (source)</p>
</li>
</ul>
<p>随着 Flink 的不断发展，可以预见到其会支持越来越多类型的连接器，关于连接器的后续发展情况，可以查看其官方文档：<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/connectors/index.html">Streaming Connectors</a> 。在所有 DataSource 连接器中，使用的广泛的就是 Kafka，所以这里我们以其为例，来介绍 Connectors 的整合步骤。</p>
<h3 id="3-2-整合-Kakfa">3.2 整合 Kakfa</h3>
<h4 id="1-导入依赖">1. 导入依赖</h4>
<p>整合 Kafka 时，一定要注意所使用的 Kafka 的版本，不同版本间所需的 Maven 依赖和开发时所调用的类均不相同，具体如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Maven 依赖</th>
<th style="text-align:left">Flink 版本</th>
<th style="text-align:left">Consumer and Producer 类的名称</th>
<th style="text-align:left">Kafka 版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">flink-connector-kafka-0.8_2.11</td>
<td style="text-align:left">1.0.0 +</td>
<td style="text-align:left">FlinkKafkaConsumer08 <br/>FlinkKafkaProducer08</td>
<td style="text-align:left">0.8.x</td>
</tr>
<tr>
<td style="text-align:left">flink-connector-kafka-0.9_2.11</td>
<td style="text-align:left">1.0.0 +</td>
<td style="text-align:left">FlinkKafkaConsumer09<br/> FlinkKafkaProducer09</td>
<td style="text-align:left">0.9.x</td>
</tr>
<tr>
<td style="text-align:left">flink-connector-kafka-0.10_2.11</td>
<td style="text-align:left">1.2.0 +</td>
<td style="text-align:left">FlinkKafkaConsumer010 <br/>FlinkKafkaProducer010</td>
<td style="text-align:left">0.10.x</td>
</tr>
<tr>
<td style="text-align:left">flink-connector-kafka-0.11_2.11</td>
<td style="text-align:left">1.4.0 +</td>
<td style="text-align:left">FlinkKafkaConsumer011 <br/>FlinkKafkaProducer011</td>
<td style="text-align:left">0.11.x</td>
</tr>
<tr>
<td style="text-align:left">flink-connector-kafka_2.11</td>
<td style="text-align:left">1.7.0 +</td>
<td style="text-align:left">FlinkKafkaConsumer <br/>FlinkKafkaProducer</td>
<td style="text-align:left">&gt;= 1.0.0</td>
</tr>
</tbody>
</table>
<p>这里我使用的 Kafka 版本为 kafka_2.12-2.2.0，添加的依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-kafka_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-代码开发">2. 代码开发</h4>
<p>这里以最简单的场景为例，接收 Kafka 上的数据并打印，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"><span class="comment">// 指定Kafka的连接位置</span></span><br><span class="line">properties.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;hadoop001:9092&quot;</span>);</span><br><span class="line"><span class="comment">// 指定监听的主题，并定义Kafka字节消息到Flink对象之间的转换规则</span></span><br><span class="line">DataStream&lt;String&gt; stream = env</span><br><span class="line">    .addSource(<span class="keyword">new</span> <span class="title class_">FlinkKafkaConsumer</span>&lt;&gt;(<span class="string">&quot;flink-stream-in-topic&quot;</span>, <span class="keyword">new</span> <span class="title class_">SimpleStringSchema</span>(), properties));</span><br><span class="line">stream.print();</span><br><span class="line">env.execute(<span class="string">&quot;Flink Streaming&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="3-3-整合测试">3.3 整合测试</h3>
<h4 id="1-启动-Kakfa">1. 启动 Kakfa</h4>
<p>Kafka 的运行依赖于 zookeeper，需要预先启动，可以启动 Kafka 内置的 zookeeper，也可以启动自己安装的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">zookeeper启动命令</span></span><br><span class="line">bin/zkServer.sh start</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">内置zookeeper启动命令</span></span><br><span class="line">bin/zookeeper-server-start.sh config/zookeeper.properties</span><br></pre></td></tr></table></figure>
<p>启动单节点 kafka 用于测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">bin/kafka-server-start.sh config/server.properties</span></span><br></pre></td></tr></table></figure>
<h4 id="2-创建-Topic">2. 创建 Topic</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">创建用于测试主题</span></span><br><span class="line">bin/kafka-topics.sh --create \</span><br><span class="line">                    --bootstrap-server hadoop001:9092 \</span><br><span class="line">                    --replication-factor 1 \</span><br><span class="line">                    --partitions 1  \</span><br><span class="line">                    --topic flink-stream-in-topic</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看所有主题</span></span><br><span class="line"> bin/kafka-topics.sh --list --bootstrap-server hadoop001:9092</span><br></pre></td></tr></table></figure>
<h4 id="3-启动-Producer">3. 启动 Producer</h4>
<p>这里 启动一个 Kafka 生产者，用于发送测试数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --broker-list hadoop001:9092 --topic flink-stream-in-topic</span><br></pre></td></tr></table></figure>
<h4 id="4-测试结果">4. 测试结果</h4>
<p>在 Producer 上输入任意测试数据，之后观察程序控制台的输出：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-kafka-datasource-producer.png"/> </div>
程序控制台的输出如下：
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-kafka-datasource-console.png"/> </div>
可以看到已经成功接收并打印出相关的数据。
<h2 id="参考资料-3">参考资料</h2>
<ol>
<li class="lvl-3">
<p>data-sources：<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/datastream_api.html#data-sources">https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/datastream_api.html#data-sources</a></p>
</li>
<li class="lvl-3">
<p>Streaming Connectors：<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/connectors/index.html">https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/connectors/index.html</a></p>
</li>
<li class="lvl-3">
<p>Apache Kafka Connector： <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/connectors/kafka.html">https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/connectors/kafka.html</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink-Standalone集群部署</title>
    <url>/posts/4715144a.html</url>
    <content><![CDATA[<h2 id="一、部署模式">一、部署模式</h2>
<p>Flink 支持使用多种部署模式来满足不同规模应用的需求，常见的有单机模式，Standalone Cluster 模式，同时 Flink 也支持部署在其他第三方平台上，如 YARN，Mesos，Docker，Kubernetes 等。以下主要介绍其单机模式和 Standalone Cluster 模式的部署。</p>
<h2 id="二、单机模式">二、单机模式</h2>
<p>单机模式是一种开箱即用的模式，可以在单台服务器上运行，适用于日常的开发和调试。具体操作步骤如下：</p>
<h3 id="2-1-安装部署">2.1 安装部署</h3>
<p><strong>1. 前置条件</strong></p>
<p>Flink 的运行依赖 JAVA 环境，故需要预先安装好 JDK，具体步骤可以参考：<a href="https://github.com/oicio/BigData-Notes/blob/master/notes/installation/Linux%E4%B8%8BJDK%E5%AE%89%E8%A3%85.md">Linux 环境下 JDK 安装</a></p>
<p><strong>2. 下载 &amp; 解压 &amp; 运行</strong></p>
<p>Flink 所有版本的安装包可以直接从其<a href="https://flink.apache.org/downloads.html">官网</a>进行下载，这里我下载的 Flink 的版本为 <code>1.9.1</code> ，要求的 JDK 版本为 <code>1.8.x +</code>。 下载后解压到指定目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf flink-1.9.1-bin-scala_2.12.tgz  -C /usr/app</span><br></pre></td></tr></table></figure>
<p>不需要进行任何配置，直接使用以下命令就可以启动单机版本的 Flink：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/start-cluster.sh</span><br></pre></td></tr></table></figure>
<p><strong>3. WEB UI 界面</strong></p>
<p>Flink 提供了 WEB 界面用于直观的管理 Flink 集群，访问端口为 <code>8081</code>：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-dashboard.png"/> </div>
<p>Flink 的 WEB UI 界面支持大多数常用功能，如提交作业，取消作业，查看各个节点运行情况，查看作业执行情况等，大家可以在部署完成后，进入该页面进行详细的浏览。</p>
<h3 id="2-2-作业提交">2.2 作业提交</h3>
<p>启动后可以运行安装包中自带的词频统计案例，具体步骤如下：</p>
<p><strong>1. 开启端口</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -lk 9999</span><br></pre></td></tr></table></figure>
<p><strong>2. 提交作业</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/flink run examples/streaming/SocketWindowWordCount.jar --port 9999</span><br></pre></td></tr></table></figure>
<p>该 JAR 包的源码可以在 Flink 官方的 GitHub 仓库中找到，地址为 ：<a href="https://github.com/apache/flink/blob/master/flink-examples/flink-examples-streaming/src/main/java/org/apache/flink/streaming/examples/socket/SocketWindowWordCount.java">SocketWindowWordCount</a> ，可选传参有 hostname， port，对应的词频数据需要使用空格进行分割。</p>
<p><strong>3. 输入测试数据</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a a b b c c c a e</span><br></pre></td></tr></table></figure>
<p><strong>4. 查看控制台输出</strong></p>
<p>可以通过 WEB UI 的控制台查看作业统运行情况：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-socket-wordcount.png"/> </div>
<p>也可以通过 WEB 控制台查看到统计结果：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-socket-wordcount-stdout.png"/> </div>
<h3 id="2-3-停止作业">2.3 停止作业</h3>
<p>可以直接在 WEB 界面上点击对应作业的 <code>Cancel Job</code>  按钮进行取消，也可以使用命令行进行取消。使用命令行进行取消时，需要先获取到作业的 JobId，可以使用 <code>flink list</code> 命令查看，输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop001 flink-1.9.1]# ./bin/flink list</span><br><span class="line">Waiting for response...</span><br><span class="line">------------------ Running/Restarting Jobs -------------------</span><br><span class="line">05.11.2019 08:19:53 : ba2b1cc41a5e241c32d574c93de8a2bc : Socket Window WordCount (RUNNING)</span><br><span class="line">--------------------------------------------------------------</span><br><span class="line">No scheduled jobs.</span><br></pre></td></tr></table></figure>
<p>获取到 JobId 后，就可以使用 <code>flink cancel</code> 命令取消作业：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/flink cancel ba2b1cc41a5e241c32d574c93de8a2bc</span><br></pre></td></tr></table></figure>
<h3 id="2-4-停止-Flink">2.4 停止 Flink</h3>
<p>命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/stop-cluster.sh</span><br></pre></td></tr></table></figure>
<h2 id="三、Standalone-Cluster">三、Standalone Cluster</h2>
<p>Standalone Cluster 模式是 Flink 自带的一种集群模式，具体配置步骤如下：</p>
<h3 id="3-1-前置条件">3.1 前置条件</h3>
<p>使用该模式前，需要确保所有服务器间都已经配置好 SSH 免密登录服务。这里我以三台服务器为例，主机名分别为 hadoop001，hadoop002，hadoop003 , 其中 hadoop001 为 master 节点，其余两台为 slave 节点，搭建步骤如下：</p>
<h3 id="3-2-搭建步骤">3.2 搭建步骤</h3>
<p>修改 <code>conf/flink-conf.yaml</code> 中 jobmanager 节点的通讯地址为 hadoop001:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jobmanager.rpc.address:</span> <span class="string">hadoop001</span></span><br></pre></td></tr></table></figure>
<p>修改 <code>conf/slaves</code> 配置文件，将 hadoop002 和 hadoop003 配置为 slave 节点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop002</span><br><span class="line">hadoop003</span><br></pre></td></tr></table></figure>
<p>将配置好的 Flink 安装包分发到其他两台服务器上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -r /usr/app/flink-1.9.1 hadoop002:/usr/app</span><br><span class="line">scp -r /usr/app/flink-1.9.1 hadoop003:/usr/app</span><br></pre></td></tr></table></figure>
<p>在 hadoop001 上使用和单机模式相同的命令来启动集群：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/start-cluster.sh</span><br></pre></td></tr></table></figure>
<p>此时控制台输出如下：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-start-cluster-shell.png"/> </div>
<p>启动完成后可以使用 <code>Jps</code> 命令或者通过 WEB 界面来查看是否启动成功。</p>
<h3 id="3-3-可选配置">3.3 可选配置</h3>
<p>除了上面介绍的 <em>jobmanager.rpc.address</em> 是必选配置外，Flink h还支持使用其他可选参数来优化集群性能，主要如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>jobmanager.heap.size</strong>：JobManager 的 JVM 堆内存大小，默认为 1024m 。</p>
</li>
<li class="lvl-2">
<p><strong>taskmanager.heap.size</strong>：Taskmanager 的 JVM 堆内存大小，默认为 1024m 。</p>
</li>
<li class="lvl-2">
<p><strong>taskmanager.numberOfTaskSlots</strong>：Taskmanager 上 slots 的数量，通常设置为 CPU 核心的数量，或其一半。</p>
</li>
<li class="lvl-2">
<p><strong>parallelism.default</strong>：任务默认的并行度。</p>
</li>
<li class="lvl-2">
<p><strong>io.tmp.dirs</strong>：存储临时文件的路径，如果没有配置，则默认采用服务器的临时目录，如 LInux 的 <code>/tmp</code> 目录。</p>
</li>
</ul>
<p>更多配置可以参考 Flink 的官方手册：<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/ops/config.html">Configuration</a></p>
<h2 id="四、Standalone-Cluster-HA">四、Standalone Cluster HA</h2>
<p>上面我们配置的 Standalone 集群实际上只有一个 JobManager，此时是存在单点故障的，所以官方提供了 Standalone Cluster HA 模式来实现集群高可用。</p>
<h3 id="4-1-前置条件">4.1 前置条件</h3>
<p>在 Standalone Cluster HA 模式下，集群可以由多个 JobManager，但只有一个处于 active 状态，其余的则处于备用状态，Flink 使用 ZooKeeper 来选举出 Active JobManager，并依赖其来提供一致性协调服务，所以需要预先安装 ZooKeeper 。</p>
<p>另外在高可用模式下，还需要使用分布式文件系统来持久化存储 JobManager 的元数据，最常用的就是 HDFS，所以 Hadoop 也需要预先安装。关于 Hadoop 集群和 ZooKeeper 集群的搭建可以参考：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://github.com/oicio/BigData-Notes/blob/master/notes/installation/Hadoop%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md">Hadoop 集群环境搭建</a></p>
</li>
<li class="lvl-2">
<p><a href="https://github.com/oicio/BigData-Notes/blob/master/notes/installation/Zookeeper%E5%8D%95%E6%9C%BA%E7%8E%AF%E5%A2%83%E5%92%8C%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md">Zookeeper 单机环境和集群环境搭建</a></p>
</li>
</ul>
<h3 id="4-2-搭建步骤">4.2 搭建步骤</h3>
<p>修改 <code>conf/flink-conf.yaml</code> 文件，增加如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置使用zookeeper来开启高可用模式</span></span><br><span class="line"><span class="attr">high-availability:</span> <span class="string">zookeeper</span></span><br><span class="line"><span class="comment"># 配置zookeeper的地址，采用zookeeper集群时，可以使用逗号来分隔多个节点地址</span></span><br><span class="line"><span class="attr">high-availability.zookeeper.quorum:</span> <span class="string">hadoop003:2181</span></span><br><span class="line"><span class="comment"># 在zookeeper上存储flink集群元信息的路径</span></span><br><span class="line"><span class="attr">high-availability.zookeeper.path.root:</span> <span class="string">/flink</span></span><br><span class="line"><span class="comment"># 集群id</span></span><br><span class="line"><span class="attr">high-availability.cluster-id:</span> <span class="string">/standalone_cluster_one</span></span><br><span class="line"><span class="comment"># 持久化存储JobManager元数据的地址，zookeeper上存储的只是指向该元数据的指针信息</span></span><br><span class="line"><span class="attr">high-availability.storageDir:</span> <span class="string">hdfs://hadoop001:8020/flink/recovery</span></span><br></pre></td></tr></table></figure>
<p>修改 <code>conf/masters</code> 文件，将 hadoop001 和 hadoop002 都配置为 master 节点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop001:8081</span><br><span class="line">hadoop002:8081</span><br></pre></td></tr></table></figure>
<p>确保 Hadoop 和 ZooKeeper 已经启动后，使用以下命令来启动集群：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/start-cluster.sh</span><br></pre></td></tr></table></figure>
<p>此时输出如下：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-standalone-cluster-ha.png"/> </div>
<p>可以看到集群已经以 HA 的模式启动，此时还需要在各个节点上使用 <code>jps</code> 命令来查看进程是否启动成功，正常情况如下：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-standalone-cluster-jps.png"/> </div>
<p>只有 hadoop001 和 hadoop002 的 JobManager 进程，hadoop002 和 hadoop003 上的 TaskManager 进程都已经完全启动，才表示 Standalone Cluster HA 模式搭建成功。</p>
<h3 id="4-3-常见异常">4.3 常见异常</h3>
<p>如果进程没有启动，可以通过查看 <code>log</code> 目录下的日志来定位错误，常见的一个错误如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2019-11-05 09:18:35,877 INFO  org.apache.flink.runtime.entrypoint.ClusterEntrypoint      </span><br><span class="line">- Shutting StandaloneSessionClusterEntrypoint down with application status FAILED. Diagnostics</span><br><span class="line">java.io.IOException: Could not create FileSystem for highly available storage (high-availability.storageDir)</span><br><span class="line">.......</span><br><span class="line">Caused by: org.apache.flink.core.fs.UnsupportedFileSystemSchemeException: Could not find a file </span><br><span class="line">system implementation for scheme &#x27;hdfs&#x27;. The scheme is not directly supported by Flink and no </span><br><span class="line">Hadoop file system to support this scheme could be loaded.</span><br><span class="line">.....</span><br><span class="line">Caused by: org.apache.flink.core.fs.UnsupportedFileSystemSchemeException: Hadoop is not in </span><br><span class="line">the classpath/dependencies.</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>可以看到是因为在 classpath 目录下找不到 Hadoop 的相关依赖，此时需要检查是否在环境变量中配置了 Hadoop 的安装路径，如果路径已经配置但仍然存在上面的问题，可以从 <a href="https://flink.apache.org/downloads.html">Flink 官网</a>下载对应版本的 Hadoop 组件包：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-optional-components.png"/> </div>
<p>下载完成后，将该 JAR 包上传至<strong>所有</strong> Flink 安装目录的 <code>lib</code> 目录即可。</p>
<h2 id="参考资料-4">参考资料</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/ops/deployment/cluster_setup.html#standalone-cluster">Standalone Cluster</a></p>
</li>
<li class="lvl-2">
<p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/ops/jobmanager_high_availability.html">JobManager High Availability (HA)</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink_Data_Transformation</title>
    <url>/posts/c3cae06a.html</url>
    <content><![CDATA[<h2 id="一、Transformations-分类">一、Transformations 分类</h2>
<p>Flink 的 Transformations 操作主要用于将一个和多个 DataStream 按需转换成新的 DataStream。它主要分为以下三类：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>DataStream Transformations</strong>：进行数据流相关转换操作；</p>
</li>
<li class="lvl-2">
<p><strong>Physical partitioning</strong>：物理分区。Flink 提供的底层 API ，允许用户定义数据的分区规则；</p>
</li>
<li class="lvl-2">
<p><strong>Task chaining and resource groups</strong>：任务链和资源组。允许用户进行任务链和资源组的细粒度的控制。</p>
</li>
</ul>
<p>以下分别对其主要 API 进行介绍：</p>
<h2 id="二、DataStream-Transformations">二、DataStream Transformations</h2>
<h3 id="2-1-Map-DataStream-→-DataStream">2.1 Map [DataStream → DataStream]</h3>
<p>对一个 DataStream 中的每个元素都执行特定的转换操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataStream&lt;Integer&gt; integerDataStream = env.fromElements(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">integerDataStream.map((MapFunction&lt;Integer, Object&gt;) value -&gt; value * <span class="number">2</span>).print();</span><br><span class="line"><span class="comment">// 输出 2,4,6,8,10</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-FlatMap-DataStream-→-DataStream">2.2 FlatMap [DataStream → DataStream]</h3>
<p>FlatMap 与 Map 类似，但是 FlatMap 中的一个输入元素可以被映射成一个或者多个输出元素，示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">string01</span> <span class="operator">=</span> <span class="string">&quot;one one one two two&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">string02</span> <span class="operator">=</span> <span class="string">&quot;third third third four&quot;</span>;</span><br><span class="line">DataStream&lt;String&gt; stringDataStream = env.fromElements(string01, string02);</span><br><span class="line">stringDataStream.flatMap(<span class="keyword">new</span> <span class="title class_">FlatMapFunction</span>&lt;String, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatMap</span><span class="params">(String value, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : value.split(<span class="string">&quot; &quot;</span>)) &#123;</span><br><span class="line">            out.collect(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).print();</span><br><span class="line"><span class="comment">// 输出每一个独立的单词，为节省排版，这里去掉换行，后文亦同</span></span><br><span class="line">one one one two two third third third four</span><br></pre></td></tr></table></figure>
<h3 id="2-3-Filter-DataStream-→-DataStream">2.3 Filter [DataStream → DataStream]</h3>
<p>用于过滤符合条件的数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">env.fromElements(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).filter(x -&gt; x &gt; <span class="number">3</span>).print();</span><br></pre></td></tr></table></figure>
<h3 id="2-4-KeyBy-和-Reduce">2.4 KeyBy 和 Reduce</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>KeyBy [DataStream → KeyedStream]</strong> ：用于将相同 Key 值的数据分到相同的分区中；</p>
</li>
<li class="lvl-2">
<p><strong>Reduce [KeyedStream → DataStream]</strong> ：用于对数据执行归约计算。</p>
</li>
</ul>
<p>如下例子将数据按照 key 值分区后，滚动进行求和计算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; tuple2DataStream = env.fromElements(<span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>),</span><br><span class="line">                                                                        <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(<span class="string">&quot;a&quot;</span>, <span class="number">2</span>), </span><br><span class="line">                                                                        <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(<span class="string">&quot;b&quot;</span>, <span class="number">3</span>), </span><br><span class="line">                                                                        <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(<span class="string">&quot;b&quot;</span>, <span class="number">5</span>));</span><br><span class="line">KeyedStream&lt;Tuple2&lt;String, Integer&gt;, Tuple&gt; keyedStream = tuple2DataStream.keyBy(<span class="number">0</span>);</span><br><span class="line">keyedStream.reduce((ReduceFunction&lt;Tuple2&lt;String, Integer&gt;&gt;) (value1, value2) -&gt;</span><br><span class="line">                   <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(value1.f0, value1.f1 + value2.f1)).print();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 持续进行求和计算，输出：</span></span><br><span class="line">(a,<span class="number">1</span>)</span><br><span class="line">(a,<span class="number">3</span>)</span><br><span class="line">(b,<span class="number">3</span>)</span><br><span class="line">(b,<span class="number">8</span>)</span><br></pre></td></tr></table></figure>
<p>KeyBy 操作存在以下两个限制：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>KeyBy 操作用于用户自定义的 POJOs 类型时，该自定义类型必须重写 hashCode 方法；</p>
</li>
<li class="lvl-2">
<p>KeyBy 操作不能用于数组类型。</p>
</li>
</ul>
<h3 id="2-5-Aggregations-KeyedStream-→-DataStream">2.5 Aggregations [KeyedStream → DataStream]</h3>
<p>Aggregations 是官方提供的聚合算子，封装了常用的聚合操作，如上利用 Reduce 进行求和的操作也可以利用 Aggregations 中的 sum 算子重写为下面的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tuple2DataStream.keyBy(<span class="number">0</span>).sum(<span class="number">1</span>).print();</span><br></pre></td></tr></table></figure>
<p>除了 sum 外，Flink 还提供了 min , max , minBy，maxBy 等常用聚合算子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滚动计算指定key的最小值，可以通过index或者fieldName来指定key</span></span><br><span class="line">keyedStream.min(<span class="number">0</span>);</span><br><span class="line">keyedStream.min(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"><span class="comment">// 滚动计算指定key的最大值</span></span><br><span class="line">keyedStream.max(<span class="number">0</span>);</span><br><span class="line">keyedStream.max(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"><span class="comment">// 滚动计算指定key的最小值，并返回其对应的元素</span></span><br><span class="line">keyedStream.minBy(<span class="number">0</span>);</span><br><span class="line">keyedStream.minBy(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"><span class="comment">// 滚动计算指定key的最大值，并返回其对应的元素</span></span><br><span class="line">keyedStream.maxBy(<span class="number">0</span>);</span><br><span class="line">keyedStream.maxBy(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-6-Union-DataStream-→-DataStream">2.6 Union [DataStream* → DataStream]</h3>
<p>用于连接两个或者多个元素类型相同的 DataStream 。当然一个 DataStream 也可以与其本生进行连接，此时该 DataStream 中的每个元素都会被获取两次：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DataStreamSource&lt;Tuple2&lt;String, Integer&gt;&gt; streamSource01 = env.fromElements(new Tuple2&lt;&gt;(&quot;a&quot;, 1), </span><br><span class="line">                                                                            new Tuple2&lt;&gt;(&quot;a&quot;, 2));</span><br><span class="line">DataStreamSource&lt;Tuple2&lt;String, Integer&gt;&gt; streamSource02 = env.fromElements(new Tuple2&lt;&gt;(&quot;b&quot;, 1), </span><br><span class="line">                                                                            new Tuple2&lt;&gt;(&quot;b&quot;, 2));</span><br><span class="line">streamSource01.union(streamSource02);</span><br><span class="line">streamSource01.union(streamSource01,streamSource02);</span><br></pre></td></tr></table></figure>
<h3 id="2-7-Connect-DataStream-DataStream-→-ConnectedStreams">2.7 Connect [DataStream,DataStream → ConnectedStreams]</h3>
<p>Connect 操作用于连接两个或者多个类型不同的 DataStream ，其返回的类型是 ConnectedStreams ，此时被连接的多个 DataStreams 可以共享彼此之间的数据状态。但是需要注意的是由于不同 DataStream 之间的数据类型是不同的，如果想要进行后续的计算操作，还需要通过 CoMap 或 CoFlatMap 将 ConnectedStreams  转换回 DataStream：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataStreamSource&lt;Tuple2&lt;String, Integer&gt;&gt; streamSource01 = env.fromElements(<span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(<span class="string">&quot;a&quot;</span>, <span class="number">3</span>), </span><br><span class="line">                                                                            <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(<span class="string">&quot;b&quot;</span>, <span class="number">5</span>));</span><br><span class="line">DataStreamSource&lt;Integer&gt; streamSource02 = env.fromElements(<span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>);</span><br><span class="line"><span class="comment">// 使用connect进行连接</span></span><br><span class="line">ConnectedStreams&lt;Tuple2&lt;String, Integer&gt;, Integer&gt; connect = streamSource01.connect(streamSource02);</span><br><span class="line">connect.map(<span class="keyword">new</span> <span class="title class_">CoMapFunction</span>&lt;Tuple2&lt;String, Integer&gt;, Integer, Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">map1</span><span class="params">(Tuple2&lt;String, Integer&gt; value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> value.f1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">map2</span><span class="params">(Integer value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).map(x -&gt; x * <span class="number">100</span>).print();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="number">300</span> <span class="number">500</span> <span class="number">200</span> <span class="number">900</span> <span class="number">300</span></span><br></pre></td></tr></table></figure>
<h3 id="2-8-Split-和-Select">2.8 Split 和 Select</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Split [DataStream → SplitStream]</strong>：用于将一个 DataStream 按照指定规则进行拆分为多个 DataStream，需要注意的是这里进行的是逻辑拆分，即 Split 只是将数据贴上不同的类型标签，但最终返回的仍然只是一个 SplitStream；</p>
</li>
<li class="lvl-2">
<p><strong>Select [SplitStream → DataStream]</strong>：想要从逻辑拆分的 SplitStream 中获取真实的不同类型的 DataStream，需要使用 Select 算子，示例如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataStreamSource&lt;Integer&gt; streamSource = env.fromElements(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line"><span class="comment">// 标记</span></span><br><span class="line">SplitStream&lt;Integer&gt; split = streamSource.split(<span class="keyword">new</span> <span class="title class_">OutputSelector</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterable&lt;String&gt; <span class="title function_">select</span><span class="params">(Integer value)</span> &#123;</span><br><span class="line">        List&lt;String&gt; output = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        output.add(value % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">&quot;even&quot;</span> : <span class="string">&quot;odd&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 获取偶数数据集</span></span><br><span class="line">split.select(<span class="string">&quot;even&quot;</span>).print();</span><br><span class="line"><span class="comment">// 输出 2,4,6,8</span></span><br></pre></td></tr></table></figure>
<h3 id="2-9-project-DataStream-→-DataStream">2.9 project [DataStream → DataStream]</h3>
<p>project 主要用于获取 tuples 中的指定字段集，示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataStreamSource&lt;Tuple3&lt;String, Integer, String&gt;&gt; streamSource = env.fromElements(</span><br><span class="line">                                                                         <span class="keyword">new</span> <span class="title class_">Tuple3</span>&lt;&gt;(<span class="string">&quot;li&quot;</span>, <span class="number">22</span>, <span class="string">&quot;2018-09-23&quot;</span>),</span><br><span class="line">                                                                         <span class="keyword">new</span> <span class="title class_">Tuple3</span>&lt;&gt;(<span class="string">&quot;ming&quot;</span>, <span class="number">33</span>, <span class="string">&quot;2020-09-23&quot;</span>));</span><br><span class="line">streamSource.project(<span class="number">0</span>,<span class="number">2</span>).print();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">(li,<span class="number">2018</span>-09-<span class="number">23</span>)</span><br><span class="line">(ming,<span class="number">2020</span>-09-<span class="number">23</span>)</span><br></pre></td></tr></table></figure>
<h2 id="三、物理分区">三、物理分区</h2>
<p>物理分区 (Physical partitioning) 是 Flink 提供的底层的 API，允许用户采用内置的分区规则或者自定义的分区规则来对数据进行分区，从而避免数据在某些分区上过于倾斜，常用的分区规则如下：</p>
<h3 id="3-1-Random-partitioning-DataStream-→-DataStream">3.1 Random partitioning [DataStream → DataStream]</h3>
<p>随机分区 (Random partitioning) 用于随机的将数据分布到所有下游分区中，通过 shuffle 方法来进行实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dataStream.shuffle();</span><br></pre></td></tr></table></figure>
<h3 id="3-2-Rebalancing-DataStream-→-DataStream">3.2 Rebalancing [DataStream → DataStream]</h3>
<p>Rebalancing 采用轮询的方式将数据进行分区，其适合于存在数据倾斜的场景下，通过 rebalance 方法进行实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dataStream.rebalance();</span><br></pre></td></tr></table></figure>
<h3 id="3-3-Rescaling-DataStream-→-DataStream">3.3 Rescaling [DataStream → DataStream]</h3>
<p>当采用 Rebalancing 进行分区平衡时，其实现的是全局性的负载均衡，数据会通过网络传输到其他节点上并完成分区数据的均衡。 而 Rescaling 则是低配版本的 rebalance，它不需要额外的网络开销，它只会对上下游的算子之间进行重新均衡，通过 rescale 方法进行实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dataStream.rescale();</span><br></pre></td></tr></table></figure>
<p>ReScale 这个单词具有重新缩放的意义，其对应的操作也是如此，具体如下：如果上游 operation 并行度为 2，而下游的 operation 并行度为 6，则其中 1 个上游的 operation 会将元素分发到 3 个下游 operation，另 1 个上游 operation 则会将元素分发到另外 3 个下游 operation。反之亦然，如果上游的 operation 并行度为 6，而下游 operation 并行度为 2，则其中 3 个上游 operation 会将元素分发到 1 个下游 operation，另 3 个上游 operation 会将元素分发到另外 1 个下游operation：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-Rescaling.png"/> </div>
<h3 id="3-4-Broadcasting-DataStream-→-DataStream">3.4 Broadcasting [DataStream → DataStream]</h3>
<p>将数据分发到所有分区上。通常用于小数据集与大数据集进行关联的情况下，此时可以将小数据集广播到所有分区上，避免频繁的跨分区关联，通过 broadcast 方法进行实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dataStream.broadcast();</span><br></pre></td></tr></table></figure>
<h3 id="3-5-Custom-partitioning-DataStream-→-DataStream">3.5 Custom partitioning [DataStream → DataStream]</h3>
<p>Flink 运行用户采用自定义的分区规则来实现分区，此时需要通过实现 Partitioner 接口来自定义分区规则，并指定对应的分区键，示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> DataStreamSource&lt;Tuple2&lt;String, Integer&gt;&gt; streamSource = env.fromElements(<span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(<span class="string">&quot;Hadoop&quot;</span>, <span class="number">1</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(<span class="string">&quot;Spark&quot;</span>, <span class="number">1</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(<span class="string">&quot;Flink-streaming&quot;</span>, <span class="number">2</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(<span class="string">&quot;Flink-batch&quot;</span>, <span class="number">4</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(<span class="string">&quot;Storm&quot;</span>, <span class="number">4</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(<span class="string">&quot;HBase&quot;</span>, <span class="number">3</span>));</span><br><span class="line">streamSource.partitionCustom(<span class="keyword">new</span> <span class="title class_">Partitioner</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(String key, <span class="type">int</span> numPartitions)</span> &#123;</span><br><span class="line">        <span class="comment">// 将第一个字段包含flink的Tuple2分配到同一个分区</span></span><br><span class="line">        <span class="keyword">return</span> key.toLowerCase().contains(<span class="string">&quot;flink&quot;</span>) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">0</span>).print();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出如下：</span></span><br><span class="line"><span class="number">1</span>&gt; (Flink-streaming,<span class="number">2</span>)</span><br><span class="line"><span class="number">1</span>&gt; (Flink-batch,<span class="number">4</span>)</span><br><span class="line"><span class="number">2</span>&gt; (Hadoop,<span class="number">1</span>)</span><br><span class="line"><span class="number">2</span>&gt; (Spark,<span class="number">1</span>)</span><br><span class="line"><span class="number">2</span>&gt; (Storm,<span class="number">4</span>)</span><br><span class="line"><span class="number">2</span>&gt; (HBase,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h2 id="四、任务链和资源组">四、任务链和资源组</h2>
<p>任务链和资源组 ( Task chaining and resource groups ) 也是 Flink 提供的底层 API，用于控制任务链和资源分配。默认情况下，如果操作允许 (例如相邻的两次 map 操作) ，则 Flink 会尝试将它们在同一个线程内进行，从而可以获取更好的性能。但是 Flink 也允许用户自己来控制这些行为，这就是任务链和资源组 API：</p>
<h3 id="4-1-startNewChain">4.1 startNewChain</h3>
<p>startNewChain 用于基于当前 operation 开启一个新的任务链。如下所示，基于第一个 map 开启一个新的任务链，此时前一个 map 和 后一个 map 将处于同一个新的任务链中，但它们与 filter 操作则分别处于不同的任务链中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">someStream.filter(...).map(...).startNewChain().map(...);</span><br></pre></td></tr></table></figure>
<h3 id="4-2-disableChaining">4.2 disableChaining</h3>
<p>disableChaining 操作用于禁止将其他操作与当前操作放置于同一个任务链中，示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">someStream.map(...).disableChaining();</span><br></pre></td></tr></table></figure>
<h3 id="4-3-slotSharingGroup">4.3 slotSharingGroup</h3>
<p>slot 是任务管理器  (TaskManager) 所拥有资源的固定子集，每个操作 (operation) 的子任务 (sub task) 都需要获取 slot 来执行计算，但每个操作所需要资源的大小都是不相同的，为了更好地利用资源，Flink 允许不同操作的子任务被部署到同一 slot 中。slotSharingGroup 用于设置操作的 slot 共享组 (slot sharing group) ，Flink 会将具有相同 slot 共享组的操作放到同一个 slot 中 。示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">someStream.filter(...).slotSharingGroup(<span class="string">&quot;slotSharingGroupName&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="参考资料-5">参考资料</h2>
<p>Flink Operators： <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/stream/operators/">https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/stream/operators/</a></p>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink-Watermark机制</title>
    <url>/posts/94f19a19.html</url>
    <content><![CDATA[<h3 id="watermark简介">watermark简介</h3>
<h4 id="watermark的概念">watermark的概念</h4>
<p>watermark是一种衡量Event Time进展的机制，它是数据本身的一个隐藏属性。通常基于Event Time的数据，自身都包含一个timestamp，例如<code>1472693399700（2016-09-01 09:29:59.700）</code>，而这条数据的watermark时间则可能是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">watermark(<span class="number">1472693399700</span>) = <span class="number">1472693396700</span>(<span class="number">2016</span>-09-<span class="number">01</span> 09:<span class="number">29</span>:<span class="number">56.700</span>)</span><br></pre></td></tr></table></figure>
<p>这条数据的watermark时间是什么含义呢？即：timestamp小于<code>1472693396700(2016-09-01 09:29:56.700)</code>的数据，都已经到达了</p>
<p><img src="https://img-blog.csdn.net/20160929172201717" alt="è¿éåå¾çæè¿°"></p>
<h4 id="watermark有什么用？">watermark有什么用？</h4>
<p>watermark是用于处理乱序事件的，而正确的处理乱序事件，通常用watermark机制结合window来实现。</p>
<p>我们知道，流处理从事件产生，到流经source，再到operator，中间是有一个过程和时间的。虽然大部分情况下，流到operator的数据都是按照事件产生的时间顺序来的，但是也不排除由于网络、背压等原因，导致乱序的产生（out-of-order或者说late element）。</p>
<p>但是对于late element，我们又不能无限期的等下去，必须要有个机制来保证一个特定的时间后，必须触发window去进行计算了。这个特别的机制，就是watermark。</p>
<h4 id="watermark如何分配？">watermark如何分配？</h4>
<p>通常，在接收到source的数据后，应该立刻生成watermark；但是，也可以在source后，应用简单的map或者filter操作，然后再生成watermark。生成watermark的方式主要有2大类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>):With Periodic <span class="title function_">Watermarks</span></span><br><span class="line"><span class="params">(<span class="number">2</span>)</span>:With Punctuated Watermarks</span><br></pre></td></tr></table></figure>
<p>第一种可以定义一个最大允许乱序的时间，这种情况应用较多。 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This generator generates watermarks assuming that elements come out of order to a certain degree only.</span></span><br><span class="line"><span class="comment"> * The latest elements for a certain timestamp t will arrive at most n milliseconds after the earliest</span></span><br><span class="line"><span class="comment"> * elements for timestamp t.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BoundedOutOfOrdernessGenerator</span> <span class="keyword">extends</span> <span class="title class_">AssignerWithPeriodicWatermarks</span>[MyEvent] &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">val</span> <span class="variable">maxOutOfOrderness</span> <span class="operator">=</span> <span class="number">3500L</span>; <span class="comment">// 3.5 seconds</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> currentMaxTimestamp: Long;</span><br><span class="line"> </span><br><span class="line">    override def <span class="title function_">extractTimestamp</span><span class="params">(element: MyEvent, previousElementTimestamp: Long)</span>: Long = &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">timestamp</span> <span class="operator">=</span> element.getCreationTime()</span><br><span class="line">        currentMaxTimestamp = max(timestamp, currentMaxTimestamp)</span><br><span class="line">        timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    override def <span class="title function_">getCurrentWatermark</span><span class="params">()</span>: Watermark = &#123;</span><br><span class="line">        <span class="comment">// return the watermark as current highest timestamp minus the out-of-orderness bound</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Watermark</span>(currentMaxTimestamp - maxOutOfOrderness);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序中有一个extractTimestamp方法，就是根据数据本身的Event time来获取；还有一个getCurrentWatermar方法，是用currentMaxTimestamp - maxOutOfOrderness来获取的。</p>
<h3 id="watermark代码">watermark代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    StreamExecutionEnvironment environment=StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    environment.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    properties.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">    properties.setProperty(<span class="string">&quot;zookeeper.connect&quot;</span>, <span class="string">&quot;localhost:2181&quot;</span>);</span><br><span class="line">    properties.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	加载数据源kafka</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    FlinkKafkaConsumer011&lt;String&gt; myConsumer = <span class="keyword">new</span> <span class="title class_">FlinkKafkaConsumer011</span>&lt;String&gt;(<span class="string">&quot;test&quot;</span>, <span class="keyword">new</span> <span class="title class_">SimpleStringSchema</span>(),properties);</span><br><span class="line">    DataStream&lt;String&gt; stream = environment.addSource(myConsumer);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	将输入的字符串以“，”切分</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    DataStream&lt;Tuple2&lt;String,Long&gt;&gt; inputMap = stream.map(<span class="keyword">new</span> <span class="title class_">MapFunction</span>&lt;String, Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Tuple2&lt;String, Long&gt; <span class="title function_">map</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            String [] arr = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(arr[<span class="number">0</span>],Long.parseLong(arr[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//赋予时间戳然后生成水位线</span></span><br><span class="line">    DataStream&lt;Tuple2&lt;String,Long&gt;&gt; watermarkStream = inputMap.assignTimestampsAndWatermarks(<span class="keyword">new</span> <span class="title class_">AssignerWithPeriodicWatermarks</span>&lt;Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">currentMaxTimeStamp</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">maxOutOfOrderness</span> <span class="operator">=</span> <span class="number">10000L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Watermark <span class="title function_">getCurrentWatermark</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Watermark</span>(currentMaxTimeStamp-maxOutOfOrderness);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">extractTimestamp</span><span class="params">(Tuple2&lt;String, Long&gt; element, <span class="type">long</span> previousTimeStamp)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> element.f1;</span><br><span class="line">            currentMaxTimeStamp = Math.max(currentMaxTimeStamp,timestamp);</span><br><span class="line">            <span class="keyword">assert</span> <span class="title function_">getCurrentWatermark</span><span class="params">()</span> != <span class="literal">null</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;键值 :&quot;</span>+element.f0+<span class="string">&quot;,事件时间:[ &quot;</span>+sdf.format(element.f1)+<span class="string">&quot; ],currentMaxTimestamp:[ &quot;</span>+</span><br><span class="line">                               sdf.format(currentMaxTimeStamp)+<span class="string">&quot; ],水印时间:[ &quot;</span>+sdf.format(getCurrentWatermark().getTimestamp())+<span class="string">&quot; ]&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> timestamp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    DataStream&lt;String&gt; window = watermarkStream.keyBy(<span class="number">0</span>)</span><br><span class="line">        .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">3</span>)))</span><br><span class="line">        .apply(<span class="keyword">new</span> <span class="title class_">WindowFunction</span>&lt;Tuple2&lt;String, Long&gt;, String, Tuple, TimeWindow&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Tuple tuple, TimeWindow timeWindow, Iterable&lt;Tuple2&lt;String, Long&gt;&gt; iterable, Collector&lt;String&gt; collector)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         *对window内数据进行排序，保证数据排序</span></span><br><span class="line"><span class="comment">                         *用list保存迭代流所有数据，然后排序</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> tuple.toString();</span><br><span class="line">                List&lt;Long&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Long&gt;();</span><br><span class="line">                Iterator&lt;Tuple2&lt;String, Long&gt;&gt; it = iterable.iterator();</span><br><span class="line">                <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                    Tuple2&lt;String, Long&gt; next = it.next();</span><br><span class="line">                    arrayList.add(next.f1);</span><br><span class="line">                &#125;</span><br><span class="line">                Collections.sort(arrayList);</span><br><span class="line">                <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;\n 键值 : &quot;</span>+ key + <span class="string">&quot;\n              触发窗内数据个数 : &quot;</span> + arrayList.size() + <span class="string">&quot;\n              触发窗起始数据： &quot;</span> + sdf.format(arrayList.get(<span class="number">0</span>)) + <span class="string">&quot;\n              触发窗最后（可能是延时）数据：&quot;</span> +</span><br><span class="line">                    sdf.format(arrayList.get(arrayList.size() - <span class="number">1</span>))</span><br><span class="line">                    + <span class="string">&quot;\n              实际窗起始和结束时间： &quot;</span> + sdf.format(timeWindow.getStart()) + <span class="string">&quot;《----》&quot;</span> + sdf.format(timeWindow.getEnd()) + <span class="string">&quot; \n \n &quot;</span>;</span><br><span class="line"></span><br><span class="line">                collector.collect(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    window.print();</span><br><span class="line">    environment.execute(<span class="string">&quot;eventtime-watermark&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>程序详解</p>
</li>
</ul>
<blockquote>
<p>接收kafka数据</p>
</blockquote>
<blockquote>
<p>将每行数据按照字符分隔，每行map成一个tuple类型（code，time）</p>
</blockquote>
<blockquote>
<p>抽取timestamp生成watermark。并打印（code，time，格式化的time，currentMaxTimestamp，currentMaxTimestamp的格式化时间，watermark时间）。</p>
</blockquote>
<blockquote>
<p>event time每隔3秒触发一次窗口，输出（code，窗口内元素个数，窗口内最早元素的时间，窗口内最晚元素的时间，窗口自身开始时间，窗口自身结束时间）</p>
</blockquote>
<p>注意：<code>new AssignerWithPeriodicWatermarks[(String,Long)</code>中有抽取timestamp和生成watermark2个方法，在执行时，它是先抽取timestamp，后生成watermark，因此我们在这里print的watermark时间，其实是上一条的watermark时间.</p>
<h3 id="watermark实验">watermark实验</h3>
<h4 id="正常数据">正常数据</h4>
<p>在上述代码中设置了允许最大的延迟时间是10s</p>
<p>输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="number">000001</span>,<span class="number">1461756862000</span></span><br><span class="line">&gt;<span class="number">000001</span>,<span class="number">1461756866000</span></span><br><span class="line">&gt;<span class="number">000001</span>,<span class="number">1461756872000</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">键值 :<span class="number">000001</span>,事件时间:[ <span class="number">2016</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">19</span>:<span class="number">34</span>:<span class="number">22.000</span> ],currentMaxTimestamp:[ <span class="number">2016</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">19</span>:<span class="number">34</span>:<span class="number">22.000</span> ],水印时间:[ <span class="number">2016</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">19</span>:<span class="number">34</span>:<span class="number">12.000</span> ]</span><br><span class="line">键值 :<span class="number">000001</span>,事件时间:[ <span class="number">2016</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">19</span>:<span class="number">34</span>:<span class="number">26.000</span> ],currentMaxTimestamp:[ <span class="number">2016</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">19</span>:<span class="number">34</span>:<span class="number">26.000</span> ],水印时间:[ <span class="number">2016</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">19</span>:<span class="number">34</span>:<span class="number">16.000</span> ]</span><br><span class="line">键值 :<span class="number">000001</span>,事件时间:[ <span class="number">2016</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">19</span>:<span class="number">34</span>:<span class="number">32.000</span> ],currentMaxTimestamp:[ <span class="number">2016</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">19</span>:<span class="number">34</span>:<span class="number">32.000</span> ],水印时间:[ <span class="number">2016</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">19</span>:<span class="number">34</span>:<span class="number">22.000</span> ]</span><br></pre></td></tr></table></figure>
<p>我们可以看到输入已经达到10s，等于第一条数据的Event Time了，却没有触发window窗口计算，此时再输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="number">000001</span>,<span class="number">1461756862000</span></span><br><span class="line">&gt;<span class="number">000001</span>,<span class="number">1461756866000</span></span><br><span class="line">&gt;<span class="number">000001</span>,<span class="number">1461756872000</span></span><br><span class="line">&gt;<span class="number">000001</span>,<span class="number">1461756874000</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">键值 :<span class="number">000001</span>,事件时间:[ <span class="number">2016</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">19</span>:<span class="number">34</span>:<span class="number">34.000</span> ],currentMaxTimestamp:[ <span class="number">2016</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">19</span>:<span class="number">34</span>:<span class="number">34.000</span> ],水印时间:[ <span class="number">2016</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">19</span>:<span class="number">34</span>:<span class="number">24.000</span> ]</span><br><span class="line"><span class="number">3</span>&gt; </span><br><span class="line"> 键值 : (<span class="number">000001</span>)</span><br><span class="line">              触发窗内数据个数 : <span class="number">1</span></span><br><span class="line">              触发窗起始数据： <span class="number">2016</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">19</span>:<span class="number">34</span>:<span class="number">22.000</span></span><br><span class="line">              触发窗最后（可能是延时）数据：<span class="number">2016</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">19</span>:<span class="number">34</span>:<span class="number">22.000</span></span><br><span class="line">              实际窗起始和结束时间： <span class="number">2016</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">19</span>:<span class="number">34</span>:<span class="number">21.000</span>《----》<span class="number">2016</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">19</span>:<span class="number">34</span>:<span class="number">24.000</span> </span><br></pre></td></tr></table></figure>
<p>此时watermark的时间<code>2016-04-27 19:34:24.000</code>是可以看到已经触发窗口计算了，因此得到一个结论，当<code>watermark时间 &gt;= window_end_time</code>的时候才会触发窗口计算，需要注意的是watermark与key无关，是系统设定的，即使是不同的key，只要是时间达到了即可触发。</p>
<p>window的触发条件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">watermark时间 &gt;= window_end_time</span></span><br><span class="line"><span class="comment">在[window_start_time,window_end_time)中有数据存在</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>只有同时满足上述条件才会触发窗口计算。</p>
<h4 id="乱序数据">乱序数据</h4>
<p>我们此时输入一个乱序的数据，此时watermark的时间<code>2016-04-27 19:34:24.000</code>，我们输入一个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="number">000001</span>,<span class="number">1461756871000</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">键值 :<span class="number">000001</span>,事件时间:[ <span class="number">2016</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">19</span>:<span class="number">34</span>:<span class="number">31.000</span> ],currentMaxTimestamp:[ <span class="number">2016</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">19</span>:<span class="number">34</span>:<span class="number">34.000</span> ],水印时间:[ <span class="number">2016</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">19</span>:<span class="number">34</span>:<span class="number">24.000</span> ]</span><br></pre></td></tr></table></figure>
<p>可以看到，虽然我们输入了一个19:34:31的数据，但是currentMaxTimestamp和watermark都没变。此时，按照我们上面提到的公式：watermark时间（19:34:24） &lt; window_end_time（19:34:27），因此不能触发window。此时再输入一条数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="number">000001</span>,<span class="number">1461756881000</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">键值 :<span class="number">000001</span>,事件时间:[ <span class="number">2016</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">19</span>:<span class="number">34</span>:<span class="number">41.000</span> ],currentMaxTimestamp:[ <span class="number">2016</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">19</span>:<span class="number">34</span>:<span class="number">41.000</span> ],水印时间:[ <span class="number">2016</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">19</span>:<span class="number">34</span>:<span class="number">31.000</span> ]</span><br><span class="line"><span class="number">3</span>&gt; </span><br><span class="line"> 键值 : (<span class="number">000001</span>)</span><br><span class="line">              触发窗内数据个数 : <span class="number">1</span></span><br><span class="line">              触发窗起始数据： <span class="number">2016</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">19</span>:<span class="number">34</span>:<span class="number">26.000</span></span><br><span class="line">              触发窗最后（可能是延时）数据：<span class="number">2016</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">19</span>:<span class="number">34</span>:<span class="number">26.000</span></span><br><span class="line">              实际窗起始和结束时间： <span class="number">2016</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">19</span>:<span class="number">34</span>:<span class="number">24.000</span>《----》<span class="number">2016</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">19</span>:<span class="number">34</span>:<span class="number">27.000</span> </span><br></pre></td></tr></table></figure>
<p>可以看到 <code>2016-04-27 19:34:31.000&gt;2016-04-27 19:34:27.000</code>，此时watermark时间大于窗口结束时间了，因此会触发窗口计算，并更新最新的窗口结束位置以及最新的watermark。</p>
<h4 id="乱序很多的数据">乱序很多的数据</h4>
<p>我们输入一个乱序很多的（其实只要Event Time &lt; watermark时间）数据来测试下：</p>
<p>输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="number">000001</span>,<span class="number">1461756862000</span></span><br><span class="line">&gt;<span class="number">000001</span>,<span class="number">1461756866000</span></span><br><span class="line">&gt;<span class="number">000001</span>,<span class="number">1461756872000</span></span><br><span class="line">&gt;<span class="number">000001</span>,<span class="number">1461756874000</span></span><br><span class="line">&gt;<span class="number">000001</span>,<span class="number">1461756871000</span></span><br><span class="line">&gt;<span class="number">000001</span>,<span class="number">1461756881000</span></span><br><span class="line">&gt;<span class="number">000001</span>,<span class="number">1461756841000</span></span><br></pre></td></tr></table></figure>
<p>此时<code>Event Time &lt; watermark</code>时间，所以来一条就触发一个window。</p>
<h3 id="总结">总结</h3>
<ol>
<li class="lvl-3">
<p>Flink如何处理乱序？</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">watermark + window机制</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>Flink何时触发window？</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">watermark时间 &gt; Event Time（对于late element太多的数据而言）</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	或者</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">watermark时间 &gt;= window_end_time（对于out-of-order以及正常的数据而言</span><br><span class="line">在[window_start_time,window_end_time)中有数据存在</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>Flink应该如何设置最大乱序时间？</p>
</li>
</ol>
<p>这个要结合自己的业务以及数据情况去设置。如果maxOutOfOrderness设置的太小，而自身数据发送时由于网络等原因导致乱序或者late太多，那么最终的结果就是会有很多单条的数据在window中被触发，数据的正确性影响太大。</p>
<p><img src="https://img-blog.csdn.net/20160930135616800" alt="è¿éåå¾çæè¿°"></p>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink开发环境搭建</title>
    <url>/posts/9abee3b7.html</url>
    <content><![CDATA[<h2 id="一、安装-Scala-插件">一、安装 Scala 插件</h2>
<p>Flink 分别提供了基于 Java 语言和 Scala 语言的 API ，如果想要使用 Scala 语言来开发 Flink 程序，可以通过在 IDEA 中安装 Scala 插件来提供语法提示，代码高亮等功能。打开 IDEA , 依次点击 <code>File =&gt; settings =&gt; plugins</code> 打开插件安装页面，搜索 Scala 插件并进行安装，安装完成后，重启 IDEA 即可生效。</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/scala-plugin.png"/> </div>
<h2 id="二、Flink-项目初始化">二、Flink 项目初始化</h2>
<h3 id="2-1-使用官方脚本构建">2.1 使用官方脚本构建</h3>
<p>Flink 官方支持使用 Maven 和 Gradle 两种构建工具来构建基于 Java 语言的 Flink 项目；支持使用 SBT 和 Maven 两种构建工具来构建基于 Scala 语言的 Flink 项目。 这里以 Maven 为例进行说明，因为其可以同时支持 Java 语言和 Scala 语言项目的构建。需要注意的是 Flink 1.9 只支持 Maven 3.0.4 以上的版本，Maven 安装完成后，可以通过以下两种方式来构建项目：</p>
<p><strong>1. 直接基于 Maven Archetype 构建</strong></p>
<p>直接使用下面的 mvn 语句来进行构建，然后根据交互信息的提示，依次输入 groupId , artifactId 以及包名等信息后等待初始化的完成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mvn archetype:generate                               \</span><br><span class="line">      -DarchetypeGroupId=org.apache.flink              \</span><br><span class="line">      -DarchetypeArtifactId=flink-quickstart-java      \</span><br><span class="line">      -DarchetypeVersion=1.9.0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：如果想要创建基于 Scala 语言的项目，只需要将 flink-quickstart-java 换成 flink-quickstart-scala 即可，后文亦同。</p>
</blockquote>
<p><strong>2. 使用官方脚本快速构建</strong></p>
<p>为了更方便的初始化项目，官方提供了快速构建脚本，可以直接通过以下命令来进行调用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">curl https://flink.apache.org/q/quickstart.sh | bash -s 1.9.0</span></span><br></pre></td></tr></table></figure>
<p>该方式其实也是通过执行 maven archetype 命令来进行初始化，其脚本内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PACKAGE=quickstart</span><br><span class="line"></span><br><span class="line">mvn archetype:generate \</span><br><span class="line">  -DarchetypeGroupId=org.apache.flink \</span><br><span class="line">  -DarchetypeArtifactId=flink-quickstart-java \</span><br><span class="line">  -DarchetypeVersion=$&#123;1:-1.8.0&#125; \</span><br><span class="line">  -DgroupId=org.myorg.quickstart \</span><br><span class="line">  -DartifactId=$PACKAGE	\</span><br><span class="line">  -Dversion=0.1 \</span><br><span class="line">  -Dpackage=org.myorg.quickstart \</span><br><span class="line">  -DinteractiveMode=false</span><br></pre></td></tr></table></figure>
<p>可以看到相比于第一种方式，该种方式只是直接指定好了 groupId ，artifactId ，version 等信息而已。</p>
<h3 id="2-2-使用-IDEA-构建">2.2 使用 IDEA 构建</h3>
<p>如果你使用的是开发工具是 IDEA ，可以直接在项目创建页面选择 Maven Flink Archetype 进行项目初始化：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-maven.png"/> </div>
<p>如果你的 IDEA 没有上述 Archetype， 可以通过点击右上角的 <code>ADD ARCHETYPE</code> ，来进行添加，依次填入所需信息，这些信息都可以从上述的 <code>archetype:generate </code> 语句中获取。点击  <code>OK</code> 保存后，该 Archetype 就会一直存在于你的 IDEA 中，之后每次创建项目时，只需要直接选择该 Archetype 即可：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-maven-new.png"/> </div>
<p>选中 Flink Archetype ，然后点击 <code>NEXT</code> 按钮，之后的所有步骤都和正常的 Maven 工程相同。</p>
<h2 id="三、项目结构">三、项目结构</h2>
<h3 id="3-1-项目结构">3.1 项目结构</h3>
<p>创建完成后的自动生成的项目结构如下：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-basis-project.png"/> </div>
<p>其中 BatchJob 为批处理的样例代码，源码如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">BatchJob</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">ExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">      ....</span><br><span class="line">    env.execute(<span class="string">&quot;Flink Batch Scala API Skeleton&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getExecutionEnvironment 代表获取批处理的执行环境，如果是本地运行则获取到的就是本地的执行环境；如果在集群上运行，得到的就是集群的执行环境。如果想要获取流处理的执行环境，则只需要将 <code>ExecutionEnvironment</code> 替换为 <code>StreamExecutionEnvironment</code>， 对应的代码样例在 StreamingJob 中：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StreamingJob</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">      ...</span><br><span class="line">    env.execute(<span class="string">&quot;Flink Streaming Scala API Skeleton&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>需要注意的是对于流处理项目 <code>env.execute()</code> 这句代码是必须的，否则流处理程序就不会被执行，但是对于批处理项目则是可选的。</p>
<h3 id="3-2-主要依赖">3.2 主要依赖</h3>
<p>基于 Maven 骨架创建的项目主要提供了以下核心依赖：其中 <code>flink-scala</code> 用于支持开发批处理程序 ；<code>flink-streaming-scala</code> 用于支持开发流处理程序 ；<code>scala-library</code> 用于提供 Scala 语言所需要的类库。如果在使用 Maven 骨架创建时选择的是 Java 语言，则默认提供的则是 <code>flink-java</code> 和 <code>flink-streaming-java</code> 依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Apache Flink dependencies --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- These dependencies are provided, because they should not be packaged into the JAR file. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-scala_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-scala_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Scala Library, provided by Flink as well. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.scala-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>scala-library<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;scala.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>需要特别注意的以上依赖的 <code>scope</code> 标签全部被标识为 provided ，这意味着这些依赖都不会被打入最终的 JAR 包。因为 Flink 的安装包中已经提供了这些依赖，位于其 lib 目录下，名为  <code>flink-dist_*.jar</code>  ，它包含了 Flink 的所有核心类和依赖：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-lib.png"/> </div>
<p><code>scope</code> 标签被标识为 provided 会导致你在 IDEA 中启动项目时会抛出 ClassNotFoundException 异常。基于这个原因，在使用 IDEA 创建项目时还自动生成了以下 profile 配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- This profile helps to make things run out of the box in IntelliJ --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Its adds Flink&#x27;s core classes to the runtime class path. --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Otherwise they are missing in IntelliJ, because the dependency is &#x27;provided&#x27; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>add-dependencies-for-IDEA<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>idea.version<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-scala_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-scala_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.scala-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>scala-library<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;scala.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 id 为 <code>add-dependencies-for-IDEA</code> 的 profile 中，所有的核心依赖都被标识为 compile，此时你可以无需改动任何代码，只需要在 IDEA 的 Maven 面板中勾选该 profile，即可直接在 IDEA 中运行 Flink 项目：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-maven-profile.png"/> </div>
<h2 id="四、词频统计案例">四、词频统计案例</h2>
<p>项目创建完成后，可以先书写一个简单的词频统计的案例来尝试运行 Flink 项目，以下以 Scala 语言为例，分别介绍流处理程序和批处理程序的编程示例：</p>
<h3 id="4-1-批处理示例">4.1 批处理示例</h3>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WordCountBatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> benv = <span class="type">ExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="keyword">val</span> dataSet = benv.readTextFile(<span class="string">&quot;D:\\wordcount.txt&quot;</span>)</span><br><span class="line">    dataSet.flatMap &#123; _.toLowerCase.split(<span class="string">&quot;,&quot;</span>)&#125;</span><br><span class="line">            .filter (_.nonEmpty)</span><br><span class="line">            .map &#123; (_, <span class="number">1</span>) &#125;</span><br><span class="line">            .groupBy(<span class="number">0</span>)</span><br><span class="line">            .sum(<span class="number">1</span>)</span><br><span class="line">            .print()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>wordcount.txt</code> 中的内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a,a,a,a,a</span><br><span class="line">b,b,b</span><br><span class="line">c,c</span><br><span class="line">d,d</span><br></pre></td></tr></table></figure>
<p>本机不需要配置其他任何的 Flink 环境，直接运行 Main 方法即可，结果如下：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-word-count.png"/> </div>
<h3 id="4-2-流处理示例">4.2 流处理示例</h3>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.<span class="type">Time</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WordCountStreaming</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> senv = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> dataStream: <span class="type">DataStream</span>[<span class="type">String</span>] = senv.socketTextStream(<span class="string">&quot;192.168.0.229&quot;</span>, <span class="number">9999</span>, &#x27;\n&#x27;)</span><br><span class="line">    dataStream.flatMap &#123; line =&gt; line.toLowerCase.split(<span class="string">&quot;,&quot;</span>) &#125;</span><br><span class="line">              .filter(_.nonEmpty)</span><br><span class="line">              .map &#123; word =&gt; (word, <span class="number">1</span>) &#125;</span><br><span class="line">              .keyBy(<span class="number">0</span>)</span><br><span class="line">              .timeWindow(<span class="type">Time</span>.seconds(<span class="number">3</span>))</span><br><span class="line">              .sum(<span class="number">1</span>)</span><br><span class="line">              .print()</span><br><span class="line">    senv.execute(<span class="string">&quot;Streaming WordCount&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里以监听指定端口号上的内容为例，使用以下命令来开启端口服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -lk 9999</span><br></pre></td></tr></table></figure>
<p>之后输入测试数据即可观察到流处理程序的处理情况。</p>
<h2 id="五、使用-Scala-Shell">五、使用 Scala Shell</h2>
<p>对于日常的 Demo 项目，如果你不想频繁地启动 IDEA 来观察测试结果，可以像 Spark 一样，直接使用 Scala Shell 来运行程序，这对于日常的学习来说，效果更加直观，也更省时。Flink 安装包的下载地址如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">https://flink.apache.org/downloads.html</span><br></pre></td></tr></table></figure>
<p>Flink 大多数版本都提供有 Scala 2.11 和 Scala 2.12 两个版本的安装包可供下载：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-download.png"/> </div>
<p>下载完成后进行解压即可，Scala Shell 位于安装目录的 bin 目录下，直接使用以下命令即可以本地模式启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./start-scala-shell.sh local</span><br></pre></td></tr></table></figure>
<p>命令行启动完成后，其已经提供了批处理 （benv 和 btenv）和流处理（senv 和 stenv）的运行环境，可以直接运行 Scala Flink 程序，示例如下：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-scala-shell.png"/> </div>
<p>最后解释一个常见的异常：这里我使用的 Flink 版本为 1.9.1，启动时会抛出如下异常。这里因为按照官方的说明，目前所有 Scala 2.12 版本的安装包暂时都不支持 Scala Shell，所以如果想要使用 Scala Shell，只能选择 Scala 2.11 版本的安装包。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop001 bin]# ./start-scala-shell.sh local</span><br><span class="line">错误: 找不到或无法加载主类 org.apache.flink.api.scala.FlinkShell</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink核心概念综述</title>
    <url>/posts/272a1e7c.html</url>
    <content><![CDATA[<h2 id="一、Flink-简介">一、Flink 简介</h2>
<p>Apache Flink 诞生于柏林工业大学的一个研究性项目，原名 StratoSphere 。2014 年，由 StratoSphere 项目孵化出 Flink，并于同年捐赠 Apache，之后成为 Apache 的顶级项目。2019 年 1 年，阿里巴巴收购了 Flink 的母公司 Data Artisans，并宣布开源内部的 Blink，Blink 是阿里巴巴基于 Flink 优化后的版本，增加了大量的新功能，并在性能和稳定性上进行了各种优化，经历过阿里内部多种复杂业务的挑战和检验。同时阿里巴巴也表示会逐步将这些新功能和特性 Merge 回社区版本的 Flink 中，因此 Flink 成为目前最为火热的大数据处理框架。</p>
<p>简单来说，Flink 是一个分布式的流处理框架，它能够对有界和无界的数据流进行高效的处理。Flink 的核心是流处理，当然它也能支持批处理，Flink 将批处理看成是流处理的一种特殊情况，即数据流是有明确界限的。这和 Spark Streaming 的思想是完全相反的，Spark Streaming 的核心是批处理，它将流处理看成是批处理的一种特殊情况， 即把数据流进行极小粒度的拆分，拆分为多个微批处理。</p>
<p>Flink 有界数据流和无界数据流：</p>
<div align="center"> <img width="600px" src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-bounded-unbounded.png"/> </div>
<p>Spark Streaming 数据流的拆分：</p>
<div align="center"> <img width="600px" src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/streaming-flow.png"/> </div>
<h2 id="二、Flink-核心架构">二、Flink 核心架构</h2>
<p>Flink 采用分层的架构设计，从而保证各层在功能和职责上的清晰。如下图所示，由上而下分别是 API &amp; Libraries 层、Runtime 核心层以及物理部署层：</p>
<div align="center"> <img width="600px"  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-stack.png"/> </div>
<h3 id="2-1-API-Libraries-层">2.1 API &amp; Libraries 层</h3>
<p>这一层主要提供了编程 API 和 顶层类库：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>编程 API : 用于进行流处理的 DataStream API 和用于进行批处理的 DataSet API；</p>
</li>
<li class="lvl-2">
<p>顶层类库：包括用于复杂事件处理的 CEP 库；用于结构化数据查询的 SQL &amp; Table 库，以及基于批处理的机器学习库 FlinkML 和 图形处理库 Gelly。</p>
</li>
</ul>
<h3 id="2-2-Runtime-核心层">2.2 Runtime 核心层</h3>
<p>这一层是 Flink 分布式计算框架的核心实现层，包括作业转换，任务调度，资源分配，任务执行等功能，基于这一层的实现，可以在流式引擎下同时运行流处理程序和批处理程序。</p>
<h3 id="2-3-物理部署层">2.3 物理部署层</h3>
<p>Flink 的物理部署层，用于支持在不同平台上部署运行 Flink 应用。</p>
<h2 id="三、Flink-分层-API">三、Flink 分层 API</h2>
<p>在上面介绍的 API &amp; Libraries 这一层，Flink 又进行了更为具体的划分。具体如下：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-api-stack.png"/> </div>
<p>按照如上的层次结构，API 的一致性由下至上依次递增，接口的表现能力由下至上依次递减，各层的核心功能如下：</p>
<h3 id="3-1-SQL-Table-API">3.1 SQL &amp; Table API</h3>
<p>SQL &amp; Table API 同时适用于批处理和流处理，这意味着你可以对有界数据流和无界数据流以相同的语义进行查询，并产生相同的结果。除了基本查询外， 它还支持自定义的标量函数，聚合函数以及表值函数，可以满足多样化的查询需求。</p>
<h3 id="3-2-DataStream-DataSet-API">3.2 DataStream &amp; DataSet API</h3>
<p>DataStream &amp;  DataSet API 是 Flink 数据处理的核心 API，支持使用 Java 语言或 Scala 语言进行调用，提供了数据读取，数据转换和数据输出等一系列常用操作的封装。</p>
<h3 id="3-3-Stateful-Stream-Processing">3.3 Stateful Stream Processing</h3>
<p>Stateful Stream Processing 是最低级别的抽象，它通过 Process Function 函数内嵌到 DataStream API 中。 Process Function 是 Flink 提供的最底层 API，具有最大的灵活性，允许开发者对于时间和状态进行细粒度的控制。</p>
<h2 id="四、Flink-集群架构">四、Flink 集群架构</h2>
<h3 id="4-1-核心组件">4.1  核心组件</h3>
<p>按照上面的介绍，Flink 核心架构的第二层是 Runtime 层， 该层采用标准的 Master - Slave 结构， 其中，Master 部分又包含了三个核心组件：Dispatcher、ResourceManager 和 JobManager，而 Slave 则主要是 TaskManager 进程。它们的功能分别如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>JobManagers</strong> (也称为 <em>masters</em>) ：JobManagers 接收由 Dispatcher 传递过来的执行程序，该执行程序包含了作业图 (JobGraph)，逻辑数据流图 (logical dataflow graph) 及其所有的 classes 文件以及第三方类库 (libraries) 等等 。紧接着 JobManagers 会将 JobGraph 转换为执行图 (ExecutionGraph)，然后向 ResourceManager 申请资源来执行该任务，一旦申请到资源，就将执行图分发给对应的 TaskManagers 。因此每个作业 (Job) 至少有一个 JobManager；高可用部署下可以有多个 JobManagers，其中一个作为 <em>leader</em>，其余的则处于 <em>standby</em> 状态。</p>
</li>
<li class="lvl-2">
<p><strong>TaskManagers</strong> (也称为 <em>workers</em>) : TaskManagers 负责实际的子任务 (subtasks) 的执行，每个 TaskManagers 都拥有一定数量的 slots。Slot 是一组固定大小的资源的合集 (如计算能力，存储空间)。TaskManagers 启动后，会将其所拥有的 slots 注册到 ResourceManager 上，由 ResourceManager 进行统一管理。</p>
</li>
<li class="lvl-2">
<p><strong>Dispatcher</strong>：负责接收客户端提交的执行程序，并传递给 JobManager 。除此之外，它还提供了一个 WEB UI 界面，用于监控作业的执行情况。</p>
</li>
<li class="lvl-2">
<p><strong>ResourceManager</strong> ：负责管理 slots 并协调集群资源。ResourceManager 接收来自 JobManager 的资源请求，并将存在空闲 slots 的 TaskManagers 分配给 JobManager 执行任务。Flink 基于不同的部署平台，如 YARN , Mesos，K8s 等提供了不同的资源管理器，当 TaskManagers 没有足够的 slots 来执行任务时，它会向第三方平台发起会话来请求额外的资源。</p>
</li>
</ul>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-application-submission.png"/> </div>
<h3 id="4-2-Task-SubTask">4.2  Task &amp; SubTask</h3>
<p>上面我们提到：TaskManagers 实际执行的是 SubTask，而不是 Task，这里解释一下两者的区别：</p>
<p>在执行分布式计算时，Flink 将可以链接的操作 (operators) 链接到一起，这就是 Task。之所以这样做， 是为了减少线程间切换和缓冲而导致的开销，在降低延迟的同时可以提高整体的吞吐量。 但不是所有的 operator 都可以被链接，如下 keyBy 等操作会导致网络 shuffle 和重分区，因此其就不能被链接，只能被单独作为一个 Task。  简单来说，一个 Task 就是一个可以链接的最小的操作链 (Operator Chains) 。如下图，source 和 map 算子被链接到一块，因此整个作业就只有三个 Task：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-task-subtask.png"/> </div>
<p>解释完 Task ，我们在解释一下什么是 SubTask，其准确的翻译是： <em>A subtask is one parallel slice of a task</em>，即一个 Task 可以按照其并行度拆分为多个 SubTask。如上图，source &amp; map 具有两个并行度，KeyBy 具有两个并行度，Sink 具有一个并行度，因此整个虽然只有 3 个 Task，但是却有 5 个 SubTask。Jobmanager 负责定义和拆分这些 SubTask，并将其交给 Taskmanagers 来执行，每个 SubTask 都是一个单独的线程。</p>
<h3 id="4-3-资源管理">4.3  资源管理</h3>
<p>理解了 SubTasks ，我们再来看看其与 Slots 的对应情况。一种可能的分配情况如下：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-tasks-slots.png"/> </div>
<p>这时每个 SubTask 线程运行在一个独立的 TaskSlot， 它们共享所属的 TaskManager 进程的TCP 连接（通过多路复用技术）和心跳信息 (heartbeat messages)，从而可以降低整体的性能开销。此时看似是最好的情况，但是每个操作需要的资源都是不尽相同的，这里假设该作业 keyBy 操作所需资源的数量比 Sink 多很多 ，那么此时 Sink 所在 Slot 的资源就没有得到有效的利用。</p>
<p>基于这个原因，Flink 允许多个 subtasks 共享 slots，即使它们是不同 tasks 的 subtasks，但只要它们来自同一个 Job 就可以。假设上面 souce &amp; map 和 keyBy 的并行度调整为 6，而 Slot 的数量不变，此时情况如下：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-subtask-slots.png"/> </div>
<p>可以看到一个 Task Slot 中运行了多个 SubTask 子任务，此时每个子任务仍然在一个独立的线程中执行，只不过共享一组 Sot 资源而已。那么 Flink 到底如何确定一个 Job 至少需要多少个 Slot 呢？Flink 对于这个问题的处理很简单，默认情况一个 Job 所需要的 Slot 的数量就等于其 Operation 操作的最高并行度。如下， A，B，D 操作的并行度为 4，而 C，E 操作的并行度为 2，那么此时整个 Job 就需要至少四个 Slots 来完成。通过这个机制，Flink 就可以不必去关心一个 Job 到底会被拆分为多少个 Tasks 和 SubTasks。</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-task-parallelism.png"/> </div>
<h3 id="4-4-组件通讯">4.4 组件通讯</h3>
<p>Flink 的所有组件都基于 Actor System 来进行通讯。Actor system是多种角色的 actor 的容器，它提供调度，配置，日志记录等多种服务，并包含一个可以启动所有 actor 的线程池，如果 actor 是本地的，则消息通过共享内存进行共享，但如果 actor 是远程的，则通过 RPC 的调用来传递消息。</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-process.png"/> </div>
<h2 id="五、Flink-的优点">五、Flink 的优点</h2>
<p>最后基于上面的介绍，来总结一下 Flink 的优点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Flink 是基于事件驱动 (Event-driven) 的应用，能够同时支持流处理和批处理；</p>
</li>
<li class="lvl-2">
<p>基于内存的计算，能够保证高吞吐和低延迟，具有优越的性能表现；</p>
</li>
<li class="lvl-2">
<p>支持精确一次 (Exactly-once) 语意，能够完美地保证一致性和正确性；</p>
</li>
<li class="lvl-2">
<p>分层 API ，能够满足各个层次的开发需求；</p>
</li>
<li class="lvl-2">
<p>支持高可用配置，支持保存点机制，能够提供安全性和稳定性上的保证；</p>
</li>
<li class="lvl-2">
<p>多样化的部署方式，支持本地，远端，云端等多种部署方案；</p>
</li>
<li class="lvl-2">
<p>具有横向扩展架构，能够按照用户的需求进行动态扩容；</p>
</li>
<li class="lvl-2">
<p>活跃度极高的社区和完善的生态圈的支持。</p>
</li>
</ul>
<h2 id="参考资料-6">参考资料</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/concepts/programming-model.html">Dataflow Programming Model</a></p>
</li>
<li class="lvl-2">
<p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/concepts/runtime.html">Distributed Runtime Environment</a></p>
</li>
<li class="lvl-3">
<p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/internals/components.html">Component Stack</a></p>
</li>
<li class="lvl-2">
<p>Fabian Hueske , Vasiliki Kalavri . 《Stream Processing with Apache Flink》.  O’Reilly Media .  2019-4-30</p>
</li>
</ul>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink状态管理与checkpoint容错机制(二)</title>
    <url>/posts/608fa1ee.html</url>
    <content><![CDATA[<h3 id="状态分类">状态分类</h3>
<p>Flink支持两种状态<code>Keyed State</code>和<code>Operator State</code>。两类状态又都包括原始状态<code>row state</code>和托管状态<code>managed state</code>。</p>
<blockquote>
<p>原始状态：由用户自行管理状态具体的数据结构，框架在做checkpoint的时候，使用byte[]来读写状态内容，对其内部数据结构一无所知。当实现一个用户自定义的operator时，会使用到原始状态</p>
</blockquote>
<blockquote>
<p>托管状态是由Flink框架管理的状态，通常在DataStream上的状态推荐使用托管的状态。</p>
</blockquote>
<h3 id="Keyed-State">Keyed State</h3>
<p>该类状态是基于KeyedStream上的状态，这个状态是根据特定的key绑定的，对keyedStream流上的每一个key，都对应着一个state。<code>stream.keyBy(...)</code></p>
<p><strong>数据结构：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>ValueState: 即类型为T的单值状态。这个状态与对应的key绑定，是最简单的状态了。它可以通过update方法更新状态值，通过value()方法获取状态值</p>
</li>
<li class="lvl-2">
<p>ListState: 即key上的状态值为一个列表。可以通过add方法往列表中附加值；也可以通过get()方法返回一个Iterable来遍历状态值。</p>
</li>
<li class="lvl-2">
<p>ReducingState:这种状态通过用户传入的reduceFunction，每次调用add方法添加值的时候，会调用reduceFunction，最后合并到一个单一的状态值。</p>
</li>
<li class="lvl-2">
<p>MapState&lt;UK, UV&gt;:即状态值为一个map。用户通过put或putAll方法添加元素。</p>
</li>
</ul>
<p>通过<code>value()</code>获取值，通过<code>update()</code>更新值，Keyed State继承RichFunction类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">sourceCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span>  StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开并设置checkpoint</span></span><br><span class="line">    <span class="comment">// 1.设置checkpoint目录，这里我用的是本地路径，记得本地路径要file开头</span></span><br><span class="line">    <span class="comment">// 2.设置checkpoint类型，at lease onece or EXACTLY_ONCE</span></span><br><span class="line">    <span class="comment">// 3.设置间隔时间，同时打开checkpoint功能，该大小的设置很重要，设置过短可能会导致flink一直处于checkpoint状态，过长会影响效果</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    env.setStateBackend(<span class="keyword">new</span> <span class="title class_">FsStateBackend</span>(<span class="string">&quot;file:///D://hadoop//data//checkpoint&quot;</span>));</span><br><span class="line">    env.getCheckpointConfig().setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE);</span><br><span class="line">    env.getCheckpointConfig().setCheckpointInterval(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    DataStream&lt;Tuple3&lt;Integer, String, Integer&gt;&gt; source = env.addSource(<span class="keyword">new</span> <span class="title class_">KeyedStateSource</span>());</span><br><span class="line">    source.keyBy(<span class="number">0</span>)</span><br><span class="line">        .window(TumblingProcessingTimeWindows.of(Time.seconds(<span class="number">2</span>)))</span><br><span class="line">        <span class="comment">//窗口函数，比如是richwindowsfunction 否侧无法使用manage state</span></span><br><span class="line">        .apply(<span class="keyword">new</span> <span class="title class_">KeyedStateRichFunction</span>());</span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	新建数据源</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">KeyedStateSource</span> <span class="keyword">implements</span> <span class="title class_">SourceFunction</span>&lt;Tuple3&lt;Integer, String, Integer&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Boolean</span> <span class="variable">isRunning</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(SourceContext&lt;Tuple3&lt;Integer, String, Integer&gt;&gt; sourceContext)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">while</span>(isRunning)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                sourceContext.collect(Tuple3.of(<span class="number">1</span>,<span class="string">&quot;ahah&quot;</span>,count));</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count&gt;<span class="number">100</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;err_________________&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//                System.out.println(&quot;source:&quot;+count);</span></span><br><span class="line">            sourceCount = count;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">KeyedStateRichFunction</span> <span class="keyword">extends</span> <span class="title class_">RichWindowFunction</span>&lt;Tuple3&lt;Integer,String,Integer&gt;, Integer, Tuple, TimeWindow&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ValueState&lt;Integer&gt; state;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Tuple tuple, TimeWindow timeWindow, Iterable&lt;Tuple3&lt;Integer, String, Integer&gt;&gt; iterable, Collector&lt;Integer&gt; collector)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//从state中获取值，获取上一个结果值</span></span><br><span class="line">        count=state.value();</span><br><span class="line">        <span class="keyword">for</span>(Tuple3&lt;Integer, String, Integer&gt; item : iterable)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新state值</span></span><br><span class="line">        state.update(count);</span><br><span class="line">        System.out.println(<span class="string">&quot;windows count:&quot;</span>+count+<span class="string">&quot;   all count:&quot;</span> + sourceCount);</span><br><span class="line">        collector.collect(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取state</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//            System.out.println(&quot;##open&quot;);</span></span><br><span class="line">        ValueStateDescriptor&lt;Integer&gt; descriptor =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ValueStateDescriptor</span>&lt;Integer&gt;(</span><br><span class="line">            <span class="string">&quot;average&quot;</span>, <span class="comment">// the state name</span></span><br><span class="line">            TypeInformation.of(<span class="keyword">new</span> <span class="title class_">TypeHint</span>&lt;Integer&gt;() &#123;&#125;), <span class="comment">// type information</span></span><br><span class="line">            <span class="number">0</span>);</span><br><span class="line">        state = getRuntimeContext().getState(descriptor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码详情：</p>
<ol>
<li class="lvl-3">
<p>加载数据源，每次<code>count=10</code>休眠2s，当达到<code>count=100</code>时中断数据源，重新开始…</p>
</li>
<li class="lvl-3">
<p>并把window窗口大小设置2s负责触发计算，观察每次throw exception后，能不能从之前的结果开始算…</p>
</li>
</ol>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">all count:<span class="number">10</span>   source count:<span class="number">10</span></span><br><span class="line">all count:<span class="number">20</span>   source count:<span class="number">20</span></span><br><span class="line">all count:<span class="number">30</span>   source count:<span class="number">30</span></span><br><span class="line">all count:<span class="number">40</span>   source count:<span class="number">40</span></span><br><span class="line">all count:<span class="number">50</span>   source count:<span class="number">50</span></span><br><span class="line">all count:<span class="number">60</span>   source count:<span class="number">60</span></span><br><span class="line">all count:<span class="number">70</span>   source count:<span class="number">70</span></span><br><span class="line">all count:<span class="number">80</span>   source count:<span class="number">80</span></span><br><span class="line">all count:<span class="number">90</span>   source count:<span class="number">90</span></span><br><span class="line">all count:<span class="number">100</span>   source count:<span class="number">100</span></span><br><span class="line">err_________________</span><br><span class="line">all count:<span class="number">110</span>   source count:<span class="number">10</span></span><br><span class="line">all count:<span class="number">120</span>   source count:<span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>从结果可以看出达到了想要的效果，all count的值并没有从0开始计算，而是从之前的结果计算。</p>
<h3 id="Operator-State">Operator State</h3>
<p>该类State与key无关，整个operator对应一个state，该类State没有Keyed Key支持的数据结构多，仅支持ListState。举例来说，Flink中的Kafka Connector，就使用了operator state。它会在每个connector实例中，保存该实例中消费topic的所有(partition, offset)映射。</p>
<p>有两种方式：</p>
<h4 id="CheckpointedFunction-很少使用，需要自己初始化">CheckpointedFunction(很少使用，需要自己初始化)</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	每当checkpoint执行的时候，snapshotState会被调用</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">snapshotState</span><span class="params">(FunctionSnapshotContext context)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	该方法不仅可以用来初始化state，还可以用于处理state recovery的逻辑</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">initializeState</span><span class="params">(FunctionInitializationContext context)</span> <span class="keyword">throws</span> Exception;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferingSink</span> <span class="keyword">implements</span> <span class="title class_">SinkFunction</span>&lt;Tuple2&lt;String, Integer&gt;&gt;,</span><br><span class="line">         CheckpointedFunction &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> threshold;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> ListState&lt;Tuple2&lt;String, Integer&gt;&gt; checkpointedState;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Tuple2&lt;String, Integer&gt;&gt; bufferedElements;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">BufferingSink</span><span class="params">(<span class="type">int</span> threshold)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.threshold = threshold;</span><br><span class="line">    <span class="built_in">this</span>.bufferedElements = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Tuple2&lt;String, Integer&gt; value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    bufferedElements.add(value);</span><br><span class="line">    <span class="keyword">if</span> (bufferedElements.size() == threshold) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Tuple2&lt;String, Integer&gt; element: bufferedElements) &#123;</span><br><span class="line">        <span class="comment">// send it to the sink</span></span><br><span class="line">     &#125;</span><br><span class="line">      bufferedElements.clear();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">snapshotState</span><span class="params">(FunctionSnapshotContext context)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line">    checkpointedState.clear();</span><br><span class="line">    <span class="keyword">for</span> (Tuple2&lt;String, Integer&gt; element : bufferedElements) &#123;</span><br><span class="line">      checkpointedState.add(element);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initializeState</span><span class="params">(FunctionInitializationContext context)</span> <span class="keyword">throws</span></span><br><span class="line">Exception &#123;</span><br><span class="line">    ListStateDescriptor&lt;Tuple2&lt;String, Integer&gt;&gt; descriptor =</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ListStateDescriptor</span>&lt;&gt;(</span><br><span class="line">        <span class="string">&quot;buffered-elements&quot;</span>,</span><br><span class="line">        TypeInformation.of(<span class="keyword">new</span> <span class="title class_">TypeHint</span>&lt;Tuple2&lt;String, Integer&gt;&gt;() &#123;&#125;));</span><br><span class="line">    checkpointedState =</span><br><span class="line">context.getOperatorStateStore().getListState(descriptor);</span><br><span class="line">    <span class="keyword">if</span> (context.isRestored()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Tuple2&lt;String, Integer&gt; element : checkpointedState.get()) &#123;</span><br><span class="line">        bufferedElements.add(element);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ListCheckpointed-常用，Flink自动初始化">ListCheckpointed(常用，Flink自动初始化)</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;T&gt; <span class="title function_">snapshotState</span><span class="params">(<span class="type">long</span> checkpointId, <span class="type">long</span> timestamp)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">restoreState</span><span class="params">(List&lt;T&gt; state)</span> <span class="keyword">throws</span> Exception;</span><br></pre></td></tr></table></figure>
<p>仅支持list state，ListCheckpointed是CheckpointedFunction的限制版，它仅仅支持Even-splitredistribution模式的list-style state。ListCheckpointed定义了两个方法，分别是snapshotState方法及restoreState方法；snapshotState方法在master触发checkpoint的时候被调用，用户需要返回当前的状态，而restoreState方法会在failure recovery的时候被调用，传递的参数为List类型的state，方法里头可以将state恢复到本地.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">sourceCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span>  StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setStateBackend(<span class="keyword">new</span> <span class="title class_">FsStateBackend</span>(<span class="string">&quot;file:///D://hadoop//data//checkpoint&quot;</span>));</span><br><span class="line">    env.getCheckpointConfig().setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE);</span><br><span class="line">    env.getCheckpointConfig().setCheckpointInterval(<span class="number">1000</span>);</span><br><span class="line">    DataStream&lt;Tuple4&lt;Integer,String,String,Integer&gt;&gt; source = env.addSource(<span class="keyword">new</span> <span class="title class_">OperatorStateSource</span>());</span><br><span class="line">    source.keyBy(<span class="number">0</span>)</span><br><span class="line">        .window(TumblingProcessingTimeWindows.of(Time.seconds(<span class="number">2</span>)))</span><br><span class="line">        .apply(<span class="keyword">new</span> <span class="title class_">OperatorStateAppy</span>());</span><br><span class="line">    env.execute(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	加载数据源，并且实现ListCheckPointed接口，没有key，一个operator就是一个state</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OperatorStateSource</span> <span class="keyword">extends</span> <span class="title class_">RichSourceFunction</span>&lt;Tuple4&lt;Integer,String,String,Integer&gt;&gt; <span class="keyword">implements</span> <span class="title class_">ListCheckpointed</span>&lt;UserState&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">is_running</span> <span class="operator">=</span><span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;UserState&gt; <span class="title function_">snapshotState</span><span class="params">(<span class="type">long</span> l, <span class="type">long</span> l1)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        List&lt;UserState&gt; userStateList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">UserState</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserState</span>();</span><br><span class="line">        state.setCount(count);</span><br><span class="line">        userStateList.add(state);</span><br><span class="line">        <span class="keyword">return</span> userStateList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreState</span><span class="params">(List&lt;UserState&gt; list)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        count = list.get(<span class="number">0</span>).getCount();</span><br><span class="line">        System.out.println(<span class="string">&quot;OperatorStateSource restoreState: &quot;</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(SourceContext&lt;Tuple4&lt;Integer, String, String, Integer&gt;&gt; sourceContext)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">while</span> (is_running)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                sourceContext.collect(Tuple4.of(<span class="number">1</span>, <span class="string">&quot;hello-&quot;</span> + count, <span class="string">&quot;alphabet&quot;</span>, count));</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            sourceCount = count;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">if</span>(count&gt;=<span class="number">100</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;err_________________&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;exception made by ourself!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span> &#123;</span><br><span class="line">        is_running = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	下游计算operator，也实现了ListCheckpoint接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OperatorStateAppy</span> <span class="keyword">implements</span> <span class="title class_">WindowFunction</span>&lt;Tuple4&lt;Integer,String,String,Integer&gt;,Integer,Tuple,TimeWindow&gt;,ListCheckpointed&lt;UserState&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;UserState&gt; <span class="title function_">snapshotState</span><span class="params">(<span class="type">long</span> l, <span class="type">long</span> l1)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        List&lt;UserState&gt; userStateList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">UserState</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserState</span>();</span><br><span class="line">        state.setCount(total);</span><br><span class="line">        userStateList.add(state);</span><br><span class="line">        <span class="keyword">return</span> userStateList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreState</span><span class="params">(List&lt;UserState&gt; list)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        total = list.get(<span class="number">0</span>).getCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Tuple tuple, TimeWindow timeWindow, Iterable&lt;Tuple4&lt;Integer, String, String, Integer&gt;&gt; iterable, Collector&lt;Integer&gt; collector)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Tuple4&lt;Integer,String,String,Integer&gt; data:iterable)&#123;</span><br><span class="line">            count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        total = total + count;</span><br><span class="line">        System.out.println(<span class="string">&quot;all count:&quot;</span>+total+<span class="string">&quot;   source count:&quot;</span> + sourceCount);</span><br><span class="line">        collector.collect(total);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserState</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCount</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">all count:<span class="number">10</span>   source count:<span class="number">10</span></span><br><span class="line">all count:<span class="number">20</span>   source count:<span class="number">20</span></span><br><span class="line">all count:<span class="number">30</span>   source count:<span class="number">30</span></span><br><span class="line">all count:<span class="number">40</span>   source count:<span class="number">40</span></span><br><span class="line">all count:<span class="number">50</span>   source count:<span class="number">50</span></span><br><span class="line">all count:<span class="number">60</span>   source count:<span class="number">60</span></span><br><span class="line">all count:<span class="number">70</span>   source count:<span class="number">70</span></span><br><span class="line">all count:<span class="number">80</span>   source count:<span class="number">80</span></span><br><span class="line">all count:<span class="number">90</span>   source count:<span class="number">90</span></span><br><span class="line">all count:<span class="number">100</span>   source count:<span class="number">100</span></span><br><span class="line">err_________________</span><br><span class="line">OperatorStateSource restoreState: <span class="number">100</span></span><br><span class="line">all count:<span class="number">110</span>   source count:<span class="number">110</span></span><br></pre></td></tr></table></figure>
<p>从结果可以看出达到了想要的结果，当数据源中断后，调用了restore方法，恢复了state的值。</p>
<p><strong>总结：</strong></p>
<p>两者的区别，实现CheckpointedFunction接口，有两种形式的ListState API可以使用，分别是getListState以及getListUnionState，它们都会返回一个ListState，但是他们在重新分区的时候会有区别，后面会详细介绍。如果我们直接实现ListCheckpointed接口，那么就会规定使用ListState，不需要我们进行初始化，Flink内部帮我们解决。</p>
<h3 id="state重分区">state重分区</h3>
<p>当我们在一个job中重新设置了一个operator的并行度之后，之前的state该如何被分配呢？下面就ListState、ListUnionState以及BroadcastState来说明如何进行重分区。</p>
<p><img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/2019-07-07-093120.jpg" alt="img"></p>
<p>参考：</p>
<ol>
<li class="lvl-3">
<p><a href="https://www.jianshu.com/p/87a45238980a?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation">Fault Tolerant与保证Exactly- Once语义</a></p>
</li>
<li class="lvl-3">
<p><a href="http://chenyuzhao.me/2017/12/24/Flink-%E5%88%86%E5%B8%83%E5%BC%8F%E5%BF%AB%E7%85%A7%E7%9A%84%E8%AE%BE%E8%AE%A1-%E5%AD%98%E5%82%A8/">Flink 分布式快照的设计-存储</a></p>
</li>
<li class="lvl-3">
<p><a href="http://chenyuzhao.me/2018/01/29/Flink-%E5%88%86%E5%B8%83%E5%BC%8F%E5%BF%AB%E7%85%A7%E7%9A%84%E8%AE%BE%E8%AE%A1-%E6%B5%81%E7%A8%8B/">Flink-分布式快照的设计-流程</a></p>
</li>
<li class="lvl-3">
<p><a href="http://www.54tianzhisheng.cn/2019/06/18/flink-state/#">Flink状态管理和容错机制介绍</a></p>
</li>
<li class="lvl-3">
<p><a href="https://blog.csdn.net/u013560925/article/details/82667085">Flink 异常处理-State和Checkpoint实践</a></p>
</li>
<li class="lvl-3">
<p><a href="https://juejin.im/post/5bf93517f265da611510760d">Flink 状态管理与checkPoint数据容错机制深入剖析-Flink牛刀小试</a></p>
</li>
<li class="lvl-3">
<p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/ops/state/checkpoints.html">https://ci.apache.org/projects/flink/flink-docs-release-1.8/ops/state/checkpoints.html</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink状态管理与Checkpoint机制(一)</title>
    <url>/posts/c930fd26.html</url>
    <content><![CDATA[<h3 id="何为状态？">何为状态？</h3>
<p>计算任务的结果不仅仅依赖于输入，还依赖于它的当前状态，其实大多数的计算都是有状态的计算。比如wordcount,给一些word,其计算它的count,这是一个很常见的业务场景。count做为输出，在计算的过程中要不断的把输入累加到count上去，那么count就是一个state。</p>
<p>在批处理过程中，数据是划分为块分片去完成的，然后每一个Task去处理一个分片。当分片执行完成后，把输出聚合起来就是最终的结果。在这个过程当中，对于state的需求还是比较小的。</p>
<p>在流处理过程中，对State有非常高的要求，因为在流系统中输入是一个无限制的流，会持续运行从不间断。在这个过程当中，就需要将状态数据很好的管理起来</p>
<h3 id="检查点checkpoint与Barrier">检查点checkpoint与Barrier</h3>
<p>checkpoint【可以理解为checkpoint是把state数据持久化存储了】，则表示Flink job在一个特定时刻的一份全局状态快照，即包含了所有的task/operator的状态。</p>
<p>Checkpoint是Flink实现容错机制最核心的功能，它能根据配置周期性地基于Stream中各个Operator/Task的状态来生成快照，从而将这些状态数据定期持久化存储下来，当Flink程序一旦意外崩溃时，重新运行程序时可以有选择地从这些快照进行恢复，从而修正因为故障带来的程序数据异常。</p>
<p>Flink分布式快照算法Asynchronous Barrier Snapshots算法借鉴了经典的Chandy-Lamport算法的主要思想，同时做了一些改进。<a href="https://arxiv.org/abs/1506.08603">Lightweight Asynchronous Snapshots for Distributed Dataflows</a></p>
<h4 id="Chandy-Lamport算法">Chandy-Lamport算法</h4>
<p>分布式系统是一个包含有限进程和有限消息通道的系统，这些进程和通道可以用一个有向图描述，其中节点表示进程，边表示通道。如下图所示：p、q分别是进程，c-&gt;c’则是消息通道，分布式系统快照是了保存分布式系统的state。分布式系统State是由进程状态和通道状态组成的。</p>
<p><img src="https://gitee.com/liurio/image_save/raw/master/flink/chandy-lamport%E7%AE%97%E6%B3%95.jpg" alt="img"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Event：分布式系统中发生的一个事件，在类似于Flink这样的分布式计算系统中从Source输入的新消息相当于一个事件</p>
</li>
<li class="lvl-2">
<p>进程状态：包含一个初始状态（initial state)，和持续发生的若干Events。初始状态可以理解为Flink中刚启动的计算节点，计算节点每处理一条Event，就转换到一个新的状态。</p>
</li>
<li class="lvl-2">
<p>通道状态：我们用在通道上传输的消息（Event）来描述一个通道的状态。</p>
</li>
</ul>
<p>进程p启动这个算法，记录自身状态，并发出Marker。随着Marker不断的沿着分布式系统的相连通道逐渐传输到所有的进程，所有的进程都会执行算法以记录自身状态和入射通道的状态，**待到所有进程执行完该算法，一个分布式Snapshot就完成了记录。**Marker相当于是一个信使，它随着消息流流经所有的进程，通知每个进程记录自身状态。且Marker对整个分布式系统的计算过程没有任何影响。只要保证Marker能在有限时间内通过通道传输到进程，每个进程能够在有限时间内完成自身状态的记录，这个算法就能在有限的时间内执行完成。</p>
<h4 id="Flink分布式快照算法ABS">Flink分布式快照算法ABS</h4>
<p>在ABS算法中用<strong>Barrier</strong>代替了C-L算法中的Marker。</p>
<ol>
<li class="lvl-3">
<p>Barrier周期性的被注入到所有的Source中，Source节点看到Barrier之后，就会立即记录自己的状态，然后将Barrier发送到Transformation Operator。</p>
</li>
<li class="lvl-3">
<p>当Operator从某个input channel收到Barrier之后，会立即Block住这条通道，直到收到所有的input channel的Barrier，此时Operator会记录自身状态，并向自己所有的output channel广播Barrier。</p>
</li>
<li class="lvl-3">
<p>Sink接受Barrier的操作流程与Transformation Operator一样。当所有的Barrier都到达Sink之后，并且所有的Sink也完成了Checkpoint，这一轮Snapshot就完成了。</p>
</li>
</ol>
<p><img src="https://gitee.com/liurio/image_save/raw/master/flink/abs%E7%AE%97%E6%B3%95.jpg" alt="img"></p>
<p>上述算法中Block Input实际上是有负面效果的，一旦某个input channel发生延迟，Barrier迟迟未到，就会导致Operator上的其他通道全部堵塞，导致系统吞吐下降。但有个一好处是可以实现<strong>Exactly Once</strong>。</p>
<p>一轮快照整个执行流程如下所示：</p>
<p><img src="http://chenyuzhao.me/2018/01/29/Flink-%E5%88%86%E5%B8%83%E5%BC%8F%E5%BF%AB%E7%85%A7%E7%9A%84%E8%AE%BE%E8%AE%A1-%E6%B5%81%E7%A8%8B/flink_ckp_flow.png" alt="flink_ckp_flow"></p>
<p>Checkpoint统一由JobManager发起，中间涉及到JobManager和TaskManager的交互，一轮快照可以分为4个阶段：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>JobManager checkpoint的发起</p>
</li>
</ul>
<blockquote>
<p>全局协调控制的核心抽象是CheckpointCoordinator，发起时的checkpoint被抽象成PendingCheckpoint，向所有的Source节点发送barrier。图中第一步</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>barrier的传递</p>
</li>
</ul>
<blockquote>
<p>当operator收到所有input channel的barrier之后，将barrier传递给下一个operator/task。图中第二步</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>operator/task的checkpoint</p>
</li>
</ul>
<blockquote>
<p>当operator/task收到所有input channels的barrier，本地计算完成后，进行状态持久化。图中第三步</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>ack消息回传</p>
</li>
</ul>
<blockquote>
<p>当TaskManager完成本地备份之后，并将数据的地址以及快照句柄等通过akka以ack消息的形式发送给CheckpointCoordinator，由其负责维护这一轮快照的全局状态视图。当CheckpointCoordinator 收到所有的ack消息后，此时checkpoint的状态由PendingCheckpoint变为 CompletedCheckpoint。此时一次checkpoint完成。图中剩余步骤</p>
</blockquote>
<h5 id="单流">单流</h5>
<p><img src="http://chenyuzhao.me/2018/01/29/Flink-%E5%88%86%E5%B8%83%E5%BC%8F%E5%BF%AB%E7%85%A7%E7%9A%84%E8%AE%BE%E8%AE%A1-%E6%B5%81%E7%A8%8B/stream_barriers.svg" alt="stream_barriers"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>每个Barrier携带着快照的ID，快照记录着ID，并将其放在快照数据的前面。</p>
</li>
<li class="lvl-2">
<p>单流时两个Barrier之间的数据，存储在相应的barrierID中，例如barrier n-1和n之间的数据存储在Barrier n中。</p>
</li>
</ul>
<h5 id="多流">多流</h5>
<p><img src="http://chenyuzhao.me/2018/01/29/Flink-%E5%88%86%E5%B8%83%E5%BC%8F%E5%BF%AB%E7%85%A7%E7%9A%84%E8%AE%BE%E8%AE%A1-%E6%B5%81%E7%A8%8B/stream_aligning.svg" alt="stream_aligning"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>比如此operator有两个输入流，当收到第一个流的barrier n时，下一个流的barrier n-1还有数据流入，此时会先临时搁置此流的数据，将数据放入缓存buffer中，即1 2 3临时存储起来。待所有输入通道都收到了barrier n时，此时所有之前的数据都是barrier n-1的数据。然后该operator会释放buffer中的数据，继续处理。</p>
</li>
<li class="lvl-2">
<p>虽然该方法有效的实现了Exactly Once，但是一旦某个input channel发生延迟，Barrier迟迟未到，这会导致Transformation Operator上的其它通道全部堵塞，系统吞吐大幅下降。Flink提供了选项，可以关闭Exactly once并仅保留at least once。</p>
</li>
</ul>
<h3 id="checkpoint的存储">checkpoint的存储</h3>
<p><img src="http://zhisheng-blog.oss-cn-hangzhou.aliyuncs.com/img/2019-07-07-093258.jpg" alt="img"></p>
<p>用户可以根据自己的需求选择，如果数据量较小，可以存放到MemoryStateBackend和FsStateBackend中，如果数据量较大，可以放到RockDB中。</p>
<h4 id="HeapStateBackend">HeapStateBackend</h4>
<p><img src="http://zhisheng-blog.oss-cn-hangzhou.aliyuncs.com/img/2019-07-07-093320.jpg" alt="img"></p>
<p>MemoryStateBackend 和 FsStateBackend 都是存储在内存中，被保存在一个由多层Java Map嵌套而成的数据结构中，默认不超过5M。优点：速度快，缺点：容量小</p>
<h4 id="RocksDBStateBackend">RocksDBStateBackend</h4>
<p><img src="http://zhisheng-blog.oss-cn-hangzhou.aliyuncs.com/img/2019-07-07-093345.jpg" alt="img"></p>
<p>RockDBKeyedStateBackend 每个State单独存储在一个ColumnFamily中。会在本地文件系统中维护状态，state会直接写入本地rocksdb中。同时RocksDB需要配置一个远端的filesystem。uri（一般是HDFS），在做checkpoint的时候，会把本地的数据直接复制到filesystem中。fail over的时候从filesystem中恢复到本地。RocksDB克服了state受内存限制的缺点，同时又能够持久化到远端文件系统中，比较适合在生产中使用。</p>
<h5 id="RocksDB全量快照">RocksDB全量快照</h5>
<p><img src="http://zhisheng-blog.oss-cn-hangzhou.aliyuncs.com/img/2019-07-07-093447.jpg" alt="img"></p>
<p>全量checkpoint会在每个节点做备份数据时，需要将数据都遍历一遍，然后写入到外部存储中，这种情况会影响备份性能。</p>
<p>RocksDB 自身的snapshot 全量写出，主要步骤如下：</p>
<ol>
<li class="lvl-3">
<p>拿到RocksDB 自身的 snapshot 对象</p>
</li>
<li class="lvl-3">
<p>通过 CheckpointStreamFactory 拿到 CheckpointStateOutputStream 作为快照写出流</p>
</li>
<li class="lvl-3">
<p>分别将快照的 meta 信息和数据写到 2 对应的输出流中</p>
</li>
<li class="lvl-3">
<p>拿到 2 输出流的句柄，获取状态offset，将 k-v 数据读取到RocksDB中，这里要注意的是快照时留下的 meta 起始标志位【标志一个新的 state 起始或者一个 keyGroup 结束】，快照恢复时需要复原.</p>
</li>
<li class="lvl-3">
<p>将 RocksDB 的快照对象及一些辅助资源释放</p>
</li>
</ol>
<p><img src="http://chenyuzhao.me/2017/12/24/Flink-%E5%88%86%E5%B8%83%E5%BC%8F%E5%BF%AB%E7%85%A7%E7%9A%84%E8%AE%BE%E8%AE%A1-%E5%AD%98%E5%82%A8/rocksdb-full-spt-data-write-format.png" alt="rocksdb-full-spt-data-write-format.png"></p>
<h5 id="RocksDB增量快照">RocksDB增量快照</h5>
<p><img src="http://zhisheng-blog.oss-cn-hangzhou.aliyuncs.com/img/2019-07-07-093511.jpg" alt="img"></p>
<p>RocksDB 的数据会更新到内存，当内存满时，会写入到磁盘中。增量的机制会将新产生的文件copy持久化中，而之前产生的文件就不需要COPY到持久化中了。这种方式减少了COPY的数据量，并提高性能。</p>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink状态管理与检查点机制</title>
    <url>/posts/d4478041.html</url>
    <content><![CDATA[<h2 id="一、状态分类">一、状态分类</h2>
<p>相对于其他流计算框架，Flink 一个比较重要的特性就是其支持有状态计算。即你可以将中间的计算结果进行保存，并提供给后续的计算使用：</p>
<div align="center"> <img width="500px" src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-stateful-stream.png" rel="noreferrer"/> </div>
<p>具体而言，Flink 又将状态 (State) 分为 Keyed State 与 Operator State：</p>
<h3 id="2-1-算子状态">2.1 算子状态</h3>
<p>算子状态 (Operator State)：顾名思义，状态是和算子进行绑定的，一个算子的状态不能被其他算子所访问到。官方文档上对 Operator State 的解释是：<em>each operator state is bound to one parallel operator instance</em>，所以更为确切的说一个算子状态是与一个并发的算子实例所绑定的，即假设算子的并行度是 2，那么其应有两个对应的算子状态：</p>
<div align="center" rel="noreferrer"> <img width="500px" src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-operator-state.png"/> </div>
<h3 id="2-2-键控状态">2.2 键控状态</h3>
<p>键控状态 (Keyed State) ：是一种特殊的算子状态，即状态是根据 key 值进行区分的，Flink 会为每类键值维护一个状态实例。如下图所示，每个颜色代表不同 key 值，对应四个不同的状态实例。需要注意的是键控状态只能在 <code>KeyedStream</code> 上进行使用，我们可以通过 <code>stream.keyBy(...)</code> 来得到 <code>KeyedStream</code> 。</p>
<div align="center" rel="noreferrer"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-keyed-state.png" /> </div>
<h2 id="二、状态编程">二、状态编程</h2>
<h3 id="2-1-键控状态">2.1 键控状态</h3>
<p>Flink 提供了以下数据格式来管理和存储键控状态 (Keyed State)：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>ValueState</strong>：存储单值类型的状态。可以使用  <code>update(T)</code> 进行更新，并通过 <code>T value()</code> 进行检索。</p>
</li>
<li class="lvl-2">
<p><strong>ListState</strong>：存储列表类型的状态。可以使用 <code>add(T)</code> 或 <code>addAll(List)</code> 添加元素；并通过 <code>get()</code> 获得整个列表。</p>
</li>
<li class="lvl-2">
<p><strong>ReducingState</strong>：用于存储经过 ReduceFunction 计算后的结果，使用 <code>add(T)</code> 增加元素。</p>
</li>
<li class="lvl-2">
<p><strong>AggregatingState</strong>：用于存储经过 AggregatingState 计算后的结果，使用 <code>add(IN)</code> 添加元素。</p>
</li>
<li class="lvl-2">
<p><strong>FoldingState</strong>：已被标识为废弃，会在未来版本中移除，官方推荐使用 <code>AggregatingState</code> 代替。</p>
</li>
<li class="lvl-3">
<p><strong>MapState</strong>：维护 Map 类型的状态。</p>
</li>
</ul>
<p>以上所有增删改查方法不必硬记，在使用时通过语法提示来调用即可。这里给出一个具体的使用示例：假设我们正在开发一个监控系统，当监控数据超过阈值一定次数后，需要发出报警信息。这里之所以要达到一定次数，是因为由于偶发原因，偶尔一次超过阈值并不能代表什么，故需要达到一定次数后才触发报警，这就需要使用到 Flink 的状态编程。相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThresholdWarning</span> <span class="keyword">extends</span> </span><br><span class="line">    <span class="title class_">RichFlatMapFunction</span>&lt;Tuple2&lt;String, Long&gt;, Tuple2&lt;String, List&lt;Long&gt;&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过ListState来存储非正常数据的状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ListState&lt;Long&gt; abnormalData;</span><br><span class="line">    <span class="comment">// 需要监控的阈值</span></span><br><span class="line">    <span class="keyword">private</span> Long threshold;</span><br><span class="line">    <span class="comment">// 触发报警的次数</span></span><br><span class="line">    <span class="keyword">private</span> Integer numberOfTimes;</span><br><span class="line"></span><br><span class="line">    ThresholdWarning(Long threshold, Integer numberOfTimes) &#123;</span><br><span class="line">        <span class="built_in">this</span>.threshold = threshold;</span><br><span class="line">        <span class="built_in">this</span>.numberOfTimes = numberOfTimes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(Configuration parameters)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过状态名称(句柄)获取状态实例，如果不存在则会自动创建</span></span><br><span class="line">        abnormalData = getRuntimeContext().getListState(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ListStateDescriptor</span>&lt;&gt;(<span class="string">&quot;abnormalData&quot;</span>, Long.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatMap</span><span class="params">(Tuple2&lt;String, Long&gt; value, Collector&lt;Tuple2&lt;String, List&lt;Long&gt;&gt;&gt; out)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">inputValue</span> <span class="operator">=</span> value.f1;</span><br><span class="line">        <span class="comment">// 如果输入值超过阈值，则记录该次不正常的数据信息</span></span><br><span class="line">        <span class="keyword">if</span> (inputValue &gt;= threshold) &#123;</span><br><span class="line">            abnormalData.add(inputValue);</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Long&gt; list = Lists.newArrayList(abnormalData.get().iterator());</span><br><span class="line">        <span class="comment">// 如果不正常的数据出现达到一定次数，则输出报警信息</span></span><br><span class="line">        <span class="keyword">if</span> (list.size() &gt;= numberOfTimes) &#123;</span><br><span class="line">            out.collect(Tuple2.of(value.f0 + <span class="string">&quot; 超过指定阈值 &quot;</span>, list));</span><br><span class="line">            <span class="comment">// 报警信息输出后，清空状态</span></span><br><span class="line">            abnormalData.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用自定义的状态监控，这里我们使用 a，b 来代表不同类型的监控数据，分别对其数据进行监控：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">DataStreamSource&lt;Tuple2&lt;String, Long&gt;&gt; tuple2DataStreamSource = env.fromElements(</span><br><span class="line">    Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">50L</span>), Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">80L</span>), Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">400L</span>),</span><br><span class="line">    Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">100L</span>), Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">200L</span>), Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">200L</span>),</span><br><span class="line">    Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">100L</span>), Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">200L</span>), Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">200L</span>),</span><br><span class="line">    Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">500L</span>), Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">600L</span>), Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">700L</span>));</span><br><span class="line">tuple2DataStreamSource</span><br><span class="line">    .keyBy(<span class="number">0</span>)</span><br><span class="line">    .flatMap(<span class="keyword">new</span> <span class="title class_">ThresholdWarning</span>(<span class="number">100L</span>, <span class="number">3</span>))  <span class="comment">// 超过100的阈值3次后就进行报警</span></span><br><span class="line">    .printToErr();</span><br><span class="line">env.execute(<span class="string">&quot;Managed Keyed State&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>输出如下结果如下：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-state-management.png"/> </div>
<h3 id="2-2-状态有效期">2.2 状态有效期</h3>
<p>以上任何类型的 keyed state 都支持配置有效期 (TTL) ，示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StateTtlConfig</span> <span class="variable">ttlConfig</span> <span class="operator">=</span> StateTtlConfig</span><br><span class="line">    <span class="comment">// 设置有效期为 10 秒</span></span><br><span class="line">    .newBuilder(Time.seconds(<span class="number">10</span>))  </span><br><span class="line">    <span class="comment">// 设置有效期更新规则，这里设置为当创建和写入时，都重置其有效期到规定的10秒</span></span><br><span class="line">    .setUpdateType(StateTtlConfig.UpdateType.OnCreateAndWrite) </span><br><span class="line">    <span class="comment">/*设置只要值过期就不可见，另外一个可选值是ReturnExpiredIfNotCleanedUp，</span></span><br><span class="line"><span class="comment">     代表即使值过期了，但如果还没有被物理删除，就是可见的*/</span></span><br><span class="line">    .setStateVisibility(StateTtlConfig.StateVisibility.NeverReturnExpired)</span><br><span class="line">    .build();</span><br><span class="line">ListStateDescriptor&lt;Long&gt; descriptor = <span class="keyword">new</span> <span class="title class_">ListStateDescriptor</span>&lt;&gt;(<span class="string">&quot;abnormalData&quot;</span>, Long.class);</span><br><span class="line">descriptor.enableTimeToLive(ttlConfig);</span><br></pre></td></tr></table></figure>
<h3 id="2-3-算子状态">2.3 算子状态</h3>
<p>相比于键控状态，算子状态目前支持的存储类型只有以下三种：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>ListState</strong>：存储列表类型的状态。</p>
</li>
<li class="lvl-2">
<p><strong>UnionListState</strong>：存储列表类型的状态，与 ListState 的区别在于：如果并行度发生变化，ListState 会将该算子的所有并发的状态实例进行汇总，然后均分给新的 Task；而 UnionListState 只是将所有并发的状态实例汇总起来，具体的划分行为则由用户进行定义。</p>
</li>
<li class="lvl-2">
<p><strong>BroadcastState</strong>：用于广播的算子状态。</p>
</li>
</ul>
<p>这里我们继续沿用上面的例子，假设此时我们不需要区分监控数据的类型，只要有监控数据超过阈值并达到指定的次数后，就进行报警，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThresholdWarning</span> <span class="keyword">extends</span> <span class="title class_">RichFlatMapFunction</span>&lt;Tuple2&lt;String, Long&gt;, </span><br><span class="line">Tuple2&lt;String, List&lt;Tuple2&lt;String, Long&gt;&gt;&gt;&gt; <span class="keyword">implements</span> <span class="title class_">CheckpointedFunction</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非正常数据</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Tuple2&lt;String, Long&gt;&gt; bufferedData;</span><br><span class="line">    <span class="comment">// checkPointedState</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ListState&lt;Tuple2&lt;String, Long&gt;&gt; checkPointedState;</span><br><span class="line">    <span class="comment">// 需要监控的阈值</span></span><br><span class="line">    <span class="keyword">private</span> Long threshold;</span><br><span class="line">    <span class="comment">// 次数</span></span><br><span class="line">    <span class="keyword">private</span> Integer numberOfTimes;</span><br><span class="line"></span><br><span class="line">    ThresholdWarning(Long threshold, Integer numberOfTimes) &#123;</span><br><span class="line">        <span class="built_in">this</span>.threshold = threshold;</span><br><span class="line">        <span class="built_in">this</span>.numberOfTimes = numberOfTimes;</span><br><span class="line">        <span class="built_in">this</span>.bufferedData = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initializeState</span><span class="params">(FunctionInitializationContext context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 注意这里获取的是OperatorStateStore</span></span><br><span class="line">        checkPointedState = context.getOperatorStateStore().</span><br><span class="line">            getListState(<span class="keyword">new</span> <span class="title class_">ListStateDescriptor</span>&lt;&gt;(<span class="string">&quot;abnormalData&quot;</span>,</span><br><span class="line">                TypeInformation.of(<span class="keyword">new</span> <span class="title class_">TypeHint</span>&lt;Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">                &#125;)));</span><br><span class="line">        <span class="comment">// 如果发生重启，则需要从快照中将状态进行恢复</span></span><br><span class="line">        <span class="keyword">if</span> (context.isRestored()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Tuple2&lt;String, Long&gt; element : checkPointedState.get()) &#123;</span><br><span class="line">                bufferedData.add(element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatMap</span><span class="params">(Tuple2&lt;String, Long&gt; value, </span></span><br><span class="line"><span class="params">                        Collector&lt;Tuple2&lt;String, List&lt;Tuple2&lt;String, Long&gt;&gt;&gt;&gt; out)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">inputValue</span> <span class="operator">=</span> value.f1;</span><br><span class="line">        <span class="comment">// 超过阈值则进行记录</span></span><br><span class="line">        <span class="keyword">if</span> (inputValue &gt;= threshold) &#123;</span><br><span class="line">            bufferedData.add(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 超过指定次数则输出报警信息</span></span><br><span class="line">        <span class="keyword">if</span> (bufferedData.size() &gt;= numberOfTimes) &#123;</span><br><span class="line">             <span class="comment">// 顺便输出状态实例的hashcode</span></span><br><span class="line">             out.collect(Tuple2.of(checkPointedState.hashCode() + <span class="string">&quot;阈值警报！&quot;</span>, bufferedData));</span><br><span class="line">            bufferedData.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">snapshotState</span><span class="params">(FunctionSnapshotContext context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 在进行快照时，将数据存储到checkPointedState</span></span><br><span class="line">        checkPointedState.clear();</span><br><span class="line">        <span class="keyword">for</span> (Tuple2&lt;String, Long&gt; element : bufferedData) &#123;</span><br><span class="line">            checkPointedState.add(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用自定义算子状态，这里需要将并行度设置为 1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"><span class="comment">// 开启检查点机制</span></span><br><span class="line">env.enableCheckpointing(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 设置并行度为1</span></span><br><span class="line">DataStreamSource&lt;Tuple2&lt;String, Long&gt;&gt; tuple2DataStreamSource = env.setParallelism(<span class="number">1</span>).fromElements(</span><br><span class="line">    Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">50L</span>), Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">80L</span>), Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">400L</span>),</span><br><span class="line">    Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">100L</span>), Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">200L</span>), Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">200L</span>),</span><br><span class="line">    Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">100L</span>), Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">200L</span>), Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">200L</span>),</span><br><span class="line">    Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">500L</span>), Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">600L</span>), Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">700L</span>));</span><br><span class="line">tuple2DataStreamSource</span><br><span class="line">    .flatMap(<span class="keyword">new</span> <span class="title class_">ThresholdWarning</span>(<span class="number">100L</span>, <span class="number">3</span>))</span><br><span class="line">    .printToErr();</span><br><span class="line">env.execute(<span class="string">&quot;Managed Keyed State&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时输出如下：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-operator-state-para1.png"/> </div>
<p>在上面的调用代码中，我们将程序的并行度设置为 1，可以看到三次输出中状态实例的 hashcode 全是一致的，证明它们都同一个状态实例。假设将并行度设置为 2，此时输出如下：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-operator-state-para2.png"/> </div>
<p>可以看到此时两次输出中状态实例的 hashcode 是不一致的，代表它们不是同一个状态实例，这也就是上文提到的，一个算子状态是与一个并发的算子实例所绑定的。同时这里只输出两次，是因为在并发处理的情况下，线程 1 可能拿到 5 个非正常值，线程 2 可能拿到 4 个非正常值，因为要大于 3 次才能输出，所以在这种情况下就会出现只输出两条记录的情况，所以需要将程序的并行度设置为 1。</p>
<h2 id="三、检查点机制">三、检查点机制</h2>
<h3 id="3-1-CheckPoints">3.1 CheckPoints</h3>
<p>为了使 Flink 的状态具有良好的容错性，Flink 提供了检查点机制 (CheckPoints)  。通过检查点机制，Flink 定期在数据流上生成 checkpoint barrier ，当某个算子收到 barrier 时，即会基于当前状态生成一份快照，然后再将该 barrier 传递到下游算子，下游算子接收到该 barrier 后，也基于当前状态生成一份快照，依次传递直至到最后的 Sink 算子上。当出现异常后，Flink 就可以根据最近的一次的快照数据将所有算子恢复到先前的状态。</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-stream-barriers.png"/> </div>
<h3 id="3-2-开启检查点">3.2 开启检查点</h3>
<p>默认情况下，检查点机制是关闭的，需要在程序中进行开启：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启检查点机制，并指定状态检查点之间的时间间隔</span></span><br><span class="line">env.enableCheckpointing(<span class="number">1000</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他可选配置如下：</span></span><br><span class="line"><span class="comment">// 设置语义</span></span><br><span class="line">env.getCheckpointConfig().setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE);</span><br><span class="line"><span class="comment">// 设置两个检查点之间的最小时间间隔</span></span><br><span class="line">env.getCheckpointConfig().setMinPauseBetweenCheckpoints(<span class="number">500</span>);</span><br><span class="line"><span class="comment">// 设置执行Checkpoint操作时的超时时间</span></span><br><span class="line">env.getCheckpointConfig().setCheckpointTimeout(<span class="number">60000</span>);</span><br><span class="line"><span class="comment">// 设置最大并发执行的检查点的数量</span></span><br><span class="line">env.getCheckpointConfig().setMaxConcurrentCheckpoints(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 将检查点持久化到外部存储</span></span><br><span class="line">env.getCheckpointConfig().enableExternalizedCheckpoints(</span><br><span class="line">    ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION);</span><br><span class="line"><span class="comment">// 如果有更近的保存点时，是否将作业回退到该检查点</span></span><br><span class="line">env.getCheckpointConfig().setPreferCheckpointForRecovery(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<h3 id="3-3-保存点机制">3.3 保存点机制</h3>
<p>保存点机制 (Savepoints) 是检查点机制的一种特殊的实现，它允许你通过手工的方式来触发 Checkpoint，并将结果持久化存储到指定路径中，主要用于避免 Flink 集群在重启或升级时导致状态丢失。示例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">触发指定<span class="built_in">id</span>的作业的Savepoint，并将结果存储到指定目录下</span></span><br><span class="line">bin/flink savepoint :jobId [:targetDirectory]</span><br></pre></td></tr></table></figure>
<p>更多命令和配置可以参考官方文档：<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/zh/ops/state/savepoints.html">savepoints</a></p>
<h2 id="四、状态后端">四、状态后端</h2>
<h3 id="4-1-状态管理器分类">4.1 状态管理器分类</h3>
<p>默认情况下，所有的状态都存储在 JVM 的堆内存中，在状态数据过多的情况下，这种方式很有可能导致内存溢出，因此 Flink 该提供了其它方式来存储状态数据，这些存储方式统一称为状态后端 (或状态管理器)：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-checkpoints-backend.png"/> </div>
<p>主要有以下三种：</p>
<h4 id="1-MemoryStateBackend">1. MemoryStateBackend</h4>
<p>默认的方式，即基于 JVM 的堆内存进行存储，主要适用于本地开发和调试。</p>
<h4 id="2-FsStateBackend">2. FsStateBackend</h4>
<p>基于文件系统进行存储，可以是本地文件系统，也可以是 HDFS 等分布式文件系统。 需要注意而是虽然选择使用了 FsStateBackend ，但正在进行的数据仍然是存储在 TaskManager 的内存中的，只有在 checkpoint 时，才会将状态快照写入到指定文件系统上。</p>
<h4 id="3-RocksDBStateBackend">3. RocksDBStateBackend</h4>
<p>RocksDBStateBackend 是 Flink 内置的第三方状态管理器，采用嵌入式的 key-value 型数据库 RocksDB 来存储正在进行的数据。等到 checkpoint 时，再将其中的数据持久化到指定的文件系统中，所以采用 RocksDBStateBackend 时也需要配置持久化存储的文件系统。之所以这样做是因为 RocksDB 作为嵌入式数据库安全性比较低，但比起全文件系统的方式，其读取速率更快；比起全内存的方式，其存储空间更大，因此它是一种比较均衡的方案。</p>
<h3 id="4-2-配置方式">4.2 配置方式</h3>
<p>Flink 支持使用两种方式来配置后端管理器：</p>
<p><strong>第一种方式</strong>：基于代码方式进行配置，只对当前作业生效：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置 FsStateBackend</span></span><br><span class="line">env.setStateBackend(<span class="keyword">new</span> <span class="title class_">FsStateBackend</span>(<span class="string">&quot;hdfs://namenode:40010/flink/checkpoints&quot;</span>));</span><br><span class="line"><span class="comment">// 配置 RocksDBStateBackend</span></span><br><span class="line">env.setStateBackend(<span class="keyword">new</span> <span class="title class_">RocksDBStateBackend</span>(<span class="string">&quot;hdfs://namenode:40010/flink/checkpoints&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>配置 RocksDBStateBackend 时，需要额外导入下面的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-statebackend-rocksdb_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>第二种方式</strong>：基于 <code>flink-conf.yaml</code> 配置文件的方式进行配置，对所有部署在该集群上的作业都生效：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">state.backend:</span> <span class="string">filesystem</span></span><br><span class="line"><span class="attr">state.checkpoints.dir:</span> <span class="string">hdfs://namenode:40010/flink/checkpoints</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：本篇文章所有示例代码下载地址：<a href="https://github.com/oicio/BigData-Notes/tree/master/code/Flink/flink-state-management">flink-state-management</a></p>
</blockquote>
<h2 id="参考资料-7">参考资料</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/stream/state/state.html">Working with State</a></p>
</li>
<li class="lvl-2">
<p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/stream/state/checkpointing.html">Checkpointing</a></p>
</li>
<li class="lvl-2">
<p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/ops/state/savepoints.html#savepoints">Savepoints</a></p>
</li>
<li class="lvl-2">
<p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/ops/state/state_backends.html">State Backends</a></p>
</li>
<li class="lvl-2">
<p>Fabian Hueske , Vasiliki Kalavri . 《Stream Processing with Apache Flink》.  O’Reilly Media .  2019-4-30</p>
</li>
</ul>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>flink背压机制</title>
    <url>/posts/219a0aae.html</url>
    <content><![CDATA[<h3 id="背压产生的原因">背压产生的原因</h3>
<p>流处理系统需要能优雅地处理反压（backpressure）问题。反压通常产生于这样的场景：短时负载高峰导致系统接收数据的速率远高于它处理数据的速率。许多日常问题都会导致反压，例如，垃圾回收停顿可能会导致流入的数据快速堆积，或者遇到大促或秒杀活动导致流量陡增。反压如果不能得到正确的处理，可能会导致资源耗尽甚至系统崩溃。</p>
<p>目前主流的流处理系统 Storm/JStorm/Spark Streaming/Flink都提供了反压机制，但实现各不相同。</p>
<h3 id="Strom的处理方法">Strom的处理方法</h3>
<p>Strom是通过监控Blot中的接收队列负载情况，如果超过高水位值就会将反压信息写到 Zookeeper ，Zookeeper 上的 watch 会通知该拓扑的所有 Worker 都进入反压状态，<strong>最后 Spout 停止发送 tuple</strong>。具体实现可以看这个 JIRA <a href="https://github.com/apache/storm/pull/700">STORM-886</a>。</p>
<p>这种方式会存在问题，当下游出现阻塞时，上游停止发送，下游消除阻塞后，上游又开闸放水，过了一会儿，下游又阻塞，上游又限流，如此反复，整个数据流会一直处在一个颠簸状态。很不稳定。</p>
<h3 id="Flink的处理方法">Flink的处理方法</h3>
<p>Flink 在运行时主要由 <strong>operators</strong> 和 <strong>streams</strong> 两大组件构成。每个 operator 会消费中间态的流，并在流上进行转换，然后生成新的流。对于 Flink 的网络机制一种形象的类比是，<strong>Flink 使用了高效有界的分布式阻塞队列，就像 Java 通用的阻塞队列（BlockingQueue）一样</strong>。还记得经典的线程间通信案例：生产者消费者模型吗？使用 BlockingQueue 的话，一个较慢的接受者会降低发送者的发送速率，因为一旦队列满了（有界队列）发送者会被阻塞。Flink 解决反压的方案就是这种感觉。</p>
<p>在 Flink 中，这些分布式阻塞队列就是这些逻辑流，而队列容量是通过缓冲池来（<code>LocalBufferPool</code>）实现的。每个被生产和被消费的流都会被分配一个缓冲池。缓冲池管理着一组缓冲(<code>Buffer</code>)，缓冲在被消费后可以被回收循环利用。这很好理解：你从池子中拿走一个缓冲，填上数据，在数据消费完之后，又把缓冲还给池子，之后你可以再次使用它。</p>
<p>在解释 Flink 的反压原理之前，我们必须先对 Flink 中网络传输的内存管理有个了解。</p>
<h4 id="网络传输中的内存管理">网络传输中的内存管理</h4>
<p>如下图所示展示了 Flink 在网络传输场景下的内存管理。网络上传输的数据会写到 Task 的 InputGate（IG） 中，经过 Task 的处理后，再由 Task 写到 ResultPartition（RS） 中。每个 Task 都包括了输入和输入，输入和输出的数据存在 <code>Buffer</code> 中（都是字节数据）。Buffer 是 MemorySegment 的包装类。</p>
<p><img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/TB14fLsHVXXXXXWXFXXXXXXXXXX.png" alt="img"></p>
<ol>
<li class="lvl-3">
<p>TaskManager（TM）在启动时，会先初始化<code>NetworkEnvironment</code>对象，TM 中所有与网络相关的东西都由该类来管理（如 Netty 连接），其中就包括<code>NetworkBufferPool</code>。根据配置，Flink 会在 NetworkBufferPool 中生成一定数量（默认2048个）的内存块 MemorySegment（关于 Flink 的内存管理，<a href="http://www.atatech.org/articles/54033">后续文章</a>会详细谈到），内存块的总数量就代表了网络传输中所有可用的内存。NetworkEnvironment 和 NetworkBufferPool 是 Task 之间共享的，每个 TM 只会实例化一个。</p>
</li>
<li class="lvl-3">
<p>Task 线程启动时，会向 NetworkEnvironment 注册，NetworkEnvironment 会为 Task 的 InputGate（IG）和 ResultPartition（RP） 分别创建一个 LocalBufferPool（缓冲池）并设置可申请的 MemorySegment（内存块）数量。IG 对应的缓冲池初始的内存块数量与 IG 中 InputChannel 数量一致，RP 对应的缓冲池初始的内存块数量与 RP 中的 ResultSubpartition 数量一致。不过，每当创建或销毁缓冲池时，NetworkBufferPool 会计算剩余空闲的内存块数量，并平均分配给已创建的缓冲池。注意，这个过程只是指定了缓冲池所能使用的内存块数量，并没有真正分配内存块，只有当需要时才分配。为什么要动态地为缓冲池扩容呢？因为内存越多，意味着系统可以更轻松地应对瞬时压力（如GC），不会频繁地进入反压状态，所以我们要利用起那部分闲置的内存块。</p>
</li>
<li class="lvl-3">
<p>在 Task 线程执行过程中，当 Netty 接收端收到数据时，为了将 Netty 中的数据拷贝到 Task 中，InputChannel（实际是 RemoteInputChannel）会向其对应的缓冲池申请内存块（上图中的①）。如果缓冲池中也没有可用的内存块且已申请的数量还没到池子上限，则会向 NetworkBufferPool 申请内存块（上图中的②）并交给 InputChannel 填上数据（上图中的③和④）。如果缓冲池已申请的数量达到上限了呢？或者 NetworkBufferPool 也没有可用内存块了呢？这时候，Task 的 Netty Channel 会暂停读取，上游的发送端会立即响应停止发送，拓扑会进入反压状态。当 Task 线程写数据到 ResultPartition 时，也会向缓冲池请求内存块，如果没有可用内存块时，会阻塞在请求内存块的地方，达到暂停写入的目的。</p>
</li>
<li class="lvl-3">
<p>当一个内存块被消费完成之后（在输入端是指内存块中的字节被反序列化成对象了，在输出端是指内存块中的字节写入到 Netty Channel 了），会调用 <code>Buffer.recycle()</code> 方法，会将内存块还给 LocalBufferPool （上图中的⑤）。如果LocalBufferPool中当前申请的数量超过了池子容量（由于上文提到的动态容量，由于新注册的 Task 导致该池子容量变小），则LocalBufferPool会将该内存块回收给 NetworkBufferPool（上图中的⑥）。如果没超过池子容量，则会继续留在池子中，减少反复申请的开销。</p>
</li>
</ol>
<h4 id="背压的过程">背压的过程</h4>
<p>下面这张图简单展示了两个 Task 之间的数据传输以及 Flink 如何感知到反压的</p>
<p><img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/TB1rCIvJpXXXXcKXXXXXXXXXXXX.png" alt="img"></p>
<ol>
<li class="lvl-3">
<p>记录“A”进入了 Flink 并且被 Task 1 处理。（这里省略了 Netty 接收、反序列化等过程）</p>
</li>
<li class="lvl-3">
<p>记录被序列化到 buffer 中。</p>
</li>
<li class="lvl-3">
<p>该 buffer 被发送到 Task 2，然后 Task 2 从这个 buffer 中读出记录。</p>
</li>
</ol>
<p><strong>不要忘了：记录能被 Flink 处理的前提是，必须有空闲可用的 Buffer。</strong></p>
<p>结合上面两张图看：Task 1 在输出端有一个相关联的 LocalBufferPool（称缓冲池1），Task 2 在输入端也有一个相关联的 LocalBufferPool（称缓冲池2）。如果缓冲池1中有空闲可用的 buffer 来序列化记录 “A”，我们就序列化并发送该 buffer。</p>
<p>这里我们需要注意两个场景：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>本地传输：如果 Task 1 和 Task 2 运行在同一个 worker 节点（TaskManager），该 buffer 可以直接交给下一个 Task。一旦 Task 2 消费了该 buffer，则该 buffer 会被缓冲池1回收。如果 Task 2 的速度比 1 慢，那么 buffer 回收的速度就会赶不上 Task 1 取 buffer 的速度，导致缓冲池1无可用的 buffer，Task 1 等待在可用的 buffer 上。最终形成 Task 1 的降速。</p>
</li>
<li class="lvl-2">
<p>远程传输：如果 Task 1 和 Task 2 运行在不同的 worker 节点上，那么 buffer 会在发送到网络（TCP Channel）后被回收。在接收端，会从 LocalBufferPool 中申请 buffer，然后拷贝网络中的数据到 buffer 中。如果没有可用的 buffer，会停止从 TCP 连接中读取数据。在输出端，通过 Netty 的水位值机制来保证不往网络中写入太多数据（后面会说）<strong>。如果网络中的数据（Netty输出缓冲中的字节数）超过了高水位值，我们会等到其降到低水位值以下才继续写入数据</strong>。这保证了网络中不会有太多的数据。<strong>如果接收端停止消费网络中的数据（由于接收端缓冲池没有可用 buffer），网络中的缓冲数据就会堆积，那么发送端也会暂停发送</strong>。另外，这会使得发送端的缓冲池得不到回收，writer 阻塞在向 LocalBufferPool 请求 buffer，阻塞了 writer 往 ResultSubPartition 写数据。</p>
</li>
</ul>
<h4 id="Netty水位值机制">Netty水位值机制</h4>
<p>下方的代码是初始化 NettyServer 时配置的水位值参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认高水位值为2个buffer大小, 当接收端消费速度跟不上，发送端会立即感知到</span></span><br><span class="line">bootstrap.childOption(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK, </span><br><span class="line">                      config.getMemorySegmentSize() + <span class="number">1</span>);</span><br><span class="line">bootstrap.childOption(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK, </span><br><span class="line">                      <span class="number">2</span> * config.getMemorySegmentSize());</span><br></pre></td></tr></table></figure>
<p>当输出缓冲中的字节数超过了高水位值, 则 Channel.isWritable() 会返回false。当输出缓存中的字节数又掉到了低水位值以下, 则 Channel.isWritable() 会重新返回true。Flink 中发送数据的核心代码在 <code>PartitionRequestQueue</code> 中，该类是 server channel pipeline 的最后一层。发送数据关键代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeAndFlushNextMessageIfPossible</span><span class="params">(<span class="keyword">final</span> Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (fatalError) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">Buffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// channel.isWritable() 配合 WRITE_BUFFER_LOW_WATER_MARK </span></span><br><span class="line">        <span class="comment">// 和 WRITE_BUFFER_HIGH_WATER_MARK 实现发送端的流量控制</span></span><br><span class="line">        <span class="keyword">if</span> (channel.isWritable()) &#123;</span><br><span class="line">            <span class="comment">// 注意: 一个while循环也就最多只发送一个BufferResponse, 连续发送BufferResponse是通过writeListener回调实现的</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (currentPartitionQueue == <span class="literal">null</span> &amp;&amp; (currentPartitionQueue = queue.poll()) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                buffer = currentPartitionQueue.getNextBuffer();</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (buffer == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 跳过这部分代码</span></span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 构造一个response返回给客户端</span></span><br><span class="line">                    <span class="type">BufferResponse</span> <span class="variable">resp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferResponse</span>(buffer, currentPartitionQueue.getSequenceNumber(), currentPartitionQueue.getReceiverId());</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">if</span> (!buffer.isBuffer() &amp;&amp;</span><br><span class="line">                            EventSerializer.fromBuffer(buffer, getClass().getClassLoader()).getClass() == EndOfPartitionEvent.class) &#123;</span><br><span class="line">                        <span class="comment">// 跳过这部分代码。batch 模式中 subpartition 的数据准备就绪，通知下游消费者。</span></span><br><span class="line">                        ...</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    <span class="comment">// 将该response发到netty channel, 当写成功后, </span></span><br><span class="line">                    <span class="comment">// 通过注册的writeListener又会回调进来, 从而不断地消费 queue 中的请求</span></span><br><span class="line">                    channel.writeAndFlush(resp).addListener(writeListener);</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buffer != <span class="literal">null</span>) &#123;</span><br><span class="line">            buffer.recycle();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 当水位值降下来后（channel 再次可写），会重新触发发送函数</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    writeAndFlushNextMessageIfPossible(ctx.channel());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心发送方法中如果channel不可写，则会跳过发送。当channel再次可写后，Netty 会调用该Handle的 <code>channelWritabilityChanged</code> 方法，从而重新触发发送函数。</p>
<h4 id="背压监控">背压监控</h4>
<p>在 Storm/JStorm 中，只要监控到队列满了，就可以记录下拓扑进入反压了。但是 Flink 的反压太过于天然了，导致我们无法简单地通过监控队列来监控反压状态。Flink 在这里使用了一个 trick 来实现对反压的监控。<strong>如果一个 Task 因为反压而降速了，那么它会卡在向 LocalBufferPool 申请内存块上</strong>。那么这时候，该 Task 的 stack trace 就会长下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.Object.wait(Native Method)</span><br><span class="line">o.a.f.[...].LocalBufferPool.requestBuffer(LocalBufferPool.java:<span class="number">163</span>)</span><br><span class="line">o.a.f.[...].LocalBufferPool.requestBufferBlocking(LocalBufferPool.java:<span class="number">133</span>) &lt;--- BLOCKING request</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<p>那么事情就简单了。通过不断地采样每个 task 的 stack trace 就可以实现反压监控。</p>
<p><img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/TB1T3cJJpXXXXXLXpXXXXXXXXXX.png" alt="img"></p>
<p>Flink 的实现中，只有当 Web 页面切换到某个 Job 的 Backpressure 页面，才会对这个 Job 触发反压检测，因为反压检测还是挺昂贵的。JobManager 会通过 Akka 给每个 TaskManager 发送<code>TriggerStackTraceSample</code>消息。默认情况下，TaskManager 会触发100次 stack trace 采样，每次间隔 50ms（也就是说一次反压检测至少要等待5秒钟）。并将这 100 次采样的结果返回给 JobManager，由 JobManager 来计算反压比率（反压出现的次数/采样的次数），最终展现在 UI 上。UI 刷新的默认周期是一分钟，目的是不对 TaskManager 造成太大的负担。</p>
<h3 id="总结-2">总结</h3>
<p>Flink 不需要一种特殊的机制来处理反压，因为 Flink 中的数据传输相当于已经提供了应对反压的机制。因此，Flink 所能获得的最大吞吐量由其 pipeline 中最慢的组件决定。相对于 Storm/JStorm 的实现，Flink 的实现更为简洁优雅，源码中也看不见与反压相关的代码，无需 Zookeeper/TopologyMaster 的参与也降低了系统的负载，也利于对反压更迅速的响应。</p>
<p>转载: <a href="https://blog.csdn.net/u011750989/article/details/82191298">flink背压</a></p>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink窗口模型</title>
    <url>/posts/f8832c13.html</url>
    <content><![CDATA[<h2 id="一、窗口概念">一、窗口概念</h2>
<p>在大多数场景下，我们需要统计的数据流都是无界的，因此我们无法等待整个数据流终止后才进行统计。通常情况下，我们只需要对某个时间范围或者数量范围内的数据进行统计分析：如每隔五分钟统计一次过去一小时内所有商品的点击量；或者每发生1000次点击后，都去统计一下每个商品点击率的占比。在 Flink 中，我们使用窗口 (Window) 来实现这类功能。按照统计维度的不同，Flink 中的窗口可以分为 时间窗口 (Time Windows) 和 计数窗口 (Count Windows) 。</p>
<h2 id="二、Time-Windows">二、Time Windows</h2>
<p>Time Windows 用于以时间为维度来进行数据聚合，具体分为以下四类：</p>
<h3 id="2-1-Tumbling-Windows">2.1 Tumbling Windows</h3>
<p>滚动窗口 (Tumbling Windows) 是指彼此之间没有重叠的窗口。例如：每隔1小时统计过去1小时内的商品点击量，那么 1 天就只能分为 24 个窗口，每个窗口彼此之间是不存在重叠的，具体如下：</p>
<div align="center"> <img width="600px" src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-tumbling-windows.png"/> </div>
<p>这里我们以词频统计为例，给出一个具体的用例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"><span class="comment">// 接收socket上的数据输入</span></span><br><span class="line">DataStreamSource&lt;String&gt; streamSource = env.socketTextStream(<span class="string">&quot;hadoop001&quot;</span>, <span class="number">9999</span>, <span class="string">&quot;\n&quot;</span>, <span class="number">3</span>);</span><br><span class="line">streamSource.flatMap(<span class="keyword">new</span> <span class="title class_">FlatMapFunction</span>&lt;String, Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatMap</span><span class="params">(String value, Collector&lt;Tuple2&lt;String, Long&gt;&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        String[] words = value.split(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            out.collect(<span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(word, <span class="number">1L</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).keyBy(<span class="number">0</span>).timeWindow(Time.seconds(<span class="number">3</span>)).sum(<span class="number">1</span>).print(); <span class="comment">//每隔3秒统计一次每个单词出现的数量</span></span><br><span class="line">env.execute(<span class="string">&quot;Flink Streaming&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>测试结果如下：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-window-word-count.png"/> </div>
<h3 id="2-2-Sliding-Windows">2.2 Sliding Windows</h3>
<p>滑动窗口用于滚动进行聚合分析，例如：每隔 6 分钟统计一次过去一小时内所有商品的点击量，那么统计窗口彼此之间就是存在重叠的，即 1天可以分为 240 个窗口。图示如下：</p>
<div align="center"> <img width="600px" src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-sliding-windows.png"/> </div>
<p>可以看到 window 1 - 4 这四个窗口彼此之间都存在着时间相等的重叠部分。想要实现滑动窗口，只需要在使用 timeWindow 方法时额外传递第二个参数作为滚动时间即可，具体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每隔3秒统计一次过去1分钟内的数据</span></span><br><span class="line">timeWindow(Time.minutes(<span class="number">1</span>),Time.seconds(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<h3 id="2-3-Session-Windows">2.3 Session Windows</h3>
<p>当用户在进行持续浏览时，可能每时每刻都会有点击数据，例如在活动区间内，用户可能频繁的将某类商品加入和移除购物车，而你只想知道用户本次浏览最终的购物车情况，此时就可以在用户持有的会话结束后再进行统计。想要实现这类统计，可以通过 Session Windows 来进行实现。</p>
<div align="center"> <img width="600px" src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-session-windows.png"/> </div>
<p>具体的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以处理时间为衡量标准，如果10秒内没有任何数据输入，就认为会话已经关闭，此时触发统计</span></span><br><span class="line">window(ProcessingTimeSessionWindows.withGap(Time.seconds(<span class="number">10</span>)))</span><br><span class="line"><span class="comment">// 以事件时间为衡量标准    </span></span><br><span class="line">window(EventTimeSessionWindows.withGap(Time.seconds(<span class="number">10</span>)))</span><br></pre></td></tr></table></figure>
<h3 id="2-4-Global-Windows">2.4 Global Windows</h3>
<p>最后一个窗口是全局窗口， 全局窗口会将所有 key 相同的元素分配到同一个窗口中，其通常配合触发器 (trigger) 进行使用。如果没有相应触发器，则计算将不会被执行。</p>
<div align="center"> <img width="600px" src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/flink-non-windowed.png"/> </div>
<p>这里继续以上面词频统计的案例为例，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当单词累计出现的次数每达到10次时，则触发计算，计算整个窗口内该单词出现的总数</span></span><br><span class="line">window(GlobalWindows.create()).trigger(CountTrigger.of(<span class="number">10</span>)).sum(<span class="number">1</span>).print();</span><br></pre></td></tr></table></figure>
<h2 id="三、Count-Windows">三、Count Windows</h2>
<p>Count Windows 用于以数量为维度来进行数据聚合，同样也分为滚动窗口和滑动窗口，实现方式也和时间窗口完全一致，只是调用的 API 不同，具体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滚动计数窗口，每1000次点击则计算一次</span></span><br><span class="line">countWindow(<span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 滑动计数窗口，每10次点击发生后，则计算过去1000次点击的情况</span></span><br><span class="line">countWindow(<span class="number">1000</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>实际上计数窗口内部就是调用的我们上一部分介绍的全局窗口来实现的，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> WindowedStream&lt;T, KEY, GlobalWindow&gt; <span class="title function_">countWindow</span><span class="params">(<span class="type">long</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> window(GlobalWindows.create()).trigger(PurgingTrigger.of(CountTrigger.of(size)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> WindowedStream&lt;T, KEY, GlobalWindow&gt; <span class="title function_">countWindow</span><span class="params">(<span class="type">long</span> size, <span class="type">long</span> slide)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> window(GlobalWindows.create())</span><br><span class="line">        .evictor(CountEvictor.of(size))</span><br><span class="line">        .trigger(CountTrigger.of(slide));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料-8">参考资料</h2>
<p>Flink Windows： <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/stream/operators/windows.html">https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/stream/operators/windows.html</a></p>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>HDFS JAVA API</title>
    <url>/posts/b40432dd.html</url>
    <content><![CDATA[<h2 id="一、-简介">一、 简介</h2>
<p>想要使用 HDFS API，需要导入依赖 <code>hadoop-client</code>。如果是 CDH 版本的 Hadoop，还需要额外指明其仓库地址：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 </span></span><br><span class="line"><span class="string">         http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.ihadu&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hdfs-java-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.0</span>&lt;/version&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-<span class="number">8</span>&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;hadoop.version&gt;<span class="number">2.6</span><span class="number">.0</span>-cdh5<span class="number">.15</span><span class="number">.2</span>&lt;/hadoop.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!---配置 CDH 仓库地址--&gt;</span><br><span class="line">    &lt;repositories&gt;</span><br><span class="line">        &lt;repository&gt;</span><br><span class="line">            &lt;id&gt;cloudera&lt;/id&gt;</span><br><span class="line">            &lt;url&gt;https:<span class="comment">//repository.cloudera.com/artifactory/cloudera-repos/&lt;/url&gt;</span></span><br><span class="line">        &lt;/repository&gt;</span><br><span class="line">    &lt;/repositories&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--Hadoop-client--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;hadoop.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">4.12</span>&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<h2 id="二、API的使用">二、API的使用</h2>
<h3 id="2-1-FileSystem">2.1 FileSystem</h3>
<p>FileSystem 是所有 HDFS 操作的主入口。由于之后的每个单元测试都需要用到它，这里使用 <code>@Before</code> 注解进行标注。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HDFS_PATH</span> <span class="operator">=</span> <span class="string">&quot;hdfs://192.168.0.106:8020&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HDFS_USER</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> FileSystem fileSystem;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">        <span class="comment">// 这里我启动的是单节点的 Hadoop,所以副本系数设置为 1,默认值为 3</span></span><br><span class="line">        configuration.set(<span class="string">&quot;dfs.replication&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        fileSystem = FileSystem.get(<span class="keyword">new</span> <span class="title class_">URI</span>(HDFS_PATH), configuration, HDFS_USER);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@After</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    fileSystem = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-创建目录">2.2 创建目录</h3>
<p>支持递归创建目录：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mkDir</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    fileSystem.mkdirs(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/hdfs-api/test0/&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-创建指定权限的目录">2.3 创建指定权限的目录</h3>
<p><code>FsPermission(FsAction u, FsAction g, FsAction o)</code> 的三个参数分别对应：创建者权限，同组其他用户权限，其他用户权限，权限值定义在 <code>FsAction</code> 枚举类中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mkDirWithPermission</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    fileSystem.mkdirs(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/hdfs-api/test1/&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FsPermission</span>(FsAction.READ_WRITE, FsAction.READ, FsAction.READ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-创建文件，并写入内容">2.4 创建文件，并写入内容</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 如果文件存在，默认会覆盖, 可以通过第二个参数进行控制。第三个参数可以控制使用缓冲区的大小</span></span><br><span class="line">    <span class="type">FSDataOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> fileSystem.create(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/hdfs-api/test/a.txt&quot;</span>),</span><br><span class="line">                                               <span class="literal">true</span>, <span class="number">4096</span>);</span><br><span class="line">    out.write(<span class="string">&quot;hello hadoop!&quot;</span>.getBytes());</span><br><span class="line">    out.write(<span class="string">&quot;hello spark!&quot;</span>.getBytes());</span><br><span class="line">    out.write(<span class="string">&quot;hello flink!&quot;</span>.getBytes());</span><br><span class="line">    <span class="comment">// 强制将缓冲区中内容刷出</span></span><br><span class="line">    out.flush();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-判断文件是否存在">2.5 判断文件是否存在</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exist</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> fileSystem.exists(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/hdfs-api/test/a.txt&quot;</span>));</span><br><span class="line">    System.out.println(exists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-查看文件内容">2.6 查看文件内容</h3>
<p>查看小文本文件的内容，直接转换成字符串后输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readToString</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">FSDataInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> fileSystem.open(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/hdfs-api/test/a.txt&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">context</span> <span class="operator">=</span> inputStreamToString(inputStream, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    System.out.println(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>inputStreamToString</code> 是一个自定义方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把输入流转换为指定编码的字符</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputStream 输入流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> encode      指定编码类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">inputStreamToString</span><span class="params">(InputStream inputStream, String encode)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (encode == <span class="literal">null</span> || (<span class="string">&quot;&quot;</span>.equals(encode))) &#123;</span><br><span class="line">            encode = <span class="string">&quot;utf-8&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream, encode));</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> ((str = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            builder.append(str).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-7-文件重命名">2.7 文件重命名</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rename</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">oldPath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/hdfs-api/test/a.txt&quot;</span>);</span><br><span class="line">    <span class="type">Path</span> <span class="variable">newPath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/hdfs-api/test/b.txt&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> fileSystem.rename(oldPath, newPath);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-8-删除目录或文件">2.8 删除目录或文件</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  第二个参数代表是否递归删除</span></span><br><span class="line"><span class="comment">     *    +  如果 path 是一个目录且递归删除为 true, 则删除该目录及其中所有文件;</span></span><br><span class="line"><span class="comment">     *    +  如果 path 是一个目录但递归删除为 false,则会则抛出异常。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> fileSystem.delete(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/hdfs-api/test/b.txt&quot;</span>), <span class="literal">true</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-9-上传文件到HDFS">2.9 上传文件到HDFS</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFromLocalFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 如果指定的是目录，则会把目录及其中的文件都复制到指定目录下</span></span><br><span class="line">    <span class="type">Path</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;D:\\BigData-Notes\\notes\\installation&quot;</span>);</span><br><span class="line">    <span class="type">Path</span> <span class="variable">dst</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/hdfs-api/test/&quot;</span>);</span><br><span class="line">    fileSystem.copyFromLocalFile(src, dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-10-上传大文件并显示上传进度">2.10 上传大文件并显示上传进度</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFromLocalBigFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\kafka.tgz&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">float</span> <span class="variable">fileSize</span> <span class="operator">=</span> file.length();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line"></span><br><span class="line">        <span class="type">FSDataOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> fileSystem.create(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/hdfs-api/test/kafka5.tgz&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Progressable</span>() &#123;</span><br><span class="line">                  <span class="type">long</span> <span class="variable">fileCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">progress</span><span class="params">()</span> &#123;</span><br><span class="line">                     fileCount++;</span><br><span class="line">                     <span class="comment">// progress 方法每上传大约 64KB 的数据后就会被调用一次</span></span><br><span class="line">                     System.out.println(<span class="string">&quot;上传进度：&quot;</span> + (fileCount * <span class="number">64</span> * <span class="number">1024</span> / fileSize) * <span class="number">100</span> + <span class="string">&quot; %&quot;</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        IOUtils.copyBytes(in, out, <span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-11-从HDFS上下载文件">2.11 从HDFS上下载文件</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyToLocalFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/hdfs-api/test/kafka.tgz&quot;</span>);</span><br><span class="line">    <span class="type">Path</span> <span class="variable">dst</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;D:\\app\\&quot;</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 第一个参数控制下载完成后是否删除源文件,默认是 true,即删除;</span></span><br><span class="line"><span class="comment">     * 最后一个参数表示是否将 RawLocalFileSystem 用作本地文件系统;</span></span><br><span class="line"><span class="comment">     * RawLocalFileSystem 默认为 false,通常情况下可以不设置,</span></span><br><span class="line"><span class="comment">     * 但如果你在执行时候抛出 NullPointerException 异常,则代表你的文件系统与程序可能存在不兼容的情况 (window 下常见),</span></span><br><span class="line"><span class="comment">     * 此时可以将 RawLocalFileSystem 设置为 true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    fileSystem.copyToLocalFile(<span class="literal">false</span>, src, dst, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-12-查看指定目录下所有文件的信息">2.12 查看指定目录下所有文件的信息</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listFiles</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    FileStatus[] statuses = fileSystem.listStatus(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/hdfs-api&quot;</span>));</span><br><span class="line">    <span class="keyword">for</span> (FileStatus fileStatus : statuses) &#123;</span><br><span class="line">        <span class="comment">//fileStatus 的 toString 方法被重写过，直接打印可以看到所有信息</span></span><br><span class="line">        System.out.println(fileStatus.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>FileStatus</code> 中包含了文件的基本信息，比如文件路径，是否是文件夹，修改时间，访问时间，所有者，所属组，文件权限，是否是符号链接等，输出内容示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FileStatus&#123;</span><br><span class="line">path=hdfs://192.168.0.106:8020/hdfs-api/test; </span><br><span class="line">isDirectory=true; </span><br><span class="line">modification_time=1556680796191; </span><br><span class="line">access_time=0; </span><br><span class="line">owner=root; </span><br><span class="line">group=supergroup; </span><br><span class="line">permission=rwxr-xr-x; </span><br><span class="line">isSymlink=false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-13-递归查看指定目录下所有文件的信息">2.13 递归查看指定目录下所有文件的信息</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listFilesRecursive</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    RemoteIterator&lt;LocatedFileStatus&gt; files = fileSystem.listFiles(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/hbase&quot;</span>), <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">while</span> (files.hasNext()) &#123;</span><br><span class="line">        System.out.println(files.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和上面输出类似，只是多了文本大小，副本系数，块大小信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LocatedFileStatus&#123;</span><br><span class="line">path=hdfs://192.168.0.106:8020/hbase/hbase.version; </span><br><span class="line">isDirectory=false; </span><br><span class="line">length=7; </span><br><span class="line">replication=1; </span><br><span class="line">blocksize=134217728; </span><br><span class="line">modification_time=1554129052916; </span><br><span class="line">access_time=1554902661455; </span><br><span class="line">owner=root; </span><br><span class="line">group=supergroup;</span><br><span class="line">permission=rw-r--r--; </span><br><span class="line">isSymlink=false&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-14-查看文件的块信息">2.14 查看文件的块信息</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getFileBlockLocations</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">FileStatus</span> <span class="variable">fileStatus</span> <span class="operator">=</span> fileSystem.getFileStatus(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/hdfs-api/test/kafka.tgz&quot;</span>));</span><br><span class="line">    BlockLocation[] blocks = fileSystem.getFileBlockLocations(fileStatus, <span class="number">0</span>, fileStatus.getLen());</span><br><span class="line">    <span class="keyword">for</span> (BlockLocation block : blocks) &#123;</span><br><span class="line">        System.out.println(block);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>块输出信息有三个值，分别是文件的起始偏移量 (offset)，文件大小 (length)，块所在的主机名 (hosts)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0,57028557,hadoop001</span><br></pre></td></tr></table></figure>
<p>这里我上传的文件只有 57M(小于 128M)，且程序中设置了副本系数为 1，所有只有一个块信息。</p>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>HDFS常用shell命令</title>
    <url>/posts/6e6bbadb.html</url>
    <content><![CDATA[<p><strong>1. 显示当前目录结构</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">显示当前目录结构</span></span><br><span class="line">hadoop fs -ls  &lt;path&gt;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">递归显示当前目录结构</span></span><br><span class="line">hadoop fs -ls  -R  &lt;path&gt;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">显示根目录下内容</span></span><br><span class="line">hadoop fs -ls  /</span><br></pre></td></tr></table></figure>
<p><strong>2. 创建目录</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">创建目录</span></span><br><span class="line">hadoop fs -mkdir  &lt;path&gt; </span><br><span class="line"><span class="meta"># </span><span class="language-bash">递归创建目录</span></span><br><span class="line">hadoop fs -mkdir -p  &lt;path&gt;  </span><br></pre></td></tr></table></figure>
<p><strong>3. 删除操作</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">删除文件</span></span><br><span class="line">hadoop fs -rm  &lt;path&gt;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">递归删除目录和文件</span></span><br><span class="line">hadoop fs -rm -R  &lt;path&gt; </span><br></pre></td></tr></table></figure>
<p><strong>4. 从本地加载文件到 HDFS</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">二选一执行即可</span></span><br><span class="line">hadoop fs -put  [localsrc] [dst] </span><br><span class="line">hadoop fs - copyFromLocal [localsrc] [dst] </span><br></pre></td></tr></table></figure>
<p><strong>5. 从 HDFS 导出文件到本地</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">二选一执行即可</span></span><br><span class="line">hadoop fs -get  [dst] [localsrc] </span><br><span class="line">hadoop fs -copyToLocal [dst] [localsrc] </span><br></pre></td></tr></table></figure>
<p><strong>6. 查看文件内容</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">二选一执行即可</span></span><br><span class="line">hadoop fs -text  &lt;path&gt; </span><br><span class="line">hadoop fs -cat  &lt;path&gt;  </span><br></pre></td></tr></table></figure>
<p><strong>7. 显示文件的最后一千字节</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -tail  &lt;path&gt; </span><br><span class="line"><span class="meta"># </span><span class="language-bash">和Linux下一样，会持续监听文件内容变化 并显示文件的最后一千字节</span></span><br><span class="line">hadoop fs -tail -f  &lt;path&gt; </span><br></pre></td></tr></table></figure>
<p><strong>8. 拷贝文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -cp [src] [dst]</span><br></pre></td></tr></table></figure>
<p><strong>9. 移动文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -mv [src] [dst] </span><br></pre></td></tr></table></figure>
<p><strong>10. 统计当前目录下各文件大小</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>默认单位字节</p>
</li>
<li class="lvl-2">
<p>-s : 显示所有文件大小总和，</p>
</li>
<li class="lvl-2">
<p>-h : 将以更友好的方式显示文件大小（例如 64.0m 而不是 67108864）</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -du  &lt;path&gt;  </span><br></pre></td></tr></table></figure>
<p><strong>11. 合并下载多个文件</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>-nl  在每个文件的末尾添加换行符（LF）</p>
</li>
<li class="lvl-2">
<p>-skip-empty-file 跳过空文件</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -getmerge</span><br><span class="line"><span class="meta"># </span><span class="language-bash">示例 将HDFS上的hbase-policy.xml和hbase-site.xml文件合并后下载到本地的/usr/test.xml</span></span><br><span class="line">hadoop fs -getmerge -nl  /test/hbase-policy.xml /test/hbase-site.xml /usr/test.xml</span><br></pre></td></tr></table></figure>
<p><strong>12. 统计文件系统的可用空间信息</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -df -h /</span><br></pre></td></tr></table></figure>
<p><strong>13. 更改文件复制因子</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -setrep [-R] [-w] &lt;numReplicas&gt; &lt;path&gt;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>更改文件的复制因子。如果 path 是目录，则更改其下所有文件的复制因子</p>
</li>
<li class="lvl-2">
<p>-w : 请求命令是否等待复制完成</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">示例</span></span><br><span class="line">hadoop fs -setrep -w 3 /user/hadoop/dir1</span><br></pre></td></tr></table></figure>
<p><strong>14. 权限控制</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">权限控制和Linux上使用方式一致</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">变更文件或目录的所属群组。 用户必须是文件的所有者或超级用户。</span></span><br><span class="line">hadoop fs -chgrp [-R] GROUP URI [URI ...]</span><br><span class="line"><span class="meta"># </span><span class="language-bash">修改文件或目录的访问权限  用户必须是文件的所有者或超级用户。</span></span><br><span class="line">hadoop fs -chmod [-R] &lt;MODE[,MODE]... | OCTALMODE&gt; URI [URI ...]</span><br><span class="line"><span class="meta"># </span><span class="language-bash">修改文件的拥有者  用户必须是超级用户。</span></span><br><span class="line">hadoop fs -chown [-R] [OWNER][:[GROUP]] URI [URI ]</span><br></pre></td></tr></table></figure>
<p><strong>15. 文件检测</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -test - [defsz]  URI</span><br></pre></td></tr></table></figure>
<p>可选选项：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>-d：如果路径是目录，返回 0。</p>
</li>
<li class="lvl-2">
<p>-e：如果路径存在，则返回 0。</p>
</li>
<li class="lvl-2">
<p>-f：如果路径是文件，则返回 0。</p>
</li>
<li class="lvl-2">
<p>-s：如果路径不为空，则返回 0。</p>
</li>
<li class="lvl-2">
<p>-r：如果路径存在且授予读权限，则返回 0。</p>
</li>
<li class="lvl-2">
<p>-w：如果路径存在且授予写入权限，则返回 0。</p>
</li>
<li class="lvl-2">
<p>-z：如果文件长度为零，则返回 0。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">示例</span></span><br><span class="line">hadoop fs -test -e filename</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大数据组件</category>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop分布式文件系统—HDFS</title>
    <url>/posts/eb6e206b.html</url>
    <content><![CDATA[<h2 id="一、介绍">一、介绍</h2>
<p><strong>HDFS</strong> （<strong>Hadoop Distributed File System</strong>）是 Hadoop 下的分布式文件系统，具有高容错、高吞吐量等特性，可以部署在低成本的硬件上。</p>
<h2 id="二、HDFS-设计原理">二、HDFS 设计原理</h2>
<div align="center"> <img width="600px" src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hdfsarchitecture.png"/> </div>
<h3 id="2-1-HDFS-架构">2.1 HDFS 架构</h3>
<p>HDFS 遵循主/从架构，由单个 NameNode(NN) 和多个 DataNode(DN) 组成：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>NameNode</strong> : 负责执行有关 <code>文件系统命名空间</code> 的操作，例如打开，关闭、重命名文件和目录等。它同时还负责集群元数据的存储，记录着文件中各个数据块的位置信息。</p>
</li>
<li class="lvl-2">
<p><strong>DataNode</strong>：负责提供来自文件系统客户端的读写请求，执行块的创建，删除等操作。</p>
</li>
</ul>
<h3 id="2-2-文件系统命名空间">2.2 文件系统命名空间</h3>
<p>HDFS 的 <code>文件系统命名空间</code> 的层次结构与大多数文件系统类似 (如 Linux)， 支持目录和文件的创建、移动、删除和重命名等操作，支持配置用户和访问权限，但不支持硬链接和软连接。<code>NameNode</code> 负责维护文件系统名称空间，记录对名称空间或其属性的任何更改。</p>
<h3 id="2-3-数据复制">2.3 数据复制</h3>
<p>由于 Hadoop 被设计运行在廉价的机器上，这意味着硬件是不可靠的，为了保证容错性，HDFS 提供了数据复制机制。HDFS 将每一个文件存储为一系列<strong>块</strong>，每个块由多个副本来保证容错，块的大小和复制因子可以自行配置（默认情况下，块大小是 128M，默认复制因子是 3）。</p>
<div align="center"> <img width="600px" src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hdfsdatanodes.png"/> </div>
<h3 id="2-4-数据复制的实现原理">2.4 数据复制的实现原理</h3>
<p>大型的 HDFS 实例在通常分布在多个机架的多台服务器上，不同机架上的两台服务器之间通过交换机进行通讯。在大多数情况下，同一机架中的服务器间的网络带宽大于不同机架中的服务器之间的带宽。因此 HDFS 采用机架感知副本放置策略，对于常见情况，当复制因子为 3 时，HDFS 的放置策略是：</p>
<p>在写入程序位于 <code>datanode</code> 上时，就优先将写入文件的一个副本放置在该 <code>datanode</code> 上，否则放在随机 <code>datanode</code> 上。之后在另一个远程机架上的任意一个节点上放置另一个副本，并在该机架上的另一个节点上放置最后一个副本。此策略可以减少机架间的写入流量，从而提高写入性能。</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hdfs-机架.png"/> </div>
<p>如果复制因子大于 3，则随机确定第 4 个和之后副本的放置位置，同时保持每个机架的副本数量低于上限，上限值通常为 <code>（复制系数 - 1）/机架数量 + 2</code>，需要注意的是不允许同一个 <code>dataNode</code> 上具有同一个块的多个副本。</p>
<h3 id="2-5-副本的选择">2.5  副本的选择</h3>
<p>为了最大限度地减少带宽消耗和读取延迟，HDFS 在执行读取请求时，优先读取距离读取器最近的副本。如果在与读取器节点相同的机架上存在副本，则优先选择该副本。如果 HDFS 群集跨越多个数据中心，则优先选择本地数据中心上的副本。</p>
<h3 id="2-6-架构的稳定性">2.6 架构的稳定性</h3>
<h4 id="1-心跳机制和重新复制">1. 心跳机制和重新复制</h4>
<p>每个 DataNode 定期向 NameNode 发送心跳消息，如果超过指定时间没有收到心跳消息，则将 DataNode 标记为死亡。NameNode 不会将任何新的 IO 请求转发给标记为死亡的 DataNode，也不会再使用这些 DataNode 上的数据。 由于数据不再可用，可能会导致某些块的复制因子小于其指定值，NameNode 会跟踪这些块，并在必要的时候进行重新复制。</p>
<h4 id="2-数据的完整性">2. 数据的完整性</h4>
<p>由于存储设备故障等原因，存储在 DataNode 上的数据块也会发生损坏。为了避免读取到已经损坏的数据而导致错误，HDFS 提供了数据完整性校验机制来保证数据的完整性，具体操作如下：</p>
<p>当客户端创建 HDFS 文件时，它会计算文件的每个块的 <code>校验和</code>，并将 <code>校验和</code> 存储在同一 HDFS 命名空间下的单独的隐藏文件中。当客户端检索文件内容时，它会验证从每个 DataNode 接收的数据是否与存储在关联校验和文件中的 <code>校验和</code> 匹配。如果匹配失败，则证明数据已经损坏，此时客户端会选择从其他 DataNode 获取该块的其他可用副本。</p>
<h4 id="3-元数据的磁盘故障">3.元数据的磁盘故障</h4>
<p><code>FsImage</code> 和 <code>EditLog</code> 是 HDFS 的核心数据，这些数据的意外丢失可能会导致整个 HDFS 服务不可用。为了避免这个问题，可以配置 NameNode 使其支持 <code>FsImage</code> 和 <code>EditLog</code> 多副本同步，这样 <code>FsImage</code> 或 <code>EditLog</code> 的任何改变都会引起每个副本 <code>FsImage</code> 和 <code>EditLog</code> 的同步更新。</p>
<h4 id="4-支持快照">4.支持快照</h4>
<p>快照支持在特定时刻存储数据副本，在数据意外损坏时，可以通过回滚操作恢复到健康的数据状态。</p>
<h2 id="三、HDFS-的特点">三、HDFS 的特点</h2>
<h3 id="3-1-高容错">3.1 高容错</h3>
<p>由于 HDFS 采用数据的多副本方案，所以部分硬件的损坏不会导致全部数据的丢失。</p>
<h3 id="3-2-高吞吐量">3.2 高吞吐量</h3>
<p>HDFS 设计的重点是支持高吞吐量的数据访问，而不是低延迟的数据访问。</p>
<h3 id="3-3-大文件支持">3.3  大文件支持</h3>
<p>HDFS 适合于大文件的存储，文档的大小应该是是 GB 到 TB 级别的。</p>
<h3 id="3-3-简单一致性模型">3.3 简单一致性模型</h3>
<p>HDFS 更适合于一次写入多次读取 (write-once-read-many) 的访问模型。支持将内容追加到文件末尾，但不支持数据的随机访问，不能从文件任意位置新增数据。</p>
<h3 id="3-4-跨平台移植性">3.4 跨平台移植性</h3>
<p>HDFS 具有良好的跨平台移植性，这使得其他大数据计算框架都将其作为数据持久化存储的首选方案。</p>
<h2 id="附：图解HDFS存储原理">附：图解HDFS存储原理</h2>
<blockquote>
<p>说明：以下图片引用自博客：<a href="https://blog.csdn.net/hudiefenmu/article/details/37655491">翻译经典 HDFS 原理讲解漫画</a></p>
</blockquote>
<h3 id="1-HDFS写数据原理">1. HDFS写数据原理</h3>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hdfs-write-1.jpg"/> </div>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hdfs-write-2.jpg"/> </div>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hdfs-write-3.jpg"/> </div>
<h3 id="2-HDFS读数据原理">2. HDFS读数据原理</h3>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hdfs-read-1.jpg"/> </div>
<h3 id="3-HDFS故障类型和其检测方法">3. HDFS故障类型和其检测方法</h3>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hdfs-tolerance-1.jpg"/> </div>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hdfs-tolerance-2.jpg"/> </div>
<p><strong>第二部分：读写故障的处理</strong></p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hdfs-tolerance-3.jpg"/> </div>
<p><strong>第三部分：DataNode 故障处理</strong></p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hdfs-tolerance-4.jpg"/> </div>
<p><strong>副本布局策略</strong>：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hdfs-tolerance-5.jpg"/> </div>
<h2 id="参考资料-9">参考资料</h2>
<ol>
<li class="lvl-3">
<p><a href="http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html">Apache Hadoop 2.9.2 &gt; HDFS Architecture</a></p>
</li>
<li class="lvl-3">
<p>Tom White . hadoop 权威指南 [M] . 清华大学出版社 . 2017.</p>
</li>
<li class="lvl-3">
<p><a href="https://blog.csdn.net/hudiefenmu/article/details/37655491">翻译经典 HDFS 原理讲解漫画</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>hdfs</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop单机版环境搭建</title>
    <url>/posts/1ad2170e.html</url>
    <content><![CDATA[<h2 id="一、前置条件">一、前置条件</h2>
<p>Hadoop 的运行依赖 JDK，需要预先安装，安装步骤见：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://github.com/oicio/BigData-Notes/blob/master/notes/installation/Linux%E4%B8%8BJDK%E5%AE%89%E8%A3%85.md">Linux 下 JDK 的安装</a></p>
</li>
</ul>
<h2 id="二、配置免密登录">二、配置免密登录</h2>
<p>Hadoop 组件之间需要基于 SSH 进行通讯。</p>
<h4 id="2-1-配置映射">2.1 配置映射</h4>
<p>配置 ip 地址和主机名映射：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/hosts</span><br><span class="line"><span class="meta"># </span><span class="language-bash">文件末尾增加</span></span><br><span class="line">192.168.43.202  hadoop001</span><br></pre></td></tr></table></figure>
<h3 id="2-2-生成公私钥">2.2  生成公私钥</h3>
<p>执行下面命令行生成公匙和私匙：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>
<h3 id="3-3-授权">3.3 授权</h3>
<p>进入 <code>~/.ssh</code> 目录下，查看生成的公匙和私匙，并将公匙写入到授权文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@@hadoop001 sbin]#  cd ~/.ssh</span><br><span class="line">[root@@hadoop001 .ssh]# ll</span><br><span class="line">-rw-------. 1 root root 1675 3 月  15 09:48 id_rsa</span><br><span class="line">-rw-r--r--. 1 root root  388 3 月  15 09:48 id_rsa.pub</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">写入公匙到授权文件</span></span><br><span class="line">[root@hadoop001 .ssh]# cat id_rsa.pub &gt;&gt; authorized_keys</span><br><span class="line">[root@hadoop001 .ssh]# chmod 600 authorized_keys</span><br></pre></td></tr></table></figure>
<h2 id="三、Hadoop-HDFS-环境搭建">三、Hadoop(HDFS)环境搭建</h2>
<h3 id="3-1-下载并解压">3.1 下载并解压</h3>
<p>下载 Hadoop 安装包，这里我下载的是 CDH 版本的，下载地址为：<a href="http://archive.cloudera.com/cdh5/cdh/5/">http://archive.cloudera.com/cdh5/cdh/5/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">解压</span></span><br><span class="line">tar -zvxf hadoop-2.6.0-cdh5.15.2.tar.gz </span><br></pre></td></tr></table></figure>
<h3 id="3-2-配置环境变量">3.2 配置环境变量</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">vi /etc/profile</span></span><br></pre></td></tr></table></figure>
<p>配置环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export HADOOP_HOME=/usr/app/hadoop-2.6.0-cdh5.15.2</span><br><span class="line">export  PATH=$&#123;HADOOP_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>执行 <code>source</code> 命令，使得配置的环境变量立即生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">source</span> /etc/profile</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-修改Hadoop配置">3.3 修改Hadoop配置</h3>
<p>进入 <code>$&#123;HADOOP_HOME&#125;/etc/hadoop/ </code> 目录下，修改以下配置：</p>
<h4 id="1-hadoop-env-sh">1. <a href="http://hadoop-env.sh">hadoop-env.sh</a></h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">JDK安装路径</span></span><br><span class="line">export  JAVA_HOME=/usr/java/jdk1.8.0_201/</span><br></pre></td></tr></table></figure>
<h4 id="2-core-site-xml">2. core-site.xml</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定 namenode 的 hdfs 协议文件系统的通信地址--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop001:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定 hadoop 存储临时文件的目录--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/hadoop/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-hdfs-site-xml">3. hdfs-site.xml</h4>
<p>指定副本系数和临时文件存储位置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--由于我们这里搭建是单机版本，所以指定 dfs 的副本系数为 1--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="4-slaves">4. slaves</h4>
<p>配置所有从属节点的主机名或 IP 地址，由于是单机版本，所以指定本机即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop001</span><br></pre></td></tr></table></figure>
<h3 id="3-4-关闭防火墙">3.4 关闭防火墙</h3>
<p>不关闭防火墙可能导致无法访问 Hadoop 的 Web UI 界面：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">查看防火墙状态</span></span><br><span class="line">sudo firewall-cmd --state</span><br><span class="line"><span class="meta"># </span><span class="language-bash">关闭防火墙:</span></span><br><span class="line">sudo systemctl stop firewalld.service</span><br></pre></td></tr></table></figure>
<h3 id="3-5-初始化">3.5 初始化</h3>
<p>第一次启动 Hadoop 时需要进行初始化，进入 <code>$&#123;HADOOP_HOME&#125;/bin/</code> 目录下，执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop001 bin]# ./hdfs namenode -format</span><br></pre></td></tr></table></figure>
<h3 id="3-6-启动HDFS">3.6 启动HDFS</h3>
<p>进入 <code>$&#123;HADOOP_HOME&#125;/sbin/</code> 目录下，启动 HDFS：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop001 sbin]# ./start-dfs.sh</span><br></pre></td></tr></table></figure>
<h3 id="3-7-验证是否启动成功">3.7 验证是否启动成功</h3>
<p>方式一：执行 <code>jps</code> 查看 <code>NameNode</code> 和 <code>DataNode</code> 服务是否已经启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop001 hadoop-2.6.0-cdh5.15.2]# jps</span><br><span class="line">9137 DataNode</span><br><span class="line">9026 NameNode</span><br><span class="line">9390 SecondaryNameNode</span><br></pre></td></tr></table></figure>
<p>方式二：查看 Web UI 界面，端口为 <code>50070</code>：</p>
<div align="center"> <img width="700px" src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hadoop安装验证.png"/> </div>
<h2 id="四、Hadoop-YARN-环境搭建">四、Hadoop(YARN)环境搭建</h2>
<h3 id="4-1-修改配置">4.1 修改配置</h3>
<p>进入 <code>$&#123;HADOOP_HOME&#125;/etc/hadoop/ </code> 目录下，修改以下配置：</p>
<h4 id="1-mapred-site-xml">1. mapred-site.xml</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">如果没有mapred-site.xml，则拷贝一份样例文件后再修改</span></span><br><span class="line">cp mapred-site.xml.template mapred-site.xml</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-yarn-site-xml">2. yarn-site.xml</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置 NodeManager 上运行的附属服务。需要配置成 mapreduce_shuffle 后才可以在 Yarn 上运行 MapReduce 程序。--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-启动服务">4.2 启动服务</h3>
<p>进入 <code>$&#123;HADOOP_HOME&#125;/sbin/</code> 目录下，启动 YARN：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./start-yarn.sh</span><br></pre></td></tr></table></figure>
<h4 id="4-3-验证是否启动成功">4.3 验证是否启动成功</h4>
<p>方式一：执行 <code>jps</code> 命令查看 <code>NodeManager</code> 和 <code>ResourceManager</code> 服务是否已经启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop001 hadoop-2.6.0-cdh5.15.2]# jps</span><br><span class="line">9137 DataNode</span><br><span class="line">9026 NameNode</span><br><span class="line">12294 NodeManager</span><br><span class="line">12185 ResourceManager</span><br><span class="line">9390 SecondaryNameNode</span><br></pre></td></tr></table></figure>
<p>方式二：查看 Web UI 界面，端口号为 <code>8088</code>：</p>
<div align="center"> <img width="700px" src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hadoop-yarn安装验证.png"/> </div>]]></content>
      <categories>
        <category>大数据组件</category>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop集群环境搭建</title>
    <url>/posts/9daef378.html</url>
    <content><![CDATA[<h2 id="一、集群规划">一、集群规划</h2>
<p>这里搭建一个 3 节点的 Hadoop 集群，其中三台主机均部署 <code>DataNode</code> 和 <code>NodeManager</code> 服务，但只有 hadoop001 上部署 <code>NameNode</code> 和 <code>ResourceManager</code> 服务。</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hadoop集群规划.png"/> </div>
<h2 id="二、前置条件">二、前置条件</h2>
<p>Hadoop 的运行依赖 JDK，需要预先安装。其安装步骤单独整理至：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://github.com/oicio/BigData-Notes/blob/master/notes/installation/Linux%E4%B8%8BJDK%E5%AE%89%E8%A3%85.md">Linux 下 JDK 的安装</a></p>
</li>
</ul>
<h2 id="三、配置免密登录">三、配置免密登录</h2>
<h3 id="3-1-生成密匙">3.1 生成密匙</h3>
<p>在每台主机上使用 <code>ssh-keygen</code> 命令生成公钥私钥对：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>
<h3 id="3-2-免密登录">3.2 免密登录</h3>
<p>将 <code>hadoop001</code> 的公钥写到本机和远程机器的 <code> ~/ .ssh/authorized_key</code> 文件中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub hadoop001</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub hadoop002</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub hadoop003</span><br></pre></td></tr></table></figure>
<h3 id="3-3-验证免密登录">3.3 验证免密登录</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh hadoop002</span><br><span class="line">ssh hadoop003</span><br></pre></td></tr></table></figure>
<h2 id="四、集群搭建">四、集群搭建</h2>
<h3 id="3-1-下载并解压-2">3.1 下载并解压</h3>
<p>下载 Hadoop。这里我下载的是 CDH 版本 Hadoop，下载地址为：<a href="http://archive.cloudera.com/cdh5/cdh/5/">http://archive.cloudera.com/cdh5/cdh/5/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">tar -zvxf hadoop-2.6.0-cdh5.15.2.tar.gz</span> </span><br></pre></td></tr></table></figure>
<h3 id="3-2-配置环境变量-2">3.2 配置环境变量</h3>
<p>编辑 <code>profile</code> 文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">vim /etc/profile</span></span><br></pre></td></tr></table></figure>
<p>增加如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export HADOOP_HOME=/usr/app/hadoop-2.6.0-cdh5.15.2</span><br><span class="line">export  PATH=$&#123;HADOOP_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>执行 <code>source</code> 命令，使得配置立即生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">source</span> /etc/profile</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-修改配置">3.3 修改配置</h3>
<p>进入 <code>$&#123;HADOOP_HOME&#125;/etc/hadoop</code> 目录下，修改配置文件。各个配置文件内容如下：</p>
<h4 id="1-hadoop-env-sh-2">1. <a href="http://hadoop-env.sh">hadoop-env.sh</a></h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">指定JDK的安装位置</span></span><br><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_201/</span><br></pre></td></tr></table></figure>
<h4 id="2-core-site-xml-2">2.  core-site.xml</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定 namenode 的 hdfs 协议文件系统的通信地址--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop001:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定 hadoop 集群存储临时文件的目录--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/hadoop/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-hdfs-site-xml-2">3. hdfs-site.xml</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--namenode 节点数据（即元数据）的存放位置，可以指定多个目录实现容错，多个目录用逗号分隔--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/hadoop/namenode/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--datanode 节点数据（即数据块）的存放位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/hadoop/datanode/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="4-yarn-site-xml">4. yarn-site.xml</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置 NodeManager 上运行的附属服务。需要配置成 mapreduce_shuffle 后才可以在 Yarn 上运行 MapReduce 程序。--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--resourcemanager 的主机名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop001<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="5-mapred-site-xml">5.  mapred-site.xml</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定 mapreduce 作业运行在 yarn 上--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="5-slaves">5. slaves</h4>
<p>配置所有从属节点的主机名或 IP 地址，每行一个。所有从属节点上的 <code>DataNode</code> 服务和 <code>NodeManager</code> 服务都会被启动。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">hadoop001</span></span><br><span class="line"><span class="attr">hadoop002</span></span><br><span class="line"><span class="attr">hadoop003</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4-分发程序">3.4 分发程序</h3>
<p>将 Hadoop 安装包分发到其他两台服务器，分发后建议在这两台服务器上也配置一下 Hadoop 的环境变量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">将安装包分发到hadoop002</span></span><br><span class="line">scp -r /usr/app/hadoop-2.6.0-cdh5.15.2/  hadoop002:/usr/app/</span><br><span class="line"><span class="meta"># </span><span class="language-bash">将安装包分发到hadoop003</span></span><br><span class="line">scp -r /usr/app/hadoop-2.6.0-cdh5.15.2/  hadoop003:/usr/app/</span><br></pre></td></tr></table></figure>
<h3 id="3-5-初始化-2">3.5  初始化</h3>
<p>在 <code>Hadoop001</code> 上执行 namenode 初始化命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hdfs namenode -format</span><br></pre></td></tr></table></figure>
<h3 id="3-6-启动集群">3.6 启动集群</h3>
<p>进入到 <code>Hadoop001</code> 的 <code>$&#123;HADOOP_HOME&#125;/sbin</code> 目录下，启动 Hadoop。此时 <code>hadoop002</code> 和 <code>hadoop003</code> 上的相关服务也会被启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">启动dfs服务</span></span><br><span class="line">start-dfs.sh</span><br><span class="line"><span class="meta"># </span><span class="language-bash">启动yarn服务</span></span><br><span class="line">start-yarn.sh</span><br></pre></td></tr></table></figure>
<h3 id="3-7-查看集群">3.7 查看集群</h3>
<p>在每台服务器上使用 <code>jps</code> 命令查看服务进程，或直接进入 Web-UI 界面进行查看，端口为 <code>50070</code>。可以看到此时有三个可用的 <code>Datanode</code>：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hadoop-集群环境搭建.png"/> </div>
<BR/>
<p>点击 <code>Live Nodes</code> 进入，可以看到每个 <code>DataNode</code> 的详细情况：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hadoop-集群搭建2.png"/> </div>
<BR/>
<p>接着可以查看 Yarn 的情况，端口号为 <code>8088</code> ：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hadoop-集群搭建3.png"/> </div>
<h2 id="五、提交服务到集群">五、提交服务到集群</h2>
<p>提交作业到集群的方式和单机环境完全一致，这里以提交 Hadoop 内置的计算 Pi 的示例程序为例，在任何一个节点上执行都可以，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop jar /usr/app/hadoop-2.6.0-cdh5.15.2/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.6.0-cdh5.15.2.jar  pi  3  3</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hbase JAVA API使用</title>
    <url>/posts/38ae16ce.html</url>
    <content><![CDATA[<h2 id="一、简述">一、简述</h2>
<p>截至到目前 (2019.04)，HBase 有两个主要的版本，分别是 1.x 和 2.x ，两个版本的 Java API 有所不同，1.x 中某些方法在 2.x 中被标识为 <code>@deprecated</code> 过时。所以下面关于 API 的样例，我会分别给出 1.x 和 2.x 两个版本。完整的代码见本仓库：</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><a href="https://github.com/ihadyou/BigData-Notes/tree/master/code/Hbase/hbase-java-api-1.x">Java API 1.x Examples</a></p>
</li>
<li class="lvl-2">
<p><a href="https://github.com/ihadyou/BigData-Notes/tree/master/code/Hbase/hbase-java-api-2.x">Java API 2.x Examples</a></p>
</li>
</ul>
</blockquote>
<p>同时你使用的客户端的版本必须与服务端版本保持一致，如果用 2.x 版本的客户端代码去连接 1.x 版本的服务端，会抛出 <code>NoSuchColumnFamilyException</code> 等异常。</p>
<h2 id="二、Java-API-1-x-基本使用">二、Java API 1.x 基本使用</h2>
<h4 id="2-1-新建Maven工程，导入项目依赖">2.1 新建Maven工程，导入项目依赖</h4>
<p>要使用 Java API 操作 HBase，需要引入 <code>hbase-client</code>。这里选取的 <code>HBase Client</code> 的版本为 <code>1.2.0</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-API-基本使用">2.2 API 基本使用</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HBaseUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection connection;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> HBaseConfiguration.create();</span><br><span class="line">        configuration.set(<span class="string">&quot;hbase.zookeeper.property.clientPort&quot;</span>, <span class="string">&quot;2181&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果是集群 则主机名用逗号分隔</span></span><br><span class="line">        configuration.set(<span class="string">&quot;hbase.zookeeper.quorum&quot;</span>, <span class="string">&quot;hadoop001&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = ConnectionFactory.createConnection(configuration);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 HBase 表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName      表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnFamilies 列族的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">createTable</span><span class="params">(String tableName, List&lt;String&gt; columnFamilies)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">HBaseAdmin</span> <span class="variable">admin</span> <span class="operator">=</span> (HBaseAdmin) connection.getAdmin();</span><br><span class="line">            <span class="keyword">if</span> (admin.tableExists(tableName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">HTableDescriptor</span> <span class="variable">tableDescriptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HTableDescriptor</span>(TableName.valueOf(tableName));</span><br><span class="line">            columnFamilies.forEach(columnFamily -&gt; &#123;</span><br><span class="line">                <span class="type">HColumnDescriptor</span> <span class="variable">columnDescriptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HColumnDescriptor</span>(columnFamily);</span><br><span class="line">                columnDescriptor.setMaxVersions(<span class="number">1</span>);</span><br><span class="line">                tableDescriptor.addFamily(columnDescriptor);</span><br><span class="line">            &#125;);</span><br><span class="line">            admin.createTable(tableDescriptor);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除 hBase 表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName 表名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">deleteTable</span><span class="params">(String tableName)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">HBaseAdmin</span> <span class="variable">admin</span> <span class="operator">=</span> (HBaseAdmin) connection.getAdmin();</span><br><span class="line">            <span class="comment">// 删除表前需要先禁用表</span></span><br><span class="line">            admin.disableTable(tableName);</span><br><span class="line">            admin.deleteTable(tableName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName        表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey           唯一标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnFamilyName 列族名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> qualifier        列标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value            数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">putRow</span><span class="params">(String tableName, String rowKey, String columnFamilyName, String qualifier,</span></span><br><span class="line"><span class="params">                                 String value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Put</span> <span class="variable">put</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Put</span>(Bytes.toBytes(rowKey));</span><br><span class="line">            put.addColumn(Bytes.toBytes(columnFamilyName), Bytes.toBytes(qualifier), Bytes.toBytes(value));</span><br><span class="line">            table.put(put);</span><br><span class="line">            table.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName        表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey           唯一标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnFamilyName 列族名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pairList         列标识和值的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">putRow</span><span class="params">(String tableName, String rowKey, String columnFamilyName, List&lt;Pair&lt;String, String&gt;&gt; pairList)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Put</span> <span class="variable">put</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Put</span>(Bytes.toBytes(rowKey));</span><br><span class="line">            pairList.forEach(pair -&gt; put.addColumn(Bytes.toBytes(columnFamilyName), Bytes.toBytes(pair.getKey()), Bytes.toBytes(pair.getValue())));</span><br><span class="line">            table.put(put);</span><br><span class="line">            table.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 rowKey 获取指定行的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName 表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey    唯一标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">getRow</span><span class="params">(String tableName, String rowKey)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Get</span> <span class="variable">get</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Get</span>(Bytes.toBytes(rowKey));</span><br><span class="line">            <span class="keyword">return</span> table.get(get);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定行指定列 (cell) 的最新版本的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName    表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey       唯一标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnFamily 列族</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> qualifier    列标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCell</span><span class="params">(String tableName, String rowKey, String columnFamily, String qualifier)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Get</span> <span class="variable">get</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Get</span>(Bytes.toBytes(rowKey));</span><br><span class="line">            <span class="keyword">if</span> (!get.isCheckExistenceOnly()) &#123;</span><br><span class="line">                get.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(qualifier));</span><br><span class="line">                <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> table.get(get);</span><br><span class="line">                <span class="type">byte</span>[] resultValue = result.getValue(Bytes.toBytes(columnFamily), Bytes.toBytes(qualifier));</span><br><span class="line">                <span class="keyword">return</span> Bytes.toString(resultValue);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检索全表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName 表名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ResultScanner <span class="title function_">getScanner</span><span class="params">(String tableName)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Scan</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scan</span>();</span><br><span class="line">            <span class="keyword">return</span> table.getScanner(scan);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检索表中指定数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName  表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filterList 过滤器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ResultScanner <span class="title function_">getScanner</span><span class="params">(String tableName, FilterList filterList)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Scan</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scan</span>();</span><br><span class="line">            scan.setFilter(filterList);</span><br><span class="line">            <span class="keyword">return</span> table.getScanner(scan);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检索表中指定数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName   表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startRowKey 起始 RowKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endRowKey   终止 RowKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filterList  过滤器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ResultScanner <span class="title function_">getScanner</span><span class="params">(String tableName, String startRowKey, String endRowKey,</span></span><br><span class="line"><span class="params">                                           FilterList filterList)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Scan</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scan</span>();</span><br><span class="line">            scan.setStartRow(Bytes.toBytes(startRowKey));</span><br><span class="line">            scan.setStopRow(Bytes.toBytes(endRowKey));</span><br><span class="line">            scan.setFilter(filterList);</span><br><span class="line">            <span class="keyword">return</span> table.getScanner(scan);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定行记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName 表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey    唯一标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">deleteRow</span><span class="params">(String tableName, String rowKey)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Delete</span> <span class="variable">delete</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Delete</span>(Bytes.toBytes(rowKey));</span><br><span class="line">            table.delete(delete);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定行的指定列</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName  表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey     唯一标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> familyName 列族</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> qualifier  列标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">deleteColumn</span><span class="params">(String tableName, String rowKey, String familyName,</span></span><br><span class="line"><span class="params">                                          String qualifier)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Delete</span> <span class="variable">delete</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Delete</span>(Bytes.toBytes(rowKey));</span><br><span class="line">            delete.addColumn(Bytes.toBytes(familyName), Bytes.toBytes(qualifier));</span><br><span class="line">            table.delete(delete);</span><br><span class="line">            table.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-单元测试">2.3 单元测试</h3>
<p>以单元测试的方式对上面封装的 API 进行测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HBaseUtilsTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TABLE_NAME</span> <span class="operator">=</span> <span class="string">&quot;class&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TEACHER</span> <span class="operator">=</span> <span class="string">&quot;teacher&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">STUDENT</span> <span class="operator">=</span> <span class="string">&quot;student&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createTable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 新建表</span></span><br><span class="line">        List&lt;String&gt; columnFamilies = Arrays.asList(TEACHER, STUDENT);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">table</span> <span class="operator">=</span> HBaseUtils.createTable(TABLE_NAME, columnFamilies);</span><br><span class="line">        System.out.println(<span class="string">&quot;表创建结果:&quot;</span> + table);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertData</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Pair&lt;String, String&gt;&gt; pairs1 = Arrays.asList(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Tom&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;22&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;gender&quot;</span>, <span class="string">&quot;1&quot;</span>));</span><br><span class="line">        HBaseUtils.putRow(TABLE_NAME, <span class="string">&quot;rowKey1&quot;</span>, STUDENT, pairs1);</span><br><span class="line"></span><br><span class="line">        List&lt;Pair&lt;String, String&gt;&gt; pairs2 = Arrays.asList(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;33&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;gender&quot;</span>, <span class="string">&quot;2&quot;</span>));</span><br><span class="line">        HBaseUtils.putRow(TABLE_NAME, <span class="string">&quot;rowKey2&quot;</span>, STUDENT, pairs2);</span><br><span class="line"></span><br><span class="line">        List&lt;Pair&lt;String, String&gt;&gt; pairs3 = Arrays.asList(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Mike&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;44&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;gender&quot;</span>, <span class="string">&quot;1&quot;</span>));</span><br><span class="line">        HBaseUtils.putRow(TABLE_NAME, <span class="string">&quot;rowKey3&quot;</span>, STUDENT, pairs3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getRow</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> HBaseUtils.getRow(TABLE_NAME, <span class="string">&quot;rowKey1&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(Bytes</span><br><span class="line">                    .toString(result.getValue(Bytes.toBytes(STUDENT), Bytes.toBytes(<span class="string">&quot;name&quot;</span>))));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getCell</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">cell</span> <span class="operator">=</span> HBaseUtils.getCell(TABLE_NAME, <span class="string">&quot;rowKey2&quot;</span>, STUDENT, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;cell age :&quot;</span> + cell);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getScanner</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ResultScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> HBaseUtils.getScanner(TABLE_NAME);</span><br><span class="line">        <span class="keyword">if</span> (scanner != <span class="literal">null</span>) &#123;</span><br><span class="line">            scanner.forEach(result -&gt; System.out.println(Bytes.toString(result.getRow()) + <span class="string">&quot;-&gt;&quot;</span> + Bytes</span><br><span class="line">                    .toString(result.getValue(Bytes.toBytes(STUDENT), Bytes.toBytes(<span class="string">&quot;name&quot;</span>)))));</span><br><span class="line">            scanner.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getScannerWithFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">FilterList</span> <span class="variable">filterList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterList</span>(FilterList.Operator.MUST_PASS_ALL);</span><br><span class="line">        <span class="type">SingleColumnValueFilter</span> <span class="variable">nameFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleColumnValueFilter</span>(Bytes.toBytes(STUDENT),</span><br><span class="line">                Bytes.toBytes(<span class="string">&quot;name&quot;</span>), CompareOperator.EQUAL, Bytes.toBytes(<span class="string">&quot;Jack&quot;</span>));</span><br><span class="line">        filterList.addFilter(nameFilter);</span><br><span class="line">        <span class="type">ResultScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> HBaseUtils.getScanner(TABLE_NAME, filterList);</span><br><span class="line">        <span class="keyword">if</span> (scanner != <span class="literal">null</span>) &#123;</span><br><span class="line">            scanner.forEach(result -&gt; System.out.println(Bytes.toString(result.getRow()) + <span class="string">&quot;-&gt;&quot;</span> + Bytes</span><br><span class="line">                    .toString(result.getValue(Bytes.toBytes(STUDENT), Bytes.toBytes(<span class="string">&quot;name&quot;</span>)))));</span><br><span class="line">            scanner.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteColumn</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> HBaseUtils.deleteColumn(TABLE_NAME, <span class="string">&quot;rowKey2&quot;</span>, STUDENT, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除结果: &quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteRow</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> HBaseUtils.deleteRow(TABLE_NAME, <span class="string">&quot;rowKey2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除结果: &quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteTable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> HBaseUtils.deleteTable(TABLE_NAME);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除结果: &quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、Java-API-2-x-基本使用">三、Java API 2.x 基本使用</h2>
<h4 id="3-1-新建Maven工程，导入项目依赖">3.1 新建Maven工程，导入项目依赖</h4>
<p>这里选取的 <code>HBase Client</code> 的版本为最新的 <code>2.1.4</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-2-API-的基本使用">3.2 API 的基本使用</h4>
<p>2.x 版本相比于 1.x 废弃了一部分方法，关于废弃的方法在源码中都会指明新的替代方法，比如，在 2.x 中创建表时：<code>HTableDescriptor</code> 和 <code>HColumnDescriptor</code> 等类都标识为废弃，取而代之的是使用 <code>TableDescriptorBuilder</code> 和 <code>ColumnFamilyDescriptorBuilder</code> 来定义表和列族。</p>
<div align="center"> <img width="700px"  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/deprecated.png"/> </div>
<p>以下为 HBase  2.x 版本 Java API 的使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HBaseUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection connection;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> HBaseConfiguration.create();</span><br><span class="line">        configuration.set(<span class="string">&quot;hbase.zookeeper.property.clientPort&quot;</span>, <span class="string">&quot;2181&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果是集群 则主机名用逗号分隔</span></span><br><span class="line">        configuration.set(<span class="string">&quot;hbase.zookeeper.quorum&quot;</span>, <span class="string">&quot;hadoop001&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = ConnectionFactory.createConnection(configuration);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 HBase 表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName      表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnFamilies 列族的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">createTable</span><span class="params">(String tableName, List&lt;String&gt; columnFamilies)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">HBaseAdmin</span> <span class="variable">admin</span> <span class="operator">=</span> (HBaseAdmin) connection.getAdmin();</span><br><span class="line">            <span class="keyword">if</span> (admin.tableExists(TableName.valueOf(tableName))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">TableDescriptorBuilder</span> <span class="variable">tableDescriptor</span> <span class="operator">=</span> TableDescriptorBuilder.newBuilder(TableName.valueOf(tableName));</span><br><span class="line">            columnFamilies.forEach(columnFamily -&gt; &#123;</span><br><span class="line">                <span class="type">ColumnFamilyDescriptorBuilder</span> <span class="variable">cfDescriptorBuilder</span> <span class="operator">=</span> ColumnFamilyDescriptorBuilder.newBuilder(Bytes.toBytes(columnFamily));</span><br><span class="line">                cfDescriptorBuilder.setMaxVersions(<span class="number">1</span>);</span><br><span class="line">                <span class="type">ColumnFamilyDescriptor</span> <span class="variable">familyDescriptor</span> <span class="operator">=</span> cfDescriptorBuilder.build();</span><br><span class="line">                tableDescriptor.setColumnFamily(familyDescriptor);</span><br><span class="line">            &#125;);</span><br><span class="line">            admin.createTable(tableDescriptor.build());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除 hBase 表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName 表名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">deleteTable</span><span class="params">(String tableName)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">HBaseAdmin</span> <span class="variable">admin</span> <span class="operator">=</span> (HBaseAdmin) connection.getAdmin();</span><br><span class="line">            <span class="comment">// 删除表前需要先禁用表</span></span><br><span class="line">            admin.disableTable(TableName.valueOf(tableName));</span><br><span class="line">            admin.deleteTable(TableName.valueOf(tableName));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName        表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey           唯一标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnFamilyName 列族名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> qualifier        列标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value            数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">putRow</span><span class="params">(String tableName, String rowKey, String columnFamilyName, String qualifier,</span></span><br><span class="line"><span class="params">                                 String value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Put</span> <span class="variable">put</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Put</span>(Bytes.toBytes(rowKey));</span><br><span class="line">            put.addColumn(Bytes.toBytes(columnFamilyName), Bytes.toBytes(qualifier), Bytes.toBytes(value));</span><br><span class="line">            table.put(put);</span><br><span class="line">            table.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName        表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey           唯一标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnFamilyName 列族名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pairList         列标识和值的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">putRow</span><span class="params">(String tableName, String rowKey, String columnFamilyName, List&lt;Pair&lt;String, String&gt;&gt; pairList)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Put</span> <span class="variable">put</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Put</span>(Bytes.toBytes(rowKey));</span><br><span class="line">            pairList.forEach(pair -&gt; put.addColumn(Bytes.toBytes(columnFamilyName), Bytes.toBytes(pair.getKey()), Bytes.toBytes(pair.getValue())));</span><br><span class="line">            table.put(put);</span><br><span class="line">            table.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 rowKey 获取指定行的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName 表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey    唯一标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">getRow</span><span class="params">(String tableName, String rowKey)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Get</span> <span class="variable">get</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Get</span>(Bytes.toBytes(rowKey));</span><br><span class="line">            <span class="keyword">return</span> table.get(get);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定行指定列 (cell) 的最新版本的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName    表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey       唯一标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnFamily 列族</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> qualifier    列标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCell</span><span class="params">(String tableName, String rowKey, String columnFamily, String qualifier)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Get</span> <span class="variable">get</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Get</span>(Bytes.toBytes(rowKey));</span><br><span class="line">            <span class="keyword">if</span> (!get.isCheckExistenceOnly()) &#123;</span><br><span class="line">                get.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(qualifier));</span><br><span class="line">                <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> table.get(get);</span><br><span class="line">                <span class="type">byte</span>[] resultValue = result.getValue(Bytes.toBytes(columnFamily), Bytes.toBytes(qualifier));</span><br><span class="line">                <span class="keyword">return</span> Bytes.toString(resultValue);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检索全表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName 表名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ResultScanner <span class="title function_">getScanner</span><span class="params">(String tableName)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Scan</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scan</span>();</span><br><span class="line">            <span class="keyword">return</span> table.getScanner(scan);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检索表中指定数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName  表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filterList 过滤器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ResultScanner <span class="title function_">getScanner</span><span class="params">(String tableName, FilterList filterList)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Scan</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scan</span>();</span><br><span class="line">            scan.setFilter(filterList);</span><br><span class="line">            <span class="keyword">return</span> table.getScanner(scan);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检索表中指定数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName   表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startRowKey 起始 RowKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endRowKey   终止 RowKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filterList  过滤器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ResultScanner <span class="title function_">getScanner</span><span class="params">(String tableName, String startRowKey, String endRowKey,</span></span><br><span class="line"><span class="params">                                           FilterList filterList)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Scan</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scan</span>();</span><br><span class="line">            scan.withStartRow(Bytes.toBytes(startRowKey));</span><br><span class="line">            scan.withStopRow(Bytes.toBytes(endRowKey));</span><br><span class="line">            scan.setFilter(filterList);</span><br><span class="line">            <span class="keyword">return</span> table.getScanner(scan);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定行记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName 表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey    唯一标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">deleteRow</span><span class="params">(String tableName, String rowKey)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Delete</span> <span class="variable">delete</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Delete</span>(Bytes.toBytes(rowKey));</span><br><span class="line">            table.delete(delete);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定行指定列</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName  表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey     唯一标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> familyName 列族</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> qualifier  列标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">deleteColumn</span><span class="params">(String tableName, String rowKey, String familyName,</span></span><br><span class="line"><span class="params">                                          String qualifier)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Delete</span> <span class="variable">delete</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Delete</span>(Bytes.toBytes(rowKey));</span><br><span class="line">            delete.addColumn(Bytes.toBytes(familyName), Bytes.toBytes(qualifier));</span><br><span class="line">            table.delete(delete);</span><br><span class="line">            table.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、正确连接Hbase">四、正确连接Hbase</h2>
<p>在上面的代码中，在类加载时就初始化了 Connection 连接，并且之后的方法都是复用这个 Connection，这时我们可能会考虑是否可以使用自定义连接池来获取更好的性能表现？实际上这是没有必要的。</p>
<p>首先官方对于 <code>Connection</code> 的使用说明如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">Connection</span> <span class="string">Pooling For applications which require high-end multithreaded   </span></span><br><span class="line"><span class="attr">access</span> <span class="string">(e.g., web-servers or  application servers  that may serve many   </span></span><br><span class="line"><span class="attr">application</span> <span class="string">threads in a single JVM), you can pre-create a Connection,   </span></span><br><span class="line"><span class="attr">as</span> <span class="string">shown in the following example:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">对于高并发多线程访问的应用程序（例如，在单个</span> <span class="string">JVM 中存在的为多个线程服务的 Web 服务器或应用程序服务器），  </span></span><br><span class="line"><span class="attr">您只需要预先创建一个</span> <span class="string">Connection。例子如下：</span></span><br><span class="line"></span><br><span class="line"> <span class="attr">//Create</span> <span class="string">a connection to the cluster.</span></span><br><span class="line"><span class="attr">Configuration</span> <span class="string">conf = HBaseConfiguration.create();</span></span><br><span class="line"><span class="attr">try</span> <span class="string">(Connection connection = ConnectionFactory.createConnection(conf);</span></span><br><span class="line">     <span class="attr">Table</span> <span class="string">table = connection.getTable(TableName.valueOf(tablename))) &#123;</span></span><br><span class="line">   <span class="attr">//use</span> <span class="string">table as needed, the table returned is lightweight</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>
<p>之所以能这样使用，这是因为 Connection 并不是一个简单的 socket 连接，<a href="https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Connection.html">接口文档</a> 中对 Connection 的表述是：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">A</span> <span class="string">cluster connection encapsulating lower level individual connections to actual servers and a  </span></span><br><span class="line"><span class="attr">connection</span> <span class="string">to zookeeper.  Connections are instantiated through the ConnectionFactory class.  </span></span><br><span class="line"><span class="attr">The</span> <span class="string">lifecycle of the connection is managed by the caller,  who has to close() the connection   </span></span><br><span class="line"><span class="attr">to</span> <span class="string">release the resources. </span></span><br><span class="line"></span><br><span class="line"><span class="attr">Connection</span> <span class="string">是一个集群连接，封装了与多台服务器（Matser/Region Server）的底层连接以及与 zookeeper 的连接。  </span></span><br><span class="line"><span class="attr">连接通过</span> <span class="string">ConnectionFactory  类实例化。连接的生命周期由调用者管理，调用者必须使用 close() 关闭连接以释放资源。</span></span><br></pre></td></tr></table></figure>
<p>之所以封装这些连接，是因为 HBase 客户端需要连接三个不同的服务角色：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Zookeeper</strong> ：主要用于获取 <code>meta</code> 表的位置信息，Master 的信息；</p>
</li>
<li class="lvl-2">
<p><strong>HBase Master</strong> ：主要用于执行 HBaseAdmin 接口的一些操作，例如建表等；</p>
</li>
<li class="lvl-2">
<p><strong>HBase RegionServer</strong> ：用于读、写数据。</p>
</li>
</ul>
<div align="center"> <img width="700px"  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-arc.png"/> </div>
<p>Connection 对象和实际的 Socket 连接之间的对应关系如下图：</p>
<div align="center"> <img width="700px"   src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-connection.png"/> </div>
<blockquote>
<p>上面两张图片引用自博客：<a href="https://yq.aliyun.com/articles/581702?spm=a2c4e.11157919.spm-cont-list.1.146c27aeFxoMsN%20%E8%BF%9E%E6%8E%A5HBase%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF">连接 HBase 的正确姿势</a></p>
</blockquote>
<p>在 HBase 客户端代码中，真正对应 Socket 连接的是 <code>RpcConnection</code> 对象。HBase 使用 <code>PoolMap</code> 这种数据结构来存储客户端到 HBase 服务器之间的连接。<code>PoolMap</code> 的内部有一个 <code>ConcurrentHashMap</code> 实例，其 key 是 <code>ConnectionId</code>(封装了服务器地址和用户 ticket)，value 是一个 <code>RpcConnection</code> 对象的资源池。当 HBase 需要连接一个服务器时，首先会根据 <code>ConnectionId</code> 找到对应的连接池，然后从连接池中取出一个连接对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@InterfaceAudience</span>.Private</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PoolMap</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> PoolType poolType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> poolMaxSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;K, Pool&lt;V&gt;&gt; pools = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PoolMap</span><span class="params">(PoolType poolType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.poolType = poolType;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HBase 中提供了三种资源池的实现，分别是 <code>Reusable</code>，<code>RoundRobin</code> 和 <code>ThreadLocal</code>。具体实现可以通 <code>hbase.client.ipc.pool.type</code> 配置项指定，默认为 <code>Reusable</code>。连接池的大小也可以通过 <code>hbase.client.ipc.pool.size</code> 配置项指定，默认为 1，即每个 Server 1 个连接。也可以通过修改配置实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">config.set(<span class="string">&quot;hbase.client.ipc.pool.type&quot;</span>,...);</span><br><span class="line">config.set(<span class="string">&quot;hbase.client.ipc.pool.size&quot;</span>,...);</span><br><span class="line">connection = ConnectionFactory.createConnection(config);</span><br></pre></td></tr></table></figure>
<p>由此可以看出 HBase 中 Connection 类已经实现了对连接的管理功能，所以我们不必在 Connection 上在做额外的管理。</p>
<p>另外，Connection 是线程安全的，但 Table 和 Admin 却不是线程安全的，因此正确的做法是一个进程共用一个 Connection 对象，而在不同的线程中使用单独的 Table 和 Admin 对象。Table 和 Admin 的获取操作 <code>getTable()</code> 和 <code>getAdmin()</code> 都是轻量级，所以不必担心性能的消耗，同时建议在使用完成后显示的调用 <code>close()</code> 方法来关闭它们。</p>
<h2 id="参考资料-10">参考资料</h2>
<ol>
<li class="lvl-3">
<p><a href="https://yq.aliyun.com/articles/581702?spm=a2c4e.11157919.spm-cont-list.1.146c27aeFxoMsN%20%E8%BF%9E%E6%8E%A5HBase%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF">连接 HBase 的正确姿势</a></p>
</li>
<li class="lvl-3">
<p><a href="http://hbase.apache.org/book.htm">Apache HBase ™ Reference Guide</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>hbase</category>
      </categories>
      <tags>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>Hbase容灾与备份</title>
    <url>/posts/51420bb9.html</url>
    <content><![CDATA[<h2 id="一、前言">一、前言</h2>
<p>本文主要介绍 Hbase 常用的三种简单的容灾备份方案，即<strong>CopyTable</strong>、<strong>Export</strong>/<strong>Import</strong>、<strong>Snapshot</strong>。分别介绍如下：</p>
<h2 id="二、CopyTable">二、CopyTable</h2>
<h3 id="2-1-简介">2.1 简介</h3>
<p><strong>CopyTable</strong>可以将现有表的数据复制到新表中，具有以下特点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>支持时间区间 、row 区间 、改变表名称 、改变列族名称 、以及是否 Copy 已被删除的数据等功能；</p>
</li>
<li class="lvl-2">
<p>执行命令前，需先创建与原表结构相同的新表；</p>
</li>
<li class="lvl-2">
<p><code>CopyTable</code> 的操作是基于 HBase Client API 进行的，即采用 <code>scan</code> 进行查询, 采用 <code>put</code> 进行写入。</p>
</li>
</ul>
<h3 id="2-2-命令格式">2.2 命令格式</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Usage: CopyTable [general options] [--starttime=X] [--endtime=Y] [--new.name=NEW] [--peer.adr=ADR] &lt;tablename&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-常用命令">2.3 常用命令</h3>
<ol>
<li class="lvl-3">
<p>同集群下 CopyTable</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase org.apache.hadoop.hbase.mapreduce.CopyTable --new.name=tableCopy  tableOrig</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>不同集群下 CopyTable</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">两表名称相同的情况</span></span><br><span class="line">hbase org.apache.hadoop.hbase.mapreduce.CopyTable \</span><br><span class="line">--peer.adr=dstClusterZK:2181:/hbase tableOrig</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">也可以指新的表名</span></span><br><span class="line">hbase org.apache.hadoop.hbase.mapreduce.CopyTable \</span><br><span class="line">--peer.adr=dstClusterZK:2181:/hbase \</span><br><span class="line">--new.name=tableCopy tableOrig</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>下面是一个官方给的比较完整的例子，指定开始和结束时间，集群地址，以及只复制指定的列族：</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase org.apache.hadoop.hbase.mapreduce.CopyTable \</span><br><span class="line">--starttime=1265875194289 \</span><br><span class="line">--endtime=1265878794289 \</span><br><span class="line">--peer.adr=server1,server2,server3:2181:/hbase \</span><br><span class="line">--families=myOldCf:myNewCf,cf2,cf3 TestTable</span><br></pre></td></tr></table></figure>
<h3 id="2-4-更多参数">2.4 更多参数</h3>
<p>可以通过 <code>--help</code> 查看更多支持的参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">hbase org.apache.hadoop.hbase.mapreduce.CopyTable --<span class="built_in">help</span></span></span><br></pre></td></tr></table></figure>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-copy-table.png"/> </div>
<h2 id="三、Export-Import">三、Export/Import</h2>
<h3 id="3-1-简介">3.1 简介</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>Export</code> 支持导出数据到 HDFS, <code>Import</code> 支持从 HDFS 导入数据。<code>Export</code> 还支持指定导出数据的开始时间和结束时间，因此可以用于增量备份。</p>
</li>
<li class="lvl-2">
<p><code>Export</code> 导出与 <code>CopyTable</code> 一样，依赖 HBase 的 <code>scan</code> 操作</p>
</li>
</ul>
<h3 id="3-2-命令格式">3.2 命令格式</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">Export</span></span><br><span class="line">hbase org.apache.hadoop.hbase.mapreduce.Export &lt;tablename&gt; &lt;outputdir&gt; [&lt;versions&gt; [&lt;starttime&gt; [&lt;endtime&gt;]]]</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Inport</span></span><br><span class="line">hbase org.apache.hadoop.hbase.mapreduce.Import &lt;tablename&gt; &lt;inputdir&gt;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>导出的 <code>outputdir</code> 目录可以不用预先创建，程序会自动创建。导出完成后，导出文件的所有权将由执行导出命令的用户所拥有。</p>
</li>
<li class="lvl-2">
<p>默认情况下，仅导出给定 <code>Cell</code> 的最新版本，而不管历史版本。要导出多个版本，需要将 <code>&lt;versions&gt;</code> 参数替换为所需的版本数。</p>
</li>
</ul>
<h3 id="3-3-常用命令">3.3 常用命令</h3>
<ol>
<li class="lvl-3">
<p>导出命令</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase org.apache.hadoop.hbase.mapreduce.Export tableName  hdfs 路径/tableName.db</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>导入命令</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hbase org.apache.hadoop.hbase.mapreduce.Import tableName  hdfs 路径/tableName.db</span><br></pre></td></tr></table></figure>
<h2 id="四、Snapshot">四、Snapshot</h2>
<h3 id="4-1-简介">4.1 简介</h3>
<p>HBase 的快照 (Snapshot) 功能允许您获取表的副本 (包括内容和元数据)，并且性能开销很小。因为快照存储的仅仅是表的元数据和 HFiles 的信息。快照的 <code>clone</code> 操作会从该快照创建新表，快照的 <code>restore</code> 操作会将表的内容还原到快照节点。<code>clone</code> 和 <code>restore</code> 操作不需要复制任何数据，因为底层 HFiles(包含 HBase 表数据的文件) 不会被修改，修改的只是表的元数据信息。</p>
<h3 id="4-2-配置">4.2 配置</h3>
<p>HBase 快照功能默认没有开启，如果要开启快照，需要在 <code>hbase-site.xml</code> 文件中添加如下配置项：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.snapshot.enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-3-常用命令">4.3 常用命令</h3>
<p>快照的所有命令都需要在 Hbase Shell 交互式命令行中执行。</p>
<h4 id="1-Take-a-Snapshot">1. Take a Snapshot</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">拍摄快照</span></span><br><span class="line"><span class="meta">hbase&gt; </span><span class="language-bash">snapshot <span class="string">&#x27;表名&#x27;</span>, <span class="string">&#x27;快照名&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>默认情况下拍摄快照之前会在内存中执行数据刷新。以保证内存中的数据包含在快照中。但是如果你不希望包含内存中的数据，则可以使用 <code>SKIP_FLUSH</code> 选项禁止刷新。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">禁止内存刷新</span></span><br><span class="line"><span class="meta">hbase&gt; </span><span class="language-bash">snapshot  <span class="string">&#x27;表名&#x27;</span>, <span class="string">&#x27;快照名&#x27;</span>, &#123;SKIP_FLUSH =&gt; <span class="literal">true</span>&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-Listing-Snapshots">2. Listing Snapshots</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">获取快照列表</span></span><br><span class="line"><span class="meta">hbase&gt; </span><span class="language-bash">list_snapshots</span></span><br></pre></td></tr></table></figure>
<h4 id="3-Deleting-Snapshots">3. Deleting Snapshots</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">删除快照</span></span><br><span class="line"><span class="meta">hbase&gt; </span><span class="language-bash">delete_snapshot <span class="string">&#x27;快照名&#x27;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="4-Clone-a-table-from-snapshot">4. Clone a table from snapshot</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">从现有的快照创建一张新表</span></span><br><span class="line"><span class="meta">hbase&gt; </span><span class="language-bash"> clone_snapshot <span class="string">&#x27;快照名&#x27;</span>, <span class="string">&#x27;新表名&#x27;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="5-Restore-a-snapshot">5. Restore a snapshot</h4>
<p>将表恢复到快照节点，恢复操作需要先禁用表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">hbase&gt; </span><span class="language-bash"><span class="built_in">disable</span> <span class="string">&#x27;表名&#x27;</span></span></span><br><span class="line"><span class="meta">hbase&gt; </span><span class="language-bash">restore_snapshot <span class="string">&#x27;快照名&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>这里需要注意的是：是如果 HBase 配置了基于 Replication 的主从复制，由于 Replication 在日志级别工作，而快照在文件系统级别工作，因此在还原之后，会出现副本与主服务器处于不同的状态的情况。这时候可以先停止同步，所有服务器还原到一致的数据点后再重新建立同步。</p>
<h2 id="参考资料-11">参考资料</h2>
<ol>
<li class="lvl-3">
<p><a href="https://blog.cloudera.com/blog/2012/06/online-hbase-backups-with-copytable-2/">Online Apache HBase Backups with CopyTable</a></p>
</li>
<li class="lvl-3">
<p><a href="http://hbase.apache.org/book.htm">Apache HBase ™ Reference Guide</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>hbase</category>
      </categories>
      <tags>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>Hbase协处理器</title>
    <url>/posts/2e2f423b.html</url>
    <content><![CDATA[<h2 id="一、简述-2">一、简述</h2>
<p>在使用 HBase 时，如果你的数据量达到了数十亿行或数百万列，此时能否在查询中返回大量数据将受制于网络的带宽，即便网络状况允许，但是客户端的计算处理也未必能够满足要求。在这种情况下，协处理器（Coprocessors）应运而生。它允许你将业务计算代码放入在 RegionServer 的协处理器中，将处理好的数据再返回给客户端，这可以极大地降低需要传输的数据量，从而获得性能上的提升。同时协处理器也允许用户扩展实现 HBase 目前所不具备的功能，如权限校验、二级索引、完整性约束等。</p>
<h2 id="二、协处理器类型">二、协处理器类型</h2>
<h3 id="2-1-Observer协处理器">2.1 Observer协处理器</h3>
<h4 id="1-功能">1. 功能</h4>
<p>Observer 协处理器类似于关系型数据库中的触发器，当发生某些事件的时候这类协处理器会被 Server 端调用。通常可以用来实现下面功能：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>权限校验</strong>：在执行 <code>Get</code> 或 <code>Put</code> 操作之前，您可以使用 <code>preGet</code> 或 <code>prePut</code> 方法检查权限；</p>
</li>
<li class="lvl-2">
<p><strong>完整性约束</strong>： HBase 不支持关系型数据库中的外键功能，可以通过触发器在插入或者删除数据的时候，对关联的数据进行检查；</p>
</li>
<li class="lvl-2">
<p><strong>二级索引</strong>： 可以使用协处理器来维护二级索引。</p>
</li>
</ul>
<h4 id="2-类型">2. 类型</h4>
<p>当前 Observer 协处理器有以下四种类型：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>RegionObserver</strong> :<br>
允许您观察 Region 上的事件，例如 Get 和 Put 操作。</p>
</li>
<li class="lvl-2">
<p><strong>RegionServerObserver</strong> :<br>
允许您观察与 RegionServer 操作相关的事件，例如启动，停止或执行合并，提交或回滚。</p>
</li>
<li class="lvl-2">
<p><strong>MasterObserver</strong> :<br>
允许您观察与 HBase Master 相关的事件，例如表创建，删除或 schema 修改。</p>
</li>
<li class="lvl-2">
<p><strong>WalObserver</strong> :<br>
允许您观察与预写日志（WAL）相关的事件。</p>
</li>
</ul>
<h4 id="3-接口">3. 接口</h4>
<p>以上四种类型的 Observer 协处理器均继承自 <code>Coprocessor</code> 接口，这四个接口中分别定义了所有可用的钩子方法，以便在对应方法前后执行特定的操作。通常情况下，我们并不会直接实现上面接口，而是继承其 Base 实现类，Base 实现类只是简单空实现了接口中的方法，这样我们在实现自定义的协处理器时，就不必实现所有方法，只需要重写必要方法即可。</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-coprocessor.png"/> </div>
<p>这里以 <code>RegionObservers </code> 为例，其接口类中定义了所有可用的钩子方法，下面截取了部分方法的定义，多数方法都是成对出现的，有 <code>pre</code> 就有 <code>post</code>：</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/RegionObserver.png"/> </div>
<h4 id="4-执行流程">4. 执行流程</h4>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/RegionObservers-works.png"/> </div>
<ul class="lvl-0">
<li class="lvl-2">
<p>客户端发出 put 请求</p>
</li>
<li class="lvl-2">
<p>该请求被分派给合适的 RegionServer 和 region</p>
</li>
<li class="lvl-2">
<p>coprocessorHost 拦截该请求，然后在该表的每个 RegionObserver 上调用 prePut()</p>
</li>
<li class="lvl-2">
<p>如果没有被 <code>prePut()</code> 拦截，该请求继续送到 region，然后进行处理</p>
</li>
<li class="lvl-2">
<p>region 产生的结果再次被 CoprocessorHost 拦截，调用 <code>postPut()</code></p>
</li>
<li class="lvl-2">
<p>假如没有 <code>postPut()</code> 拦截该响应，最终结果被返回给客户端</p>
</li>
</ul>
<p>如果大家了解 Spring，可以将这种执行方式类比于其 AOP 的执行原理即可，官方文档当中也是这样类比的：</p>
<blockquote>
<p>If you are familiar with Aspect Oriented Programming (AOP), you can think of a coprocessor as applying advice by intercepting a request and then running some custom code,before passing the request on to its final destination (or even changing the destination).</p>
<p>如果您熟悉面向切面编程（AOP），您可以将协处理器视为通过拦截请求然后运行一些自定义代码来使用 Advice，然后将请求传递到其最终目标（或者更改目标）。</p>
</blockquote>
<h3 id="2-2-Endpoint协处理器">2.2  Endpoint协处理器</h3>
<p>Endpoint 协处理器类似于关系型数据库中的存储过程。客户端可以调用 Endpoint 协处理器在服务端对数据进行处理，然后再返回。</p>
<p>以聚集操作为例，如果没有协处理器，当用户需要找出一张表中的最大数据，即 max 聚合操作，就必须进行全表扫描，然后在客户端上遍历扫描结果，这必然会加重了客户端处理数据的压力。利用 Coprocessor，用户可以将求最大值的代码部署到 HBase Server 端，HBase 将利用底层 cluster 的多个节点并发执行求最大值的操作。即在每个 Region 范围内执行求最大值的代码，将每个 Region 的最大值在 Region Server 端计算出来，仅仅将该 max 值返回给客户端。之后客户端只需要将每个 Region 的最大值进行比较而找到其中最大的值即可。</p>
<h2 id="三、协处理的加载方式">三、协处理的加载方式</h2>
<p>要使用我们自己开发的协处理器，必须通过静态（使用 HBase 配置）或动态（使用 HBase Shell 或 Java API）加载它。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>静态加载的协处理器称之为 <strong>System Coprocessor</strong>（系统级协处理器）,作用范围是整个 HBase 上的所有表，需要重启 HBase 服务；</p>
</li>
<li class="lvl-2">
<p>动态加载的协处理器称之为 <strong>Table Coprocessor</strong>（表处理器），作用于指定的表，不需要重启 HBase 服务。</p>
</li>
</ul>
<p>其加载和卸载方式分别介绍如下。</p>
<h2 id="四、静态加载与卸载">四、静态加载与卸载</h2>
<h3 id="4-1-静态加载">4.1 静态加载</h3>
<p>静态加载分以下三步：</p>
<ol>
<li class="lvl-3">
<p>在 <code>hbase-site.xml</code> 定义需要加载的协处理器。</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.coprocessor.region.classes<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.myname.hbase.coprocessor.endpoint.SumEndPoint<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code> &lt;name&gt;</code> 标签的值必须是下面其中之一：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>RegionObservers 和 Endpoints 协处理器：<code>hbase.coprocessor.region.classes</code></p>
</li>
<li class="lvl-2">
<p>WALObservers 协处理器： <code>hbase.coprocessor.wal.classes</code></p>
</li>
<li class="lvl-2">
<p>MasterObservers 协处理器：<code>hbase.coprocessor.master.classes</code></p>
</li>
</ul>
<p><code>&lt;value&gt;</code> 必须是协处理器实现类的全限定类名。如果为加载指定了多个类，则类名必须以逗号分隔。</p>
<ol start="2">
<li class="lvl-3">
<p>将 jar(包含代码和所有依赖项) 放入 HBase 安装目录中的 <code>lib</code> 目录下；</p>
</li>
<li class="lvl-3">
<p>重启 HBase。</p>
</li>
</ol>
<h3 id="4-2-静态卸载">4.2 静态卸载</h3>
<ol>
<li class="lvl-3">
<p>从 hbase-site.xml 中删除配置的协处理器的&lt;property&gt;元素及其子元素；</p>
</li>
<li class="lvl-3">
<p>从类路径或 HBase 的 lib 目录中删除协处理器的 JAR 文件（可选）；</p>
</li>
<li class="lvl-3">
<p>重启 HBase。</p>
</li>
</ol>
<h2 id="五、动态加载与卸载">五、动态加载与卸载</h2>
<p>使用动态加载协处理器，不需要重新启动 HBase。但动态加载的协处理器是基于每个表加载的，只能用于所指定的表。此外，在使用动态加载必须使表脱机（disable）以加载协处理器。动态加载通常有两种方式：Shell 和 Java API 。</p>
<blockquote>
<p>以下示例基于两个前提：</p>
<ol>
<li class="lvl-3">coprocessor.jar 包含协处理器实现及其所有依赖项。</li>
<li class="lvl-3">JAR 包存放在 HDFS 上的路径为：hdfs：// &lt;namenode&gt;：&lt;port&gt; / user / &lt;hadoop-user&gt; /coprocessor.jar</li>
</ol>
</blockquote>
<h3 id="5-1-HBase-Shell动态加载">5.1 HBase Shell动态加载</h3>
<ol>
<li class="lvl-3">
<p>使用 HBase Shell 禁用表</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase &gt; disable &#x27;tableName&#x27;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>使用如下命令加载协处理器</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase &gt; alter &#x27;tableName&#x27;, METHOD =&gt; &#x27;table_att&#x27;, &#x27;Coprocessor&#x27;=&gt;&#x27;hdfs://&lt;namenode&gt;:&lt;port&gt;/</span><br><span class="line">user/&lt;hadoop-user&gt;/coprocessor.jar| org.myname.hbase.Coprocessor.RegionObserverExample|1073741823|</span><br><span class="line">arg1=1,arg2=2&#x27;</span><br></pre></td></tr></table></figure>
<p><code>Coprocessor</code> 包含由管道（|）字符分隔的四个参数，按顺序解释如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>JAR 包路径</strong>：通常为 JAR 包在 HDFS 上的路径。关于路径以下两点需要注意：</p>
</li>
<li class="lvl-2">
<p>允许使用通配符，例如：<code>hdfs://&lt;namenode&gt;:&lt;port&gt;/user/&lt;hadoop-user&gt;/*.jar</code> 来添加指定的 JAR 包；</p>
</li>
<li class="lvl-2">
<p>可以使指定目录，例如：<code>hdfs://&lt;namenode&gt;:&lt;port&gt;/user/&lt;hadoop-user&gt;/</code> ，这会添加目录中的所有 JAR 包，但不会搜索子目录中的 JAR 包。</p>
</li>
<li class="lvl-2">
<p><strong>类名</strong>：协处理器的完整类名。</p>
</li>
<li class="lvl-2">
<p><strong>优先级</strong>：协处理器的优先级，遵循数字的自然序，即值越小优先级越高。可以为空，在这种情况下，将分配默认优先级值。</p>
</li>
<li class="lvl-2">
<p><strong>可选参数</strong> ：传递的协处理器的可选参数。</p>
</li>
</ul>
<ol start="3">
<li class="lvl-3">
<p>启用表</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase &gt; enable &#x27;tableName&#x27;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li class="lvl-3">
<p>验证协处理器是否已加载</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase &gt; describe &#x27;tableName&#x27;</span><br></pre></td></tr></table></figure>
<p>协处理器出现在 <code>TABLE_ATTRIBUTES</code> 属性中则代表加载成功。</p>
<h3 id="5-2-HBase-Shell动态卸载">5.2 HBase Shell动态卸载</h3>
<ol>
<li class="lvl-3">
<p>禁用表</p>
</li>
</ol>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">hbase&gt; </span><span class="language-bash"><span class="built_in">disable</span> <span class="string">&#x27;tableName&#x27;</span></span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>移除表协处理器</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">hbase&gt; </span><span class="language-bash">alter <span class="string">&#x27;tableName&#x27;</span>, METHOD =&gt; <span class="string">&#x27;table_att_unset&#x27;</span>, NAME =&gt; <span class="string">&#x27;coprocessor$1&#x27;</span></span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>启用表</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">hbase&gt; </span><span class="language-bash"><span class="built_in">enable</span> <span class="string">&#x27;tableName&#x27;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="5-3-Java-API-动态加载">5.3 Java API 动态加载</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TableName</span> <span class="variable">tableName</span> <span class="operator">=</span> TableName.valueOf(<span class="string">&quot;users&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;hdfs://&lt;namenode&gt;:&lt;port&gt;/user/&lt;hadoop-user&gt;/coprocessor.jar&quot;</span>;</span><br><span class="line"><span class="type">Configuration</span> <span class="variable">conf</span> <span class="operator">=</span> HBaseConfiguration.create();</span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionFactory.createConnection(conf);</span><br><span class="line"><span class="type">Admin</span> <span class="variable">admin</span> <span class="operator">=</span> connection.getAdmin();</span><br><span class="line">admin.disableTable(tableName);</span><br><span class="line"><span class="type">HTableDescriptor</span> <span class="variable">hTableDescriptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HTableDescriptor</span>(tableName);</span><br><span class="line"><span class="type">HColumnDescriptor</span> <span class="variable">columnFamily1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HColumnDescriptor</span>(<span class="string">&quot;personalDet&quot;</span>);</span><br><span class="line">columnFamily1.setMaxVersions(<span class="number">3</span>);</span><br><span class="line">hTableDescriptor.addFamily(columnFamily1);</span><br><span class="line"><span class="type">HColumnDescriptor</span> <span class="variable">columnFamily2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HColumnDescriptor</span>(<span class="string">&quot;salaryDet&quot;</span>);</span><br><span class="line">columnFamily2.setMaxVersions(<span class="number">3</span>);</span><br><span class="line">hTableDescriptor.addFamily(columnFamily2);</span><br><span class="line">hTableDescriptor.setValue(<span class="string">&quot;COPROCESSOR$1&quot;</span>, path + <span class="string">&quot;|&quot;</span></span><br><span class="line">+ RegionObserverExample.class.getCanonicalName() + <span class="string">&quot;|&quot;</span></span><br><span class="line">+ Coprocessor.PRIORITY_USER);</span><br><span class="line">admin.modifyTable(tableName, hTableDescriptor);</span><br><span class="line">admin.enableTable(tableName);</span><br></pre></td></tr></table></figure>
<p>在 HBase 0.96 及其以后版本中，HTableDescriptor 的 addCoprocessor() 方法提供了一种更为简便的加载方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TableName</span> <span class="variable">tableName</span> <span class="operator">=</span> TableName.valueOf(<span class="string">&quot;users&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;hdfs://&lt;namenode&gt;:&lt;port&gt;/user/&lt;hadoop-user&gt;/coprocessor.jar&quot;</span>);</span><br><span class="line"><span class="type">Configuration</span> <span class="variable">conf</span> <span class="operator">=</span> HBaseConfiguration.create();</span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionFactory.createConnection(conf);</span><br><span class="line"><span class="type">Admin</span> <span class="variable">admin</span> <span class="operator">=</span> connection.getAdmin();</span><br><span class="line">admin.disableTable(tableName);</span><br><span class="line"><span class="type">HTableDescriptor</span> <span class="variable">hTableDescriptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HTableDescriptor</span>(tableName);</span><br><span class="line"><span class="type">HColumnDescriptor</span> <span class="variable">columnFamily1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HColumnDescriptor</span>(<span class="string">&quot;personalDet&quot;</span>);</span><br><span class="line">columnFamily1.setMaxVersions(<span class="number">3</span>);</span><br><span class="line">hTableDescriptor.addFamily(columnFamily1);</span><br><span class="line"><span class="type">HColumnDescriptor</span> <span class="variable">columnFamily2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HColumnDescriptor</span>(<span class="string">&quot;salaryDet&quot;</span>);</span><br><span class="line">columnFamily2.setMaxVersions(<span class="number">3</span>);</span><br><span class="line">hTableDescriptor.addFamily(columnFamily2);</span><br><span class="line">hTableDescriptor.addCoprocessor(RegionObserverExample.class.getCanonicalName(), path,</span><br><span class="line">Coprocessor.PRIORITY_USER, <span class="literal">null</span>);</span><br><span class="line">admin.modifyTable(tableName, hTableDescriptor);</span><br><span class="line">admin.enableTable(tableName);</span><br></pre></td></tr></table></figure>
<h3 id="5-4-Java-API-动态卸载">5.4 Java API 动态卸载</h3>
<p>卸载其实就是重新定义表但不设置协处理器。这会删除所有表上的协处理器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TableName</span> <span class="variable">tableName</span> <span class="operator">=</span> TableName.valueOf(<span class="string">&quot;users&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;hdfs://&lt;namenode&gt;:&lt;port&gt;/user/&lt;hadoop-user&gt;/coprocessor.jar&quot;</span>;</span><br><span class="line"><span class="type">Configuration</span> <span class="variable">conf</span> <span class="operator">=</span> HBaseConfiguration.create();</span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionFactory.createConnection(conf);</span><br><span class="line"><span class="type">Admin</span> <span class="variable">admin</span> <span class="operator">=</span> connection.getAdmin();</span><br><span class="line">admin.disableTable(tableName);</span><br><span class="line"><span class="type">HTableDescriptor</span> <span class="variable">hTableDescriptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HTableDescriptor</span>(tableName);</span><br><span class="line"><span class="type">HColumnDescriptor</span> <span class="variable">columnFamily1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HColumnDescriptor</span>(<span class="string">&quot;personalDet&quot;</span>);</span><br><span class="line">columnFamily1.setMaxVersions(<span class="number">3</span>);</span><br><span class="line">hTableDescriptor.addFamily(columnFamily1);</span><br><span class="line"><span class="type">HColumnDescriptor</span> <span class="variable">columnFamily2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HColumnDescriptor</span>(<span class="string">&quot;salaryDet&quot;</span>);</span><br><span class="line">columnFamily2.setMaxVersions(<span class="number">3</span>);</span><br><span class="line">hTableDescriptor.addFamily(columnFamily2);</span><br><span class="line">admin.modifyTable(tableName, hTableDescriptor);</span><br><span class="line">admin.enableTable(tableName);</span><br></pre></td></tr></table></figure>
<h2 id="六、协处理器案例">六、协处理器案例</h2>
<p>这里给出一个简单的案例，实现一个类似于 Redis 中 <code>append</code> 命令的协处理器，当我们对已有列执行 put 操作时候，HBase 默认执行的是 update 操作，这里我们修改为执行 append 操作。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">redis append 命令示例</span></span><br><span class="line"><span class="meta">redis&gt; </span><span class="language-bash"> EXISTS mykey</span></span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">redis&gt; </span><span class="language-bash"> APPEND mykey <span class="string">&quot;Hello&quot;</span></span></span><br><span class="line">(integer) 5</span><br><span class="line"><span class="meta">redis&gt; </span><span class="language-bash"> APPEND mykey <span class="string">&quot; World&quot;</span></span></span><br><span class="line">(integer) 11</span><br><span class="line"><span class="meta">redis&gt; </span><span class="language-bash"> GET mykey</span> </span><br><span class="line">&quot;Hello World&quot;</span><br></pre></td></tr></table></figure>
<h3 id="6-1-创建测试表">6.1 创建测试表</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">创建一张杂志表 有文章和图片两个列族</span></span><br><span class="line">hbase &gt;  create &#x27;magazine&#x27;,&#x27;article&#x27;,&#x27;picture&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-协处理器编程">6.2 协处理器编程</h3>
<blockquote>
<p>完整代码可见本仓库：<a href="https://github.com/ihadyou/BigData-Notes/tree/master/code/Hbase%5Chbase-observer-coprocessor">hbase-observer-coprocessor</a></p>
</blockquote>
<p>新建 Maven 工程，导入下面依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>继承 <code>BaseRegionObserver</code> 实现我们自定义的 <code>RegionObserver</code>,对相同的 <code>article:content</code> 执行 put 命令时，将新插入的内容添加到原有内容的末尾，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppendRegionObserver</span> <span class="keyword">extends</span> <span class="title class_">BaseRegionObserver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] columnFamily = Bytes.toBytes(<span class="string">&quot;article&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] qualifier = Bytes.toBytes(<span class="string">&quot;content&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prePut</span><span class="params">(ObserverContext&lt;RegionCoprocessorEnvironment&gt; e, Put put, WALEdit edit,</span></span><br><span class="line"><span class="params">                       Durability durability)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (put.has(columnFamily, qualifier)) &#123;</span><br><span class="line">            <span class="comment">// 遍历查询结果，获取指定列的原值</span></span><br><span class="line">            <span class="type">Result</span> <span class="variable">rs</span> <span class="operator">=</span> e.getEnvironment().getRegion().get(<span class="keyword">new</span> <span class="title class_">Get</span>(put.getRow()));</span><br><span class="line">            <span class="type">String</span> <span class="variable">oldValue</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (Cell cell : rs.rawCells())</span><br><span class="line">                <span class="keyword">if</span> (CellUtil.matchingColumn(cell, columnFamily, qualifier)) &#123;</span><br><span class="line">                    oldValue = Bytes.toString(CellUtil.cloneValue(cell));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取指定列新插入的值</span></span><br><span class="line">            List&lt;Cell&gt; cells = put.get(columnFamily, qualifier);</span><br><span class="line">            <span class="type">String</span> <span class="variable">newValue</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (Cell cell : cells) &#123;</span><br><span class="line">                <span class="keyword">if</span> (CellUtil.matchingColumn(cell, columnFamily, qualifier)) &#123;</span><br><span class="line">                    newValue = Bytes.toString(CellUtil.cloneValue(cell));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Append 操作</span></span><br><span class="line">            put.addColumn(columnFamily, qualifier, Bytes.toBytes(oldValue + newValue));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-3-打包项目">6.3 打包项目</h3>
<p>使用 maven 命令进行打包，打包后的文件名为 <code>hbase-observer-coprocessor-1.0-SNAPSHOT.jar</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">mvn clean package</span></span><br></pre></td></tr></table></figure>
<h3 id="6-4-上传JAR包到HDFS">6.4 上传JAR包到HDFS</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">上传项目到HDFS上的hbase目录</span></span><br><span class="line">hadoop fs -put /usr/app/hbase-observer-coprocessor-1.0-SNAPSHOT.jar /hbase</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看上传是否成功</span></span><br><span class="line">hadoop fs -ls /hbase</span><br></pre></td></tr></table></figure>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-cp-hdfs.png"/> </div>
<h3 id="6-5-加载协处理器">6.5 加载协处理器</h3>
<ol>
<li class="lvl-3">
<p>加载协处理器前需要先禁用表</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase &gt;  disable &#x27;magazine&#x27;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>加载协处理器</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase &gt;   alter &#x27;magazine&#x27;, METHOD =&gt; &#x27;table_att&#x27;, &#x27;Coprocessor&#x27;=&gt;&#x27;hdfs://hadoop001:8020/hbase/hbase-observer-coprocessor-1.0-SNAPSHOT.jar|com.ihadyou.AppendRegionObserver|1001|&#x27;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>启用表</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase &gt;  enable &#x27;magazine&#x27;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li class="lvl-3">
<p>查看协处理器是否加载成功</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase &gt;  desc &#x27;magazine&#x27;</span><br></pre></td></tr></table></figure>
<p>协处理器出现在 <code>TABLE_ATTRIBUTES</code> 属性中则代表加载成功，如下图：</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-cp-load.png"/> </div>
<h3 id="6-6-测试加载结果">6.6 测试加载结果</h3>
<p>插入一组测试数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase &gt; put &#x27;magazine&#x27;, &#x27;rowkey1&#x27;,&#x27;article:content&#x27;,&#x27;Hello&#x27;</span><br><span class="line">hbase &gt; get &#x27;magazine&#x27;,&#x27;rowkey1&#x27;,&#x27;article:content&#x27;</span><br><span class="line">hbase &gt; put &#x27;magazine&#x27;, &#x27;rowkey1&#x27;,&#x27;article:content&#x27;,&#x27;World&#x27;</span><br><span class="line">hbase &gt; get &#x27;magazine&#x27;,&#x27;rowkey1&#x27;,&#x27;article:content&#x27;</span><br></pre></td></tr></table></figure>
<p>可以看到对于指定列的值已经执行了 append 操作：</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-cp-helloworld.png"/> </div>
<p>插入一组对照数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase &gt; put &#x27;magazine&#x27;, &#x27;rowkey1&#x27;,&#x27;article:author&#x27;,&#x27;zhangsan&#x27;</span><br><span class="line">hbase &gt; get &#x27;magazine&#x27;,&#x27;rowkey1&#x27;,&#x27;article:author&#x27;</span><br><span class="line">hbase &gt; put &#x27;magazine&#x27;, &#x27;rowkey1&#x27;,&#x27;article:author&#x27;,&#x27;lisi&#x27;</span><br><span class="line">hbase &gt; get &#x27;magazine&#x27;,&#x27;rowkey1&#x27;,&#x27;article:author&#x27;</span><br></pre></td></tr></table></figure>
<p>可以看到对于正常的列还是执行 update 操作:</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-cp-lisi.png"/> </div>
<h3 id="6-7-卸载协处理器">6.7 卸载协处理器</h3>
<ol>
<li class="lvl-3">
<p>卸载协处理器前需要先禁用表</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase &gt;  disable &#x27;magazine&#x27;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>卸载协处理器</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase &gt; alter &#x27;magazine&#x27;, METHOD =&gt; &#x27;table_att_unset&#x27;, NAME =&gt; &#x27;coprocessor$1&#x27;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>启用表</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase &gt;  enable &#x27;magazine&#x27;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li class="lvl-3">
<p>查看协处理器是否卸载成功</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase &gt;  desc &#x27;magazine&#x27;</span><br></pre></td></tr></table></figure>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-co-unload.png"/> </div>
<h3 id="6-8-测试卸载结果">6.8 测试卸载结果</h3>
<p>依次执行下面命令可以测试卸载是否成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase &gt; get &#x27;magazine&#x27;,&#x27;rowkey1&#x27;,&#x27;article:content&#x27;</span><br><span class="line">hbase &gt; put &#x27;magazine&#x27;, &#x27;rowkey1&#x27;,&#x27;article:content&#x27;,&#x27;Hello&#x27;</span><br><span class="line">hbase &gt; get &#x27;magazine&#x27;,&#x27;rowkey1&#x27;,&#x27;article:content&#x27;</span><br></pre></td></tr></table></figure>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-unload-test.png"/> </div>
<h2 id="参考资料-12">参考资料</h2>
<ol>
<li class="lvl-3">
<p><a href="http://hbase.apache.org/book.html#cp">Apache HBase Coprocessors</a></p>
</li>
<li class="lvl-3">
<p><a href="https://blogs.apache.org/hbase/entry/coprocessor_introduction">Apache HBase Coprocessor Introduction</a></p>
</li>
<li class="lvl-3">
<p><a href="https://www.itread01.com/content/1546245908.html">HBase 高階知識</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>hbase</category>
      </categories>
      <tags>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>Hbase常用shell命令</title>
    <url>/posts/e516feb9.html</url>
    <content><![CDATA[<h2 id="一、基本命令">一、基本命令</h2>
<p>打开 Hbase Shell：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">hbase shell</span></span><br></pre></td></tr></table></figure>
<h4 id="1-1-获取帮助">1.1 获取帮助</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">获取帮助</span></span><br><span class="line">help</span><br><span class="line"><span class="meta"># </span><span class="language-bash">获取命令的详细信息</span></span><br><span class="line">help &#x27;status&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-查看服务器状态">1.2 查看服务器状态</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">status</span><br></pre></td></tr></table></figure>
<h4 id="1-3-查看版本信息">1.3 查看版本信息</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">version</span><br></pre></td></tr></table></figure>
<h2 id="二、关于表的操作">二、关于表的操作</h2>
<h4 id="2-1-查看所有表">2.1 查看所有表</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">list</span><br></pre></td></tr></table></figure>
<h4 id="2-2-创建表">2.2 创建表</h4>
<p><strong>命令格式</strong>： create ‘表名称’, ‘列族名称 1’,‘列族名称 2’,‘列名称 N’</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">创建一张名为Student的表,包含基本信息（baseInfo）、学校信息（schoolInfo）两个列族</span></span><br><span class="line">create &#x27;Student&#x27;,&#x27;baseInfo&#x27;,&#x27;schoolInfo&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-查看表的基本信息">2.3 查看表的基本信息</h4>
<p><strong>命令格式</strong>：desc ‘表名’</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">describe &#x27;Student&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-表的启用-禁用">2.4 表的启用/禁用</h4>
<p>enable 和 disable 可以启用/禁用这个表,is_enabled 和 is_disabled 来检查表是否被禁用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">禁用表</span></span><br><span class="line">disable &#x27;Student&#x27;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">检查表是否被禁用</span></span><br><span class="line">is_disabled &#x27;Student&#x27;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">启用表</span></span><br><span class="line">enable &#x27;Student&#x27;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">检查表是否被启用</span></span><br><span class="line">is_enabled &#x27;Student&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="2-5-检查表是否存在">2.5 检查表是否存在</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exists &#x27;Student&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="2-6-删除表">2.6 删除表</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">删除表前需要先禁用表</span></span><br><span class="line">disable &#x27;Student&#x27;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">删除表</span></span><br><span class="line">drop &#x27;Student&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="三、增删改">三、增删改</h2>
<h4 id="3-1-添加列族">3.1 添加列族</h4>
<p><strong>命令格式</strong>： alter ‘表名’, ‘列族名’</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alter &#x27;Student&#x27;, &#x27;teacherInfo&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-删除列族">3.2 删除列族</h4>
<p><strong>命令格式</strong>：alter ‘表名’, {NAME =&gt; ‘列族名’, METHOD =&gt; ‘delete’}</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alter &#x27;Student&#x27;, &#123;NAME =&gt; &#x27;teacherInfo&#x27;, METHOD =&gt; &#x27;delete&#x27;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-更改列族存储版本的限制">3.3 更改列族存储版本的限制</h4>
<p>默认情况下，列族只存储一个版本的数据，如果需要存储多个版本的数据，则需要修改列族的属性。修改后可通过 <code>desc</code> 命令查看。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alter &#x27;Student&#x27;,&#123;NAME=&gt;&#x27;baseInfo&#x27;,VERSIONS=&gt;3&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-4-插入数据">3.4 插入数据</h4>
<p><strong>命令格式</strong>：put ‘表名’, ‘行键’,‘列族:列’,‘值’</p>
<p><strong>注意：如果新增数据的行键值、列族名、列名与原有数据完全相同，则相当于更新操作</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">put &#x27;Student&#x27;, &#x27;rowkey1&#x27;,&#x27;baseInfo:name&#x27;,&#x27;tom&#x27;</span><br><span class="line">put &#x27;Student&#x27;, &#x27;rowkey1&#x27;,&#x27;baseInfo:birthday&#x27;,&#x27;1990-01-09&#x27;</span><br><span class="line">put &#x27;Student&#x27;, &#x27;rowkey1&#x27;,&#x27;baseInfo:age&#x27;,&#x27;29&#x27;</span><br><span class="line">put &#x27;Student&#x27;, &#x27;rowkey1&#x27;,&#x27;schoolInfo:name&#x27;,&#x27;Havard&#x27;</span><br><span class="line">put &#x27;Student&#x27;, &#x27;rowkey1&#x27;,&#x27;schoolInfo:localtion&#x27;,&#x27;Boston&#x27;</span><br><span class="line"></span><br><span class="line">put &#x27;Student&#x27;, &#x27;rowkey2&#x27;,&#x27;baseInfo:name&#x27;,&#x27;jack&#x27;</span><br><span class="line">put &#x27;Student&#x27;, &#x27;rowkey2&#x27;,&#x27;baseInfo:birthday&#x27;,&#x27;1998-08-22&#x27;</span><br><span class="line">put &#x27;Student&#x27;, &#x27;rowkey2&#x27;,&#x27;baseInfo:age&#x27;,&#x27;21&#x27;</span><br><span class="line">put &#x27;Student&#x27;, &#x27;rowkey2&#x27;,&#x27;schoolInfo:name&#x27;,&#x27;yale&#x27;</span><br><span class="line">put &#x27;Student&#x27;, &#x27;rowkey2&#x27;,&#x27;schoolInfo:localtion&#x27;,&#x27;New Haven&#x27;</span><br><span class="line"></span><br><span class="line">put &#x27;Student&#x27;, &#x27;rowkey3&#x27;,&#x27;baseInfo:name&#x27;,&#x27;maike&#x27;</span><br><span class="line">put &#x27;Student&#x27;, &#x27;rowkey3&#x27;,&#x27;baseInfo:birthday&#x27;,&#x27;1995-01-22&#x27;</span><br><span class="line">put &#x27;Student&#x27;, &#x27;rowkey3&#x27;,&#x27;baseInfo:age&#x27;,&#x27;24&#x27;</span><br><span class="line">put &#x27;Student&#x27;, &#x27;rowkey3&#x27;,&#x27;schoolInfo:name&#x27;,&#x27;yale&#x27;</span><br><span class="line">put &#x27;Student&#x27;, &#x27;rowkey3&#x27;,&#x27;schoolInfo:localtion&#x27;,&#x27;New Haven&#x27;</span><br><span class="line"></span><br><span class="line">put &#x27;Student&#x27;, &#x27;wrowkey4&#x27;,&#x27;baseInfo:name&#x27;,&#x27;maike-jack&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="3-5-获取指定行、指定行中的列族、列的信息">3.5 获取指定行、指定行中的列族、列的信息</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">获取指定行中所有列的数据信息</span></span><br><span class="line">get &#x27;Student&#x27;,&#x27;rowkey3&#x27;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">获取指定行中指定列族下所有列的数据信息</span></span><br><span class="line">get &#x27;Student&#x27;,&#x27;rowkey3&#x27;,&#x27;baseInfo&#x27;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">获取指定行中指定列的数据信息</span></span><br><span class="line">get &#x27;Student&#x27;,&#x27;rowkey3&#x27;,&#x27;baseInfo:name&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="3-6-删除指定行、指定行中的列">3.6 删除指定行、指定行中的列</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">删除指定行</span></span><br><span class="line">delete &#x27;Student&#x27;,&#x27;rowkey3&#x27;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">删除指定行中指定列的数据</span></span><br><span class="line">delete &#x27;Student&#x27;,&#x27;rowkey3&#x27;,&#x27;baseInfo:name&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="四、查询">四、查询</h2>
<p>hbase 中访问数据有两种基本的方式：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>按指定 rowkey 获取数据：get 方法；</p>
</li>
<li class="lvl-2">
<p>按指定条件获取数据：scan 方法。</p>
</li>
</ul>
<p><code>scan</code> 可以设置 begin 和 end 参数来访问一个范围内所有的数据。get 本质上就是 begin 和 end 相等的一种特殊的 scan。</p>
<h4 id="4-1Get查询">4.1Get查询</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">获取指定行中所有列的数据信息</span></span><br><span class="line">get &#x27;Student&#x27;,&#x27;rowkey3&#x27;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">获取指定行中指定列族下所有列的数据信息</span></span><br><span class="line">get &#x27;Student&#x27;,&#x27;rowkey3&#x27;,&#x27;baseInfo&#x27;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">获取指定行中指定列的数据信息</span></span><br><span class="line">get &#x27;Student&#x27;,&#x27;rowkey3&#x27;,&#x27;baseInfo:name&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-查询整表数据">4.2 查询整表数据</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scan &#x27;Student&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-查询指定列簇的数据">4.3 查询指定列簇的数据</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scan &#x27;Student&#x27;, &#123;COLUMN=&gt;&#x27;baseInfo&#x27;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-条件查询">4.4  条件查询</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">查询指定列的数据</span></span><br><span class="line">scan &#x27;Student&#x27;, &#123;COLUMNS=&gt; &#x27;baseInfo:birthday&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>除了列 <code>（COLUMNS）</code> 修饰词外，HBase 还支持 <code>Limit</code>（限制查询结果行数），<code>STARTROW</code>（<code>ROWKEY</code> 起始行，会先根据这个 <code>key</code> 定位到 <code>region</code>，再向后扫描）、<code>STOPROW</code>(结束行)、<code>TIMERANGE</code>（限定时间戳范围）、<code>VERSIONS</code>（版本数）、和 <code>FILTER</code>（按条件过滤行）等。</p>
<p>如下代表从 <code>rowkey2</code> 这个 <code>rowkey</code> 开始，查找下两个行的最新 3 个版本的 name 列的数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scan &#x27;Student&#x27;, &#123;COLUMNS=&gt; &#x27;baseInfo:name&#x27;,STARTROW =&gt; &#x27;rowkey2&#x27;,STOPROW =&gt; &#x27;wrowkey4&#x27;,LIMIT=&gt;2, VERSIONS=&gt;3&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-5-条件过滤">4.5  条件过滤</h4>
<p>Filter 可以设定一系列条件来进行过滤。如我们要查询值等于 24 的所有数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scan &#x27;Student&#x27;, FILTER=&gt;&quot;ValueFilter(=,&#x27;binary:24&#x27;)&quot;</span><br></pre></td></tr></table></figure>
<p>值包含 yale 的所有数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scan &#x27;Student&#x27;, FILTER=&gt;&quot;ValueFilter(=,&#x27;substring:yale&#x27;)&quot;</span><br></pre></td></tr></table></figure>
<p>列名中的前缀为 birth 的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scan &#x27;Student&#x27;, FILTER=&gt;&quot;ColumnPrefixFilter(&#x27;birth&#x27;)&quot;</span><br></pre></td></tr></table></figure>
<p>FILTER 中支持多个过滤条件通过括号、AND 和 OR 进行组合：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">列名中的前缀为birth且列值中包含1998的数据</span></span><br><span class="line">scan &#x27;Student&#x27;, FILTER=&gt;&quot;ColumnPrefixFilter(&#x27;birth&#x27;) AND ValueFilter ValueFilter(=,&#x27;substring:1998&#x27;)&quot;</span><br></pre></td></tr></table></figure>
<p><code>PrefixFilter</code> 用于对 Rowkey 的前缀进行判断：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scan &#x27;Student&#x27;, FILTER=&gt;&quot;PrefixFilter(&#x27;wr&#x27;)&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>hbase</category>
      </categories>
      <tags>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>Hbase环境搭建</title>
    <url>/posts/ff07428e.html</url>
    <content><![CDATA[<h2 id="一、安装前置条件说明">一、安装前置条件说明</h2>
<h3 id="1-1-JDK版本说明">1.1 JDK版本说明</h3>
<p>HBase 需要依赖 JDK 环境，同时 HBase 2.0+ 以上版本不再支持 JDK 1.7 ，需要安装 JDK 1.8+ 。JDK 安装方式见本仓库：</p>
<blockquote>
<p><a href="https://github.com/ihadyou/BigData-Notes/blob/master/notes/installation/Linux%E4%B8%8BJDK%E5%AE%89%E8%A3%85.md">Linux 环境下 JDK 安装</a></p>
</blockquote>
<h3 id="1-2-Standalone模式和伪集群模式的区别">1.2 Standalone模式和伪集群模式的区别</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>在 <code>Standalone</code> 模式下，所有守护进程都运行在一个 <code>jvm</code> 进程/实例中；</p>
</li>
<li class="lvl-2">
<p>在伪分布模式下，HBase 仍然在单个主机上运行，但是每个守护进程 (HMaster，HRegionServer 和 ZooKeeper) 则分别作为一个单独的进程运行。</p>
</li>
</ul>
<p><strong>说明：两种模式任选其一进行部署即可，对于开发测试来说区别不大。</strong></p>
<h2 id="二、Standalone-模式">二、Standalone 模式</h2>
<h3 id="2-1-下载并解压">2.1 下载并解压</h3>
<p>从<a href="https://hbase.apache.org/downloads.html">官方网站</a> 下载所需要版本的二进制安装包，并进行解压：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">tar -zxvf hbase-2.1.4-bin.tar.gz</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-配置环境变量">2.2 配置环境变量</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">vim /etc/profile</span></span><br></pre></td></tr></table></figure>
<p>添加环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HBASE_HOME=/usr/app/hbase-2.1.4</span><br><span class="line">export PATH=$HBASE_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>使得配置的环境变量生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">source</span> /etc/profile</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-进行HBase相关配置">2.3 进行HBase相关配置</h3>
<p>修改安装目录下的 <code>conf/hbase-env.sh</code>,指定 JDK 的安装路径：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">The java implementation to use.  Java 1.8+ required.</span></span><br><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_201</span><br></pre></td></tr></table></figure>
<p>修改安装目录下的 <code>conf/hbase-site.xml</code>，增加如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:///home/hbase/rootdir<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.dataDir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/zookeeper/dataDir<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.unsafe.stream.capability.enforce<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>hbase.rootdir</code>: 配置 hbase 数据的存储路径；</p>
<p><code>hbase.zookeeper.property.dataDir</code>: 配置 zookeeper 数据的存储路径；</p>
<p><code>hbase.unsafe.stream.capability.enforce</code>: 使用本地文件系统存储，不使用 HDFS 的情况下需要禁用此配置，设置为 false。</p>
<h3 id="2-4-启动HBase">2.4 启动HBase</h3>
<p>由于已经将 HBase 的 bin 目录配置到环境变量，直接使用以下命令启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">start-hbase.sh</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-验证启动是否成功">2.5 验证启动是否成功</h3>
<p>验证方式一 ：使用 <code>jps</code> 命令查看 HMaster 进程是否启动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@hadoop001 hbase-2.1.4]# jps</span><br><span class="line">16336 Jps</span><br><span class="line">15500 HMaster</span><br></pre></td></tr></table></figure>
<p>验证方式二 ：访问 HBaseWeb UI 页面，默认端口为 <code>16010</code> 。</p>
<div align="center"> <img src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-web-ui.png"/> </div>
<h2 id="三、伪集群模式安装（Pseudo-Distributed）">三、伪集群模式安装（Pseudo-Distributed）</h2>
<h3 id="3-1-Hadoop单机伪集群安装">3.1 Hadoop单机伪集群安装</h3>
<p>这里我们采用 HDFS 作为 HBase 的存储方案，需要预先安装 Hadoop。Hadoop 的安装方式单独整理至：</p>
<blockquote>
<p><a href="https://github.com/ihadyou/BigData-Notes/blob/master/notes/installation/Hadoop%E5%8D%95%E6%9C%BA%E7%89%88%E6%9C%AC%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md">Hadoop 单机伪集群搭建</a></p>
</blockquote>
<h3 id="3-2-Hbase版本选择">3.2 Hbase版本选择</h3>
<p>HBase 的版本必须要与 Hadoop 的版本兼容，不然会出现各种 Jar 包冲突。这里我 Hadoop 安装的版本为 <code>hadoop-2.6.0-cdh5.15.2</code>，为保持版本一致，选择的 HBase 版本为 <code>hbase-1.2.0-cdh5.15.2</code> 。所有软件版本如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Hadoop 版本： hadoop-2.6.0-cdh5.15.2</p>
</li>
<li class="lvl-2">
<p>HBase 版本： hbase-1.2.0-cdh5.15.2</p>
</li>
<li class="lvl-2">
<p>JDK 版本：JDK 1.8</p>
</li>
</ul>
<h3 id="3-3-软件下载解压">3.3 软件下载解压</h3>
<p>下载后进行解压，下载地址：<a href="http://archive.cloudera.com/cdh5/cdh/5/">http://archive.cloudera.com/cdh5/cdh/5/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">tar -zxvf hbase-1.2.0-cdh5.15.2.tar.gz</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4-配置环境变量">3.4 配置环境变量</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">vim /etc/profile</span></span><br></pre></td></tr></table></figure>
<p>添加环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HBASE_HOME=/usr/app/hbase-1.2.0-cdh5.15.2</span><br><span class="line">export PATH=$HBASE_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>使得配置的环境变量生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">source</span> /etc/profile</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-进行HBase相关配置">3.5 进行HBase相关配置</h3>
<p>1.修改安装目录下的 <code>conf/hbase-env.sh</code>,指定 JDK 的安装路径：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">The java implementation to use.  Java 1.7+ required.</span></span><br><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_201</span><br></pre></td></tr></table></figure>
<p>2.修改安装目录下的 <code>conf/hbase-site.xml</code>，增加如下配置 (hadoop001 为主机名)：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--指定 HBase 以分布式模式运行--&gt;</span>   </span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--指定 HBase 数据存储路径为 HDFS 上的 hbase 目录,hbase 目录不需要预先创建，程序会自动创建--&gt;</span>   </span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop001:8020/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定 zookeeper 数据的存储位置--&gt;</span>   </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.dataDir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/zookeeper/dataDir<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>3.修改安装目录下的 <code>conf/regionservers</code>，指定 region  servers 的地址，修改后其内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop001</span><br></pre></td></tr></table></figure>
<h3 id="3-6-启动">3.6 启动</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">bin/start-hbase.sh</span></span><br></pre></td></tr></table></figure>
<h3 id="3-7-验证启动是否成功">3.7 验证启动是否成功</h3>
<p>验证方式一 ：使用 <code>jps</code> 命令查看进程。其中 <code>HMaster</code>，<code>HRegionServer</code> 是 HBase 的进程，<code>HQuorumPeer</code> 是 HBase 内置的 Zookeeper 的进程，其余的为 HDFS 和 YARN 的进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop001 conf]# jps</span><br><span class="line">28688 NodeManager</span><br><span class="line">25824 GradleDaemon</span><br><span class="line">10177 Jps</span><br><span class="line">22083 HRegionServer</span><br><span class="line">20534 DataNode</span><br><span class="line">20807 SecondaryNameNode</span><br><span class="line">18744 Main</span><br><span class="line">20411 NameNode</span><br><span class="line">21851 HQuorumPeer</span><br><span class="line">28573 ResourceManager</span><br><span class="line">21933 HMaster</span><br></pre></td></tr></table></figure>
<p>验证方式二 ：访问 HBase Web UI 界面，需要注意的是 1.2 版本的 HBase 的访问端口为 <code>60010</code></p>
<div align="center"> <img src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-60010.png"/> </div>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>hbase</category>
      </categories>
      <tags>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>Hbase架构及数据结构</title>
    <url>/posts/ad906e39.html</url>
    <content><![CDATA[<h2 id="一、基本概念">一、基本概念</h2>
<p>一个典型的 Hbase Table 表如下：</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-webtable.png"/> </div>
<h3 id="1-1-Row-Key-行键">1.1 Row Key (行键)</h3>
<p><code>Row Key</code> 是用来检索记录的主键。想要访问 HBase Table 中的数据，只有以下三种方式：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>通过指定的 <code>Row Key</code> 进行访问；</p>
</li>
<li class="lvl-2">
<p>通过 Row Key 的 range 进行访问，即访问指定范围内的行；</p>
</li>
<li class="lvl-2">
<p>进行全表扫描。</p>
</li>
</ul>
<p><code>Row Key</code> 可以是任意字符串，存储时数据按照 <code>Row Key</code> 的字典序进行排序。这里需要注意以下两点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>因为字典序对 Int 排序的结果是 1,10,100,11,12,13,14,15,16,17,18,19,2,20,21,…,9,91,92,93,94,95,96,97,98,99。如果你使用整型的字符串作为行键，那么为了保持整型的自然序，行键必须用 0 作左填充。</p>
</li>
<li class="lvl-2">
<p>行的一次读写操作时原子性的 (不论一次读写多少列)。</p>
</li>
</ul>
<h3 id="1-2-Column-Family（列族）">1.2 Column Family（列族）</h3>
<p>HBase 表中的每个列，都归属于某个列族。列族是表的 Schema 的一部分，所以列族需要在创建表时进行定义。列族的所有列都以列族名作为前缀，例如 <code>courses:history</code>，<code>courses:math</code> 都属于 <code>courses</code> 这个列族。</p>
<h3 id="1-3-Column-Qualifier-列限定符">1.3 Column Qualifier (列限定符)</h3>
<p>列限定符，你可以理解为是具体的列名，例如 <code>courses:history</code>，<code>courses:math</code> 都属于 <code>courses</code> 这个列族，它们的列限定符分别是 <code>history</code> 和 <code>math</code>。需要注意的是列限定符不是表 Schema 的一部分，你可以在插入数据的过程中动态创建列。</p>
<h3 id="1-4-Column-列">1.4 Column(列)</h3>
<p>HBase 中的列由列族和列限定符组成，它们由 <code>:</code>(冒号) 进行分隔，即一个完整的列名应该表述为 <code>列族名 ：列限定符</code>。</p>
<h3 id="1-5-Cell">1.5 Cell</h3>
<p><code>Cell</code> 是行，列族和列限定符的组合，并包含值和时间戳。你可以等价理解为关系型数据库中由指定行和指定列确定的一个单元格，但不同的是 HBase 中的一个单元格是由多个版本的数据组成的，每个版本的数据用时间戳进行区分。</p>
<h3 id="1-6-Timestamp-时间戳">1.6 Timestamp(时间戳)</h3>
<p>HBase 中通过 <code>row key</code> 和 <code>column</code> 确定的为一个存储单元称为 <code>Cell</code>。每个 <code>Cell</code> 都保存着同一份数据的多个版本。版本通过时间戳来索引，时间戳的类型是 64 位整型，时间戳可以由 HBase 在数据写入时自动赋值，也可以由客户显式指定。每个 <code>Cell</code> 中，不同版本的数据按照时间戳倒序排列，即最新的数据排在最前面。</p>
<h2 id="二、存储结构">二、存储结构</h2>
<h3 id="2-1-Regions">2.1 Regions</h3>
<p>HBase Table 中的所有行按照 <code>Row Key</code> 的字典序排列。HBase Tables 通过行键的范围 (row key range) 被水平切分成多个 <code>Region</code>, 一个 <code>Region</code> 包含了在 start key 和 end key 之间的所有行。</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/HBaseArchitecture-Blog-Fig2.png"/> </div>
<p>每个表一开始只有一个 <code>Region</code>，随着数据不断增加，<code>Region</code> 会不断增大，当增大到一个阀值的时候，<code>Region</code> 就会等分为两个新的 <code>Region</code>。当 Table 中的行不断增多，就会有越来越多的 <code>Region</code>。</p>
<div align="center"> <img width="600px" src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-region-splite.png"/> </div>
<p><code>Region</code> 是 HBase 中<strong>分布式存储和负载均衡的最小单元</strong>。这意味着不同的 <code>Region</code> 可以分布在不同的 <code>Region Server</code> 上。但一个 <code>Region</code> 是不会拆分到多个 Server 上的。</p>
<div align="center"> <img width="600px" src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-region-dis.png"/> </div>
<h3 id="2-2-Region-Server">2.2 Region Server</h3>
<p><code>Region Server</code> 运行在 HDFS 的 DataNode 上。它具有以下组件：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>WAL(Write Ahead Log，预写日志)</strong>：用于存储尚未进持久化存储的数据记录，以便在发生故障时进行恢复。</p>
</li>
<li class="lvl-2">
<p><strong>BlockCache</strong>：读缓存。它将频繁读取的数据存储在内存中，如果存储不足，它将按照 <code>最近最少使用原则</code> 清除多余的数据。</p>
</li>
<li class="lvl-2">
<p><strong>MemStore</strong>：写缓存。它存储尚未写入磁盘的新数据，并会在数据写入磁盘之前对其进行排序。每个 Region 上的每个列族都有一个 MemStore。</p>
</li>
<li class="lvl-2">
<p><strong>HFile</strong> ：将行数据按照 Key\Values 的形式存储在文件系统上。</p>
</li>
</ul>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-Region-Server.png"/> </div>
<p>Region Server 存取一个子表时，会创建一个 Region 对象，然后对表的每个列族创建一个 <code>Store</code> 实例，每个 <code>Store</code> 会有 0 个或多个 <code>StoreFile</code> 与之对应，每个 <code>StoreFile</code> 则对应一个 <code>HFile</code>，HFile 就是实际存储在 HDFS 上的文件。</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-hadoop.png"/> </div>
<h2 id="三、Hbase系统架构">三、Hbase系统架构</h2>
<h3 id="3-1-系统架构">3.1 系统架构</h3>
<p>HBase 系统遵循 Master/Salve 架构，由三种不同类型的组件组成：</p>
<p><strong>Zookeeper</strong></p>
<ol>
<li class="lvl-3">
<p>保证任何时候，集群中只有一个 Master；</p>
</li>
<li class="lvl-3">
<p>存贮所有 Region 的寻址入口；</p>
</li>
<li class="lvl-3">
<p>实时监控 Region Server 的状态，将 Region Server 的上线和下线信息实时通知给 Master；</p>
</li>
<li class="lvl-3">
<p>存储 HBase 的 Schema，包括有哪些 Table，每个 Table 有哪些 Column Family 等信息。</p>
</li>
</ol>
<p><strong>Master</strong></p>
<ol>
<li class="lvl-3">
<p>为 Region Server 分配 Region ；</p>
</li>
<li class="lvl-3">
<p>负责 Region Server 的负载均衡 ；</p>
</li>
<li class="lvl-3">
<p>发现失效的 Region Server 并重新分配其上的 Region；</p>
</li>
<li class="lvl-3">
<p>GFS 上的垃圾文件回收；</p>
</li>
<li class="lvl-3">
<p>处理 Schema 的更新请求。</p>
</li>
</ol>
<p><strong>Region Server</strong></p>
<ol>
<li class="lvl-3">
<p>Region Server 负责维护 Master 分配给它的 Region ，并处理发送到 Region 上的 IO 请求；</p>
</li>
<li class="lvl-3">
<p>Region Server 负责切分在运行过程中变得过大的 Region。</p>
</li>
</ol>
<div align="center"> <img width="600px" src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/HBaseArchitecture-Blog-Fig1.png"/> </div>
<h3 id="3-2-组件间的协作">3.2 组件间的协作</h3>
<p>HBase 使用 ZooKeeper 作为分布式协调服务来维护集群中的服务器状态。 Zookeeper 负责维护可用服务列表，并提供服务故障通知等服务：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>每个 Region Server 都会在 ZooKeeper 上创建一个临时节点，Master 通过 Zookeeper 的 Watcher 机制对节点进行监控，从而可以发现新加入的 Region Server 或故障退出的 Region Server；</p>
</li>
<li class="lvl-2">
<p>所有 Masters 会竞争性地在 Zookeeper 上创建同一个临时节点，由于 Zookeeper 只能有一个同名节点，所以必然只有一个 Master 能够创建成功，此时该 Master 就是主 Master，主 Master 会定期向 Zookeeper 发送心跳。备用 Masters 则通过 Watcher 机制对主 HMaster 所在节点进行监听；</p>
</li>
<li class="lvl-2">
<p>如果主 Master 未能定时发送心跳，则其持有的 Zookeeper 会话会过期，相应的临时节点也会被删除，这会触发定义在该节点上的 Watcher 事件，使得备用的 Master Servers 得到通知。所有备用的 Master Servers 在接到通知后，会再次去竞争性地创建临时节点，完成主 Master 的选举。</p>
</li>
</ul>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/HBaseArchitecture-Blog-Fig5.png"/> </div>
<h2 id="四、数据的读写流程简述">四、数据的读写流程简述</h2>
<h3 id="4-1-写入数据的流程">4.1 写入数据的流程</h3>
<ol>
<li class="lvl-3">
<p>Client 向 Region Server 提交写请求；</p>
</li>
<li class="lvl-3">
<p>Region Server 找到目标 Region；</p>
</li>
<li class="lvl-3">
<p>Region 检查数据是否与 Schema 一致；</p>
</li>
<li class="lvl-3">
<p>如果客户端没有指定版本，则获取当前系统时间作为数据版本；</p>
</li>
<li class="lvl-3">
<p>将更新写入 WAL Log；</p>
</li>
<li class="lvl-3">
<p>将更新写入 Memstore；</p>
</li>
<li class="lvl-3">
<p>判断 Memstore 存储是否已满，如果存储已满则需要 flush 为 Store Hfile 文件。</p>
</li>
</ol>
<blockquote>
<p>更为详细写入流程可以参考：<a href="http://hbasefly.com/2016/03/23/hbase_writer/">HBase － 数据写入流程解析</a></p>
</blockquote>
<h3 id="4-2-读取数据的流程">4.2 读取数据的流程</h3>
<p>以下是客户端首次读写 HBase 上数据的流程：</p>
<ol>
<li class="lvl-3">
<p>客户端从 Zookeeper 获取 <code>META</code> 表所在的 Region Server；</p>
</li>
<li class="lvl-3">
<p>客户端访问 <code>META</code> 表所在的 Region Server，从 <code>META</code> 表中查询到访问行键所在的 Region Server，之后客户端将缓存这些信息以及 <code>META</code> 表的位置；</p>
</li>
<li class="lvl-3">
<p>客户端从行键所在的 Region Server 上获取数据。</p>
</li>
</ol>
<p>如果再次读取，客户端将从缓存中获取行键所在的 Region Server。这样客户端就不需要再次查询 <code>META</code> 表，除非 Region 移动导致缓存失效，这样的话，则将会重新查询并更新缓存。</p>
<p>注：<code>META</code> 表是 HBase 中一张特殊的表，它保存了所有 Region 的位置信息，META 表自己的位置信息则存储在 ZooKeeper 上。</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/HBaseArchitecture-Blog-Fig7.png"/> </div>
<blockquote>
<p>更为详细读取数据流程参考：</p>
<p><a href="http://hbasefly.com/2016/12/21/hbase-getorscan/">HBase 原理－数据读取流程解析</a></p>
<p><a href="http://hbasefly.com/2017/06/11/hbase-scan-2/">HBase 原理－迟到的‘数据读取流程部分细节</a></p>
</blockquote>
<h2 id="参考资料-13">参考资料</h2>
<p>本篇文章内容主要参考自官方文档和以下两篇博客，图片也主要引用自以下两篇博客：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://mapr.com/blog/in-depth-look-hbase-architecture/#.VdMxvWSqqko">HBase Architectural Components</a></p>
</li>
<li class="lvl-2">
<p><a href="https://www.open-open.com/lib/view/open1346821084631.html">Hbase 系统架构及数据结构</a></p>
</li>
</ul>
<p>官方文档：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://hbase.apache.org/2.1/book.html">Apache HBase ™ Reference Guide</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>hbase</category>
      </categories>
      <tags>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>Hbase的SQL中间层—Phoenix</title>
    <url>/posts/1618daf0.html</url>
    <content><![CDATA[<h2 id="一、Phoenix简介">一、Phoenix简介</h2>
<p><code>Phoenix</code> 是 HBase 的开源 SQL 中间层，它允许你使用标准 JDBC 的方式来操作 HBase 上的数据。在 <code>Phoenix</code> 之前，如果你要访问 HBase，只能调用它的 Java API，但相比于使用一行 SQL 就能实现数据查询，HBase 的 API 还是过于复杂。<code>Phoenix</code> 的理念是 <code>we put sql SQL back in NOSQL</code>，即你可以使用标准的 SQL 就能完成对 HBase 上数据的操作。同时这也意味着你可以通过集成 <code>Spring Data  JPA</code> 或 <code>Mybatis</code> 等常用的持久层框架来操作 HBase。</p>
<p>其次 <code>Phoenix</code> 的性能表现也非常优异，<code>Phoenix</code> 查询引擎会将 SQL 查询转换为一个或多个 HBase Scan，通过并行执行来生成标准的 JDBC 结果集。它通过直接使用 HBase API 以及协处理器和自定义过滤器，可以为小型数据查询提供毫秒级的性能，为千万行数据的查询提供秒级的性能。同时 Phoenix 还拥有二级索引等 HBase 不具备的特性，因为以上的优点，所以 <code>Phoenix</code> 成为了 HBase 最优秀的 SQL 中间层。</p>
<div align="center"> <img width="600px"  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/Phoenix-hadoop.png"/> </div>
<h2 id="二、Phoenix安装">二、Phoenix安装</h2>
<blockquote>
<p>我们可以按照官方安装说明进行安装，官方说明如下：</p>
<ul class="lvl-1">
<li class="lvl-2">download and expand our installation tar</li>
<li class="lvl-2">copy the phoenix server jar that is compatible with your HBase installation into the lib directory of every region server</li>
<li class="lvl-2">restart the region servers</li>
<li class="lvl-2">add the phoenix client jar to the classpath of your HBase client</li>
<li class="lvl-2">download and setup SQuirrel as your SQL client so you can issue adhoc SQL against your HBase cluster</li>
</ul>
</blockquote>
<h3 id="2-1-下载并解压-2">2.1 下载并解压</h3>
<p>官方针对 Apache 版本和 CDH 版本的 HBase 均提供了安装包，按需下载即可。官方下载地址: <a href="http://phoenix.apache.org/download.html">http://phoenix.apache.org/download.html</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">下载</span></span><br><span class="line">wget http://mirror.bit.edu.cn/apache/phoenix/apache-phoenix-4.14.0-cdh5.14.2/bin/apache-phoenix-4.14.0-cdh5.14.2-bin.tar.gz</span><br><span class="line"><span class="meta"># </span><span class="language-bash">解压</span></span><br><span class="line">tar tar apache-phoenix-4.14.0-cdh5.14.2-bin.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="2-2-拷贝Jar包">2.2 拷贝Jar包</h3>
<p>按照官方文档的说明，需要将 <code>phoenix server jar</code> 添加到所有 <code>Region Servers</code> 的安装目录的 <code>lib</code> 目录下。</p>
<p>这里由于我搭建的是 HBase 伪集群，所以只需要拷贝到当前机器的 HBase 的 lib 目录下。如果是真实集群，则使用 scp 命令分发到所有 <code>Region Servers</code> 机器上。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /usr/app/apache-phoenix-4.14.0-cdh5.14.2-bin/phoenix-4.14.0-cdh5.14.2-server.jar /usr/app/hbase-1.2.0-cdh5.15.2/lib</span><br></pre></td></tr></table></figure>
<h3 id="2-3-重启-Region-Servers">2.3 重启 Region Servers</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">停止Hbase</span></span><br><span class="line">stop-hbase.sh</span><br><span class="line"><span class="meta"># </span><span class="language-bash">启动Hbase</span></span><br><span class="line">start-hbase.sh</span><br></pre></td></tr></table></figure>
<h3 id="2-4-启动Phoenix">2.4 启动Phoenix</h3>
<p>在 Phoenix 解压目录下的 <code>bin</code> 目录下执行如下命令，需要指定 Zookeeper 的地址：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果 HBase 采用 Standalone 模式或者伪集群模式搭建，则默认采用内置的 Zookeeper 服务，端口为 2181；</p>
</li>
<li class="lvl-2">
<p>如果是 HBase 是集群模式并采用外置的 Zookeeper 集群，则按照自己的实际情况进行指定。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">./sqlline.py hadoop001:2181</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-启动结果">2.5 启动结果</h3>
<p>启动后则进入了 Phoenix 交互式 SQL 命令行，可以使用 <code>!table</code> 或 <code>!tables</code> 查看当前所有表的信息</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/phoenix-shell.png"/> </div>
<h2 id="三、Phoenix-简单使用">三、Phoenix 简单使用</h2>
<h3 id="3-1-创建表">3.1 创建表</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> us_population (</span><br><span class="line">      state <span class="type">CHAR</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">      city <span class="type">VARCHAR</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">      population <span class="type">BIGINT</span></span><br><span class="line">      <span class="keyword">CONSTRAINT</span> my_pk <span class="keyword">PRIMARY</span> KEY (state, city));</span><br></pre></td></tr></table></figure>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/Phoenix-create-table.png"/> </div>
新建的表会按照特定的规则转换为 HBase 上的表，关于表的信息，可以通过 Hbase Web UI 进行查看：
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-web-ui-phoenix.png"/> </div>
### 3.2 插入数据
<p>Phoenix 中插入数据采用的是 <code>UPSERT</code> 而不是 <code>INSERT</code>,因为 Phoenix 并没有更新操作，插入相同主键的数据就视为更新，所以 <code>UPSERT</code> 就相当于 <code>UPDATE</code>+<code>INSERT</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">UPSERT INTO us_population VALUES(&#x27;NY&#x27;,&#x27;New York&#x27;,8143197);</span><br><span class="line">UPSERT INTO us_population VALUES(&#x27;CA&#x27;,&#x27;Los Angeles&#x27;,3844829);</span><br><span class="line">UPSERT INTO us_population VALUES(&#x27;IL&#x27;,&#x27;Chicago&#x27;,2842518);</span><br><span class="line">UPSERT INTO us_population VALUES(&#x27;TX&#x27;,&#x27;Houston&#x27;,2016582);</span><br><span class="line">UPSERT INTO us_population VALUES(&#x27;PA&#x27;,&#x27;Philadelphia&#x27;,1463281);</span><br><span class="line">UPSERT INTO us_population VALUES(&#x27;AZ&#x27;,&#x27;Phoenix&#x27;,1461575);</span><br><span class="line">UPSERT INTO us_population VALUES(&#x27;TX&#x27;,&#x27;San Antonio&#x27;,1256509);</span><br><span class="line">UPSERT INTO us_population VALUES(&#x27;CA&#x27;,&#x27;San Diego&#x27;,1255540);</span><br><span class="line">UPSERT INTO us_population VALUES(&#x27;TX&#x27;,&#x27;Dallas&#x27;,1213825);</span><br><span class="line">UPSERT INTO us_population VALUES(&#x27;CA&#x27;,&#x27;San Jose&#x27;,912332);</span><br></pre></td></tr></table></figure>
<h3 id="3-3-修改数据">3.3 修改数据</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 插入主键相同的数据就视为更新</span></span><br><span class="line">UPSERT <span class="keyword">INTO</span> us_population <span class="keyword">VALUES</span>(<span class="string">&#x27;NY&#x27;</span>,<span class="string">&#x27;New York&#x27;</span>,<span class="number">999999</span>);</span><br></pre></td></tr></table></figure>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/Phoenix-update.png"/> </div>
### 3.4 删除数据
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> us_population <span class="keyword">WHERE</span> city<span class="operator">=</span><span class="string">&#x27;Dallas&#x27;</span>;</span><br></pre></td></tr></table></figure>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/Phoenix-delete.png"/> </div>
### 3.5 查询数据
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> state <span class="keyword">as</span> &quot;州&quot;,<span class="built_in">count</span>(city) <span class="keyword">as</span> &quot;市&quot;,<span class="built_in">sum</span>(population) <span class="keyword">as</span> &quot;热度&quot;</span><br><span class="line"><span class="keyword">FROM</span> us_population</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> state</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">sum</span>(population) <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/Phoenix-select.png"/> </div>
<h3 id="3-6-退出命令">3.6 退出命令</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">!</span>quit</span><br></pre></td></tr></table></figure>
<h3 id="3-7-扩展">3.7 扩展</h3>
<p>从上面的操作中可以看出，Phoenix 支持大多数标准的 SQL 语法。关于 Phoenix 支持的语法、数据类型、函数、序列等详细信息，因为涉及内容很多，可以参考其官方文档，官方文档上有详细的说明：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>语法 (Grammar)</strong> ：<a href="https://phoenix.apache.org/language/index.html">https://phoenix.apache.org/language/index.html</a></p>
</li>
<li class="lvl-2">
<p><strong>函数 (Functions)</strong> ：<a href="http://phoenix.apache.org/language/functions.html">http://phoenix.apache.org/language/functions.html</a></p>
</li>
<li class="lvl-2">
<p><strong>数据类型 (Datatypes)</strong> ：<a href="http://phoenix.apache.org/language/datatypes.html">http://phoenix.apache.org/language/datatypes.html</a></p>
</li>
<li class="lvl-2">
<p><strong>序列 (Sequences)</strong> :<a href="http://phoenix.apache.org/sequences.html">http://phoenix.apache.org/sequences.html</a></p>
</li>
<li class="lvl-2">
<p><strong>联结查询 (Joins)</strong> ：<a href="http://phoenix.apache.org/joins.html">http://phoenix.apache.org/joins.html</a></p>
</li>
</ul>
<h2 id="四、Phoenix-Java-API">四、Phoenix Java API</h2>
<p>因为 Phoenix 遵循 JDBC 规范，并提供了对应的数据库驱动 <code>PhoenixDriver</code>，这使得采用 Java 语言对其进行操作的时候，就如同对其他关系型数据库一样，下面给出基本的使用示例。</p>
<h3 id="4-1-引入Phoenix-core-JAR包">4.1 引入Phoenix core JAR包</h3>
<p>如果是 maven 项目，直接在 maven 中央仓库找到对应的版本，导入依赖即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.phoenix/phoenix-core --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.phoenix<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>phoenix-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.14.0-cdh5.14.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果是普通项目，则可以从 Phoenix 解压目录下找到对应的 JAR 包，然后手动引入：</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/phoenix-core-jar.png"/> </div>
### 4.2 简单的Java API实例
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoenixJavaApi</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载数据库驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;org.apache.phoenix.jdbc.PhoenixDriver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 指定数据库地址,格式为 jdbc:phoenix:Zookeeper 地址</span></span><br><span class="line"><span class="comment">         * 如果 HBase 采用 Standalone 模式或者伪集群模式搭建，则 HBase 默认使用内置的 Zookeeper，默认端口为 2181</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:phoenix:192.168.200.226:2181&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.prepareStatement(<span class="string">&quot;SELECT * FROM us_population&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">            System.out.println(resultSet.getString(<span class="string">&quot;city&quot;</span>) + <span class="string">&quot; &quot;</span></span><br><span class="line">                    + resultSet.getInt(<span class="string">&quot;population&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/Phoenix-java-api-result.png"/> </div>
<p>实际的开发中我们通常都是采用第三方框架来操作数据库，如 <code>mybatis</code>，<code>Hibernate</code>，<code>Spring Data</code> 等。关于 Phoenix 与这些框架的整合步骤参见下一篇文章：<a href="https://github.com/ihadyou/BigData-Notes/blob/master/notes/Spring+Mybtais+Phoenix%E6%95%B4%E5%90%88.md">Spring/Spring Boot + Mybatis + Phoenix</a></p>
<h1>参考资料</h1>
<ol>
<li class="lvl-3">
<p><a href="http://phoenix.apache.org/">http://phoenix.apache.org/</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>hbase</category>
      </categories>
      <tags>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>Hbase简介</title>
    <url>/posts/98e8148c.html</url>
    <content><![CDATA[<h2 id="一、Hadoop的局限">一、Hadoop的局限</h2>
<p>HBase 是一个构建在 Hadoop 文件系统之上的面向列的数据库管理系统。</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase.jpg"/> </div>
<p>要想明白为什么产生 HBase，就需要先了解一下 Hadoop 存在的限制？Hadoop 可以通过 HDFS 来存储结构化、半结构甚至非结构化的数据，它是传统数据库的补充，是海量数据存储的最佳方法，它针对大文件的存储，批量访问和流式访问都做了优化，同时也通过多副本解决了容灾问题。</p>
<p>但是 Hadoop 的缺陷在于它只能执行批处理，并且只能以顺序方式访问数据，这意味着即使是最简单的工作，也必须搜索整个数据集，无法实现对数据的随机访问。实现数据的随机访问是传统的关系型数据库所擅长的，但它们却不能用于海量数据的存储。在这种情况下，必须有一种新的方案来解决海量数据存储和随机访问的问题，HBase 就是其中之一 (HBase，Cassandra，couchDB，Dynamo 和 MongoDB 都能存储海量数据并支持随机访问)。</p>
<blockquote>
<p>注：数据结构分类：</p>
<ul class="lvl-1">
<li class="lvl-2">结构化数据：即以关系型数据库表形式管理的数据；</li>
<li class="lvl-2">半结构化数据：非关系模型的，有基本固定结构模式的数据，例如日志文件、XML 文档、JSON 文档、Email 等；</li>
<li class="lvl-2">非结构化数据：没有固定模式的数据，如 WORD、PDF、PPT、EXL，各种格式的图片、视频等。</li>
</ul>
</blockquote>
<h2 id="二、HBase简介">二、HBase简介</h2>
<p>HBase 是一个构建在 Hadoop 文件系统之上的面向列的数据库管理系统。</p>
<p>HBase 是一种类似于 <code>Google’s Big Table</code> 的数据模型，它是 Hadoop 生态系统的一部分，它将数据存储在 HDFS 上，客户端可以通过 HBase 实现对 HDFS 上数据的随机访问。它具有以下特性：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>不支持复杂的事务，只支持行级事务，即单行数据的读写都是原子性的；</p>
</li>
<li class="lvl-2">
<p>由于是采用 HDFS 作为底层存储，所以和 HDFS 一样，支持结构化、半结构化和非结构化的存储；</p>
</li>
<li class="lvl-2">
<p>支持通过增加机器进行横向扩展；</p>
</li>
<li class="lvl-2">
<p>支持数据分片；</p>
</li>
<li class="lvl-2">
<p>支持 RegionServers 之间的自动故障转移；</p>
</li>
<li class="lvl-2">
<p>易于使用的 Java 客户端 API；</p>
</li>
<li class="lvl-2">
<p>支持 BlockCache 和布隆过滤器；</p>
</li>
<li class="lvl-2">
<p>过滤器支持谓词下推。</p>
</li>
</ul>
<h2 id="三、HBase-Table">三、HBase Table</h2>
<p>HBase 是一个面向 <code>列</code> 的数据库管理系统，这里更为确切的而说，HBase 是一个面向 <code>列族</code> 的数据库管理系统。表 schema 仅定义列族，表具有多个列族，每个列族可以包含任意数量的列，列由多个单元格（cell ）组成，单元格可以存储多个版本的数据，多个版本数据以时间戳进行区分。</p>
<p>下图为 HBase 中一张表的：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>RowKey 为行的唯一标识，所有行按照 RowKey 的字典序进行排序；</p>
</li>
<li class="lvl-2">
<p>该表具有两个列族，分别是 personal 和 office;</p>
</li>
<li class="lvl-2">
<p>其中列族 personal 拥有 name、city、phone 三个列，列族 office 拥有 tel、addres 两个列。</p>
</li>
</ul>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/HBase_table-iteblog.png"/> </div>
<blockquote>
<p><em>图片引用自 : HBase 是列式存储数据库吗</em> <em><a href="https://www.iteblog.com/archives/2498.html">https://www.iteblog.com/archives/2498.html</a></em></p>
</blockquote>
<p>Hbase 的表具有以下特点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>容量大：一个表可以有数十亿行，上百万列；</p>
</li>
<li class="lvl-2">
<p>面向列：数据是按照列存储，每一列都单独存放，数据即索引，在查询时可以只访问指定列的数据，有效地降低了系统的 I/O 负担；</p>
</li>
<li class="lvl-2">
<p>稀疏性：空 (null) 列并不占用存储空间，表可以设计的非常稀疏  ；</p>
</li>
<li class="lvl-2">
<p>数据多版本：每个单元中的数据可以有多个版本，按照时间戳排序，新的数据在最上面；</p>
</li>
<li class="lvl-2">
<p>存储类型：所有数据的底层存储格式都是字节数组 (byte[])。</p>
</li>
</ul>
<h2 id="四、Phoenix">四、Phoenix</h2>
<p><code>Phoenix</code> 是 HBase 的开源 SQL 中间层，它允许你使用标准 JDBC 的方式来操作 HBase 上的数据。在 <code>Phoenix</code> 之前，如果你要访问 HBase，只能调用它的 Java API，但相比于使用一行 SQL 就能实现数据查询，HBase 的 API 还是过于复杂。<code>Phoenix</code> 的理念是 <code>we put sql SQL back in NOSQL</code>，即你可以使用标准的 SQL 就能完成对 HBase 上数据的操作。同时这也意味着你可以通过集成 <code>Spring Data  JPA</code> 或 <code>Mybatis</code> 等常用的持久层框架来操作 HBase。</p>
<p>其次 <code>Phoenix</code> 的性能表现也非常优异，<code>Phoenix</code> 查询引擎会将 SQL 查询转换为一个或多个 HBase Scan，通过并行执行来生成标准的 JDBC 结果集。它通过直接使用 HBase API 以及协处理器和自定义过滤器，可以为小型数据查询提供毫秒级的性能，为千万行数据的查询提供秒级的性能。同时 Phoenix 还拥有二级索引等 HBase 不具备的特性，因为以上的优点，所以 <code>Phoenix</code> 成为了 HBase 最优秀的 SQL 中间层。</p>
<h2 id="参考资料-14">参考资料</h2>
<ol>
<li class="lvl-3">
<p><a href="https://www.tutorialspoint.com/hbase/hbase_overview.htm">HBase - Overview</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>hbase</category>
      </categories>
      <tags>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>Hbase过滤器</title>
    <url>/posts/5f20503a.html</url>
    <content><![CDATA[<h2 id="一、HBase过滤器简介">一、HBase过滤器简介</h2>
<p>Hbase 提供了种类丰富的过滤器（filter）来提高数据处理的效率，用户可以通过内置或自定义的过滤器来对数据进行过滤，所有的过滤器都在服务端生效，即谓词下推（predicate push down）。这样可以保证过滤掉的数据不会被传送到客户端，从而减轻网络传输和客户端处理的压力。</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-fliter.png"/> </div>
<h2 id="二、过滤器基础">二、过滤器基础</h2>
<h3 id="2-1-Filter接口和FilterBase抽象类">2.1  Filter接口和FilterBase抽象类</h3>
<p>Filter 接口中定义了过滤器的基本方法，FilterBase 抽象类实现了 Filter 接口。所有内置的过滤器则直接或者间接继承自 FilterBase 抽象类。用户只需要将定义好的过滤器通过 <code>setFilter</code> 方法传递给 <code>Scan</code> 或 <code>put</code> 的实例即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setFilter(Filter filter)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Scan 中定义的 setFilter</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Scan <span class="title function_">setFilter</span><span class="params">(Filter filter)</span> &#123;</span><br><span class="line">   <span class="built_in">super</span>.setFilter(filter);</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// Get 中定义的 setFilter</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Get <span class="title function_">setFilter</span><span class="params">(Filter filter)</span> &#123;</span><br><span class="line">   <span class="built_in">super</span>.setFilter(filter);</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>FilterBase 的所有子类过滤器如下：<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-filterbase-subclass.png"/> </div></p>
<blockquote>
<p>说明：上图基于当前时间点（2019.4）最新的 Hbase-2.1.4 ，下文所有说明均基于此版本。</p>
</blockquote>
<h3 id="2-2-过滤器分类">2.2 过滤器分类</h3>
<p>HBase 内置过滤器可以分为三类：分别是比较过滤器，专用过滤器和包装过滤器。分别在下面的三个小节中做详细的介绍。</p>
<h2 id="三、比较过滤器">三、比较过滤器</h2>
<p>所有比较过滤器均继承自 <code>CompareFilter</code>。创建一个比较过滤器需要两个参数，分别是<strong>比较运算符</strong>和<strong>比较器实例</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CompareFilter</span><span class="params">(<span class="keyword">final</span> CompareOp compareOp,<span class="keyword">final</span> ByteArrayComparable comparator)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.compareOp = compareOp;</span><br><span class="line">   <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-比较运算符">3.1 比较运算符</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>LESS (&lt;)</p>
</li>
<li class="lvl-2">
<p>LESS_OR_EQUAL (&lt;=)</p>
</li>
<li class="lvl-2">
<p>EQUAL (=)</p>
</li>
<li class="lvl-2">
<p>NOT_EQUAL (!=)</p>
</li>
<li class="lvl-2">
<p>GREATER_OR_EQUAL (&gt;=)</p>
</li>
<li class="lvl-2">
<p>GREATER (&gt;)</p>
</li>
<li class="lvl-2">
<p>NO_OP (排除所有符合条件的值)</p>
</li>
</ul>
<p>比较运算符均定义在枚举类 <code>CompareOperator</code> 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@InterfaceAudience</span>.Public</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">CompareOperator</span> &#123;</span><br><span class="line">  LESS,</span><br><span class="line">  LESS_OR_EQUAL,</span><br><span class="line">  EQUAL,</span><br><span class="line">  NOT_EQUAL,</span><br><span class="line">  GREATER_OR_EQUAL,</span><br><span class="line">  GREATER,</span><br><span class="line">  NO_OP,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在 1.x 版本的 HBase 中，比较运算符定义在 <code>CompareFilter.CompareOp</code> 枚举类中，但在 2.0 之后这个类就被标识为 @deprecated ，并会在 3.0 移除。所以 2.0 之后版本的 HBase 需要使用 <code>CompareOperator</code> 这个枚举类。</p>
</blockquote>
<h3 id="3-2-比较器">3.2 比较器</h3>
<p>所有比较器均继承自 <code>ByteArrayComparable</code> 抽象类，常用的有以下几种：</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-bytearraycomparable.png"/> </div>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>BinaryComparator</strong>  : 使用 <code>Bytes.compareTo(byte []，byte [])</code> 按字典序比较指定的字节数组。</p>
</li>
<li class="lvl-2">
<p><strong>BinaryPrefixComparator</strong> : 按字典序与指定的字节数组进行比较，但只比较到这个字节数组的长度。</p>
</li>
<li class="lvl-2">
<p><strong>RegexStringComparator</strong> :  使用给定的正则表达式与指定的字节数组进行比较。仅支持 <code>EQUAL</code> 和 <code>NOT_EQUAL</code> 操作。</p>
</li>
<li class="lvl-2">
<p><strong>SubStringComparator</strong> : 测试给定的子字符串是否出现在指定的字节数组中，比较不区分大小写。仅支持 <code>EQUAL</code> 和 <code>NOT_EQUAL</code> 操作。</p>
</li>
<li class="lvl-2">
<p><strong>NullComparator</strong> ：判断给定的值是否为空。</p>
</li>
<li class="lvl-2">
<p><strong>BitComparator</strong> ：按位进行比较。</p>
</li>
</ul>
<p><code>BinaryPrefixComparator</code> 和 <code>BinaryComparator</code> 的区别不是很好理解，这里举例说明一下：</p>
<p>在进行 <code>EQUAL</code> 的比较时，如果比较器传入的是 <code>abcd</code> 的字节数组，但是待比较数据是 <code>abcdefgh</code>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果使用的是 <code>BinaryPrefixComparator</code> 比较器，则比较以 <code>abcd</code> 字节数组的长度为准，即 <code>efgh</code> 不会参与比较，这时候认为 <code>abcd</code> 与 <code>abcdefgh</code> 是满足 <code>EQUAL</code> 条件的；</p>
</li>
<li class="lvl-2">
<p>如果使用的是 <code>BinaryComparator</code> 比较器，则认为其是不相等的。</p>
</li>
</ul>
<h3 id="3-3-比较过滤器种类">3.3 比较过滤器种类</h3>
<p>比较过滤器共有五个（Hbase 1.x 版本和 2.x 版本相同），见下图：</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-compareFilter.png"/> </div>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>RowFilter</strong> ：基于行键来过滤数据；</p>
</li>
<li class="lvl-2">
<p><strong>FamilyFilterr</strong> ：基于列族来过滤数据；</p>
</li>
<li class="lvl-2">
<p><strong>QualifierFilterr</strong> ：基于列限定符（列名）来过滤数据；</p>
</li>
<li class="lvl-2">
<p><strong>ValueFilterr</strong> ：基于单元格 (cell) 的值来过滤数据；</p>
</li>
<li class="lvl-2">
<p><strong>DependentColumnFilter</strong> ：指定一个参考列来过滤其他列的过滤器，过滤的原则是基于参考列的时间戳来进行筛选 。</p>
</li>
</ul>
<p>前四种过滤器的使用方法相同，均只要传递比较运算符和运算器实例即可构建，然后通过 <code>setFilter</code> 方法传递给 <code>scan</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Filter</span> <span class="variable">filter</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RowFilter</span>(CompareOperator.LESS_OR_EQUAL,</span><br><span class="line">                               <span class="keyword">new</span> <span class="title class_">BinaryComparator</span>(Bytes.toBytes(<span class="string">&quot;xxx&quot;</span>)));</span><br><span class="line"> scan.setFilter(filter);    </span><br></pre></td></tr></table></figure>
<p><code>DependentColumnFilter</code> 的使用稍微复杂一点，这里单独做下说明。</p>
<h3 id="3-4-DependentColumnFilter">3.4 DependentColumnFilter</h3>
<p>可以把 <code>DependentColumnFilter</code> 理解为<strong>一个 valueFilter 和一个时间戳过滤器的组合</strong>。<code>DependentColumnFilter</code> 有三个带参构造器，这里选择一个参数最全的进行说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DependentColumnFilter(<span class="keyword">final</span> <span class="type">byte</span> [] family, <span class="keyword">final</span> <span class="type">byte</span>[] qualifier,</span><br><span class="line">                               <span class="keyword">final</span> <span class="type">boolean</span> dropDependentColumn, <span class="keyword">final</span> CompareOperator op,</span><br><span class="line">                               <span class="keyword">final</span> ByteArrayComparable valueComparator)</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>family</strong>  ：列族</p>
</li>
<li class="lvl-2">
<p><strong>qualifier</strong> ：列限定符（列名）</p>
</li>
<li class="lvl-2">
<p><strong>dropDependentColumn</strong> ：决定参考列是否被包含在返回结果内，为 true 时表示参考列被返回，为 false 时表示被丢弃</p>
</li>
<li class="lvl-2">
<p><strong>op</strong> ：比较运算符</p>
</li>
<li class="lvl-2">
<p><strong>valueComparator</strong> ：比较器</p>
</li>
</ul>
<p>这里举例进行说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DependentColumnFilter</span> <span class="variable">dependentColumnFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependentColumnFilter</span>( </span><br><span class="line">    Bytes.toBytes(<span class="string">&quot;student&quot;</span>),</span><br><span class="line">    Bytes.toBytes(<span class="string">&quot;name&quot;</span>),</span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    CompareOperator.EQUAL, </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">BinaryPrefixComparator</span>(Bytes.toBytes(<span class="string">&quot;xiaolan&quot;</span>)));</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>首先会去查找 <code>student:name</code> 中值以 <code>xiaolan</code> 开头的所有数据获得 <code>参考数据集</code>，这一步等同于 valueFilter 过滤器；</p>
</li>
<li class="lvl-2">
<p>其次再用参考数据集中所有数据的时间戳去检索其他列，获得时间戳相同的其他列的数据作为 <code>结果数据集</code>，这一步等同于时间戳过滤器；</p>
</li>
<li class="lvl-2">
<p>最后如果 <code>dropDependentColumn</code> 为 true，则返回 <code>参考数据集</code>+<code>结果数据集</code>，若为 false，则抛弃参考数据集，只返回 <code>结果数据集</code>。</p>
</li>
</ul>
<h2 id="四、专用过滤器">四、专用过滤器</h2>
<p>专用过滤器通常直接继承自 <code>FilterBase</code>，适用于范围更小的筛选规则。</p>
<h3 id="4-1-单列列值过滤器-SingleColumnValueFilter">4.1 单列列值过滤器 (SingleColumnValueFilter)</h3>
<p>基于某列（参考列）的值决定某行数据是否被过滤。其实例有以下方法：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>setFilterIfMissing(boolean filterIfMissing)</strong> ：默认值为 false，即如果该行数据不包含参考列，其依然被包含在最后的结果中；设置为 true 时，则不包含；</p>
</li>
<li class="lvl-2">
<p><strong>setLatestVersionOnly(boolean latestVersionOnly)</strong> ：默认为 true，即只检索参考列的最新版本数据；设置为 false，则检索所有版本数据。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SingleColumnValueFilter singleColumnValueFilter = new SingleColumnValueFilter(</span><br><span class="line">                &quot;student&quot;.getBytes(), </span><br><span class="line">                &quot;name&quot;.getBytes(), </span><br><span class="line">                CompareOperator.EQUAL, </span><br><span class="line">                new SubstringComparator(&quot;xiaolan&quot;));</span><br><span class="line">singleColumnValueFilter.setFilterIfMissing(true);</span><br><span class="line">scan.setFilter(singleColumnValueFilter);</span><br></pre></td></tr></table></figure>
<h3 id="4-2-单列列值排除器-SingleColumnValueExcludeFilter">4.2 单列列值排除器 (SingleColumnValueExcludeFilter)</h3>
<p><code>SingleColumnValueExcludeFilter</code> 继承自上面的 <code>SingleColumnValueFilter</code>，过滤行为与其相反。</p>
<h3 id="4-3-行键前缀过滤器-PrefixFilter">4.3 行键前缀过滤器 (PrefixFilter)</h3>
<p>基于 RowKey 值决定某行数据是否被过滤。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PrefixFilter</span> <span class="variable">prefixFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrefixFilter</span>(Bytes.toBytes(<span class="string">&quot;xxx&quot;</span>));</span><br><span class="line">scan.setFilter(prefixFilter);</span><br></pre></td></tr></table></figure>
<h3 id="4-4-列名前缀过滤器-ColumnPrefixFilter">4.4 列名前缀过滤器 (ColumnPrefixFilter)</h3>
<p>基于列限定符（列名）决定某行数据是否被过滤。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ColumnPrefixFilter</span> <span class="variable">columnPrefixFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColumnPrefixFilter</span>(Bytes.toBytes(<span class="string">&quot;xxx&quot;</span>));</span><br><span class="line"> scan.setFilter(columnPrefixFilter);</span><br></pre></td></tr></table></figure>
<h3 id="4-5-分页过滤器-PageFilter">4.5 分页过滤器 (PageFilter)</h3>
<p>可以使用这个过滤器实现对结果按行进行分页，创建 PageFilter 实例的时候需要传入每页的行数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PageFilter</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> pageSize)</span> &#123;</span><br><span class="line">    Preconditions.checkArgument(pageSize &gt;= <span class="number">0</span>, <span class="string">&quot;must be positive %s&quot;</span>, pageSize);</span><br><span class="line">    <span class="built_in">this</span>.pageSize = pageSize;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>下面的代码体现了客户端实现分页查询的主要逻辑，这里对其进行一下解释说明：</p>
<p>客户端进行分页查询，需要传递 <code>startRow</code>(起始 RowKey)，知道起始 <code>startRow</code> 后，就可以返回对应的 pageSize 行数据。这里唯一的问题就是，对于第一次查询，显然 <code>startRow</code> 就是表格的第一行数据，但是之后第二次、第三次查询我们并不知道 <code>startRow</code>，只能知道上一次查询的最后一条数据的 RowKey（简单称之为 <code>lastRow</code>）。</p>
<p>我们不能将 <code>lastRow</code> 作为新一次查询的 <code>startRow</code> 传入，因为 scan 的查询区间是[startRow，endRow) ，即前开后闭区间，这样 <code>startRow</code> 在新的查询也会被返回，这条数据就重复了。</p>
<p>同时在不使用第三方数据库存储 RowKey 的情况下，我们是无法通过知道 <code>lastRow</code> 的下一个 RowKey 的，因为 RowKey 的设计可能是连续的也有可能是不连续的。</p>
<p>由于 Hbase 的 RowKey 是按照字典序进行排序的。这种情况下，就可以在 <code>lastRow</code> 后面加上 <code>0</code> ，作为 <code>startRow</code> 传入，因为按照字典序的规则，某个值加上 <code>0</code> 后的新值，在字典序上一定是这个值的下一个值，对于 HBase 来说下一个 RowKey 在字典序上一定也是等于或者大于这个新值的。</p>
<p>所以最后传入 <code>lastRow</code>+<code>0</code>，如果等于这个值的 RowKey 存在就从这个值开始 scan,否则从字典序的下一个 RowKey 开始 scan。</p>
<blockquote>
<p>25 个字母以及数字字符，字典排序如下:</p>
<p><code>'0' &lt; '1' &lt; '2' &lt; ... &lt; '9' &lt; 'a' &lt; 'b' &lt; ... &lt; 'z'</code></p>
</blockquote>
<p>分页查询主要实现逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] POSTFIX = <span class="keyword">new</span> <span class="title class_">byte</span>[] &#123; <span class="number">0x00</span> &#125;;</span><br><span class="line"><span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageFilter</span>(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">totalRows</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">byte</span>[] lastRow = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">Scan</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scan</span>();</span><br><span class="line">    scan.setFilter(filter);</span><br><span class="line">    <span class="keyword">if</span> (lastRow != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果不是首行 则 lastRow + 0</span></span><br><span class="line">        <span class="type">byte</span>[] startRow = Bytes.add(lastRow, POSTFIX);</span><br><span class="line">        System.out.println(<span class="string">&quot;start row: &quot;</span> +</span><br><span class="line">                           Bytes.toStringBinary(startRow));</span><br><span class="line">        scan.withStartRow(startRow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ResultScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> table.getScanner(scan);</span><br><span class="line">    <span class="type">int</span> <span class="variable">localRows</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Result result;</span><br><span class="line">    <span class="keyword">while</span> ((result = scanner.next()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(localRows++ + <span class="string">&quot;: &quot;</span> + result);</span><br><span class="line">        totalRows++;</span><br><span class="line">        lastRow = result.getRow();</span><br><span class="line">    &#125;</span><br><span class="line">    scanner.close();</span><br><span class="line">    <span class="comment">//最后一页，查询结束  </span></span><br><span class="line">    <span class="keyword">if</span> (localRows == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;total rows: &quot;</span> + totalRows);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是在多台 Regin Services 上执行分页过滤的时候，由于并行执行的过滤器不能共享它们的状态和边界，所以有可能每个过滤器都会在完成扫描前获取了 PageCount 行的结果，这种情况下会返回比分页条数更多的数据，分页过滤器就有失效的可能。</p>
</blockquote>
<h3 id="4-6-时间戳过滤器-TimestampsFilter">4.6 时间戳过滤器 (TimestampsFilter)</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Long&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1554975573000L</span>);</span><br><span class="line"><span class="type">TimestampsFilter</span> <span class="variable">timestampsFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimestampsFilter</span>(list);</span><br><span class="line">scan.setFilter(timestampsFilter);</span><br></pre></td></tr></table></figure>
<h3 id="4-7-首次行键过滤器-FirstKeyOnlyFilter">4.7 首次行键过滤器 (FirstKeyOnlyFilter)</h3>
<p><code>FirstKeyOnlyFilter</code> 只扫描每行的第一列，扫描完第一列后就结束对当前行的扫描，并跳转到下一行。相比于全表扫描，其性能更好，通常用于行数统计的场景，因为如果某一行存在，则行中必然至少有一列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FirstKeyOnlyFilter</span> <span class="variable">firstKeyOnlyFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FirstKeyOnlyFilter</span>();</span><br><span class="line">scan.set(firstKeyOnlyFilter);</span><br></pre></td></tr></table></figure>
<h2 id="五、包装过滤器">五、包装过滤器</h2>
<p>包装过滤器就是通过包装其他过滤器以实现某些拓展的功能。</p>
<h3 id="5-1-SkipFilter过滤器">5.1 SkipFilter过滤器</h3>
<p><code>SkipFilter</code> 包装一个过滤器，当被包装的过滤器遇到一个需要过滤的 KeyValue 实例时，则拓展过滤整行数据。下面是一个使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 ValueFilter 过滤器</span></span><br><span class="line"><span class="type">Filter</span> <span class="variable">filter1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ValueFilter</span>(CompareOperator.NOT_EQUAL,</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">BinaryComparator</span>(Bytes.toBytes(<span class="string">&quot;xxx&quot;</span>)));</span><br><span class="line"><span class="comment">// 使用 SkipFilter 进行包装</span></span><br><span class="line"><span class="type">Filter</span> <span class="variable">filter2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SkipFilter</span>(filter1);</span><br></pre></td></tr></table></figure>
<h3 id="5-2-WhileMatchFilter过滤器">5.2 WhileMatchFilter过滤器</h3>
<p><code>WhileMatchFilter</code> 包装一个过滤器，当被包装的过滤器遇到一个需要过滤的 KeyValue 实例时，<code>WhileMatchFilter</code> 则结束本次扫描，返回已经扫描到的结果。下面是其使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Filter</span> <span class="variable">filter1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RowFilter</span>(CompareOperator.NOT_EQUAL,</span><br><span class="line">                               <span class="keyword">new</span> <span class="title class_">BinaryComparator</span>(Bytes.toBytes(<span class="string">&quot;rowKey4&quot;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="type">Scan</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scan</span>();</span><br><span class="line">scan.setFilter(filter1);</span><br><span class="line"><span class="type">ResultScanner</span> <span class="variable">scanner1</span> <span class="operator">=</span> table.getScanner(scan);</span><br><span class="line"><span class="keyword">for</span> (Result result : scanner1) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Cell cell : result.listCells()) &#123;</span><br><span class="line">        System.out.println(cell);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">scanner1.close();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 WhileMatchFilter 进行包装</span></span><br><span class="line"><span class="type">Filter</span> <span class="variable">filter2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WhileMatchFilter</span>(filter1);</span><br><span class="line"></span><br><span class="line">scan.setFilter(filter2);</span><br><span class="line"><span class="type">ResultScanner</span> <span class="variable">scanner2</span> <span class="operator">=</span> table.getScanner(scan);</span><br><span class="line"><span class="keyword">for</span> (Result result : scanner1) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Cell cell : result.listCells()) &#123;</span><br><span class="line">        System.out.println(cell);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">scanner2.close();</span><br></pre></td></tr></table></figure>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">rowKey0/student</span>:<span class="string">name/1555035006994/Put/vlen=8/seqid=0</span></span><br><span class="line"><span class="attr">rowKey1/student</span>:<span class="string">name/1555035007019/Put/vlen=8/seqid=0</span></span><br><span class="line"><span class="attr">rowKey2/student</span>:<span class="string">name/1555035007025/Put/vlen=8/seqid=0</span></span><br><span class="line"><span class="attr">rowKey3/student</span>:<span class="string">name/1555035007037/Put/vlen=8/seqid=0</span></span><br><span class="line"><span class="attr">rowKey5/student</span>:<span class="string">name/1555035007051/Put/vlen=8/seqid=0</span></span><br><span class="line"><span class="attr">rowKey6/student</span>:<span class="string">name/1555035007057/Put/vlen=8/seqid=0</span></span><br><span class="line"><span class="attr">rowKey7/student</span>:<span class="string">name/1555035007062/Put/vlen=8/seqid=0</span></span><br><span class="line"><span class="attr">rowKey8/student</span>:<span class="string">name/1555035007068/Put/vlen=8/seqid=0</span></span><br><span class="line"><span class="attr">rowKey9/student</span>:<span class="string">name/1555035007073/Put/vlen=8/seqid=0</span></span><br><span class="line"><span class="attr">--------------------</span></span><br><span class="line"><span class="attr">rowKey0/student</span>:<span class="string">name/1555035006994/Put/vlen=8/seqid=0</span></span><br><span class="line"><span class="attr">rowKey1/student</span>:<span class="string">name/1555035007019/Put/vlen=8/seqid=0</span></span><br><span class="line"><span class="attr">rowKey2/student</span>:<span class="string">name/1555035007025/Put/vlen=8/seqid=0</span></span><br><span class="line"><span class="attr">rowKey3/student</span>:<span class="string">name/1555035007037/Put/vlen=8/seqid=0</span></span><br></pre></td></tr></table></figure>
<p>可以看到被包装后，只返回了 <code>rowKey4</code> 之前的数据。</p>
<h2 id="六、FilterList">六、FilterList</h2>
<p>以上都是讲解单个过滤器的作用，当需要多个过滤器共同作用于一次查询的时候，就需要使用 <code>FilterList</code>。<code>FilterList</code> 支持通过构造器或者 <code>addFilter</code> 方法传入多个过滤器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造器传入</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FilterList</span><span class="params">(<span class="keyword">final</span> Operator operator, <span class="keyword">final</span> List&lt;Filter&gt; filters)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FilterList</span><span class="params">(<span class="keyword">final</span> List&lt;Filter&gt; filters)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FilterList</span><span class="params">(<span class="keyword">final</span> Filter... filters)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法传入</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFilter</span><span class="params">(List&lt;Filter&gt; filters)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFilter</span><span class="params">(Filter filter)</span></span><br></pre></td></tr></table></figure>
<p>多个过滤器组合的结果由 <code>operator</code> 参数定义 ，其可选参数定义在 <code>Operator</code> 枚举类中。只有 <code>MUST_PASS_ALL</code> 和 <code>MUST_PASS_ONE</code> 两个可选的值：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>MUST_PASS_ALL</strong> ：相当于 AND，必须所有的过滤器都通过才认为通过；</p>
</li>
<li class="lvl-2">
<p><strong>MUST_PASS_ONE</strong> ：相当于 OR，只有要一个过滤器通过则认为通过。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@InterfaceAudience</span>.Public</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Operator</span> &#123;</span><br><span class="line">    <span class="comment">/** !AND */</span></span><br><span class="line">    MUST_PASS_ALL,</span><br><span class="line">    <span class="comment">/** !OR */</span></span><br><span class="line">    MUST_PASS_ONE</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>使用示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Filter&gt; filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Filter&gt;();</span><br><span class="line"></span><br><span class="line"><span class="type">Filter</span> <span class="variable">filter1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RowFilter</span>(CompareOperator.GREATER_OR_EQUAL,</span><br><span class="line">                               <span class="keyword">new</span> <span class="title class_">BinaryComparator</span>(Bytes.toBytes(<span class="string">&quot;XXX&quot;</span>)));</span><br><span class="line">filters.add(filter1);</span><br><span class="line"></span><br><span class="line"><span class="type">Filter</span> <span class="variable">filter2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RowFilter</span>(CompareOperator.LESS_OR_EQUAL,</span><br><span class="line">                               <span class="keyword">new</span> <span class="title class_">BinaryComparator</span>(Bytes.toBytes(<span class="string">&quot;YYY&quot;</span>)));</span><br><span class="line">filters.add(filter2);</span><br><span class="line"></span><br><span class="line"><span class="type">Filter</span> <span class="variable">filter3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QualifierFilter</span>(CompareOperator.EQUAL,</span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">RegexStringComparator</span>(<span class="string">&quot;ZZZ&quot;</span>));</span><br><span class="line">filters.add(filter3);</span><br><span class="line"></span><br><span class="line"><span class="type">FilterList</span> <span class="variable">filterList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterList</span>(filters);</span><br><span class="line"></span><br><span class="line"><span class="type">Scan</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scan</span>();</span><br><span class="line">scan.setFilter(filterList);</span><br></pre></td></tr></table></figure>
<h2 id="参考资料-15">参考资料</h2>
<p><a href="https://www.oreilly.com/library/view/hbase-the-definitive/9781449314682/ch04.html">HBase: The Definitive Guide _&gt;  Chapter 4. Client API: Advanced Features</a></p>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>hbase</category>
      </categories>
      <tags>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>Hbase集群搭建</title>
    <url>/posts/7527daf3.html</url>
    <content><![CDATA[<h2 id="一、集群规划-2">一、集群规划</h2>
<p>这里搭建一个 3 节点的 HBase 集群，其中三台主机上均为 <code>Regin Server</code>。同时为了保证高可用，除了在 hadoop001 上部署主 <code>Master</code> 服务外，还在 hadoop002 上部署备用的 <code>Master</code> 服务。Master 服务由 Zookeeper 集群进行协调管理，如果主 <code>Master</code> 不可用，则备用 <code>Master</code> 会成为新的主 <code>Master</code>。</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase集群规划.png"/> </div>
<h2 id="二、前置条件-2">二、前置条件</h2>
<p>HBase 的运行需要依赖 Hadoop 和 JDK(<code>HBase 2.0+</code> 对应 <code>JDK 1.8+</code>) 。同时为了保证高可用，这里我们不采用 HBase 内置的 Zookeeper 服务，而采用外置的 Zookeeper 集群。相关搭建步骤可以参阅：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://github.com/ihadyou/BigData-Notes/blob/master/notes/installation/Linux%E4%B8%8BJDK%E5%AE%89%E8%A3%85.md">Linux 环境下 JDK 安装</a></p>
</li>
<li class="lvl-2">
<p><a href="https://github.com/ihadyou/BigData-Notes/blob/master/notes/installation/Zookeeper%E5%8D%95%E6%9C%BA%E7%8E%AF%E5%A2%83%E5%92%8C%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md">Zookeeper 单机环境和集群环境搭建</a></p>
</li>
<li class="lvl-2">
<p><a href="https://github.com/ihadyou/BigData-Notes/blob/master/notes/installation/Hadoop%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md">Hadoop 集群环境搭建</a></p>
</li>
</ul>
<h2 id="三、集群搭建">三、集群搭建</h2>
<h3 id="3-1-下载并解压-3">3.1 下载并解压</h3>
<p>下载并解压，这里我下载的是 CDH 版本 HBase，下载地址为：<a href="http://archive.cloudera.com/cdh5/cdh/5/">http://archive.cloudera.com/cdh5/cdh/5/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">tar -zxvf hbase-1.2.0-cdh5.15.2.tar.gz</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-配置环境变量-3">3.2 配置环境变量</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">vim /etc/profile</span></span><br></pre></td></tr></table></figure>
<p>添加环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HBASE_HOME=usr/app/hbase-1.2.0-cdh5.15.2</span><br><span class="line">export PATH=$HBASE_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>使得配置的环境变量立即生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">source</span> /etc/profile</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-集群配置">3.3 集群配置</h3>
<p>进入 <code>$&#123;HBASE_HOME&#125;/conf</code> 目录下，修改配置：</p>
<h4 id="1-hbase-env-sh">1. <a href="http://hbase-env.sh">hbase-env.sh</a></h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">配置JDK安装位置</span></span><br><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_201</span><br><span class="line"><span class="meta"># </span><span class="language-bash">不使用内置的zookeeper服务</span></span><br><span class="line">export HBASE_MANAGES_ZK=false</span><br></pre></td></tr></table></figure>
<h4 id="2-hbase-site-xml">2. hbase-site.xml</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定 hbase 以分布式集群的方式运行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定 hbase 在 HDFS 上的存储位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop001:8020/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定 zookeeper 的地址--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop001:2181,hadoop002:2181,hadoop003:2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-regionservers">3. regionservers</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hadoop001</span><br><span class="line">hadoop002</span><br><span class="line">hadoop003</span><br></pre></td></tr></table></figure>
<h4 id="4-backup-masters">4. backup-masters</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hadoop002</span><br></pre></td></tr></table></figure>
<p><code> backup-masters</code> 这个文件是不存在的，需要新建，主要用来指明备用的 master 节点，可以是多个，这里我们以 1 个为例。</p>
<h3 id="3-4-HDFS客户端配置">3.4 HDFS客户端配置</h3>
<p>这里有一个可选的配置：如果您在 Hadoop 集群上进行了 HDFS 客户端配置的更改，比如将副本系数 <code>dfs.replication</code> 设置成 5，则必须使用以下方法之一来使 HBase 知道，否则 HBase 将依旧使用默认的副本系数 3 来创建文件：</p>
<blockquote>
<ol>
<li class="lvl-3">
<p>Add a pointer to your <code>HADOOP_CONF_DIR</code> to the <code>HBASE_CLASSPATH</code> environment variable in <em><a href="http://hbase-env.sh">hbase-env.sh</a></em>.</p>
</li>
<li class="lvl-3">
<p>Add a copy of <em>hdfs-site.xml</em> (or <em>hadoop-site.xml</em>) or, better, symlinks, under <em>${HBASE_HOME}/conf</em>, or</p>
</li>
<li class="lvl-3">
<p>if only a small set of HDFS client configurations, add them to <em>hbase-site.xml</em>.</p>
</li>
</ol>
</blockquote>
<p>以上是官方文档的说明，这里解释一下：</p>
<p><strong>第一种</strong> ：将 Hadoop 配置文件的位置信息添加到 <code>hbase-env.sh</code> 的 <code>HBASE_CLASSPATH</code> 属性，示例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HBASE_CLASSPATH=usr/app/hadoop-2.6.0-cdh5.15.2/etc/hadoop</span><br></pre></td></tr></table></figure>
<p><strong>第二种</strong> ：将 Hadoop 的 <code> hdfs-site.xml</code> 或 <code>hadoop-site.xml</code> 拷贝到  <code>$&#123;HBASE_HOME&#125;/conf </code> 目录下，或者通过符号链接的方式。如果采用这种方式的话，建议将两者都拷贝或建立符号链接，示例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">拷贝</span></span><br><span class="line">cp core-site.xml hdfs-site.xml /usr/app/hbase-1.2.0-cdh5.15.2/conf/</span><br><span class="line"><span class="meta"># </span><span class="language-bash">使用符号链接</span></span><br><span class="line">ln -s   /usr/app/hadoop-2.6.0-cdh5.15.2/etc/hadoop/core-site.xml</span><br><span class="line">ln -s   /usr/app/hadoop-2.6.0-cdh5.15.2/etc/hadoop/hdfs-site.xml</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：<code>hadoop-site.xml</code> 这个配置文件现在叫做 <code>core-site.xml</code></p>
</blockquote>
<p><strong>第三种</strong> ：如果你只有少量更改，那么直接配置到 <code>hbase-site.xml</code> 中即可。</p>
<h3 id="3-5-安装包分发">3.5 安装包分发</h3>
<p>将 HBase 的安装包分发到其他服务器，分发后建议在这两台服务器上也配置一下 HBase 的环境变量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -r /usr/app/hbase-1.2.0-cdh5.15.2/  hadoop002:usr/app/</span><br><span class="line">scp -r /usr/app/hbase-1.2.0-cdh5.15.2/  hadoop003:usr/app/</span><br></pre></td></tr></table></figure>
<h2 id="四、启动集群">四、启动集群</h2>
<h3 id="4-1-启动ZooKeeper集群">4.1 启动ZooKeeper集群</h3>
<p>分别到三台服务器上启动 ZooKeeper 服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zkServer.sh start</span><br></pre></td></tr></table></figure>
<h3 id="4-2-启动Hadoop集群">4.2 启动Hadoop集群</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">启动dfs服务</span></span><br><span class="line">start-dfs.sh</span><br><span class="line"><span class="meta"># </span><span class="language-bash">启动yarn服务</span></span><br><span class="line">start-yarn.sh</span><br></pre></td></tr></table></figure>
<h3 id="4-3-启动HBase集群">4.3 启动HBase集群</h3>
<p>进入 hadoop001 的 <code>$&#123;HBASE_HOME&#125;/bin</code>，使用以下命令启动 HBase 集群。执行此命令后，会在 hadoop001 上启动 <code>Master</code> 服务，在 hadoop002 上启动备用 <code>Master</code> 服务，在 <code>regionservers</code> 文件中配置的所有节点启动 <code>region server</code> 服务。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-hbase.sh</span><br></pre></td></tr></table></figure>
<h3 id="4-5-查看服务">4.5 查看服务</h3>
<p>访问 HBase 的 Web-UI 界面，这里我安装的 HBase 版本为 1.2，访问端口为 <code>60010</code>，如果你安装的是 2.0 以上的版本，则访问端口号为 <code>16010</code>。可以看到 <code>Master</code> 在 hadoop001 上，三个 <code>Regin Servers</code> 分别在 hadoop001，hadoop002，和 hadoop003 上，并且还有一个 <code>Backup Matser</code> 服务在 hadoop002 上。</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-集群搭建1.png"/> </div>
<br/>
<p>hadoop002 上的 HBase 出于备用状态：</p>
<br/>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-集群搭建2.png"/> </div>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>hbase</category>
      </categories>
      <tags>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive常用DDL操作</title>
    <url>/posts/d5dc7ba9.html</url>
    <content><![CDATA[<h2 id="一、Database">一、Database</h2>
<h3 id="1-1-查看数据列表">1.1 查看数据列表</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br></pre></td></tr></table></figure>
<div align="center"> <img width='700px' src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-show-database.png"/> </div>
<h3 id="1-2-使用数据库">1.2 使用数据库</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE database_name;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-新建数据库">1.3 新建数据库</h3>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> (DATABASE<span class="operator">|</span>SCHEMA) [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] database_name   <span class="comment">--DATABASE|SCHEMA 是等价的</span></span><br><span class="line">  [COMMENT database_comment] <span class="comment">--数据库注释</span></span><br><span class="line">  [LOCATION hdfs_path] <span class="comment">--存储在 HDFS 上的位置</span></span><br><span class="line">  [<span class="keyword">WITH</span> DBPROPERTIES (property_name<span class="operator">=</span>property_value, ...)]; <span class="comment">--指定额外属性</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> hive_test</span><br><span class="line">  COMMENT <span class="string">&#x27;hive database for test&#x27;</span></span><br><span class="line">  <span class="keyword">WITH</span> DBPROPERTIES (<span class="string">&#x27;create&#x27;</span><span class="operator">=</span><span class="string">&#x27;oicio&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="1-4-查看数据库信息">1.4 查看数据库信息</h3>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESC</span> DATABASE [EXTENDED] db_name; <span class="comment">--EXTENDED 表示是否显示额外属性</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESC</span> DATABASE  EXTENDED hive_test;</span><br></pre></td></tr></table></figure>
<h3 id="1-5-删除数据库">1.5 删除数据库</h3>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> (DATABASE<span class="operator">|</span>SCHEMA) [IF <span class="keyword">EXISTS</span>] database_name [RESTRICT<span class="operator">|</span>CASCADE];</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>默认行为是 RESTRICT，如果数据库中存在表则删除失败。要想删除库及其中的表，可以使用 CASCADE 级联删除。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> hive_test CASCADE;</span><br></pre></td></tr></table></figure>
<h2 id="二、创建表">二、创建表</h2>
<h3 id="2-1-建表语法">2.1 建表语法</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [TEMPORARY] [<span class="keyword">EXTERNAL</span>] <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [db_name.]table_name     <span class="comment">--表名</span></span><br><span class="line">  [(col_name data_type [COMMENT col_comment],</span><br><span class="line">    ... [constraint_specification])]  <span class="comment">--列名 列数据类型</span></span><br><span class="line">  [COMMENT table_comment]   <span class="comment">--表描述</span></span><br><span class="line">  [PARTITIONED <span class="keyword">BY</span> (col_name data_type [COMMENT col_comment], ...)]  <span class="comment">--分区表分区规则</span></span><br><span class="line">  [</span><br><span class="line">    CLUSTERED <span class="keyword">BY</span> (col_name, col_name, ...) </span><br><span class="line">   [SORTED <span class="keyword">BY</span> (col_name [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], ...)] <span class="keyword">INTO</span> num_buckets BUCKETS</span><br><span class="line">  ]  <span class="comment">--分桶表分桶规则</span></span><br><span class="line">  [SKEWED <span class="keyword">BY</span> (col_name, col_name, ...) <span class="keyword">ON</span> ((col_value, col_value, ...), (col_value, col_value, ...), ...)  </span><br><span class="line">   [STORED <span class="keyword">AS</span> DIRECTORIES] </span><br><span class="line">  ]  <span class="comment">--指定倾斜列和值</span></span><br><span class="line">  [</span><br><span class="line">   [<span class="type">ROW</span> FORMAT row_format]    </span><br><span class="line">   [STORED <span class="keyword">AS</span> file_format]</span><br><span class="line">     <span class="operator">|</span> STORED <span class="keyword">BY</span> <span class="string">&#x27;storage.handler.class.name&#x27;</span> [<span class="keyword">WITH</span> SERDEPROPERTIES (...)]  </span><br><span class="line">  ]  <span class="comment">-- 指定行分隔符、存储文件格式或采用自定义存储格式</span></span><br><span class="line">  [LOCATION hdfs_path]  <span class="comment">-- 指定表的存储位置</span></span><br><span class="line">  [TBLPROPERTIES (property_name<span class="operator">=</span>property_value, ...)]  <span class="comment">--指定表的属性</span></span><br><span class="line">  [<span class="keyword">AS</span> select_statement];   <span class="comment">--从查询结果创建表</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-内部表">2.2 内部表</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">  empno <span class="type">INT</span>,</span><br><span class="line">  ename STRING,</span><br><span class="line">  job STRING,</span><br><span class="line">  mgr <span class="type">INT</span>,</span><br><span class="line">  hiredate <span class="type">TIMESTAMP</span>,</span><br><span class="line">  sal <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">  comm <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">  deptno <span class="type">INT</span>)</span><br><span class="line">  <span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> &quot;\t&quot;;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-外部表">2.3 外部表</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> emp_external(</span><br><span class="line">  empno <span class="type">INT</span>,</span><br><span class="line">  ename STRING,</span><br><span class="line">  job STRING,</span><br><span class="line">  mgr <span class="type">INT</span>,</span><br><span class="line">  hiredate <span class="type">TIMESTAMP</span>,</span><br><span class="line">  sal <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">  comm <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">  deptno <span class="type">INT</span>)</span><br><span class="line">  <span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> &quot;\t&quot;</span><br><span class="line">  LOCATION <span class="string">&#x27;/hive/emp_external&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>使用 <code>desc format  emp_external</code> 命令可以查看表的详细信息如下：</p>
<div align="center"> <img width='700px' src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-external-table.png"/> </div>
<h3 id="2-4-分区表">2.4 分区表</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> emp_partition(</span><br><span class="line">  empno <span class="type">INT</span>,</span><br><span class="line">  ename STRING,</span><br><span class="line">  job STRING,</span><br><span class="line">  mgr <span class="type">INT</span>,</span><br><span class="line">  hiredate <span class="type">TIMESTAMP</span>,</span><br><span class="line">  sal <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">  comm <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line">  )</span><br><span class="line">  PARTITIONED <span class="keyword">BY</span> (deptno <span class="type">INT</span>)   <span class="comment">-- 按照部门编号进行分区</span></span><br><span class="line">  <span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> &quot;\t&quot;</span><br><span class="line">  LOCATION <span class="string">&#x27;/hive/emp_partition&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-分桶表">2.5 分桶表</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> emp_bucket(</span><br><span class="line">  empno <span class="type">INT</span>,</span><br><span class="line">  ename STRING,</span><br><span class="line">  job STRING,</span><br><span class="line">  mgr <span class="type">INT</span>,</span><br><span class="line">  hiredate <span class="type">TIMESTAMP</span>,</span><br><span class="line">  sal <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">  comm <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">  deptno <span class="type">INT</span>)</span><br><span class="line">  CLUSTERED <span class="keyword">BY</span>(empno) SORTED <span class="keyword">BY</span>(empno <span class="keyword">ASC</span>) <span class="keyword">INTO</span> <span class="number">4</span> BUCKETS  <span class="comment">--按照员工编号散列到四个 bucket 中</span></span><br><span class="line">  <span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> &quot;\t&quot;</span><br><span class="line">  LOCATION <span class="string">&#x27;/hive/emp_bucket&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-倾斜表">2.6 倾斜表</h3>
<p>通过指定一个或者多个列经常出现的值（严重偏斜），Hive 会自动将涉及到这些值的数据拆分为单独的文件。在查询时，如果涉及到倾斜值，它就直接从独立文件中获取数据，而不是扫描所有文件，这使得性能得到提升。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> emp_skewed(</span><br><span class="line">  empno <span class="type">INT</span>,</span><br><span class="line">  ename STRING,</span><br><span class="line">  job STRING,</span><br><span class="line">  mgr <span class="type">INT</span>,</span><br><span class="line">  hiredate <span class="type">TIMESTAMP</span>,</span><br><span class="line">  sal <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">  comm <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line">  )</span><br><span class="line">  SKEWED <span class="keyword">BY</span> (empno) <span class="keyword">ON</span> (<span class="number">66</span>,<span class="number">88</span>,<span class="number">100</span>)  <span class="comment">--指定 empno 的倾斜值 66,88,100</span></span><br><span class="line">  <span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> &quot;\t&quot;</span><br><span class="line">  LOCATION <span class="string">&#x27;/hive/emp_skewed&#x27;</span>;   </span><br></pre></td></tr></table></figure>
<h3 id="2-7-临时表">2.7 临时表</h3>
<p>临时表仅对当前 session 可见，临时表的数据将存储在用户的暂存目录中，并在会话结束后删除。如果临时表与永久表表名相同，则对该表名的任何引用都将解析为临时表，而不是永久表。临时表还具有以下两个限制：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>不支持分区列；</p>
</li>
<li class="lvl-2">
<p>不支持创建索引。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TEMPORARY <span class="keyword">TABLE</span> emp_temp(</span><br><span class="line">  empno <span class="type">INT</span>,</span><br><span class="line">  ename STRING,</span><br><span class="line">  job STRING,</span><br><span class="line">  mgr <span class="type">INT</span>,</span><br><span class="line">  hiredate <span class="type">TIMESTAMP</span>,</span><br><span class="line">  sal <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">  comm <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line">  )</span><br><span class="line">  <span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> &quot;\t&quot;;</span><br></pre></td></tr></table></figure>
<h3 id="2-8-CTAS创建表">2.8 CTAS创建表</h3>
<p>支持从查询语句的结果创建表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp_copy <span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> deptno<span class="operator">=</span><span class="string">&#x27;20&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-9-复制表结构">2.9 复制表结构</h3>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [TEMPORARY] [<span class="keyword">EXTERNAL</span>] <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [db_name.]table_name  <span class="comment">--创建表表名</span></span><br><span class="line">   <span class="keyword">LIKE</span> existing_table_or_view_name  <span class="comment">--被复制表的表名</span></span><br><span class="line">   [LOCATION hdfs_path]; <span class="comment">--存储位置</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TEMPORARY <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span>  IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>  emp_co  <span class="keyword">LIKE</span> emp</span><br></pre></td></tr></table></figure>
<h3 id="2-10-加载数据到表">2.10 加载数据到表</h3>
<p>加载数据到表中属于 DML 操作，这里为了方便大家测试，先简单介绍一下加载本地数据到表中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 加载数据到 emp 表中</span></span><br><span class="line">load data <span class="keyword">local</span> inpath &quot;/usr/file/emp.txt&quot; <span class="keyword">into</span> <span class="keyword">table</span> emp;</span><br></pre></td></tr></table></figure>
<p>其中 emp.txt 的内容如下，你可以直接复制使用，也可以到本仓库的<a href="https://github.com/oicio/BigData-Notes/tree/master/resources">resources</a> 目录下载：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">7369	SMITH	CLERK	7902	1980-12-17 00:00:00	800.00		20</span><br><span class="line">7499	ALLEN	SALESMAN	7698	1981-02-20 00:00:00	1600.00	300.00	30</span><br><span class="line">7521	WARD	SALESMAN	7698	1981-02-22 00:00:00	1250.00	500.00	30</span><br><span class="line">7566	JONES	MANAGER	7839	1981-04-02 00:00:00	2975.00		20</span><br><span class="line">7654	MARTIN	SALESMAN	7698	1981-09-28 00:00:00	1250.00	1400.00	30</span><br><span class="line">7698	BLAKE	MANAGER	7839	1981-05-01 00:00:00	2850.00		30</span><br><span class="line">7782	CLARK	MANAGER	7839	1981-06-09 00:00:00	2450.00		10</span><br><span class="line">7788	SCOTT	ANALYST	7566	1987-04-19 00:00:00	1500.00		20</span><br><span class="line">7839	KING	PRESIDENT		1981-11-17 00:00:00	5000.00		10</span><br><span class="line">7844	TURNER	SALESMAN	7698	1981-09-08 00:00:00	1500.00	0.00	30</span><br><span class="line">7876	ADAMS	CLERK	7788	1987-05-23 00:00:00	1100.00		20</span><br><span class="line">7900	JAMES	CLERK	7698	1981-12-03 00:00:00	950.00		30</span><br><span class="line">7902	FORD	ANALYST	7566	1981-12-03 00:00:00	3000.00		20</span><br><span class="line">7934	MILLER	CLERK	7782	1982-01-23 00:00:00	1300.00		10</span><br></pre></td></tr></table></figure>
<p>加载后可查询表中数据：</p>
<div align="center"> <img width='700px' src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-select-emp.png"/> </div>
<h2 id="三、修改表">三、修改表</h2>
<h3 id="3-1-重命名表">3.1 重命名表</h3>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name RENAME <span class="keyword">TO</span> new_table_name;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp_temp RENAME <span class="keyword">TO</span> new_emp; <span class="comment">--把 emp_temp 表重命名为 new_emp</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-修改列">3.2 修改列</h3>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name [<span class="keyword">PARTITION</span> partition_spec] CHANGE [<span class="keyword">COLUMN</span>] col_old_name col_new_name column_type</span><br><span class="line">  [COMMENT col_comment] [<span class="keyword">FIRST</span><span class="operator">|</span>AFTER column_name] [CASCADE<span class="operator">|</span>RESTRICT];</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 修改字段名和类型</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp_temp CHANGE empno empno_new <span class="type">INT</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 修改字段 sal 的名称 并将其放置到 empno 字段后</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp_temp CHANGE sal sal_new <span class="type">decimal</span>(<span class="number">7</span>,<span class="number">2</span>)  AFTER ename;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为字段增加注释</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp_temp CHANGE mgr mgr_new <span class="type">INT</span> COMMENT <span class="string">&#x27;this is column mgr&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-新增列">3.3 新增列</h3>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp_temp <span class="keyword">ADD</span> COLUMNS (address STRING COMMENT <span class="string">&#x27;home address&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="四、清空表-删除表">四、清空表/删除表</h2>
<h3 id="4-1-清空表">4.1 清空表</h3>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 清空整个表或表指定分区中的数据</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> table_name [<span class="keyword">PARTITION</span> (partition_column <span class="operator">=</span> partition_col_value,  ...)];</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>目前只有内部表才能执行 TRUNCATE 操作，外部表执行时会抛出异常 <code>Cannot truncate non-managed table XXXX</code>。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> emp_mgt_ptn <span class="keyword">PARTITION</span> (deptno<span class="operator">=</span><span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<h3 id="4-2-删除表">4.2 删除表</h3>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [IF <span class="keyword">EXISTS</span>] table_name [PURGE]; </span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>内部表：不仅会删除表的元数据，同时会删除 HDFS 上的数据；</p>
</li>
<li class="lvl-2">
<p>外部表：只会删除表的元数据，不会删除 HDFS 上的数据；</p>
</li>
<li class="lvl-2">
<p>删除视图引用的表时，不会给出警告（但视图已经无效了，必须由用户删除或重新创建）。</p>
</li>
</ul>
<h2 id="五、其他命令">五、其他命令</h2>
<h3 id="5-1-Describe">5.1 Describe</h3>
<p>查看数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span><span class="operator">|</span><span class="keyword">Desc</span> DATABASE [EXTENDED] db_name;  <span class="comment">--EXTENDED 是否显示额外属性</span></span><br></pre></td></tr></table></figure>
<p>查看表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span><span class="operator">|</span><span class="keyword">Desc</span> [EXTENDED<span class="operator">|</span>FORMATTED] table_name <span class="comment">--FORMATTED 以友好的展现方式查看表详情</span></span><br></pre></td></tr></table></figure>
<h3 id="5-2-Show">5.2 Show</h3>
<p><strong>1. 查看数据库列表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 语法</span></span><br><span class="line"><span class="keyword">SHOW</span> (DATABASES<span class="operator">|</span>SCHEMAS) [<span class="keyword">LIKE</span> <span class="string">&#x27;identifier_with_wildcards&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 示例：</span></span><br><span class="line"><span class="keyword">SHOW</span> DATABASES <span class="keyword">like</span> <span class="string">&#x27;hive*&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>LIKE 子句允许使用正则表达式进行过滤，但是 SHOW 语句当中的 LIKE 子句只支持 <code>*</code>（通配符）和 <code>|</code>（条件或）两个符号。例如 <code>employees</code>，<code>emp *</code>，<code>emp * | * ees</code>，所有这些都将匹配名为 <code>employees</code> 的数据库。</p>
<p><strong>2. 查看表的列表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 语法</span></span><br><span class="line"><span class="keyword">SHOW</span> TABLES [<span class="keyword">IN</span> database_name] [<span class="string">&#x27;identifier_with_wildcards&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 示例</span></span><br><span class="line"><span class="keyword">SHOW</span> TABLES <span class="keyword">IN</span> <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>
<p><strong>3. 查看视图列表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VIEWS [<span class="keyword">IN</span><span class="operator">/</span><span class="keyword">FROM</span> database_name] [<span class="keyword">LIKE</span> <span class="string">&#x27;pattern_with_wildcards&#x27;</span>];   <span class="comment">--仅支持 Hive 2.2.0 +</span></span><br></pre></td></tr></table></figure>
<p><strong>4. 查看表的分区列表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> PARTITIONS table_name;</span><br></pre></td></tr></table></figure>
<p><strong>5. 查看表/视图的创建语句</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ([db_name.]table_name<span class="operator">|</span>view_name);</span><br></pre></td></tr></table></figure>
<h2 id="参考资料-16">参考资料</h2>
<p><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL">LanguageManual DDL</a></p>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>hive</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive 常用DML操作</title>
    <url>/posts/8e3ba3ed.html</url>
    <content><![CDATA[<h2 id="一、加载文件数据到表">一、加载文件数据到表</h2>
<h3 id="1-1-语法">1.1 语法</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">LOAD DATA [LOCAL] INPATH &#x27;filepath&#x27; [OVERWRITE] </span><br><span class="line">INTO TABLE tablename [PARTITION (partcol1=val1, partcol2=val2 ...)]</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>LOCAL</code> 关键字代表从本地文件系统加载文件，省略则代表从 HDFS 上加载文件：</p>
</li>
</ul>
<ul class="lvl-0">
<li class="lvl-2">
<p>从本地文件系统加载文件时， <code>filepath</code> 可以是绝对路径也可以是相对路径 (建议使用绝对路径)；</p>
</li>
<li class="lvl-2">
<p>从 HDFS 加载文件时候，<code>filepath</code> 为文件完整的 URL 地址：如 <code>hdfs://namenode:port/user/hive/project/ data1</code></p>
</li>
</ul>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>filepath</code> 可以是文件路径 (在这种情况下 Hive 会将文件移动到表中)，也可以目录路径 (在这种情况下，Hive 会将该目录中的所有文件移动到表中)；</p>
</li>
<li class="lvl-2">
<p>如果使用 OVERWRITE 关键字，则将删除目标表（或分区）的内容，使用新的数据填充；不使用此关键字，则数据以追加的方式加入；</p>
</li>
<li class="lvl-2">
<p>加载的目标可以是表或分区。如果是分区表，则必须指定加载数据的分区；</p>
</li>
<li class="lvl-2">
<p>加载文件的格式必须与建表时使用 <code> STORED AS</code> 指定的存储格式相同。</p>
</li>
</ul>
<blockquote>
<p>使用建议：</p>
<p><strong>不论是本地路径还是 URL 都建议使用完整的</strong>。虽然可以使用不完整的 URL 地址，此时 Hive 将使用 hadoop 中的 <a href="http://fs.default.name">fs.default.name</a> 配置来推断地址，但是为避免不必要的错误，建议使用完整的本地路径或 URL 地址；</p>
<p><strong>加载对象是分区表时建议显示指定分区</strong>。在 Hive 3.0 之后，内部将加载 (LOAD) 重写为 INSERT AS SELECT，此时如果不指定分区，INSERT AS SELECT 将假设最后一组列是分区列，如果该列不是表定义的分区，它将抛出错误。为避免错误，还是建议显示指定分区。</p>
</blockquote>
<h3 id="1-2-示例">1.2 示例</h3>
<p>新建分区表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp_ptn(</span><br><span class="line">  empno <span class="type">INT</span>,</span><br><span class="line">  ename STRING,</span><br><span class="line">  job STRING,</span><br><span class="line">  mgr <span class="type">INT</span>,</span><br><span class="line">  hiredate <span class="type">TIMESTAMP</span>,</span><br><span class="line">  sal <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">  comm <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line">  )</span><br><span class="line">  PARTITIONED <span class="keyword">BY</span> (deptno <span class="type">INT</span>)   <span class="comment">-- 按照部门编号进行分区</span></span><br><span class="line">  <span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> &quot;\t&quot;;</span><br></pre></td></tr></table></figure>
<p>从 HDFS 上加载数据到分区表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">LOAD DATA  INPATH &quot;hdfs://hadoop001:8020/mydir/emp.txt&quot; OVERWRITE <span class="keyword">INTO</span> <span class="keyword">TABLE</span> emp_ptn <span class="keyword">PARTITION</span> (deptno<span class="operator">=</span><span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>emp.txt 文件可在本仓库的 resources 目录中下载</p>
</blockquote>
<p>加载后表中数据如下,分区列 deptno 全部赋值成 20：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-emp-ptn.png"/> </div>
<h2 id="二、查询结果插入到表">二、查询结果插入到表</h2>
<h3 id="2-1-语法">2.1 语法</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> tablename1 [<span class="keyword">PARTITION</span> (partcol1<span class="operator">=</span>val1, partcol2<span class="operator">=</span>val2 ...) [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>]]   </span><br><span class="line">select_statement1 <span class="keyword">FROM</span> from_statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tablename1 [<span class="keyword">PARTITION</span> (partcol1<span class="operator">=</span>val1, partcol2<span class="operator">=</span>val2 ...)] </span><br><span class="line">select_statement1 <span class="keyword">FROM</span> from_statement;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>Hive 0.13.0 开始，建表时可以通过使用 TBLPROPERTIES（“immutable”=“true”）来创建不可变表 (immutable table) ，如果不可以变表中存在数据，则 INSERT INTO 失败。（注：INSERT OVERWRITE 的语句不受 <code>immutable</code> 属性的影响）;</p>
</li>
<li class="lvl-2">
<p>可以对表或分区执行插入操作。如果表已分区，则必须通过指定所有分区列的值来指定表的特定分区；</p>
</li>
<li class="lvl-2">
<p>从 Hive 1.1.0 开始，TABLE 关键字是可选的；</p>
</li>
<li class="lvl-2">
<p>从 Hive 1.2.0 开始 ，可以采用 INSERT INTO tablename(z，x，c1) 指明插入列；</p>
</li>
<li class="lvl-2">
<p>可以将 SELECT 语句的查询结果插入多个表（或分区），称为多表插入。语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> from_statement</span><br><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> tablename1 </span><br><span class="line">[<span class="keyword">PARTITION</span> (partcol1<span class="operator">=</span>val1, partcol2<span class="operator">=</span>val2 ...) [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>]] select_statement1</span><br><span class="line">[<span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> tablename2 [<span class="keyword">PARTITION</span> ... [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>]] select_statement2]</span><br><span class="line">[<span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tablename2 [<span class="keyword">PARTITION</span> ...] select_statement2] ...;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-2-动态插入分区">2.2 动态插入分区</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> tablename <span class="keyword">PARTITION</span> (partcol1[<span class="operator">=</span>val1], partcol2[<span class="operator">=</span>val2] ...) </span><br><span class="line">select_statement <span class="keyword">FROM</span> from_statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tablename <span class="keyword">PARTITION</span> (partcol1[<span class="operator">=</span>val1], partcol2[<span class="operator">=</span>val2] ...) </span><br><span class="line">select_statement <span class="keyword">FROM</span> from_statement;</span><br></pre></td></tr></table></figure>
<p>在向分区表插入数据时候，分区列名是必须的，但是列值是可选的。如果给出了分区列值，我们将其称为静态分区，否则它是动态分区。动态分区列必须在 SELECT 语句的列中最后指定，并且与它们在 PARTITION() 子句中出现的顺序相同。</p>
<p>注意：Hive 0.9.0 之前的版本动态分区插入是默认禁用的，而 0.9.0 之后的版本则默认启用。以下是动态分区的相关配置：</p>
<table>
<thead>
<tr>
<th>配置</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>hive.exec.dynamic.partition</code></td>
<td><code>true</code></td>
<td>需要设置为 true 才能启用动态分区插入</td>
</tr>
<tr>
<td><code>hive.exec.dynamic.partition.mode</code></td>
<td><code>strict</code></td>
<td>在严格模式 (strict) 下，用户必须至少指定一个静态分区，以防用户意外覆盖所有分区，在非严格模式下，允许所有分区都是动态的</td>
</tr>
<tr>
<td><code>hive.exec.max.dynamic.partitions.pernode</code></td>
<td>100</td>
<td>允许在每个 mapper/reducer 节点中创建的最大动态分区数</td>
</tr>
<tr>
<td><code>hive.exec.max.dynamic.partitions</code></td>
<td>1000</td>
<td>允许总共创建的最大动态分区数</td>
</tr>
<tr>
<td><code>hive.exec.max.created.files</code></td>
<td>100000</td>
<td>作业中所有 mapper/reducer 创建的 HDFS 文件的最大数量</td>
</tr>
<tr>
<td><code>hive.error.on.empty.partition</code></td>
<td><code>false</code></td>
<td>如果动态分区插入生成空结果，是否抛出异常</td>
</tr>
</tbody>
</table>
<h3 id="2-3-示例">2.3 示例</h3>
<ol>
<li class="lvl-3">
<p>新建 emp 表，作为查询对象表</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">    empno <span class="type">INT</span>,</span><br><span class="line">    ename STRING,</span><br><span class="line">    job STRING,</span><br><span class="line">    mgr <span class="type">INT</span>,</span><br><span class="line">    hiredate <span class="type">TIMESTAMP</span>,</span><br><span class="line">    sal <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">    comm <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">    deptno <span class="type">INT</span>)</span><br><span class="line">    <span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> &quot;\t&quot;;</span><br><span class="line">    </span><br><span class="line"> <span class="comment">-- 加载数据到 emp 表中 这里直接从本地加载</span></span><br><span class="line">load data <span class="keyword">local</span> inpath &quot;/usr/file/emp.txt&quot; <span class="keyword">into</span> <span class="keyword">table</span> emp;</span><br></pre></td></tr></table></figure>
<p>​	完成后 <code>emp</code> 表中数据如下：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-emp.png"/> </div>
<ol start="2">
<li class="lvl-3">
<p>为清晰演示，先清空 <code>emp_ptn</code> 表中加载的数据：</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> emp_ptn;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>静态分区演示：从 <code>emp</code> 表中查询部门编号为 20 的员工数据，并插入 <code>emp_ptn</code> 表中，语句如下：</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> emp_ptn <span class="keyword">PARTITION</span> (deptno<span class="operator">=</span><span class="number">20</span>) </span><br><span class="line"><span class="keyword">SELECT</span> empno,ename,job,mgr,hiredate,sal,comm <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> deptno<span class="operator">=</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>​	完成后 <code>emp_ptn</code> 表中数据如下：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-emp-deptno-20.png"/> </div>
<ol start="4">
<li class="lvl-3">
<p>接着演示动态分区：</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 由于我们只有一个分区，且还是动态分区，所以需要关闭严格默认。因为在严格模式下，用户必须至少指定一个静态分区</span></span><br><span class="line"><span class="keyword">set</span> hive.exec.dynamic.partition.mode<span class="operator">=</span>nonstrict;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 动态分区   此时查询语句的最后一列为动态分区列，即 deptno</span></span><br><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> emp_ptn <span class="keyword">PARTITION</span> (deptno) </span><br><span class="line"><span class="keyword">SELECT</span> empno,ename,job,mgr,hiredate,sal,comm,deptno <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> deptno<span class="operator">=</span><span class="number">30</span>;</span><br></pre></td></tr></table></figure>
<p>​	完成后 <code>emp_ptn</code> 表中数据如下：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-emp-deptno-20-30.png"/> </div>
<h2 id="三、使用SQL语句插入值">三、使用SQL语句插入值</h2>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tablename [<span class="keyword">PARTITION</span> (partcol1[<span class="operator">=</span>val1], partcol2[<span class="operator">=</span>val2] ...)] </span><br><span class="line"><span class="keyword">VALUES</span> ( <span class="keyword">value</span> [, <span class="keyword">value</span> ...] )</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用时必须为表中的每个列都提供值。不支持只向部分列插入值（可以为缺省值的列提供空值来消除这个弊端）；</p>
</li>
<li class="lvl-2">
<p>如果目标表表支持 ACID 及其事务管理器，则插入后自动提交；</p>
</li>
<li class="lvl-2">
<p>不支持支持复杂类型 (array, map, struct, union) 的插入。</p>
</li>
</ul>
<h2 id="四、更新和删除数据">四、更新和删除数据</h2>
<h3 id="4-1-语法">4.1 语法</h3>
<p>更新和删除的语法比较简单，和关系型数据库一致。需要注意的是这两个操作都只能在支持 ACID 的表，也就是事务表上才能执行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 更新</span></span><br><span class="line"><span class="keyword">UPDATE</span> tablename <span class="keyword">SET</span> <span class="keyword">column</span> <span class="operator">=</span> <span class="keyword">value</span> [, <span class="keyword">column</span> <span class="operator">=</span> <span class="keyword">value</span> ...] [<span class="keyword">WHERE</span> expression]</span><br><span class="line"></span><br><span class="line"><span class="comment">--删除</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tablename [<span class="keyword">WHERE</span> expression]</span><br></pre></td></tr></table></figure>
<h3 id="4-2-示例">4.2 示例</h3>
<p><strong>1. 修改配置</strong></p>
<p>首先需要更改 <code>hive-site.xml</code>，添加如下配置，开启事务支持，配置完成后需要重启 Hive 服务。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.support.concurrency<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.enforce.bucketing<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.exec.dynamic.partition.mode<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>nonstrict<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.txn.manager<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.hive.ql.lockmgr.DbTxnManager<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.compactor.initiator.on<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.in.test<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>2. 创建测试表</strong></p>
<p>创建用于测试的事务表，建表时候指定属性 <code>transactional = true</code> 则代表该表是事务表。需要注意的是，按照<a href="https://cwiki.apache.org/confluence/display/Hive/Hive+Transactions">官方文档</a> 的说明，目前 Hive 中的事务表有以下限制：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>必须是 buckets Table;</p>
</li>
<li class="lvl-2">
<p>仅支持 ORC 文件格式；</p>
</li>
<li class="lvl-2">
<p>不支持 LOAD DATA …语句。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp_ts(  </span><br><span class="line">  empno <span class="type">int</span>,  </span><br><span class="line">  ename String</span><br><span class="line">)</span><br><span class="line">CLUSTERED <span class="keyword">BY</span> (empno) <span class="keyword">INTO</span> <span class="number">2</span> BUCKETS STORED <span class="keyword">AS</span> ORC</span><br><span class="line">TBLPROPERTIES (&quot;transactional&quot;<span class="operator">=</span>&quot;true&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>3. 插入测试数据</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> emp_ts  <span class="keyword">VALUES</span> (<span class="number">1</span>,&quot;ming&quot;),(<span class="number">2</span>,&quot;hong&quot;);</span><br></pre></td></tr></table></figure>
<p>插入数据依靠的是 MapReduce 作业，执行成功后数据如下：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-emp-ts.png"/> </div>
<p><strong>4. 测试更新和删除</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--更新数据</span></span><br><span class="line"><span class="keyword">UPDATE</span> emp_ts <span class="keyword">SET</span> ename <span class="operator">=</span> &quot;lan&quot;  <span class="keyword">WHERE</span>  empno<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--删除数据</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> emp_ts <span class="keyword">WHERE</span> empno<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>更新和删除数据依靠的也是 MapReduce 作业，执行成功后数据如下：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-emp-ts-2.png"/> </div>
<h2 id="五、查询结果写出到文件系统">五、查询结果写出到文件系统</h2>
<h3 id="5-1-语法">5.1 语法</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> OVERWRITE [<span class="keyword">LOCAL</span>] DIRECTORY directory1</span><br><span class="line">  [<span class="type">ROW</span> FORMAT row_format] [STORED <span class="keyword">AS</span> file_format] </span><br><span class="line">  <span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ...</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>OVERWRITE 关键字表示输出文件存在时，先删除后再重新写入；</p>
</li>
<li class="lvl-2">
<p>和 Load 语句一样，建议无论是本地路径还是 URL 地址都使用完整的；</p>
</li>
<li class="lvl-2">
<p>写入文件系统的数据被序列化为文本，其中列默认由^A 分隔，行由换行符分隔。如果列不是基本类型，则将其序列化为 JSON 格式。其中行分隔符不允许自定义，但列分隔符可以自定义，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 定义列分隔符为&#x27;\t&#x27; </span></span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">local</span> directory <span class="string">&#x27;./test-04&#x27;</span> </span><br><span class="line"><span class="type">row</span> format delimited </span><br><span class="line">FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\t&#x27;</span></span><br><span class="line">COLLECTION ITEMS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;,&#x27;</span></span><br><span class="line">MAP KEYS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;:&#x27;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> src;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="5-2-示例">5.2 示例</h3>
<p>这里我们将上面创建的 <code>emp_ptn</code> 表导出到本地文件系统，语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">LOCAL</span> DIRECTORY <span class="string">&#x27;/usr/file/ouput&#x27;</span></span><br><span class="line"><span class="type">ROW</span> FORMAT DELIMITED</span><br><span class="line">FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\t&#x27;</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp_ptn;</span><br></pre></td></tr></table></figure>
<p>导出结果如下：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-ouput.png"/> </div>
<h2 id="参考资料-17">参考资料</h2>
<ol>
<li class="lvl-3">
<p><a href="https://cwiki.apache.org/confluence/display/Hive/Hive+Transactions">Hive Transactions</a></p>
</li>
<li class="lvl-3">
<p><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DML">Hive Data Manipulation Language</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>hive</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive分区表和分桶表</title>
    <url>/posts/7393af63.html</url>
    <content><![CDATA[<h2 id="一、分区表">一、分区表</h2>
<h3 id="1-1-概念">1.1 概念</h3>
<p>Hive 中的表对应为 HDFS 上的指定目录，在查询数据时候，默认会对全表进行扫描，这样时间和性能的消耗都非常大。</p>
<p><strong>分区为 HDFS 上表目录的子目录</strong>，数据按照分区存储在子目录中。如果查询的 <code>where</code> 字句的中包含分区条件，则直接从该分区去查找，而不是扫描整个表目录，合理的分区设计可以极大提高查询速度和性能。</p>
<blockquote>
<p>这里说明一下分区表并 Hive 独有的概念，实际上这个概念非常常见。比如在我们常用的 Oracle 数据库中，当表中的数据量不断增大，查询数据的速度就会下降，这时也可以对表进行分区。表进行分区后，逻辑上表仍然是一张完整的表，只是将表中的数据存放到多个表空间（物理文件上），这样查询数据时，就不必要每次都扫描整张表，从而提升查询性能。</p>
</blockquote>
<h3 id="1-2-使用场景">1.2  使用场景</h3>
<p>通常，在管理大规模数据集的时候都需要进行分区，比如将日志文件按天进行分区，从而保证数据细粒度的划分，使得查询性能得到提升。</p>
<h3 id="1-3-创建分区表">1.3 创建分区表</h3>
<p>在 Hive 中可以使用 <code>PARTITIONED BY</code> 子句创建分区表。表可以包含一个或多个分区列，程序会为分区列中的每个不同值组合创建单独的数据目录。下面的我们创建一张雇员表作为测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CREATE EXTERNAL TABLE emp_partition(</span><br><span class="line">   empno INT,</span><br><span class="line">   ename STRING,</span><br><span class="line">   job STRING,</span><br><span class="line">   mgr INT,</span><br><span class="line">   hiredate TIMESTAMP,</span><br><span class="line">   sal DECIMAL(7,2),</span><br><span class="line">   comm DECIMAL(7,2)</span><br><span class="line">   )</span><br><span class="line">   PARTITIONED BY (deptno INT)   -- 按照部门编号进行分区</span><br><span class="line">   ROW FORMAT DELIMITED FIELDS TERMINATED BY &quot;\t&quot;</span><br><span class="line">   LOCATION &#x27;/hive/emp_partition&#x27;;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-加载数据到分区表">1.4 加载数据到分区表</h3>
<p>加载数据到分区表时候必须要指定数据所处的分区：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">加载部门编号为20的数据到表中</span></span><br><span class="line">LOAD DATA LOCAL INPATH &quot;/usr/file/emp20.txt&quot; OVERWRITE INTO TABLE emp_partition PARTITION (deptno=20)</span><br><span class="line"><span class="meta"># </span><span class="language-bash">加载部门编号为30的数据到表中</span></span><br><span class="line">LOAD DATA LOCAL INPATH &quot;/usr/file/emp30.txt&quot; OVERWRITE INTO TABLE emp_partition PARTITION (deptno=30)</span><br></pre></td></tr></table></figure>
<h3 id="1-5-查看分区目录">1.5 查看分区目录</h3>
<p>这时候我们直接查看表目录，可以看到表目录下存在两个子目录，分别是 <code>deptno=20</code> 和 <code>deptno=30</code>,这就是分区目录，分区目录下才是我们加载的数据文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">hadoop fs -<span class="built_in">ls</span>  hdfs://hadoop001:8020/hive/emp_partition/</span></span><br></pre></td></tr></table></figure>
<p>这时候当你的查询语句的 <code>where</code> 包含 <code>deptno=20</code>，则就去对应的分区目录下进行查找，而不用扫描全表。</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-hadoop-partitation.png"/> </div>
<h2 id="二、分桶表">二、分桶表</h2>
<h3 id="1-1-简介">1.1 简介</h3>
<p>分区提供了一个隔离数据和优化查询的可行方案，但是并非所有的数据集都可以形成合理的分区，分区的数量也不是越多越好，过多的分区条件可能会导致很多分区上没有数据。同时 Hive 会限制动态分区可以创建的最大分区数，用来避免过多分区文件对文件系统产生负担。鉴于以上原因，Hive 还提供了一种更加细粒度的数据拆分方案：分桶表 (bucket Table)。</p>
<p>分桶表会将指定列的值进行哈希散列，并对 bucket（桶数量）取余，然后存储到对应的 bucket（桶）中。</p>
<h3 id="1-2-理解分桶表">1.2 理解分桶表</h3>
<p>单从概念上理解分桶表可能会比较晦涩，其实和分区一样，分桶这个概念同样不是 Hive 独有的，对于 Java 开发人员而言，这可能是一个每天都会用到的概念，因为 Hive 中的分桶概念和 Java 数据结构中的 HashMap 的分桶概念是一致的。</p>
<p>当调用 HashMap 的 put() 方法存储数据时，程序会先对 key 值调用 hashCode() 方法计算出 hashcode，然后对数组长度取模计算出 index，最后将数据存储在数组 index 位置的链表上，链表达到一定阈值后会转换为红黑树 (JDK1.8+)。下图为 HashMap 的数据结构图：</p>
<div align="center"> <img width="600px"  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/HashMap-HashTable.png"/> </div>
<blockquote>
<p>图片引用自：<a href="http://www.itcuties.com/java/hashmap-hashtable/">HashMap vs. Hashtable</a></p>
</blockquote>
<h3 id="1-3-创建分桶表">1.3 创建分桶表</h3>
<p>在 Hive 中，我们可以通过 <code>CLUSTERED BY</code> 指定分桶列，并通过 <code>SORTED BY</code> 指定桶中数据的排序参考列。下面为分桶表建表语句示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> emp_bucket(</span><br><span class="line">  empno <span class="type">INT</span>,</span><br><span class="line">  ename STRING,</span><br><span class="line">  job STRING,</span><br><span class="line">  mgr <span class="type">INT</span>,</span><br><span class="line">  hiredate <span class="type">TIMESTAMP</span>,</span><br><span class="line">  sal <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">  comm <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">  deptno <span class="type">INT</span>)</span><br><span class="line">  CLUSTERED <span class="keyword">BY</span>(empno) SORTED <span class="keyword">BY</span>(empno <span class="keyword">ASC</span>) <span class="keyword">INTO</span> <span class="number">4</span> BUCKETS  <span class="comment">--按照员工编号散列到四个 bucket 中</span></span><br><span class="line">  <span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> &quot;\t&quot;</span><br><span class="line">  LOCATION <span class="string">&#x27;/hive/emp_bucket&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-加载数据到分桶表">1.4 加载数据到分桶表</h3>
<p>这里直接使用 <code>Load</code> 语句向分桶表加载数据，数据时可以加载成功的，但是数据并不会分桶。</p>
<p>这是由于分桶的实质是对指定字段做了 hash 散列然后存放到对应文件中，这意味着向分桶表中插入数据是必然要通过 MapReduce，且 Reducer 的数量必须等于分桶的数量。由于以上原因，分桶表的数据通常只能使用 CTAS(CREATE TABLE AS SELECT) 方式插入，因为 CTAS 操作会触发 MapReduce。加载数据步骤如下：</p>
<h4 id="1-设置强制分桶">1. 设置强制分桶</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.enforce.bucketing <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">--Hive 2.x 不需要这一步</span></span><br></pre></td></tr></table></figure>
<p>在 Hive 0.x and 1.x 版本，必须使用设置 <code>hive.enforce.bucketing = true</code>，表示强制分桶，允许程序根据表结构自动选择正确数量的 Reducer 和 cluster by  column 来进行分桶。</p>
<h4 id="2-CTAS导入数据">2. CTAS导入数据</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> emp_bucket <span class="keyword">SELECT</span> <span class="operator">*</span>  <span class="keyword">FROM</span> emp;  <span class="comment">--这里的 emp 表就是一张普通的雇员表</span></span><br></pre></td></tr></table></figure>
<p>可以从执行日志看到 CTAS 触发 MapReduce 操作，且 Reducer 数量和建表时候指定 bucket 数量一致：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-hadoop-mapreducer.png"/> </div>
<h3 id="1-5-查看分桶文件">1.5 查看分桶文件</h3>
<p>bucket(桶) 本质上就是表目录下的具体文件：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-hadoop-bucket.png"/> </div>
<h2 id="三、分区表和分桶表结合使用">三、分区表和分桶表结合使用</h2>
<p>分区表和分桶表的本质都是将数据按照不同粒度进行拆分，从而使得在查询时候不必扫描全表，只需要扫描对应的分区或分桶，从而提升查询效率。两者可以结合起来使用，从而保证表数据在不同粒度上都能得到合理的拆分。下面是 Hive 官方给出的示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> page_view_bucketed(</span><br><span class="line">	viewTime <span class="type">INT</span>, </span><br><span class="line">    userid <span class="type">BIGINT</span>,</span><br><span class="line">    page_url STRING, </span><br><span class="line">    referrer_url STRING,</span><br><span class="line">    ip STRING )</span><br><span class="line"> PARTITIONED <span class="keyword">BY</span>(dt STRING)</span><br><span class="line"> CLUSTERED <span class="keyword">BY</span>(userid) SORTED <span class="keyword">BY</span>(viewTime) <span class="keyword">INTO</span> <span class="number">32</span> BUCKETS</span><br><span class="line"> <span class="type">ROW</span> FORMAT DELIMITED</span><br><span class="line">   FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\001&#x27;</span></span><br><span class="line">   COLLECTION ITEMS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\002&#x27;</span></span><br><span class="line">   MAP KEYS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\003&#x27;</span></span><br><span class="line"> STORED <span class="keyword">AS</span> SEQUENCEFILE;</span><br></pre></td></tr></table></figure>
<p>此时导入数据时需要指定分区：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">INSERT OVERWRITE page_view_bucketed</span><br><span class="line">PARTITION (dt=&#x27;2009-02-25&#x27;)</span><br><span class="line">SELECT * FROM page_view WHERE dt=&#x27;2009-02-25&#x27;;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料-18">参考资料</h2>
<ol>
<li class="lvl-3">
<p><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL+BucketedTables">LanguageManual DDL BucketedTables</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>hive</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive数据查询实战</title>
    <url>/posts/a8d1717b.html</url>
    <content><![CDATA[<h2 id="一、数据准备">一、数据准备</h2>
<p>为了演示查询操作，这里需要预先创建三张表，并加载测试数据。</p>
<blockquote>
<p>数据文件 emp.txt 和 dept.txt 可以从本仓库的<a href="https://gitee.com/oicio/BigData-Notes/tree/master/resources">resources</a> 目录下载。</p>
</blockquote>
<h3 id="1-1-员工表">1.1 员工表</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> <span class="comment">-- 建表语句</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">                    empno <span class="type">INT</span>,     <span class="comment">-- 员工表编号</span></span><br><span class="line">                    ename STRING,  <span class="comment">-- 员工姓名</span></span><br><span class="line">                    job STRING,    <span class="comment">-- 职位类型</span></span><br><span class="line">                    mgr <span class="type">INT</span>,</span><br><span class="line">                    hiredate <span class="type">TIMESTAMP</span>,  <span class="comment">--雇佣日期</span></span><br><span class="line">                    sal <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),  <span class="comment">--工资</span></span><br><span class="line">                    comm <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">                    deptno <span class="type">INT</span>)   <span class="comment">--部门编号</span></span><br><span class="line">    <span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> &quot;\t&quot;;</span><br><span class="line"></span><br><span class="line"><span class="comment">--加载数据</span></span><br><span class="line">LOAD DATA <span class="keyword">LOCAL</span> INPATH &quot;/usr/file/emp.txt&quot; OVERWRITE <span class="keyword">INTO</span> <span class="keyword">TABLE</span> emp;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-部门表">1.2 部门表</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建表语句</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept(</span><br><span class="line">    deptno <span class="type">INT</span>,   <span class="comment">--部门编号</span></span><br><span class="line">    dname STRING,  <span class="comment">--部门名称</span></span><br><span class="line">    loc STRING    <span class="comment">--部门所在的城市</span></span><br><span class="line">)</span><br><span class="line"><span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> &quot;\t&quot;;</span><br><span class="line"></span><br><span class="line"><span class="comment">--加载数据</span></span><br><span class="line">LOAD DATA <span class="keyword">LOCAL</span> INPATH &quot;/usr/file/dept.txt&quot; OVERWRITE <span class="keyword">INTO</span> <span class="keyword">TABLE</span> dept;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-分区表">1.3 分区表</h3>
<p>这里需要额外创建一张分区表，主要是为了演示分区查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> emp_ptn(</span><br><span class="line">      empno <span class="type">INT</span>,</span><br><span class="line">      ename STRING,</span><br><span class="line">      job STRING,</span><br><span class="line">      mgr <span class="type">INT</span>,</span><br><span class="line">      hiredate <span class="type">TIMESTAMP</span>,</span><br><span class="line">      sal <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">      comm <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line">  )</span><br><span class="line"> PARTITIONED <span class="keyword">BY</span> (deptno <span class="type">INT</span>)   <span class="comment">-- 按照部门编号进行分区</span></span><br><span class="line"> <span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> &quot;\t&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--加载数据</span></span><br><span class="line">LOAD DATA <span class="keyword">LOCAL</span> INPATH &quot;/usr/file/emp.txt&quot; OVERWRITE <span class="keyword">INTO</span> <span class="keyword">TABLE</span> emp_ptn <span class="keyword">PARTITION</span> (deptno<span class="operator">=</span><span class="number">20</span>)</span><br><span class="line">LOAD DATA <span class="keyword">LOCAL</span> INPATH &quot;/usr/file/emp.txt&quot; OVERWRITE <span class="keyword">INTO</span> <span class="keyword">TABLE</span> emp_ptn <span class="keyword">PARTITION</span> (deptno<span class="operator">=</span><span class="number">30</span>)</span><br><span class="line">LOAD DATA <span class="keyword">LOCAL</span> INPATH &quot;/usr/file/emp.txt&quot; OVERWRITE <span class="keyword">INTO</span> <span class="keyword">TABLE</span> emp_ptn <span class="keyword">PARTITION</span> (deptno<span class="operator">=</span><span class="number">40</span>)</span><br><span class="line">LOAD DATA <span class="keyword">LOCAL</span> INPATH &quot;/usr/file/emp.txt&quot; OVERWRITE <span class="keyword">INTO</span> <span class="keyword">TABLE</span> emp_ptn <span class="keyword">PARTITION</span> (deptno<span class="operator">=</span><span class="number">50</span>)</span><br></pre></td></tr></table></figure>
<h2 id="二、单表查询">二、单表查询</h2>
<h3 id="2-1-SELECT">2.1 SELECT</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询表中全部数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-WHERE">2.2 WHERE</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询 10 号部门中员工编号大于 7782 的员工信息 </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empno <span class="operator">&gt;</span> <span class="number">7782</span> <span class="keyword">AND</span> deptno <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-DISTINCT">2.3  DISTINCT</h3>
<p>Hive 支持使用 DISTINCT 关键字去重。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询所有工作类型</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> job <span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-分区查询">2.4 分区查询</h3>
<p>分区查询 (Partition Based Queries)，可以指定某个分区或者分区范围。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询分区表中部门编号在[20,40]之间的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> emp_ptn.<span class="operator">*</span> <span class="keyword">FROM</span> emp_ptn</span><br><span class="line"><span class="keyword">WHERE</span> emp_ptn.deptno <span class="operator">&gt;=</span> <span class="number">20</span> <span class="keyword">AND</span> emp_ptn.deptno <span class="operator">&lt;=</span> <span class="number">40</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-LIMIT">2.5 LIMIT</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询薪资最高的 5 名员工</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">ORDER</span> <span class="keyword">BY</span> sal <span class="keyword">DESC</span> LIMIT <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-GROUP-BY">2.6 GROUP BY</h3>
<p>Hive 支持使用 GROUP BY 进行分组聚合操作。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.map.aggr<span class="operator">=</span><span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询各个部门薪酬综合</span></span><br><span class="line"><span class="keyword">SELECT</span> deptno,<span class="built_in">SUM</span>(sal) <span class="keyword">FROM</span> emp <span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno;</span><br></pre></td></tr></table></figure>
<p><code>hive.map.aggr</code> 控制程序如何进行聚合。默认值为 false。如果设置为 true，Hive 会在 map 阶段就执行一次聚合。这可以提高聚合效率，但需要消耗更多内存。</p>
<h3 id="2-7-ORDER-AND-SORT">2.7 ORDER AND SORT</h3>
<p>可以使用 ORDER BY 或者 Sort BY 对查询结果进行排序，排序字段可以是整型也可以是字符串：如果是整型，则按照大小排序；如果是字符串，则按照字典序排序。ORDER BY 和 SORT BY 的区别如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用 ORDER BY 时会有一个 Reducer 对全部查询结果进行排序，可以保证数据的全局有序性；</p>
</li>
<li class="lvl-2">
<p>使用 SORT BY 时只会在每个 Reducer 中进行排序，这可以保证每个 Reducer 的输出数据是有序的，但不能保证全局有序。</p>
</li>
</ul>
<p>由于 ORDER BY 的时间可能很长，如果你设置了严格模式 (hive.mapred.mode = strict)，则其后面必须再跟一个 <code>limit</code> 子句。</p>
<blockquote>
<p>注 ：hive.mapred.mode 默认值是 nonstrict ，也就是非严格模式。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询员工工资，结果按照部门升序，按照工资降序排列</span></span><br><span class="line"><span class="keyword">SELECT</span> empno, deptno, sal <span class="keyword">FROM</span> emp <span class="keyword">ORDER</span> <span class="keyword">BY</span> deptno <span class="keyword">ASC</span>, sal <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-8-HAVING">2.8 HAVING</h3>
<p>可以使用 HAVING 对分组数据进行过滤。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询工资总和大于 9000 的所有部门</span></span><br><span class="line"><span class="keyword">SELECT</span> deptno,<span class="built_in">SUM</span>(sal) <span class="keyword">FROM</span> emp <span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno <span class="keyword">HAVING</span> <span class="built_in">SUM</span>(sal)<span class="operator">&gt;</span><span class="number">9000</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-9-DISTRIBUTE-BY">2.9 DISTRIBUTE BY</h3>
<p>如果想要把具有相同 Key 值的数据分发到同一个 Reducer 进行处理，这可以使用 DISTRIBUTE BY 字句。需要注意的是，DISTRIBUTE BY 虽然能把具有相同 Key 值的数据分发到同一个 Reducer，但是不能保证数据在 Reducer 上是有序的。情况如下：</p>
<p>把以下 5 个数据发送到两个 Reducer 上进行处理：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">k1</span></span><br><span class="line"><span class="attr">k2</span></span><br><span class="line"><span class="attr">k4</span></span><br><span class="line"><span class="attr">k3</span></span><br><span class="line"><span class="attr">k1</span></span><br></pre></td></tr></table></figure>
<p>Reducer1 得到如下乱序数据：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">k1</span></span><br><span class="line"><span class="attr">k2</span></span><br><span class="line"><span class="attr">k1</span></span><br></pre></td></tr></table></figure>
<p>Reducer2 得到数据如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">k4</span></span><br><span class="line"><span class="attr">k3</span></span><br></pre></td></tr></table></figure>
<p>如果想让 Reducer 上的数据是有序的，可以结合 <code>SORT BY</code> 使用 (示例如下)，或者使用下面我们将要介绍的 CLUSTER BY。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 将数据按照部门分发到对应的 Reducer 上处理</span></span><br><span class="line"><span class="keyword">SELECT</span> empno, deptno, sal <span class="keyword">FROM</span> emp DISTRIBUTE <span class="keyword">BY</span> deptno SORT <span class="keyword">BY</span> deptno <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-10-CLUSTER-BY">2.10 CLUSTER BY</h3>
<p>如果 <code>SORT BY</code> 和 <code>DISTRIBUTE BY</code> 指定的是相同字段，且 SORT BY 排序规则是 ASC，此时可以使用 <code>CLUSTER BY</code> 进行替换，同时 <code>CLUSTER BY</code> 可以保证数据在全局是有序的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empno, deptno, sal <span class="keyword">FROM</span> emp CLUSTER  <span class="keyword">BY</span> deptno ;</span><br></pre></td></tr></table></figure>
<h2 id="三、多表联结查询">三、多表联结查询</h2>
<p>Hive 支持内连接，外连接，左外连接，右外连接，笛卡尔连接，这和传统数据库中的概念是一致的，可以参见下图。</p>
<p>需要特别强调：JOIN 语句的关联条件必须用 ON 指定，不能用 WHERE 指定，否则就会先做笛卡尔积，再过滤，这会导致你得不到预期的结果 (下面的演示会有说明)。</p>
<div align="center"> <img width="600px"  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/sql-join.jpg"/> </div>
<h3 id="3-1-INNER-JOIN">3.1 INNER JOIN</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询员工编号为 7369 的员工的详细信息</span></span><br><span class="line"><span class="keyword">SELECT</span> e.<span class="operator">*</span>,d.<span class="operator">*</span> <span class="keyword">FROM</span> </span><br><span class="line">emp e <span class="keyword">JOIN</span> dept d</span><br><span class="line"><span class="keyword">ON</span> e.deptno <span class="operator">=</span> d.deptno </span><br><span class="line"><span class="keyword">WHERE</span> empno<span class="operator">=</span><span class="number">7369</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--如果是三表或者更多表连接，语法如下</span></span><br><span class="line"><span class="keyword">SELECT</span> a.val, b.val, c.val <span class="keyword">FROM</span> a <span class="keyword">JOIN</span> b <span class="keyword">ON</span> (a.key <span class="operator">=</span> b.key1) <span class="keyword">JOIN</span> c <span class="keyword">ON</span> (c.key <span class="operator">=</span> b.key1)</span><br></pre></td></tr></table></figure>
<h3 id="3-2-LEFT-OUTER-JOIN">3.2 LEFT OUTER  JOIN</h3>
<p>LEFT OUTER  JOIN 和 LEFT  JOIN 是等价的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 左连接</span></span><br><span class="line"><span class="keyword">SELECT</span> e.<span class="operator">*</span>,d.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> emp e <span class="keyword">LEFT</span> <span class="keyword">OUTER</span>  <span class="keyword">JOIN</span>  dept d</span><br><span class="line"><span class="keyword">ON</span> e.deptno <span class="operator">=</span> d.deptno;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-RIGHT-OUTER-JOIN">3.3 RIGHT OUTER  JOIN</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--右连接</span></span><br><span class="line"><span class="keyword">SELECT</span> e.<span class="operator">*</span>,d.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> emp e <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span>  dept d</span><br><span class="line"><span class="keyword">ON</span> e.deptno <span class="operator">=</span> d.deptno;</span><br></pre></td></tr></table></figure>
<p>执行右连接后，由于 40 号部门下没有任何员工，所以此时员工信息为 NULL。这个查询可以很好的复述上面提到的——JOIN 语句的关联条件必须用 ON 指定，不能用 WHERE 指定。你可以把 ON 改成 WHERE，你会发现无论如何都查不出 40 号部门这条数据，因为笛卡尔运算不会有 (NULL, 40) 这种情况。</p>
<div align="center"> <img width="700px"   src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-right-join.png"/> </div>
### 3.4 FULL OUTER  JOIN 
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.<span class="operator">*</span>,d.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> emp e <span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span>  dept d</span><br><span class="line"><span class="keyword">ON</span> e.deptno <span class="operator">=</span> d.deptno;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-LEFT-SEMI-JOIN">3.5 LEFT SEMI JOIN</h3>
<p>LEFT SEMI JOIN （左半连接）是 IN/EXISTS 子查询的一种更高效的实现。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>JOIN 子句中右边的表只能在 ON 子句中设置过滤条件;</p>
</li>
<li class="lvl-2">
<p>查询结果只包含左边表的数据，所以只能 SELECT 左表中的列。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询在纽约办公的所有员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> emp.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> emp <span class="keyword">LEFT</span> SEMI <span class="keyword">JOIN</span> dept </span><br><span class="line"><span class="keyword">ON</span> emp.deptno <span class="operator">=</span> dept.deptno <span class="keyword">AND</span> dept.loc<span class="operator">=</span>&quot;NEW YORK&quot;;</span><br><span class="line"></span><br><span class="line"><span class="comment">--上面的语句就等价于</span></span><br><span class="line"><span class="keyword">SELECT</span> emp.<span class="operator">*</span> <span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> emp.deptno <span class="keyword">IN</span> (<span class="keyword">SELECT</span> deptno <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> loc<span class="operator">=</span>&quot;NEW YORK&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="3-6-JOIN">3.6 JOIN</h3>
<p>笛卡尔积连接，这个连接日常的开发中可能很少遇到，且性能消耗比较大，基于这个原因，如果在严格模式下 (hive.mapred.mode = strict)，Hive 会阻止用户执行此操作。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">JOIN</span> dept;</span><br></pre></td></tr></table></figure>
<h2 id="四、JOIN优化">四、JOIN优化</h2>
<h3 id="4-1-STREAMTABLE">4.1 STREAMTABLE</h3>
<p>在多表进行联结的时候，如果每个 ON 字句都使用到共同的列（如下面的 <code>b.key</code>），此时 Hive 会进行优化，将多表 JOIN 在同一个 map / reduce 作业上进行。同时假定查询的最后一个表（如下面的 c 表）是最大的一个表，在对每行记录进行 JOIN 操作时，它将尝试将其他的表缓存起来，然后扫描最后那个表进行计算。因此用户需要保证查询的表的大小从左到右是依次增加的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">`<span class="keyword">SELECT</span> a.val, b.val, c.val <span class="keyword">FROM</span> a <span class="keyword">JOIN</span> b <span class="keyword">ON</span> (a.key <span class="operator">=</span> b.key) <span class="keyword">JOIN</span> c <span class="keyword">ON</span> (c.key <span class="operator">=</span> b.key)`</span><br></pre></td></tr></table></figure>
<p>然后，用户并非需要总是把最大的表放在查询语句的最后面，Hive 提供了 <code>/*+ STREAMTABLE() */</code> 标志，用于标识最大的表，示例如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ STREAMTABLE(d) */</span>  e.<span class="operator">*</span>,d.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> emp e <span class="keyword">JOIN</span> dept d</span><br><span class="line"><span class="keyword">ON</span> e.deptno <span class="operator">=</span> d.deptno</span><br><span class="line"><span class="keyword">WHERE</span> job<span class="operator">=</span><span class="string">&#x27;CLERK&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-MAPJOIN">4.2 MAPJOIN</h3>
<p>如果所有表中只有一张表是小表，那么 Hive 把这张小表加载到内存中。这时候程序会在 map 阶段直接拿另外一个表的数据和内存中表数据做匹配，由于在 map 就进行了 JOIN 操作，从而可以省略 reduce 过程，这样效率可以提升很多。Hive 中提供了 <code>/*+ MAPJOIN() */</code> 来标记小表，示例如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ MAPJOIN(d) */</span> e.<span class="operator">*</span>,d.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> emp e <span class="keyword">JOIN</span> dept d</span><br><span class="line"><span class="keyword">ON</span> e.deptno <span class="operator">=</span> d.deptno</span><br><span class="line"><span class="keyword">WHERE</span> job<span class="operator">=</span><span class="string">&#x27;CLERK&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="五、SELECT的其他用途">五、SELECT的其他用途</h2>
<p>查看当前数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> current_database()</span><br></pre></td></tr></table></figure>
<h2 id="六、本地模式">六、本地模式</h2>
<p>在上面演示的语句中，大多数都会触发 MapReduce, 少部分不会触发，比如 <code>select * from emp limit 5</code> 就不会触发 MR，此时 Hive 只是简单的读取数据文件中的内容，然后格式化后进行输出。在需要执行 MapReduce 的查询中，你会发现执行时间可能会很长，这时候你可以选择开启本地模式。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--本地模式默认关闭，需要手动开启此功能</span></span><br><span class="line"><span class="keyword">SET</span> hive.exec.mode.local.auto<span class="operator">=</span><span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>启用后，Hive 将分析查询中每个 map-reduce 作业的大小，如果满足以下条件，则可以在本地运行它：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>作业的总输入大小低于：hive.exec.mode.local.auto.inputbytes.max（默认为 128MB）；</p>
</li>
<li class="lvl-2">
<p>map-tasks 的总数小于：hive.exec.mode.local.auto.tasks.max（默认为 4）；</p>
</li>
<li class="lvl-2">
<p>所需的 reduce 任务总数为 1 或 0。</p>
</li>
</ul>
<p>因为我们测试的数据集很小，所以你再次去执行上面涉及 MR 操作的查询，你会发现速度会有显著的提升。</p>
<h2 id="参考资料-19">参考资料</h2>
<ol>
<li class="lvl-3">
<p><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Select">LanguageManual Select</a></p>
</li>
<li class="lvl-3">
<p><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Joins">LanguageManual Joins</a></p>
</li>
<li class="lvl-3">
<p><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+GroupBy">LanguageManual GroupBy</a></p>
</li>
<li class="lvl-3">
<p><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+SortBy">LanguageManual SortBy</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>hive</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive条件与日期函数汇总</title>
    <url>/posts/b9b34c29.html</url>
    <content><![CDATA[<h2 id="条件函数">条件函数</h2>
<h3 id="assert-true-BOOLEAN-condition">assert_true(BOOLEAN condition)</h3>
<ul class="lvl-0">
<li class="lvl-2">解释</li>
</ul>
<p>如果condition不为true，则抛出异常，否则返回null</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> assert_true(<span class="number">1</span><span class="operator">&lt;</span><span class="number">2</span>) <span class="comment">-- 返回null</span></span><br><span class="line"><span class="keyword">select</span> assert_true(<span class="number">1</span><span class="operator">&gt;</span><span class="number">2</span>) <span class="comment">-- 抛出异常</span></span><br></pre></td></tr></table></figure>
<h3 id="coalesce-T-v1-T-v2-…">coalesce(T v1, T v2, …)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回第一个不为null的值，如果都为null，则返回null</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">coalesce</span>(<span class="keyword">null</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="keyword">null</span>)  <span class="comment">-- 返回1</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">coalesce</span>(<span class="number">1</span>,<span class="keyword">null</span>) <span class="comment">-- 返回1</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">coalesce</span>(<span class="keyword">null</span>,<span class="keyword">null</span>) <span class="comment">-- 返回null</span></span><br></pre></td></tr></table></figure>
<h3 id="if-BOOLEAN-testCondition-valueTrue-valueFalseOrNull">if(BOOLEAN testCondition,valueTrue, valueFalseOrNull)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>如果testCondition条件为true，则返回第一个值，否则返回第二个值</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> if(<span class="number">1</span> <span class="keyword">is</span> <span class="keyword">null</span>,<span class="number">0</span>,<span class="number">1</span>)  <span class="comment">-- 返回1</span></span><br><span class="line"><span class="keyword">select</span> if(<span class="keyword">null</span> <span class="keyword">is</span> <span class="keyword">null</span>,<span class="number">0</span>,<span class="number">1</span>) <span class="comment">-- 返回0</span></span><br></pre></td></tr></table></figure>
<h3 id="isnotnull-a">isnotnull(a)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>如果参数a不为null，则返回true，否则返回false</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> isnotnull(<span class="number">1</span>) <span class="comment">-- 返回true</span></span><br><span class="line"><span class="keyword">select</span> isnotnull(<span class="keyword">null</span>) <span class="comment">-- 返回false</span></span><br></pre></td></tr></table></figure>
<h3 id="isnull-a">isnull(a)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>与isnotnull相反，如果参数a为null，则返回true，否则返回false</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> isnull(<span class="keyword">null</span>) <span class="comment">-- 返回true</span></span><br><span class="line"><span class="keyword">select</span> isnull(<span class="number">1</span>) <span class="comment">-- 返回false</span></span><br></pre></td></tr></table></figure>
<h3 id="nullif-a-b">nullif(a, b)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>如果参数a=b，返回null，否则返回a值(Hive2.2.0版本)</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">nullif</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">-- 返回1</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">nullif</span>(<span class="number">1</span>,<span class="number">1</span>) <span class="comment">-- 返回null</span></span><br></pre></td></tr></table></figure>
<h3 id="nvl-T-value-T-default-value">nvl(T value, T default_value)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>如果value的值为null，则返回default_value默认值，否则返回value的值。在null值判断时，可以使用if函数给定默认值，也可以使用此函数给定默认值，使用该函数sql特别简洁。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> nvl(<span class="number">1</span>,<span class="number">0</span>) <span class="comment">-- 返回1</span></span><br><span class="line"><span class="keyword">select</span> nvl(<span class="keyword">null</span>,<span class="number">0</span>) <span class="comment">-- 返回0</span></span><br></pre></td></tr></table></figure>
<h2 id="日期函数">日期函数</h2>
<h3 id="add-months-DATE-STRING-TIMESTAMP-start-date-INT-num-months">add_months(DATE|STRING|TIMESTAMP start_date, INT num_months)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>  start_date参数可以是string, date 或者timestamp类型，num_months参数时int类型。返回一个日期，该日期是在start_date基础之上加上num_months个月，即start_date之后null_months个月的一个日期。如果start_date的时间部分的数据会被忽略。注意：如果start_date所在月份的天数大于结果日期月的天数，则返回结果月的最后一天的日期。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> add_months(&quot;2020-05-20&quot;,<span class="number">2</span>); <span class="comment">-- 返回2020-07-20</span></span><br><span class="line"><span class="keyword">select</span> add_months(&quot;2020-05-20&quot;,<span class="number">8</span>); <span class="comment">-- 返回2021-01-20</span></span><br><span class="line"><span class="keyword">select</span> add_months(&quot;2020-05-31&quot;,<span class="number">1</span>); <span class="comment">-- 返回2020-06-30,5月有31天，6月只有30天，所以返回下一个月的最后一天</span></span><br></pre></td></tr></table></figure>
<h3 id="current-date">current_date</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回查询时刻的当前日期</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">current_date</span>() <span class="comment">-- 返回当前查询日期2020-05-20</span></span><br></pre></td></tr></table></figure>
<h3 id="current-timestamp">current_timestamp()</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回查询时刻的当前时间</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">current_timestamp</span>() <span class="comment">-- 2020-05-20 14:40:47.273</span></span><br></pre></td></tr></table></figure>
<h3 id="datediff-STRING-enddate-STRING-startdate">datediff(STRING enddate, STRING startdate)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回开始日期startdate与结束日期enddate之前相差的天数</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> datediff(&quot;2020-05-20&quot;,&quot;2020-05-21&quot;); <span class="comment">-- 返回-1</span></span><br><span class="line"><span class="keyword">select</span> datediff(&quot;2020-05-21&quot;,&quot;2020-05-20&quot;); <span class="comment">-- 返回1</span></span><br></pre></td></tr></table></figure>
<h3 id="date-add-DATE-startdate-INT-days">date_add(DATE startdate, INT days)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>在startdate基础上加上几天，然后返回加上几天之后的一个日期</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> date_add(&quot;2020-05-20&quot;,<span class="number">1</span>); <span class="comment">-- 返回2020-05-21,1表示加1天</span></span><br><span class="line"><span class="keyword">select</span> date_add(&quot;2020-05-20&quot;,<span class="number">-1</span>); <span class="comment">-- 返回2020-05-19，-1表示减一天</span></span><br></pre></td></tr></table></figure>
<h3 id="date-sub-DATE-startdate-INT-days">date_sub(DATE startdate, INT days)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>在startdate基础上减去几天，然后返回减去几天之后的一个日期,功能与date_add很类似</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> date_sub(&quot;2020-05-20&quot;,<span class="number">1</span>); <span class="comment">-- 返回2020-05-19,1表示减1天</span></span><br><span class="line"><span class="keyword">select</span> date_sub(&quot;2020-05-20&quot;,<span class="number">-1</span>); <span class="comment">-- 返回2020-05-21，-1表示加1天</span></span><br></pre></td></tr></table></figure>
<h3 id="date-format-DATE-TIMESTAMP-STRING-ts-STRING-fmt">date_format(DATE|TIMESTAMP|STRING ts, STRING fmt)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>将date/timestamp/string类型的值转换为一个具体格式化的字符串。支持java的SimpleDateFormat格式，第二个参数fmt必须是一个常量</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> date_format(<span class="string">&#x27;2020-05-20&#x27;</span>, <span class="string">&#x27;yyyy&#x27;</span>); <span class="comment">-- 返回2020</span></span><br><span class="line"><span class="keyword">select</span> date_format(<span class="string">&#x27;2020-05-20&#x27;</span>, <span class="string">&#x27;MM&#x27;</span>); <span class="comment">-- 返回05</span></span><br><span class="line"><span class="keyword">select</span> date_format(<span class="string">&#x27;2020-05-20&#x27;</span>, <span class="string">&#x27;dd&#x27;</span>); <span class="comment">-- 返回20</span></span><br><span class="line"><span class="comment">-- 返回2020年05月20日 00时00分00秒</span></span><br><span class="line"><span class="keyword">select</span> date_format(<span class="string">&#x27;2020-05-20&#x27;</span>, <span class="string">&#x27;yyyy年MM月dd日 HH时mm分ss秒&#x27;</span>) ;</span><br><span class="line"><span class="keyword">select</span> date_format(<span class="string">&#x27;2020-05-20&#x27;</span>, <span class="string">&#x27;yy/MM/dd&#x27;</span>) <span class="comment">-- 返回 20/05/20</span></span><br></pre></td></tr></table></figure>
<h3 id="dayofmonth-STRING-date">dayofmonth(STRING date)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回一个日期或时间的天,与day()函数功能相同</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> dayofmonth(<span class="string">&#x27;2020-05-20&#x27;</span>) <span class="comment">-- 返回20</span></span><br></pre></td></tr></table></figure>
<h3 id="extract-field-FROM-source">extract(field FROM source)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>  提取 day, dayofweek, hour, minute, month, quarter, second, week 或者year的值，field可以选择day, dayofweek, hour, minute, month, quarter, second, week 或者year，source必须是一个date、timestamp或者可以转为 date 、timestamp的字符串。注意：Hive 2.2.0版本之后支持该函数</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="string">&#x27;2020-05-20 15:21:34.467&#x27;</span>); <span class="comment">-- 返回2020，年</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(quarter <span class="keyword">from</span> <span class="string">&#x27;2020-05-20 15:21:34.467&#x27;</span>); <span class="comment">-- 返回2，季度</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(<span class="keyword">month</span> <span class="keyword">from</span> <span class="string">&#x27;2020-05-20 15:21:34.467&#x27;</span>); <span class="comment">-- 返回05，月份</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(week <span class="keyword">from</span> <span class="string">&#x27;2020-05-20 15:21:34.467&#x27;</span>); <span class="comment">-- 返回21，同weekofyear，一年中的第几周</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(dayofweek <span class="keyword">from</span> <span class="string">&#x27;2020-05-20 15:21:34.467&#x27;</span>); <span class="comment">-- 返回4,代表星期三</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(<span class="keyword">day</span> <span class="keyword">from</span> <span class="string">&#x27;2020-05-20 15:21:34.467&#x27;</span>); <span class="comment">-- 返回20，天</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(<span class="keyword">hour</span> <span class="keyword">from</span> <span class="string">&#x27;2020-05-20 15:21:34.467&#x27;</span>); <span class="comment">-- 返回15，小时</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(<span class="keyword">minute</span> <span class="keyword">from</span> <span class="string">&#x27;2020-05-20 15:21:34.467&#x27;</span>); <span class="comment">-- 返回21，分钟</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(<span class="keyword">second</span> <span class="keyword">from</span> <span class="string">&#x27;2020-05-20 15:21:34.467&#x27;</span>); <span class="comment">-- 返回34，秒</span></span><br></pre></td></tr></table></figure>
<h4 id="year-STRING-date">year(STRING date)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回时间的年份,可以用extract函数替代</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">year</span>(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>); <span class="comment">-- 返回2020</span></span><br></pre></td></tr></table></figure>
<h4 id="quarter-DATE-TIMESTAMP-STRING-a">quarter(DATE|TIMESTAMP|STRING a)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回给定时间或日期的季度，1至4个季度,可以用extract函数替代</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> quarter(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>); <span class="comment">-- 返回2，第2季度</span></span><br></pre></td></tr></table></figure>
<h4 id="month-STRING-date">month(STRING date)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回时间的月份,可以用extract函数替代</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">month</span>(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>) <span class="comment">-- 返回5</span></span><br></pre></td></tr></table></figure>
<h4 id="day-STRING-date">day(STRING date)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回一个日期或者时间的天,可以用extract函数替代</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">day</span>(&quot;2020-05-20&quot;); <span class="comment">-- 返回20</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">day</span>(&quot;2020-05-20 15:05:27.5&quot;); <span class="comment">-- 返回20</span></span><br></pre></td></tr></table></figure>
<h4 id="hour-STRING-date">hour(STRING date)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回一个时间的小时,可以用extract函数替代</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">hour</span>(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>);<span class="comment">-- 返回15</span></span><br></pre></td></tr></table></figure>
<h4 id="minute-STRING-date">minute(STRING date)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回一个时间的分钟值,可以用extract函数替代</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">minute</span>(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>); <span class="comment">-- 返回21</span></span><br></pre></td></tr></table></figure>
<h4 id="second-STRING-date">second(STRING date)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回一个时间的秒,可以用extract函数替代</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">second</span>(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>); <span class="comment">--返回34</span></span><br></pre></td></tr></table></figure>
<h3 id="from-unixtime-BIGINT-unixtime-STRING-format">from_unixtime(BIGINT unixtime [, STRING format])</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>将Unix时间戳转换为字符串格式的时间(比如yyyy-MM-dd HH:mm:ss格式)</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> from_unixtime(<span class="number">1589960708</span>); <span class="comment">-- 返回2020-05-20 15:45:08</span></span><br><span class="line"><span class="keyword">select</span> from_unixtime(<span class="number">1589960708</span>, <span class="string">&#x27;yyyy-MM-dd hh:mm:ss&#x27;</span>); <span class="comment">-- -- 返回2020-05-20 15:45:08</span></span><br><span class="line"><span class="keyword">select</span> from_unixtime(<span class="number">1589960708</span>, <span class="string">&#x27;yyyy-MM-dd&#x27;</span>); <span class="comment">-- 返回2020-05-20</span></span><br></pre></td></tr></table></figure>
<h3 id="from-utc-timestamp-T-a-STRING-timezone">from_utc_timestamp(T a, STRING timezone)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>转换为特定时区的时间</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> from_utc_timestamp(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>,<span class="string">&#x27;PST&#x27;</span>); <span class="comment">-- 返回2020-05-20 08:21:34.0</span></span><br><span class="line"><span class="keyword">select</span> from_utc_timestamp(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>,<span class="string">&#x27;GMT&#x27;</span>); <span class="comment">-- 返回2020-05-20 15:21:34.0</span></span><br><span class="line"><span class="keyword">select</span> from_utc_timestamp(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>,<span class="string">&#x27;UTC&#x27;</span>); <span class="comment">-- 返回2020-05-20 15:21:34.0</span></span><br><span class="line"><span class="keyword">select</span> from_utc_timestamp(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>,<span class="string">&#x27;DST&#x27;</span>); <span class="comment">-- 返回2020-05-20 15:21:34.0</span></span><br><span class="line"><span class="keyword">select</span> from_utc_timestamp(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>,<span class="string">&#x27;CST&#x27;</span>); <span class="comment">-- 返回2020-05-20 10:21:34.0</span></span><br></pre></td></tr></table></figure>
<h3 id="last-day-STRING-date">last_day(STRING date)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回给定时间或日期所在月的最后一天，参数可以是’yyyy-MM-dd HH:mm:ss’ 或者 ‘yyyy-MM-dd’类型，时间部分会被忽略</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> last_day(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>); <span class="comment">-- 返回2020-05-31</span></span><br><span class="line"><span class="keyword">select</span> last_day(<span class="string">&#x27;2020-05-20&#x27;</span>); <span class="comment">-- 返回2020-05-31</span></span><br></pre></td></tr></table></figure>
<h3 id="to-date-STRING-timestamp">to_date(STRING timestamp)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回一个字符串时间的日期部分，去掉时间部分，2.1.0之前版本返回的是string，2.1.0版本及之后返回的是date</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> to_date(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>); <span class="comment">-- 返回2020-05-20</span></span><br><span class="line"><span class="keyword">select</span> to_date(<span class="string">&#x27;2020-05-20&#x27;</span>); <span class="comment">-- 返回2020-05-20</span></span><br></pre></td></tr></table></figure>
<h3 id="to-utc-timestamp-T-a-STRING-timezone">to_utc_timestamp(T a, STRING timezone)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>转换为世界标准时间UTC的时间戳,与from_utc_timestamp类似</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> to_utc_timestamp(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>, <span class="string">&#x27;GMT&#x27;</span>); <span class="comment">-- 返回2020-05-20 15:21:34.0</span></span><br></pre></td></tr></table></figure>
<h3 id="trunc-STRING-date-STRING-format">trunc(STRING date, STRING format)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>截断日期到指定的日期精度，仅支持月（MONTH/MON/MM）或者年（YEAR/YYYY/YY）</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> trunc(<span class="string">&#x27;2020-05-20&#x27;</span>, <span class="string">&#x27;YY&#x27;</span>);   <span class="comment">-- 返回2020-01-01，返回年的1月1日</span></span><br><span class="line"><span class="keyword">select</span> trunc(<span class="string">&#x27;2020-05-20&#x27;</span>, <span class="string">&#x27;MM&#x27;</span>);   <span class="comment">-- 返回2020-05-01，返回月的第一天</span></span><br><span class="line"><span class="keyword">select</span> trunc(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>, <span class="string">&#x27;MM&#x27;</span>);   <span class="comment">-- 返回2020-05-01</span></span><br></pre></td></tr></table></figure>
<h3 id="unix-timestamp-STRING-date-STRING-pattern">unix_timestamp([STRING date [, STRING pattern]])</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>参数时可选的，当参数为空时，返回当前Unix是时间戳，精确到秒。可以指定一个具体的日期，转换为Unix时间戳格式</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 返回1589959294</span></span><br><span class="line"><span class="keyword">select</span> unix_timestamp(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>,<span class="string">&#x27;yyyy-MM-dd hh:mm:ss&#x27;</span>);</span><br><span class="line"><span class="comment">-- 返回1589904000</span></span><br><span class="line"><span class="keyword">select</span> unix_timestamp(<span class="string">&#x27;2020-05-20&#x27;</span>,<span class="string">&#x27;yyyy-MM-dd&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="weekofyear-STRING-date">weekofyear(STRING date)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回一个日期或时间在一年中的第几周，可以用extract替代</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> weekofyear(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>); <span class="comment">-- 返回21，第21周</span></span><br><span class="line"><span class="keyword">select</span> weekofyear(<span class="string">&#x27;2020-05-20&#x27;</span>); <span class="comment">-- 返回21，第21周</span></span><br></pre></td></tr></table></figure>
<h3 id="next-day-STRING-start-date-STRING-day-of-week">next_day(STRING start_date, STRING day_of_week)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>参数start_date可以是一个时间或日期，day_of_week表示星期几，比如Mo表示星期一，Tu表示星期二，Wed表示星期三，Thur表示星期四，Fri表示星期五，Sat表示星期六，Sun表示星期日。如果指定的星期几在该日期所在的周且在该日期之后，则返回当周的星期几日期，如果指定的星期几不在该日期所在的周，则返回下一个星期几对应的日期</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> next_day(<span class="string">&#x27;2020-05-20&#x27;</span>,<span class="string">&#x27;Mon&#x27;</span>);<span class="comment">-- 返回当前日期的下一个周一日期:2020-05-25</span></span><br><span class="line"><span class="keyword">select</span> next_day(<span class="string">&#x27;2020-05-20&#x27;</span>,<span class="string">&#x27;Tu&#x27;</span>);<span class="comment">-- 返回当前日期的下一个周二日期:2020-05-26</span></span><br><span class="line"><span class="keyword">select</span> next_day(<span class="string">&#x27;2020-05-20&#x27;</span>,<span class="string">&#x27;Wed&#x27;</span>);<span class="comment">-- 返回当前日期的下一个周三日期:2020-05-27</span></span><br><span class="line"><span class="comment">-- 2020-05-20为周三，指定的参数为周四，所以返回当周的周四就是2020-05-21</span></span><br><span class="line"><span class="keyword">select</span> next_day(<span class="string">&#x27;2020-05-20&#x27;</span>,<span class="string">&#x27;Th&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> next_day(<span class="string">&#x27;2020-05-20&#x27;</span>,<span class="string">&#x27;Fri&#x27;</span>);<span class="comment">-- 返回周五日期2020-05-22</span></span><br><span class="line"><span class="keyword">select</span> next_day(<span class="string">&#x27;2020-05-20&#x27;</span>,<span class="string">&#x27;Sat&#x27;</span>); <span class="comment">-- 返回周六日期2020-05-23</span></span><br><span class="line"><span class="keyword">select</span> next_day(<span class="string">&#x27;2020-05-20&#x27;</span>,<span class="string">&#x27;Sun&#x27;</span>); <span class="comment">-- 返回周六日期2020-05-24</span></span><br></pre></td></tr></table></figure>
<p>该函数比较重要：比如取当前日期所在的周一和周日，通过长用在按周进行汇总数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> date_add(next_day(<span class="string">&#x27;2020-05-20&#x27;</span>,<span class="string">&#x27;MO&#x27;</span>),<span class="number">-7</span>); <span class="comment">-- 返回当前日期的周一日期2020-05-18</span></span><br><span class="line"><span class="keyword">select</span> date_add(next_day(<span class="string">&#x27;2020-05-20&#x27;</span>,<span class="string">&#x27;MO&#x27;</span>),<span class="number">-1</span>); <span class="comment">-- 返回当前日期的周日日期2020-05-24</span></span><br></pre></td></tr></table></figure>
<h3 id="months-between-DATE-TIMESTAMP-STRING-date1-…-date2">months_between(DATE|TIMESTAMP|STRING date1, … date2)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回 date1 和 date2 的月份差。如果date1大于date2，返回正值，否则返回负值，如果是相减是整数月，则返回一个整数，否则会返回小数</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> months_between(<span class="string">&#x27;2020-05-20&#x27;</span>,<span class="string">&#x27;2020-05-20&#x27;</span>); <span class="comment">-- 返回0</span></span><br><span class="line"><span class="keyword">select</span> months_between(<span class="string">&#x27;2020-05-20&#x27;</span>,<span class="string">&#x27;2020-06-20&#x27;</span>); <span class="comment">-- 返回-1</span></span><br><span class="line"><span class="comment">-- 相差的整数月</span></span><br><span class="line"><span class="keyword">select</span> months_between(<span class="string">&#x27;2020-06-30&#x27;</span>,<span class="string">&#x27;2020-05-31&#x27;</span>); <span class="comment">-- 返回1</span></span><br><span class="line"><span class="comment">-- 非整数月，一个月差一天</span></span><br><span class="line"><span class="keyword">select</span> months_between(<span class="string">&#x27;2020-06-29&#x27;</span>,<span class="string">&#x27;2020-05-31&#x27;</span>); <span class="comment">-- 返回0.93548387</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大数据组件</category>
        <category>hive</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka消费者详解</title>
    <url>/posts/ba56d3ed.html</url>
    <content><![CDATA[<h2 id="一、消费者和消费者群组">一、消费者和消费者群组</h2>
<p>在 Kafka 中，消费者通常是消费者群组的一部分，多个消费者群组共同读取同一个主题时，彼此之间互不影响。Kafka 之所以要引入消费者群组这个概念是因为 Kafka 消费者经常会做一些高延迟的操作，比如把数据写到数据库或 HDFS ，或者进行耗时的计算，在这些情况下，单个消费者无法跟上数据生成的速度。此时可以增加更多的消费者，让它们分担负载，分别处理部分分区的消息，这就是 Kafka 实现横向伸缩的主要手段。</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka-consumer01.png"/> </div>
<p>需要注意的是：同一个分区只能被同一个消费者群组里面的一个消费者读取，不可能存在同一个分区被同一个消费者群里多个消费者共同读取的情况，如图：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka-consumer02.png"/> </div>
<p>可以看到即便消费者 Consumer5 空闲了，但是也不会去读取任何一个分区的数据，这同时也提醒我们在使用时应该合理设置消费者的数量，以免造成闲置和额外开销。</p>
<h2 id="二、分区再均衡">二、分区再均衡</h2>
<p>因为群组里的消费者共同读取主题的分区，所以当一个消费者被关闭或发生崩溃时，它就离开了群组，原本由它读取的分区将由群组里的其他消费者来读取。同时在主题发生变化时 ， 比如添加了新的分区，也会发生分区与消费者的重新分配，分区的所有权从一个消费者转移到另一个消费者，这样的行为被称为再均衡。正是因为再均衡，所以消费费者群组才能保证高可用性和伸缩性。</p>
<p>消费者通过向群组协调器所在的 broker 发送心跳来维持它们和群组的从属关系以及它们对分区的所有权。只要消费者以正常的时间间隔发送心跳，就被认为是活跃的，说明它还在读取分区里的消息。消费者会在轮询消息或提交偏移量时发送心跳。如果消费者停止发送心跳的时间足够长，会话就会过期，群组协调器认为它已经死亡，就会触发再均衡。</p>
<h2 id="三、创建Kafka消费者">三、创建Kafka消费者</h2>
<p>在创建消费者的时候以下以下三个选项是必选的：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>bootstrap.servers</strong> ：指定 broker 的地址清单，清单里不需要包含所有的 broker 地址，生产者会从给定的 broker 里查找 broker 的信息。不过建议至少要提供两个 broker 的信息作为容错；</p>
</li>
<li class="lvl-2">
<p><strong>key.deserializer</strong> ：指定键的反序列化器；</p>
</li>
<li class="lvl-2">
<p><strong>value.deserializer</strong> ：指定值的反序列化器。</p>
</li>
</ul>
<p>除此之外你还需要指明你需要想订阅的主题，可以使用如下两个 API :</p>
<ul class="lvl-0">
<li class="lvl-3">
<p><strong>consumer.subscribe(Collection&lt;String&gt; topics)</strong>  ：指明需要订阅的主题的集合；</p>
</li>
<li class="lvl-2">
<p><strong>consumer.subscribe(Pattern pattern)</strong>  ：使用正则来匹配需要订阅的集合。</p>
</li>
</ul>
<p>最后只需要通过轮询 API(<code>poll</code>) 向服务器定时请求数据。一旦消费者订阅了主题，轮询就会处理所有的细节，包括群组协调、分区再均衡、发送心跳和获取数据，这使得开发者只需要关注从分区返回的数据，然后进行业务处理。 示例如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> topic = <span class="string">&quot;Hello-Kafka&quot;</span>;</span><br><span class="line"><span class="type">String</span> group = <span class="string">&quot;group1&quot;</span>;</span><br><span class="line"><span class="type">Properties</span> props = <span class="keyword">new</span> <span class="type">Properties</span>();</span><br><span class="line">props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;hadoop001:9092&quot;</span>);</span><br><span class="line"><span class="comment">/*指定分组 ID*/</span></span><br><span class="line">props.put(<span class="string">&quot;group.id&quot;</span>, group);</span><br><span class="line">props.put(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line"><span class="type">KafkaConsumer</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; consumer = <span class="keyword">new</span> <span class="type">KafkaConsumer</span>&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*订阅主题 (s)*/</span></span><br><span class="line">consumer.subscribe(<span class="type">Collections</span>.singletonList(topic));</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">/*轮询获取数据*/</span></span><br><span class="line">        <span class="type">ConsumerRecords</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; records = consumer.poll(<span class="type">Duration</span>.of(<span class="number">100</span>, <span class="type">ChronoUnit</span>.<span class="type">MILLIS</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">ConsumerRecord</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; record : records) &#123;</span><br><span class="line">            <span class="type">System</span>.out.printf(<span class="string">&quot;topic = %s,partition = %d, key = %s, value = %s, offset = %d,\n&quot;</span>,</span><br><span class="line">           record.topic(), record.partition(), record.key(), record.value(), record.offset());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本篇文章的所有示例代码可以从 Github 上进行下载：<a href="https://github.com/oicio/BigData-Notes/tree/master/code/Kafka/kafka-basis">kafka-basis</a></p>
</blockquote>
<h2 id="三、-自动提交偏移量">三、 自动提交偏移量</h2>
<h3 id="3-1-偏移量的重要性">3.1 偏移量的重要性</h3>
<p>Kafka 的每一条消息都有一个偏移量属性，记录了其在分区中的位置，偏移量是一个单调递增的整数。消费者通过往一个叫作 <code>＿consumer_offset</code> 的特殊主题发送消息，消息里包含每个分区的偏移量。 如果消费者一直处于运行状态，那么偏移量就没有什么用处。不过，如果有消费者退出或者新分区加入，此时就会触发再均衡。完成再均衡之后，每个消费者可能分配到新的分区，而不是之前处理的那个。为了能够继续之前的工作，消费者需要读取每个分区最后一次提交的偏移量，然后从偏移量指定的地方继续处理。 因为这个原因，所以如果不能正确提交偏移量，就可能会导致数据丢失或者重复出现消费，比如下面情况：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果提交的偏移量小于客户端处理的最后一个消息的偏移量 ，那么处于两个偏移量之间的消息就会被重复消费；</p>
</li>
<li class="lvl-2">
<p>如果提交的偏移量大于客户端处理的最后一个消息的偏移量，那么处于两个偏移量之间的消息将会丢失。</p>
</li>
</ul>
<h3 id="3-2-自动提交偏移量">3.2 自动提交偏移量</h3>
<p>Kafka 支持自动提交和手动提交偏移量两种方式。这里先介绍比较简单的自动提交：</p>
<p>只需要将消费者的 <code>enable.auto.commit</code> 属性配置为 <code>true</code> 即可完成自动提交的配置。 此时每隔固定的时间，消费者就会把 <code>poll()</code> 方法接收到的最大偏移量进行提交，提交间隔由 <code>auto.commit.interval.ms</code> 属性进行配置，默认值是 5s。</p>
<p>使用自动提交是存在隐患的，假设我们使用默认的 5s 提交时间间隔，在最近一次提交之后的 3s 发生了再均衡，再均衡之后，消费者从最后一次提交的偏移量位置开始读取消息。这个时候偏移量已经落后了 3s ，所以在这 3s 内到达的消息会被重复处理。可以通过修改提交时间间隔来更频繁地提交偏移量，减小可能出现重复消息的时间窗，不过这种情况是无法完全避免的。基于这个原因，Kafka 也提供了手动提交偏移量的 API，使得用户可以更为灵活的提交偏移量。</p>
<h2 id="四、手动提交偏移量">四、手动提交偏移量</h2>
<p>用户可以通过将 <code>enable.auto.commit</code> 设为 <code>false</code>，然后手动提交偏移量。基于用户需求手动提交偏移量可以分为两大类：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>手动提交当前偏移量：即手动提交当前轮询的最大偏移量；</p>
</li>
<li class="lvl-2">
<p>手动提交固定偏移量：即按照业务需求，提交某一个固定的偏移量。</p>
</li>
</ul>
<p>而按照 Kafka API，手动提交偏移量又可以分为同步提交和异步提交。</p>
<h3 id="4-1-同步提交">4.1 同步提交</h3>
<p>通过调用 <code>consumer.commitSync()</code> 来进行同步提交，不传递任何参数时提交的是当前轮询的最大偏移量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.of(<span class="number">100</span>, ChronoUnit.MILLIS));</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.println(record);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*同步提交*/</span></span><br><span class="line">    consumer.commitSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果某个提交失败，同步提交还会进行重试，这可以保证数据能够最大限度提交成功，但是同时也会降低程序的吞吐量。基于这个原因，Kafka 还提供了异步提交的 API。</p>
<h3 id="4-2-异步提交">4.2 异步提交</h3>
<p>异步提交可以提高程序的吞吐量，因为此时你可以尽管请求数据，而不用等待 Broker 的响应。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.of(<span class="number">100</span>, ChronoUnit.MILLIS));</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.println(record);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*异步提交并定义回调*/</span></span><br><span class="line">    consumer.commitAsync(<span class="keyword">new</span> <span class="title class_">OffsetCommitCallback</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, Exception exception)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;错误处理&quot;</span>);</span><br><span class="line">             offsets.forEach((x, y) -&gt; System.out.printf(<span class="string">&quot;topic = %s,partition = %d, offset = %s \n&quot;</span>,</span><br><span class="line">                                                            x.topic(), x.partition(), y.offset()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异步提交存在的问题是，在提交失败的时候不会进行自动重试，实际上也不能进行自动重试。假设程序同时提交了 200 和 300 的偏移量，此时 200 的偏移量失败的，但是紧随其后的 300 的偏移量成功了，此时如果重试就会存在 200 覆盖 300 偏移量的可能。同步提交就不存在这个问题，因为在同步提交的情况下，300 的提交请求必须等待服务器返回 200 提交请求的成功反馈后才会发出。基于这个原因，某些情况下，需要同时组合同步和异步两种提交方式。</p>
<blockquote>
<p>注：虽然程序不能在失败时候进行自动重试，但是我们是可以手动进行重试的，你可以通过一个 Map&lt;TopicPartition, Integer&gt; offsets 来维护你提交的每个分区的偏移量，然后当失败时候，你可以判断失败的偏移量是否小于你维护的同主题同分区的最后提交的偏移量，如果小于则代表你已经提交了更大的偏移量请求，此时不需要重试，否则就可以进行手动重试。</p>
</blockquote>
<h3 id="4-3-同步加异步提交">4.3  同步加异步提交</h3>
<p>下面这种情况，在正常的轮询中使用异步提交来保证吞吐量，但是因为在最后即将要关闭消费者了，所以此时需要用同步提交来保证最大限度的提交成功。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">ConsumerRecords</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; records = consumer.poll(<span class="type">Duration</span>.of(<span class="number">100</span>, <span class="type">ChronoUnit</span>.<span class="type">MILLIS</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">ConsumerRecord</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; record : records) &#123;</span><br><span class="line">            <span class="type">System</span>.out.println(record);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 异步提交</span></span><br><span class="line">        consumer.commitAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="type">Exception</span> e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 因为即将要关闭消费者，所以要用同步提交保证提交成功</span></span><br><span class="line">        consumer.commitSync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        consumer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-4-提交特定偏移量">4.4 提交特定偏移量</h3>
<p>在上面同步和异步提交的 API 中，实际上我们都没有对 commit 方法传递参数，此时默认提交的是当前轮询的最大偏移量，如果你需要提交特定的偏移量，可以调用它们的重载方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*同步提交特定偏移量*/</span></span><br><span class="line">commitSync(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets) </span><br><span class="line"><span class="comment">/*异步提交特定偏移量*/</span>    </span><br><span class="line">commitAsync(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, OffsetCommitCallback callback)</span><br></pre></td></tr></table></figure>
<p>需要注意的是，因为你可以订阅多个主题，所以 <code>offsets</code> 中必须要包含所有主题的每个分区的偏移量，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.of(<span class="number">100</span>, ChronoUnit.MILLIS));</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">            System.out.println(record);</span><br><span class="line">            <span class="comment">/*记录每个主题的每个分区的偏移量*/</span></span><br><span class="line">            <span class="type">TopicPartition</span> <span class="variable">topicPartition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TopicPartition</span>(record.topic(), record.partition());</span><br><span class="line">            <span class="type">OffsetAndMetadata</span> <span class="variable">offsetAndMetadata</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OffsetAndMetadata</span>(record.offset()+<span class="number">1</span>, <span class="string">&quot;no metaData&quot;</span>);</span><br><span class="line">            <span class="comment">/*TopicPartition 重写过 hashCode 和 equals 方法，所以能够保证同一主题和分区的实例不会被重复添加*/</span></span><br><span class="line">            offsets.put(topicPartition, offsetAndMetadata);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*提交特定偏移量*/</span></span><br><span class="line">        consumer.commitAsync(offsets, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、监听分区再均衡">五、监听分区再均衡</h2>
<p>因为分区再均衡会导致分区与消费者的重新划分，有时候你可能希望在再均衡前执行一些操作：比如提交已经处理但是尚未提交的偏移量，关闭数据库连接等。此时可以在订阅主题时候，调用 <code>subscribe</code> 的重载方法传入自定义的分区再均衡监听器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/*订阅指定集合内的所有主题*/</span></span><br><span class="line">subscribe(Collection&lt;String&gt; topics, ConsumerRebalanceListener listener)</span><br><span class="line"> <span class="comment">/*使用正则匹配需要订阅的主题*/</span>    </span><br><span class="line">subscribe(Pattern pattern, ConsumerRebalanceListener listener)    </span><br></pre></td></tr></table></figure>
<p>代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">consumer.subscribe(Collections.singletonList(topic), <span class="keyword">new</span> <span class="title class_">ConsumerRebalanceListener</span>() &#123;</span><br><span class="line">    <span class="comment">/*该方法会在消费者停止读取消息之后，再均衡开始之前就调用*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPartitionsRevoked</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;再均衡即将触发&quot;</span>);</span><br><span class="line">        <span class="comment">// 提交已经处理的偏移量</span></span><br><span class="line">        consumer.commitSync(offsets);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*该方法会在重新分配分区之后，消费者开始读取消息之前被调用*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPartitionsAssigned</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.of(<span class="number">100</span>, ChronoUnit.MILLIS));</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">            System.out.println(record);</span><br><span class="line">            <span class="type">TopicPartition</span> <span class="variable">topicPartition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TopicPartition</span>(record.topic(), record.partition());</span><br><span class="line">            <span class="type">OffsetAndMetadata</span> <span class="variable">offsetAndMetadata</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OffsetAndMetadata</span>(record.offset() + <span class="number">1</span>, <span class="string">&quot;no metaData&quot;</span>);</span><br><span class="line">            <span class="comment">/*TopicPartition 重写过 hashCode 和 equals 方法，所以能够保证同一主题和分区的实例不会被重复添加*/</span></span><br><span class="line">            offsets.put(topicPartition, offsetAndMetadata);</span><br><span class="line">        &#125;</span><br><span class="line">        consumer.commitAsync(offsets, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六-、退出轮询">六 、退出轮询</h2>
<p>Kafka 提供了 <code>consumer.wakeup()</code> 方法用于退出轮询，它通过抛出 <code>WakeupException</code> 异常来跳出循环。需要注意的是，在退出线程时最好显示的调用 <code>consumer.close()</code> , 此时消费者会提交任何还没有提交的东西，并向群组协调器发送消息，告知自己要离开群组，接下来就会触发再均衡 ，而不需要等待会话超时。</p>
<p>下面的示例代码为监听控制台输出，当输入 <code>exit</code> 时结束轮询，关闭消费者并退出程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*调用 wakeup 优雅的退出*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">mainThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;exit&quot;</span>.equals(sc.next())) &#123;</span><br><span class="line">            consumer.wakeup();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/*等待主线程完成提交偏移量、关闭消费者等操作*/</span></span><br><span class="line">                mainThread.join();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.of(<span class="number">100</span>, ChronoUnit.MILLIS));</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; rd : records) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;topic = %s,partition = %d, key = %s, value = %s, offset = %d,\n&quot;</span>,</span><br><span class="line">                              rd.topic(), rd.partition(), rd.key(), rd.value(), rd.offset());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (WakeupException e) &#123;</span><br><span class="line">    <span class="comment">//对于 wakeup() 调用引起的 WakeupException 异常可以不必处理</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    consumer.close();</span><br><span class="line">    System.out.println(<span class="string">&quot;consumer 关闭&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="七、独立的消费者">七、独立的消费者</h2>
<p>因为 Kafka 的设计目标是高吞吐和低延迟，所以在 Kafka 中，消费者通常都是从属于某个群组的，这是因为单个消费者的处理能力是有限的。但是某些时候你的需求可能很简单，比如可能只需要一个消费者从一个主题的所有分区或者某个特定的分区读取数据，这个时候就不需要消费者群组和再均衡了， 只需要把主题或者分区分配给消费者，然后开始读取消息井提交偏移量即可。</p>
<p>在这种情况下，就不需要订阅主题， 取而代之的是消费者为自己分配分区。 一个消费者可以订阅主题（井加入消费者群组），或者为自己分配分区，但不能同时做这两件事情。 分配分区的示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;TopicPartition&gt; partitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;PartitionInfo&gt; partitionInfos = consumer.partitionsFor(topic);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*可以指定读取哪些分区 如这里假设只读取主题的 0 分区*/</span></span><br><span class="line"><span class="keyword">for</span> (PartitionInfo partition : partitionInfos) &#123;</span><br><span class="line">    <span class="keyword">if</span> (partition.partition()==<span class="number">0</span>)&#123;</span><br><span class="line">        partitions.add(<span class="keyword">new</span> <span class="title class_">TopicPartition</span>(partition.topic(), partition.partition()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为消费者指定分区</span></span><br><span class="line">consumer.assign(partitions);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;Integer, String&gt; records = consumer.poll(Duration.of(<span class="number">100</span>, ChronoUnit.MILLIS));</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;Integer, String&gt; record : records) &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;partition = %s, key = %d, value = %s\n&quot;</span>,</span><br><span class="line">                          record.partition(), record.key(), record.value());</span><br><span class="line">    &#125;</span><br><span class="line">    consumer.commitSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="附录-Kafka消费者可选属性">附录 : Kafka消费者可选属性</h2>
<h3 id="1-fetch-min-byte">1. fetch.min.byte</h3>
<p>消费者从服务器获取记录的最小字节数。如果可用的数据量小于设置值，broker 会等待有足够的可用数据时才会把它返回给消费者。</p>
<h3 id="2-fetch-max-wait-ms">2. <a href="http://fetch.max.wait.ms">fetch.max.wait.ms</a></h3>
<p>broker 返回给消费者数据的等待时间，默认是 500ms。</p>
<h3 id="3-max-partition-fetch-bytes">3. max.partition.fetch.bytes</h3>
<p>该属性指定了服务器从每个分区返回给消费者的最大字节数，默认为 1MB。</p>
<h3 id="4-session-timeout-ms">4. <a href="http://session.timeout.ms">session.timeout.ms</a></h3>
<p>消费者在被认为死亡之前可以与服务器断开连接的时间，默认是 3s。</p>
<h3 id="5-auto-offset-reset">5. auto.offset.reset</h3>
<p>该属性指定了消费者在读取一个没有偏移量的分区或者偏移量无效的情况下该作何处理：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>latest (默认值) ：在偏移量无效的情况下，消费者将从最新的记录开始读取数据（在消费者启动之后生成的最新记录）;</p>
</li>
<li class="lvl-2">
<p>earliest ：在偏移量无效的情况下，消费者将从起始位置读取分区的记录。</p>
</li>
</ul>
<h3 id="6-enable-auto-commit">6. enable.auto.commit</h3>
<p>是否自动提交偏移量，默认值是 true。为了避免出现重复消费和数据丢失，可以把它设置为 false。</p>
<h3 id="7-client-id">7. <a href="http://client.id">client.id</a></h3>
<p>客户端 id，服务器用来识别消息的来源。</p>
<h3 id="8-max-poll-records">8. max.poll.records</h3>
<p>单次调用 <code>poll()</code> 方法能够返回的记录数量。</p>
<h3 id="9-receive-buffer-bytes-send-buffer-byte">9. receive.buffer.bytes &amp; send.buffer.byte</h3>
<p>这两个参数分别指定 TCP socket 接收和发送数据包缓冲区的大小，-1 代表使用操作系统的默认值。</p>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka生产者详解</title>
    <url>/posts/88c8c32e.html</url>
    <content><![CDATA[<h2 id="一、生产者发送消息的过程">一、生产者发送消息的过程</h2>
<p>首先介绍一下 Kafka 生产者发送消息的过程：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Kafka 会将发送消息包装为 ProducerRecord 对象， ProducerRecord 对象包含了目标主题和要发送的内容，同时还可以指定键和分区。在发送 ProducerRecord 对象前，生产者会先把键和值对象序列化成字节数组，这样它们才能够在网络上传输。</p>
</li>
<li class="lvl-2">
<p>接下来，数据被传给分区器。如果之前已经在 ProducerRecord 对象里指定了分区，那么分区器就不会再做任何事情。如果没有指定分区 ，那么分区器会根据 ProducerRecord 对象的键来选择一个分区，紧接着，这条记录被添加到一个记录批次里，这个批次里的所有消息会被发送到相同的主题和分区上。有一个独立的线程负责把这些记录批次发送到相应的 broker 上。</p>
</li>
<li class="lvl-2">
<p>服务器在收到这些消息时会返回一个响应。如果消息成功写入 Kafka，就返回一个 RecordMetaData 对象，它包含了主题和分区信息，以及记录在分区里的偏移量。如果写入失败，则会返回一个错误。生产者在收到错误之后会尝试重新发送消息，如果达到指定的重试次数后还没有成功，则直接抛出异常，不再重试。</p>
</li>
</ul>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka-send-messgaes.png"/> </div>
<h2 id="二、创建生产者">二、创建生产者</h2>
<h3 id="2-1-项目依赖">2.1 项目依赖</h3>
<p>本项目采用 Maven 构建，想要调用 Kafka 生产者 API，需要导入 <code>kafka-clients</code> 依赖，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-创建生产者">2.2 创建生产者</h3>
<p>创建 Kafka 生产者时，以下三个属性是必须指定的：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>bootstrap.servers</strong> ：指定 broker 的地址清单，清单里不需要包含所有的 broker 地址，生产者会从给定的 broker 里查找 broker 的信息。不过建议至少要提供两个 broker 的信息作为容错；</p>
</li>
<li class="lvl-2">
<p><strong>key.serializer</strong> ：指定键的序列化器；</p>
</li>
<li class="lvl-2">
<p><strong>value.serializer</strong> ：指定值的序列化器。</p>
</li>
</ul>
<p>创建的示例代码如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SimpleProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    public static void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> topicName = <span class="string">&quot;Hello-Kafka&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Properties</span> props = <span class="keyword">new</span> <span class="type">Properties</span>();</span><br><span class="line">        props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;hadoop001:9092&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        <span class="comment">/*创建生产者*/</span></span><br><span class="line">        <span class="type">Producer</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; producer = <span class="keyword">new</span> <span class="type">KafkaProducer</span>&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">ProducerRecord</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; record = <span class="keyword">new</span> <span class="type">ProducerRecord</span>&lt;&gt;(topicName, <span class="string">&quot;hello&quot;</span> + i, </span><br><span class="line">                                                                         <span class="string">&quot;world&quot;</span> + i);</span><br><span class="line">            <span class="comment">/* 发送消息*/</span></span><br><span class="line">            producer.send(record);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*关闭生产者*/</span></span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本篇文章的所有示例代码可以从 Github 上进行下载：<a href="https://github.com/oicio/BigData-Notes/tree/master/code/Kafka/kafka-basis">kafka-basis</a></p>
</blockquote>
<h3 id="2-3-测试">2.3 测试</h3>
<h4 id="1-启动Kakfa">1. 启动Kakfa</h4>
<p>Kafka 的运行依赖于 zookeeper，需要预先启动，可以启动 Kafka 内置的 zookeeper，也可以启动自己安装的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">zookeeper启动命令</span></span><br><span class="line">bin/zkServer.sh start</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">内置zookeeper启动命令</span></span><br><span class="line">bin/zookeeper-server-start.sh config/zookeeper.properties</span><br></pre></td></tr></table></figure>
<p>启动单节点 kafka 用于测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">bin/kafka-server-start.sh config/server.properties</span></span><br></pre></td></tr></table></figure>
<h4 id="2-创建topic">2. 创建topic</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">创建用于测试主题</span></span><br><span class="line">bin/kafka-topics.sh --create \</span><br><span class="line">                    --bootstrap-server hadoop001:9092 \</span><br><span class="line">                     --replication-factor 1 --partitions 1 \</span><br><span class="line">                     --topic Hello-Kafka</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看所有主题</span></span><br><span class="line"> bin/kafka-topics.sh --list --bootstrap-server hadoop001:9092</span><br></pre></td></tr></table></figure>
<h4 id="3-启动消费者">3. 启动消费者</h4>
<p>启动一个控制台消费者用于观察写入情况，启动命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">bin/kafka-console-consumer.sh --bootstrap-server hadoop001:9092 --topic Hello-Kafka --from-beginning</span></span><br></pre></td></tr></table></figure>
<h4 id="4-运行项目">4. 运行项目</h4>
<p>此时可以看到消费者控制台，输出如下，这里 <code>kafka-console-consumer</code> 只会打印出值信息，不会打印出键信息。</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka-simple-producer.png"/> </div>
<h3 id="2-4-可能出现的问题">2.4 可能出现的问题</h3>
<p>在这里可能出现的一个问题是：生产者程序在启动后，一直处于等待状态。这通常出现在你使用默认配置启动 Kafka 的情况下，此时需要对 <code>server.properties</code> 文件中的 <code>listeners</code> 配置进行更改：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">hadoop001 为我启动kafka服务的主机名，你可以换成自己的主机名或者ip地址</span></span><br><span class="line">listeners=PLAINTEXT://hadoop001:9092</span><br></pre></td></tr></table></figure>
<h2 id="二、发送消息">二、发送消息</h2>
<p>上面的示例程序调用了 <code>send</code> 方法发送消息后没有做任何操作，在这种情况下，我们没有办法知道消息发送的结果。想要知道消息发送的结果，可以使用同步发送或者异步发送来实现。</p>
<h3 id="2-1-同步发送">2.1 同步发送</h3>
<p>在调用 <code>send</code> 方法后可以接着调用 <code>get()</code> 方法，<code>send</code> 方法的返回值是一个 Future&lt;RecordMetadata&gt;对象，RecordMetadata 里面包含了发送消息的主题、分区、偏移量等信息。改写后的代码如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ProducerRecord</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; record = <span class="keyword">new</span> <span class="type">ProducerRecord</span>&lt;&gt;(topicName, <span class="string">&quot;k&quot;</span> + i, <span class="string">&quot;world&quot;</span> + i);</span><br><span class="line">        <span class="comment">/*同步发送消息*/</span></span><br><span class="line">        <span class="type">RecordMetadata</span> metadata = producer.send(record).get();</span><br><span class="line">        <span class="type">System</span>.out.printf(<span class="string">&quot;topic=%s, partition=%d, offset=%s \n&quot;</span>,</span><br><span class="line">                metadata.topic(), metadata.partition(), metadata.offset());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="type">InterruptedException</span> | <span class="type">ExecutionException</span> e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时得到的输出如下：偏移量和调用次数有关，所有记录都分配到了 0 分区，这是因为在创建 <code>Hello-Kafka</code> 主题时候，使用 <code>--partitions</code> 指定其分区数为 1，即只有一个分区。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">topic=Hello-Kafka, partition=0, offset=40 </span><br><span class="line">topic=Hello-Kafka, partition=0, offset=41 </span><br><span class="line">topic=Hello-Kafka, partition=0, offset=42 </span><br><span class="line">topic=Hello-Kafka, partition=0, offset=43 </span><br><span class="line">topic=Hello-Kafka, partition=0, offset=44 </span><br><span class="line">topic=Hello-Kafka, partition=0, offset=45 </span><br><span class="line">topic=Hello-Kafka, partition=0, offset=46 </span><br><span class="line">topic=Hello-Kafka, partition=0, offset=47 </span><br><span class="line">topic=Hello-Kafka, partition=0, offset=48 </span><br><span class="line">topic=Hello-Kafka, partition=0, offset=49 </span><br></pre></td></tr></table></figure>
<h3 id="2-2-异步发送">2.2 异步发送</h3>
<p>通常我们并不关心发送成功的情况，更多关注的是失败的情况，因此 Kafka 提供了异步发送和回调函数。 代码如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="type">ProducerRecord</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; record = <span class="keyword">new</span> <span class="type">ProducerRecord</span>&lt;&gt;(topicName, <span class="string">&quot;k&quot;</span> + i, <span class="string">&quot;world&quot;</span> + i);</span><br><span class="line">    <span class="comment">/*异步发送消息，并监听回调*/</span></span><br><span class="line">    producer.send(record, <span class="keyword">new</span> <span class="type">Callback</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        public void onCompletion(<span class="type">RecordMetadata</span> metadata, <span class="type">Exception</span> exception) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">System</span>.out.println(<span class="string">&quot;进行异常处理&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">System</span>.out.printf(<span class="string">&quot;topic=%s, partition=%d, offset=%s \n&quot;</span>,</span><br><span class="line">                        metadata.topic(), metadata.partition(), metadata.offset());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、自定义分区器">三、自定义分区器</h2>
<p>Kafka 有着默认的分区机制：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果键值为 null， 则使用轮询 (Round Robin) 算法将消息均衡地分布到各个分区上；</p>
</li>
<li class="lvl-2">
<p>如果键值不为 null，那么 Kafka 会使用内置的散列算法对键进行散列，然后分布到各个分区上。</p>
</li>
</ul>
<p>某些情况下，你可能有着自己的分区需求，这时候可以采用自定义分区器实现。这里给出一个自定义分区器的示例：</p>
<h3 id="3-1-自定义分区器">3.1 自定义分区器</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义分区器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomPartitioner</span> <span class="keyword">implements</span> <span class="title class_">Partitioner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> passLine;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(Map&lt;String, ?&gt; configs)</span> &#123;</span><br><span class="line">        <span class="comment">/*从生产者配置中获取分数线*/</span></span><br><span class="line">        passLine = (Integer) configs.get(<span class="string">&quot;pass.line&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(String topic, Object key, <span class="type">byte</span>[] keyBytes, Object value, </span></span><br><span class="line"><span class="params">                         <span class="type">byte</span>[] valueBytes, Cluster cluster)</span> &#123;</span><br><span class="line">        <span class="comment">/*key 值为分数，当分数大于分数线时候，分配到 1 分区，否则分配到 0 分区*/</span></span><br><span class="line">        <span class="keyword">return</span> (Integer) key &gt;= passLine ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;分区器关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要在创建生产者时指定分区器，和分区器所需要的配置参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerWithPartitioner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">topicName</span> <span class="operator">=</span> <span class="string">&quot;Kafka-Partitioner-Test&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;hadoop001:9092&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.IntegerSerializer&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*传递自定义分区器*/</span></span><br><span class="line">        props.put(<span class="string">&quot;partitioner.class&quot;</span>, <span class="string">&quot;com.oicio.producers.partitioners.CustomPartitioner&quot;</span>);</span><br><span class="line">        <span class="comment">/*传递分区器所需的参数*/</span></span><br><span class="line">        props.put(<span class="string">&quot;pass.line&quot;</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        Producer&lt;Integer, String&gt; producer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">score</span> <span class="operator">=</span> <span class="string">&quot;score:&quot;</span> + i;</span><br><span class="line">            ProducerRecord&lt;Integer, String&gt; record = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(topicName, i, score);</span><br><span class="line">            <span class="comment">/*异步发送消息*/</span></span><br><span class="line">            producer.send(record, (metadata, exception) -&gt;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%s, partition=%d, \n&quot;</span>, score, metadata.partition()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-测试">3.2 测试</h3>
<p>需要创建一个至少有两个分区的主题：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --create \</span><br><span class="line">                   --bootstrap-server hadoop001:9092 \</span><br><span class="line">                    --replication-factor 1 --partitions 2 \</span><br><span class="line">                    --topic Kafka-Partitioner-Test</span><br></pre></td></tr></table></figure>
<p>此时输入如下，可以看到分数大于等于 6 分的都被分到 1 分区，而小于 6 分的都被分到了 0 分区。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">score:6, partition=1, </span><br><span class="line">score:7, partition=1, </span><br><span class="line">score:8, partition=1, </span><br><span class="line">score:9, partition=1, </span><br><span class="line">score:10, partition=1, </span><br><span class="line">score:0, partition=0, </span><br><span class="line">score:1, partition=0, </span><br><span class="line">score:2, partition=0, </span><br><span class="line">score:3, partition=0, </span><br><span class="line">score:4, partition=0, </span><br><span class="line">score:5, partition=0, </span><br><span class="line">分区器关闭</span><br></pre></td></tr></table></figure>
<h2 id="四、生产者其他属性">四、生产者其他属性</h2>
<p>上面生产者的创建都仅指定了服务地址，键序列化器、值序列化器，实际上 Kafka 的生产者还有很多可配置属性，如下：</p>
<h3 id="1-acks">1. acks</h3>
<p>acks 参数指定了必须要有多少个分区副本收到消息，生产者才会认为消息写入是成功的：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>acks=0</strong> ： 消息发送出去就认为已经成功了，不会等待任何来自服务器的响应；</p>
</li>
<li class="lvl-2">
<p><strong>acks=1</strong> ： 只要集群的首领节点收到消息，生产者就会收到一个来自服务器成功响应；</p>
</li>
<li class="lvl-2">
<p><strong>acks=all</strong> ：只有当所有参与复制的节点全部收到消息时，生产者才会收到一个来自服务器的成功响应。</p>
</li>
</ul>
<h3 id="2-buffer-memory">2. buffer.memory</h3>
<p>设置生产者内存缓冲区的大小。</p>
<h3 id="3-compression-type">3. compression.type</h3>
<p>默认情况下，发送的消息不会被压缩。如果想要进行压缩，可以配置此参数，可选值有 snappy，gzip，lz4。</p>
<h3 id="4-retries">4. retries</h3>
<p>发生错误后，消息重发的次数。如果达到设定值，生产者就会放弃重试并返回错误。</p>
<h3 id="5-batch-size">5. batch.size</h3>
<p>当有多个消息需要被发送到同一个分区时，生产者会把它们放在同一个批次里。该参数指定了一个批次可以使用的内存大小，按照字节数计算。</p>
<h3 id="6-linger-ms">6. <a href="http://linger.ms">linger.ms</a></h3>
<p>该参数制定了生产者在发送批次之前等待更多消息加入批次的时间。</p>
<h3 id="7-clent-id">7. <a href="http://clent.id">clent.id</a></h3>
<p>客户端 id,服务器用来识别消息的来源。</p>
<h3 id="8-max-in-flight-requests-per-connection">8. max.in.flight.requests.per.connection</h3>
<p>指定了生产者在收到服务器响应之前可以发送多少个消息。它的值越高，就会占用越多的内存，不过也会提升吞吐量，把它设置为 1 可以保证消息是按照发送的顺序写入服务器，即使发生了重试。</p>
<h3 id="9-timeout-ms-request-timeout-ms-metadata-fetch-timeout-ms">9. <a href="http://timeout.ms">timeout.ms</a>, <a href="http://request.timeout.ms">request.timeout.ms</a> &amp; <a href="http://metadata.fetch.timeout.ms">metadata.fetch.timeout.ms</a></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="http://timeout.ms">timeout.ms</a> 指定了 borker 等待同步副本返回消息的确认时间；</p>
</li>
<li class="lvl-2">
<p><a href="http://request.timeout.ms">request.timeout.ms</a> 指定了生产者在发送数据时等待服务器返回响应的时间；</p>
</li>
<li class="lvl-2">
<p><a href="http://metadata.fetch.timeout.ms">metadata.fetch.timeout.ms</a> 指定了生产者在获取元数据（比如分区首领是谁）时等待服务器返回响应的时间。</p>
</li>
</ul>
<h3 id="10-max-block-ms">10. <a href="http://max.block.ms">max.block.ms</a></h3>
<p>指定了在调用 <code>send()</code> 方法或使用 <code>partitionsFor()</code> 方法获取元数据时生产者的阻塞时间。当生产者的发送缓冲区已满，或者没有可用的元数据时，这些方法会阻塞。在阻塞时间达到 <a href="http://max.block.ms">max.block.ms</a> 时，生产者会抛出超时异常。</p>
<h3 id="11-max-request-size">11. max.request.size</h3>
<p>该参数用于控制生产者发送的请求大小。它可以指发送的单个消息的最大值，也可以指单个请求里所有消息总的大小。例如，假设这个值为 1000K ，那么可以发送的单个最大消息为 1000K ，或者生产者可以在单个请求里发送一个批次，该批次包含了 1000 个消息，每个消息大小为 1K。</p>
<h3 id="12-receive-buffer-bytes-send-buffer-byte">12. receive.buffer.bytes &amp; send.buffer.byte</h3>
<p>这两个参数分别指定 TCP socket 接收和发送数据包缓冲区的大小，-1 代表使用操作系统的默认值。</p>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka简介</title>
    <url>/posts/d54daaca.html</url>
    <content><![CDATA[<h2 id="一、简介">一、简介</h2>
<p>ApacheKafka 是一个分布式的流处理平台。它具有以下特点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>支持消息的发布和订阅，类似于 RabbtMQ、ActiveMQ 等消息队列；</p>
</li>
<li class="lvl-2">
<p>支持数据实时处理；</p>
</li>
<li class="lvl-2">
<p>能保证消息的可靠性投递；</p>
</li>
<li class="lvl-2">
<p>支持消息的持久化存储，并通过多副本分布式的存储方案来保证消息的容错；</p>
</li>
<li class="lvl-2">
<p>高吞吐率，单 Broker 可以轻松处理数千个分区以及每秒百万级的消息量。</p>
</li>
</ul>
<h2 id="二、基本概念">二、基本概念</h2>
<h3 id="2-1-Messages-And-Batches">2.1 Messages And Batches</h3>
<p>Kafka 的基本数据单元被称为 message(消息)，为减少网络开销，提高效率，多个消息会被放入同一批次 (Batch) 中后再写入。</p>
<h3 id="2-2-Topics-And-Partitions">2.2 Topics And Partitions</h3>
<p>Kafka 的消息通过 Topics(主题) 进行分类，一个主题可以被分为若干个 Partitions(分区)，一个分区就是一个提交日志 (commit log)。消息以追加的方式写入分区，然后以先入先出的顺序读取。Kafka 通过分区来实现数据的冗余和伸缩性，分区可以分布在不同的服务器上，这意味着一个 Topic 可以横跨多个服务器，以提供比单个服务器更强大的性能。</p>
<p>由于一个 Topic 包含多个分区，因此无法在整个 Topic 范围内保证消息的顺序性，但可以保证消息在单个分区内的顺序性。</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka-topic.png"/> </div>
<h3 id="2-3-Producers-And-Consumers">2.3 Producers And Consumers</h3>
<h4 id="1-生产者">1. 生产者</h4>
<p>生产者负责创建消息。一般情况下，生产者在把消息均衡地分布到在主题的所有分区上，而并不关心消息会被写到哪个分区。如果我们想要把消息写到指定的分区，可以通过自定义分区器来实现。</p>
<h4 id="2-消费者">2. 消费者</h4>
<p>消费者是消费者群组的一部分，消费者负责消费消息。消费者可以订阅一个或者多个主题，并按照消息生成的顺序来读取它们。消费者通过检查消息的偏移量 (offset) 来区分读取过的消息。偏移量是一个不断递增的数值，在创建消息时，Kafka 会把它添加到其中，在给定的分区里，每个消息的偏移量都是唯一的。消费者把每个分区最后读取的偏移量保存在 Zookeeper 或 Kafka 上，如果消费者关闭或者重启，它还可以重新获取该偏移量，以保证读取状态不会丢失。</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka-producer-consumer.png"/> </div>
<p>一个分区只能被同一个消费者群组里面的一个消费者读取，但可以被不同消费者群组中所组成的多个消费者共同读取。多个消费者群组中消费者共同读取同一个主题时，彼此之间互不影响。</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka消费者.png"/> </div>
<h3 id="2-4-Brokers-And-Clusters">2.4 Brokers And Clusters</h3>
<p>一个独立的 Kafka 服务器被称为 Broker。Broker 接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存。Broker 为消费者提供服务，对读取分区的请求做出响应，返回已经提交到磁盘的消息。</p>
<p>Broker 是集群 (Cluster) 的组成部分。每一个集群都会选举出一个 Broker 作为集群控制器 (Controller)，集群控制器负责管理工作，包括将分区分配给 Broker 和监控 Broker。</p>
<p>在集群中，一个分区 (Partition) 从属一个 Broker，该 Broker 被称为分区的首领 (Leader)。一个分区可以分配给多个 Brokers，这个时候会发生分区复制。这种复制机制为分区提供了消息冗余，如果有一个 Broker 失效，其他 Broker 可以接管领导权。</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka-cluster.png"/> </div>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux环境下Hive的安装</title>
    <url>/posts/ca6cd067.html</url>
    <content><![CDATA[<h2 id="一、安装Hive">一、安装Hive</h2>
<h3 id="1-1-下载并解压">1.1 下载并解压</h3>
<p>下载所需版本的 Hive，这里我下载版本为 <code>cdh5.15.2</code>。下载地址：<a href="http://archive.cloudera.com/cdh5/cdh/5/">http://archive.cloudera.com/cdh5/cdh/5/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">下载后进行解压</span></span><br><span class="line"> tar -zxvf hive-1.1.0-cdh5.15.2.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="1-2-配置环境变量">1.2 配置环境变量</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">vim /etc/profile</span></span><br></pre></td></tr></table></figure>
<p>添加环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HIVE_HOME=/usr/app/hive-1.1.0-cdh5.15.2</span><br><span class="line">export PATH=$HIVE_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>使得配置的环境变量立即生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">source</span> /etc/profile</span></span><br></pre></td></tr></table></figure>
<h3 id="1-3-修改配置">1.3 修改配置</h3>
<p><strong>1. <a href="http://hive-env.sh">hive-env.sh</a></strong></p>
<p>进入安装目录下的 <code>conf/</code> 目录，拷贝 Hive 的环境配置模板 <code>flume-env.sh.template</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp hive-env.sh.template hive-env.sh</span><br></pre></td></tr></table></figure>
<p>修改 <code>hive-env.sh</code>，指定 Hadoop 的安装路径：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HADOOP_HOME=/usr/app/hadoop-2.6.0-cdh5.15.2</span><br></pre></td></tr></table></figure>
<p><strong>2. hive-site.xml</strong></p>
<p>新建 hive-site.xml 文件，内容如下，主要是配置存放元数据的 MySQL 的地址、驱动、用户名和密码等信息：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>jdbc:mysql://hadoop001:3306/hadoop_hive?createDatabaseIfNotExist=true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-4-拷贝数据库驱动">1.4 拷贝数据库驱动</h3>
<p>将 MySQL 驱动包拷贝到 Hive 安装目录的 <code>lib</code> 目录下, MySQL 驱动的下载地址为：<a href="https://dev.mysql.com/downloads/connector/j/">https://dev.mysql.com/downloads/connector/j/</a>  , 在本仓库的<a href="https://github.com/oicio/BigData-Notes/tree/master/resources">resources</a> 目录下我也上传了一份，有需要的可以自行下载。</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-mysql.png"/> </div>
<h3 id="1-5-初始化元数据库">1.5 初始化元数据库</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>当使用的 hive 是 1.x 版本时，可以不进行初始化操作，Hive 会在第一次启动的时候会自动进行初始化，但不会生成所有的元数据信息表，只会初始化必要的一部分，在之后的使用中用到其余表时会自动创建；</p>
</li>
<li class="lvl-2">
<p>当使用的 hive 是 2.x 版本时，必须手动初始化元数据库。初始化命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">schematool 命令在安装目录的 bin 目录下，由于上面已经配置过环境变量，在任意位置执行即可</span></span><br><span class="line">schematool -dbType mysql -initSchema</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里我使用的是 CDH 的 <code>hive-1.1.0-cdh5.15.2.tar.gz</code>，对应 <code>Hive 1.1.0</code> 版本，可以跳过这一步。</p>
<h3 id="1-6-启动">1.6 启动</h3>
<p>由于已经将 Hive 的 bin 目录配置到环境变量，直接使用以下命令启动，成功进入交互式命令行后执行 <code>show databases</code> 命令，无异常则代表搭建成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">hive</span></span><br></pre></td></tr></table></figure>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-install-2.png"/> </div>
<p>在 Mysql 中也能看到 Hive 创建的库和存放元数据信息的表</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-mysql-tables.png"/> </div>
<h2 id="二、HiveServer2-beeline">二、HiveServer2/beeline</h2>
<p>Hive 内置了 HiveServer 和 HiveServer2 服务，两者都允许客户端使用多种编程语言进行连接，但是 HiveServer 不能处理多个客户端的并发请求，因此产生了 HiveServer2。HiveServer2（HS2）允许远程客户端可以使用各种编程语言向 Hive 提交请求并检索结果，支持多客户端并发访问和身份验证。HS2 是由多个服务组成的单个进程，其包括基于 Thrift 的 Hive 服务（TCP 或 HTTP）和用于 Web UI 的 Jetty Web 服务。</p>
<p>HiveServer2 拥有自己的 CLI 工具——Beeline。Beeline 是一个基于 SQLLine 的 JDBC 客户端。由于目前 HiveServer2 是 Hive 开发维护的重点，所以官方更加推荐使用 Beeline 而不是 Hive CLI。以下主要讲解 Beeline 的配置方式。</p>
<h3 id="2-1-修改Hadoop配置">2.1 修改Hadoop配置</h3>
<p>修改 hadoop 集群的 core-site.xml 配置文件，增加如下配置，指定 hadoop 的 root 用户可以代理本机上所有的用户。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.proxyuser.root.hosts<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>*<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.proxyuser.root.groups<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>*<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>之所以要配置这一步，是因为 hadoop 2.0 以后引入了安全伪装机制，使得 hadoop 不允许上层系统（如 hive）直接将实际用户传递到 hadoop 层，而应该将实际用户传递给一个超级代理，由该代理在 hadoop 上执行操作，以避免任意客户端随意操作 hadoop。如果不配置这一步，在之后的连接中可能会抛出 <code>AuthorizationException</code> 异常。</p>
<blockquote>
<p>关于 Hadoop 的用户代理机制，可以参考：<a href="https://blog.csdn.net/u012948976/article/details/49904675#%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E8%A7%A3%E8%AF%BB">hadoop 的用户代理机制</a> 或 <a href="http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-common/Superusers.html">Superusers Acting On Behalf Of Other Users</a></p>
</blockquote>
<h3 id="2-2-启动hiveserver2">2.2 启动hiveserver2</h3>
<p>由于上面已经配置过环境变量，这里直接启动即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">nohup</span> hiveserver2 &amp;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-使用beeline">2.3 使用beeline</h3>
<p>可以使用以下命令进入 beeline 交互式命令行，出现 <code>Connected</code> 则代表连接成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">beeline -u jdbc:hive2://hadoop001:10000 -n root</span></span><br></pre></td></tr></table></figure>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-beeline-cli.png"/> </div>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>hive</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Sqoop一致性探讨</title>
    <url>/posts/f51cf5f9.html</url>
    <content><![CDATA[<h2 id="Sqoop导入导出Null存储一致性问题">Sqoop导入导出Null存储一致性问题</h2>
<p>Hive中的Null在底层是以“\N”来存储，而MySQL中的Null在底层就是Null，为了保证数据两端的一致性。在导出数据时采用–input-null-string和–input-null-non-string两个参数。导入数据时采用–null-string和–null-non-string。</p>
<h2 id="Sqoop数据导出一致性问题">Sqoop数据导出一致性问题</h2>
<h3 id="场景1：">场景1：</h3>
<p>如Sqoop在导出到Mysql时，使用4个Map任务，过程中有2个任务失败，那此时MySQL中存储了另外两个Map任务导入的数据，此时老板正好看到了这个报表数据。而开发工程师发现任务失败后，会调试问题并最终将全部数据正确的导入MySQL，那后面老板再次看报表数据，发现本次看到的数据与之前的不一致，这在生产环境是不允许的。</p>
<h4 id="解决方案：">解决方案：</h4>
<p>由于Sqoop将导出过程分解为多个事务，因此失败的导出作业可能会导致部分数据提交到数据库。在某些情况下，这可能进一步导致后续作业因插入冲突而失败，在其他情况下，这又可能导致数据重复。您可以通过–staging-table选项指定暂存表来解决此问题，该选项用作用于暂存导出数据的辅助表。最后，分阶段处理的数据将在单个事务中移至目标表</p>
<h5 id="命令：">命令：</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sqoop export \</span><br><span class="line">--connect jdbc:mysql://192.168.137.10:3306/user_behavior \</span><br><span class="line">--username root \</span><br><span class="line">--password 123456 \</span><br><span class="line">--table app_cource_study_report \</span><br><span class="line">--columns watch_video_cnt,complete_video_cnt,dt \</span><br><span class="line">--fields-terminated-by &quot;\t&quot; \</span><br><span class="line">--export-dir &quot;/user/hive/warehouse/tmp.db/app_cource_study_analysis_$&#123;day&#125;&quot; \</span><br><span class="line">--staging-table app_cource_study_report_tmp \</span><br><span class="line">--clear-staging-table \</span><br><span class="line">--input-null-string &#x27;\N&#x27;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>sqoop</category>
      </categories>
      <tags>
        <tag>sqoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring整合Mybatis+Phoenix</title>
    <url>/posts/864324fe.html</url>
    <content><![CDATA[<h2 id="一、前言-2">一、前言</h2>
<p>使用 Spring+Mybatis 操作 Phoenix 和操作其他的关系型数据库（如 Mysql，Oracle）在配置上是基本相同的，下面会分别给出 Spring/Spring Boot 整合步骤，完整代码见本仓库：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://github.com/ihadyou/BigData-Notes/tree/master/code/Phoenix/spring-mybatis-phoenix">Spring + Mybatis + Phoenix</a></p>
</li>
<li class="lvl-2">
<p><a href="https://github.com/ihadyou/BigData-Notes/tree/master/code/Phoenix/spring-boot-mybatis-phoenix">SpringBoot + Mybatis + Phoenix</a></p>
</li>
</ul>
<h2 id="二、Spring-Mybatis-Phoenix">二、Spring + Mybatis + Phoenix</h2>
<h3 id="2-1-项目结构">2.1 项目结构</h3>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/spring-mybatis-phoenix.png"/> </div>
<h3 id="2-2-主要依赖">2.2 主要依赖</h3>
<p>除了 Spring 相关依赖外，还需要导入 <code>phoenix-core</code> 和对应的 Mybatis 依赖包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis 依赖包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--phoenix core--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.phoenix<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>phoenix-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.14.0-cdh5.14.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-数据库配置文件">2.3  数据库配置文件</h3>
<p>在数据库配置文件 <code>jdbc.properties</code>  中配置数据库驱动和 zookeeper 地址</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据库驱动</span></span><br><span class="line"><span class="attr">phoenix.driverClassName</span>=<span class="string">org.apache.phoenix.jdbc.PhoenixDriver</span></span><br><span class="line"><span class="comment"># zookeeper地址</span></span><br><span class="line"><span class="attr">phoenix.url</span>=<span class="string">jdbc:phoenix:192.168.0.105:2181</span></span><br></pre></td></tr></table></figure>
<h3 id="2-4-配置数据源和会话工厂">2.4  配置数据源和会话工厂</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启注解包扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ihadyou.*&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--指定配置文件的位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Phoenix 配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;phoenix.driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;phoenix.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置 mybatis 会话工厂 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定 mapper 文件所在的位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath*:/mappers/**/*.xml&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatisConfig.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--扫描注册接口 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--作用:从接口的基础包开始递归搜索，并将它们注册为 MapperFactoryBean(只有至少一种方法的接口才会被注册;, 具体类将被忽略)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定会话工厂 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定 mybatis 接口所在的包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.ihadyou.dao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-Mybtais参数配置">2.5 Mybtais参数配置</h3>
<p>新建 mybtais 配置文件，按照需求配置额外参数， 更多 settings 配置项可以参考<a href="http://www.mybatis.org/mybatis-3/zh/configuration.html">官方文档</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- mybatis 配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 开启驼峰命名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 打印查询 sql --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-6-查询接口">2.6 查询接口</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PopulationDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;USPopulation&gt; <span class="title function_">queryAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(USPopulation USPopulation)</span>;</span><br><span class="line"></span><br><span class="line">    USPopulation <span class="title function_">queryByStateAndCity</span><span class="params">(<span class="meta">@Param(&quot;state&quot;)</span> String state, <span class="meta">@Param(&quot;city&quot;)</span> String city)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteByStateAndCity</span><span class="params">(<span class="meta">@Param(&quot;state&quot;)</span> String state, <span class="meta">@Param(&quot;city&quot;)</span> String city)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.ihadyou.dao.PopulationDao&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.ihadyou.bean.USPopulation&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM us_population</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;save&quot;</span>&gt;</span></span><br><span class="line">        UPSERT INTO us_population VALUES( #&#123;state&#125;, #&#123;city&#125;, #&#123;population&#125; )</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryByStateAndCity&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.ihadyou.bean.USPopulation&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM us_population WHERE state=#&#123;state&#125; AND city = #&#123;city&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByStateAndCity&quot;</span>&gt;</span></span><br><span class="line">        DELETE FROM us_population WHERE state=#&#123;state&#125; AND city = #&#123;city&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-7-单元测试">2.7 单元测试</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&#123;&quot;classpath:springApplication.xml&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PopulationDaoTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PopulationDao populationDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryAll</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;USPopulation&gt; USPopulationList = populationDao.queryAll();</span><br><span class="line">        <span class="keyword">if</span> (USPopulationList != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (USPopulation USPopulation : USPopulationList) &#123;</span><br><span class="line">                System.out.println(USPopulation.getCity() + <span class="string">&quot; &quot;</span> + USPopulation.getPopulation());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        populationDao.save(<span class="keyword">new</span> <span class="title class_">USPopulation</span>(<span class="string">&quot;TX&quot;</span>, <span class="string">&quot;Dallas&quot;</span>, <span class="number">66666</span>));</span><br><span class="line">        <span class="type">USPopulation</span> <span class="variable">usPopulation</span> <span class="operator">=</span> populationDao.queryByStateAndCity(<span class="string">&quot;TX&quot;</span>, <span class="string">&quot;Dallas&quot;</span>);</span><br><span class="line">        System.out.println(usPopulation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        populationDao.save(<span class="keyword">new</span> <span class="title class_">USPopulation</span>(<span class="string">&quot;TX&quot;</span>, <span class="string">&quot;Dallas&quot;</span>, <span class="number">99999</span>));</span><br><span class="line">        <span class="type">USPopulation</span> <span class="variable">usPopulation</span> <span class="operator">=</span> populationDao.queryByStateAndCity(<span class="string">&quot;TX&quot;</span>, <span class="string">&quot;Dallas&quot;</span>);</span><br><span class="line">        System.out.println(usPopulation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        populationDao.deleteByStateAndCity(<span class="string">&quot;TX&quot;</span>, <span class="string">&quot;Dallas&quot;</span>);</span><br><span class="line">        <span class="type">USPopulation</span> <span class="variable">usPopulation</span> <span class="operator">=</span> populationDao.queryByStateAndCity(<span class="string">&quot;TX&quot;</span>, <span class="string">&quot;Dallas&quot;</span>);</span><br><span class="line">        System.out.println(usPopulation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、SpringBoot-Mybatis-Phoenix">三、SpringBoot + Mybatis + Phoenix</h2>
<h3 id="3-1-项目结构-2">3.1 项目结构</h3>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/spring-boot-mybatis-phoenix.png"/> </div>
<h3 id="3-2-主要依赖-2">3.2 主要依赖</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring 1.5 x 以上版本对应 mybatis 1.3.x (1.3.1)</span></span><br><span class="line"><span class="comment">        关于更多 spring-boot 与 mybatis 的版本对应可以参见 &lt;a href=&quot;http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/&quot;&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--phoenix core--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.phoenix<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>phoenix-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.14.0-cdh5.14.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>spring boot 与 mybatis 版本的对应关系：</p>
<table>
<thead>
<tr>
<th>MyBatis-Spring-Boot-Starter 版本</th>
<th>MyBatis-Spring 版本</th>
<th>Spring Boot 版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1.3.x (1.3.1)</strong></td>
<td>1.3 or higher</td>
<td>1.5 or higher</td>
</tr>
<tr>
<td><strong>1.2.x (1.2.1)</strong></td>
<td>1.3 or higher</td>
<td>1.4 or higher</td>
</tr>
<tr>
<td><strong>1.1.x (1.1.1)</strong></td>
<td>1.3 or higher</td>
<td>1.3 or higher</td>
</tr>
<tr>
<td><strong>1.0.x (1.0.2)</strong></td>
<td>1.2 or higher</td>
<td>1.3 or higher</td>
</tr>
</tbody>
</table>
<h3 id="3-3-配置数据源">3.3 配置数据源</h3>
<p>在 application.yml 中配置数据源，spring boot 2.x 版本默认采用 Hikari 作为数据库连接池，Hikari 是目前 java 平台性能最好的连接池，性能好于 druid。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment">#zookeeper 地址</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:phoenix:192.168.0.105:2181</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">org.apache.phoenix.jdbc.PhoenixDriver</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果不想配置对数据库连接池做特殊配置的话,以下关于连接池的配置就不是必须的</span></span><br><span class="line">    <span class="comment"># spring-boot 2.X 默认采用高性能的 Hikari 作为连接池 更多配置可以参考 https://github.com/brettwooldridge/HikariCP#configuration-knobs-baby</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="comment"># 池中维护的最小空闲连接数</span></span><br><span class="line">      <span class="attr">minimum-idle:</span> <span class="number">10</span></span><br><span class="line">      <span class="comment"># 池中最大连接数，包括闲置和使用中的连接</span></span><br><span class="line">      <span class="attr">maximum-pool-size:</span> <span class="number">20</span></span><br><span class="line">      <span class="comment"># 此属性控制从池返回的连接的默认自动提交行为。默认为 true</span></span><br><span class="line">      <span class="attr">auto-commit:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># 允许最长空闲时间</span></span><br><span class="line">      <span class="attr">idle-timeout:</span> <span class="number">30000</span></span><br><span class="line">      <span class="comment"># 此属性表示连接池的用户定义名称，主要显示在日志记录和 JMX 管理控制台中，以标识池和池配置。 默认值：自动生成</span></span><br><span class="line">      <span class="attr">pool-name:</span> <span class="string">custom-hikari</span></span><br><span class="line">      <span class="comment">#此属性控制池中连接的最长生命周期，值 0 表示无限生命周期，默认 1800000 即 30 分钟</span></span><br><span class="line">      <span class="attr">max-lifetime:</span> <span class="number">1800000</span></span><br><span class="line">      <span class="comment"># 数据库连接超时时间,默认 30 秒，即 30000</span></span><br><span class="line">      <span class="attr">connection-timeout:</span> <span class="number">30000</span></span><br><span class="line">      <span class="comment"># 连接测试 sql 这个地方需要根据数据库方言差异而配置 例如 oracle 就应该写成  select 1 from dual</span></span><br><span class="line">      <span class="attr">connection-test-query:</span> <span class="string">SELECT</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mybatis 相关配置</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment"># 是否打印 sql 语句 调试的时候可以开启</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4-新建查询接口">3.4 新建查询接口</h3>
<p>上面 Spring+Mybatis 我们使用了 XML 的方式来写 SQL，为了体现 Mybatis 支持多种方式，这里使用注解的方式来写 SQL。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PopulationDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * from us_population&quot;)</span></span><br><span class="line">    List&lt;USPopulation&gt; <span class="title function_">queryAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;UPSERT INTO us_population VALUES( #&#123;state&#125;, #&#123;city&#125;, #&#123;population&#125; )&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(USPopulation USPopulation)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM us_population WHERE state=#&#123;state&#125; AND city = #&#123;city&#125;&quot;)</span></span><br><span class="line">    USPopulation <span class="title function_">queryByStateAndCity</span><span class="params">(String state, String city)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete(&quot;DELETE FROM us_population WHERE state=#&#123;state&#125; AND city = #&#123;city&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteByStateAndCity</span><span class="params">(String state, String city)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-单元测试">3.5 单元测试</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PopulationTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PopulationDao populationDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryAll</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;USPopulation&gt; USPopulationList = populationDao.queryAll();</span><br><span class="line">        <span class="keyword">if</span> (USPopulationList != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (USPopulation USPopulation : USPopulationList) &#123;</span><br><span class="line">                System.out.println(USPopulation.getCity() + <span class="string">&quot; &quot;</span> + USPopulation.getPopulation());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        populationDao.save(<span class="keyword">new</span> <span class="title class_">USPopulation</span>(<span class="string">&quot;TX&quot;</span>, <span class="string">&quot;Dallas&quot;</span>, <span class="number">66666</span>));</span><br><span class="line">        <span class="type">USPopulation</span> <span class="variable">usPopulation</span> <span class="operator">=</span> populationDao.queryByStateAndCity(<span class="string">&quot;TX&quot;</span>, <span class="string">&quot;Dallas&quot;</span>);</span><br><span class="line">        System.out.println(usPopulation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        populationDao.save(<span class="keyword">new</span> <span class="title class_">USPopulation</span>(<span class="string">&quot;TX&quot;</span>, <span class="string">&quot;Dallas&quot;</span>, <span class="number">99999</span>));</span><br><span class="line">        <span class="type">USPopulation</span> <span class="variable">usPopulation</span> <span class="operator">=</span> populationDao.queryByStateAndCity(<span class="string">&quot;TX&quot;</span>, <span class="string">&quot;Dallas&quot;</span>);</span><br><span class="line">        System.out.println(usPopulation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        populationDao.deleteByStateAndCity(<span class="string">&quot;TX&quot;</span>, <span class="string">&quot;Dallas&quot;</span>);</span><br><span class="line">        <span class="type">USPopulation</span> <span class="variable">usPopulation</span> <span class="operator">=</span> populationDao.queryByStateAndCity(<span class="string">&quot;TX&quot;</span>, <span class="string">&quot;Dallas&quot;</span>);</span><br><span class="line">        System.out.println(usPopulation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="附：建表语句">附：建表语句</h2>
<p>上面单元测试涉及到的测试表的建表语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> us_population (</span><br><span class="line">      state <span class="type">CHAR</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">      city <span class="type">VARCHAR</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">      population <span class="type">BIGINT</span></span><br><span class="line">      <span class="keyword">CONSTRAINT</span> my_pk <span class="keyword">PRIMARY</span> KEY (state, city));</span><br><span class="line">      </span><br><span class="line"><span class="comment">-- 测试数据</span></span><br><span class="line">UPSERT <span class="keyword">INTO</span> us_population <span class="keyword">VALUES</span>(<span class="string">&#x27;NY&#x27;</span>,<span class="string">&#x27;New York&#x27;</span>,<span class="number">8143197</span>);</span><br><span class="line">UPSERT <span class="keyword">INTO</span> us_population <span class="keyword">VALUES</span>(<span class="string">&#x27;CA&#x27;</span>,<span class="string">&#x27;Los Angeles&#x27;</span>,<span class="number">3844829</span>);</span><br><span class="line">UPSERT <span class="keyword">INTO</span> us_population <span class="keyword">VALUES</span>(<span class="string">&#x27;IL&#x27;</span>,<span class="string">&#x27;Chicago&#x27;</span>,<span class="number">2842518</span>);</span><br><span class="line">UPSERT <span class="keyword">INTO</span> us_population <span class="keyword">VALUES</span>(<span class="string">&#x27;TX&#x27;</span>,<span class="string">&#x27;Houston&#x27;</span>,<span class="number">2016582</span>);</span><br><span class="line">UPSERT <span class="keyword">INTO</span> us_population <span class="keyword">VALUES</span>(<span class="string">&#x27;PA&#x27;</span>,<span class="string">&#x27;Philadelphia&#x27;</span>,<span class="number">1463281</span>);</span><br><span class="line">UPSERT <span class="keyword">INTO</span> us_population <span class="keyword">VALUES</span>(<span class="string">&#x27;AZ&#x27;</span>,<span class="string">&#x27;Phoenix&#x27;</span>,<span class="number">1461575</span>);</span><br><span class="line">UPSERT <span class="keyword">INTO</span> us_population <span class="keyword">VALUES</span>(<span class="string">&#x27;TX&#x27;</span>,<span class="string">&#x27;San Antonio&#x27;</span>,<span class="number">1256509</span>);</span><br><span class="line">UPSERT <span class="keyword">INTO</span> us_population <span class="keyword">VALUES</span>(<span class="string">&#x27;CA&#x27;</span>,<span class="string">&#x27;San Diego&#x27;</span>,<span class="number">1255540</span>);</span><br><span class="line">UPSERT <span class="keyword">INTO</span> us_population <span class="keyword">VALUES</span>(<span class="string">&#x27;CA&#x27;</span>,<span class="string">&#x27;San Jose&#x27;</span>,<span class="number">912332</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>hbase</category>
      </categories>
      <tags>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>Sqoop使用案例</title>
    <url>/posts/fdbfd415.html</url>
    <content><![CDATA[<h2 id="Sqoop-原理">Sqoop 原理</h2>
<p>将导入或导出命令翻译成 mapreduce 程序来实现。在翻译出的 mapreduce 中主要是对 inputformat 和 outputformat 进行定制。</p>
<h3 id="测试-Sqoop-是否能够成功连接数据库">测试 Sqoop 是否能够成功连接数据库</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop list-databases --connect jdbc:mysql://hadoop102:3306/</span></span><br><span class="line">--username root --password 000000</span><br></pre></td></tr></table></figure>
<h2 id="Sqoop-的简单使用案例">Sqoop 的简单使用案例</h2>
<h3 id="导入数据">导入数据</h3>
<p>在 Sqoop 中，“导入”概念指：从非大数据集群（RDBMS）向大数据集群（HDFS，HIVE，<br>
HBASE）中传输数据，叫做：导入，即使用 import 关键字。</p>
<h4 id="（1）全部导入">（1）全部导入</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop import \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--table staff \</span></span><br><span class="line"><span class="language-bash">--target-dir /user/company \</span></span><br><span class="line"><span class="language-bash">--delete-target-dir \</span></span><br><span class="line"><span class="language-bash">--num-mappers 1 \</span></span><br><span class="line"><span class="language-bash">--fields-terminated-by <span class="string">&quot;\t&quot;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="（2）查询导入">（2）查询导入</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop import \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--target-dir /user/company \</span></span><br><span class="line"><span class="language-bash">--delete-target-dir \</span></span><br><span class="line"><span class="language-bash">--num-mappers 1 \</span></span><br><span class="line"><span class="language-bash">--fields-terminated-by <span class="string">&quot;\t&quot;</span> \</span></span><br><span class="line"><span class="language-bash">--query <span class="string">&#x27;select name,sex from staff where id &lt;=1 and $CONDITIONS;&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>提示：<code>must contain '$CONDITIONS' in WHERE clause</code>.<br>
如果 query 后使用的是双引号，则$CONDITIONS 前必须加转移符，防止 shell 识别为自己的变量。</p>
<h4 id="（3）导入指定列">（3）导入指定列</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop import \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--target-dir /user/company \</span></span><br><span class="line"><span class="language-bash">--delete-target-dir \</span></span><br><span class="line"><span class="language-bash">--num-mappers 1 \</span></span><br><span class="line"><span class="language-bash">--fields-terminated-by <span class="string">&quot;\t&quot;</span> \</span></span><br><span class="line"><span class="language-bash">--columns <span class="built_in">id</span>,sex \</span></span><br><span class="line"><span class="language-bash">--table staff</span></span><br></pre></td></tr></table></figure>
<p>提示：columns 中如果涉及到多列，用逗号分隔，分隔时不要添加空格</p>
<h4 id="（4）使用-sqoop-关键字筛选查询导入数据">（4）使用 sqoop 关键字筛选查询导入数据</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop import \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--target-dir /user/company \</span></span><br><span class="line"><span class="language-bash">--delete-target-dir \</span></span><br><span class="line"><span class="language-bash">--num-mappers 1 \</span></span><br><span class="line"><span class="language-bash">--fields-terminated-by <span class="string">&quot;\t&quot;</span> \</span></span><br><span class="line"><span class="language-bash">--table staff \</span></span><br><span class="line"><span class="language-bash">--<span class="built_in">where</span> <span class="string">&quot;id=1&quot;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="RDBMS-到-Hive">RDBMS 到 Hive</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop import \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--table staff \</span></span><br><span class="line"><span class="language-bash">--num-mappers 1 \</span></span><br><span class="line"><span class="language-bash">--hive-import \</span></span><br><span class="line"><span class="language-bash">--fields-terminated-by <span class="string">&quot;\t&quot;</span> \</span></span><br><span class="line"><span class="language-bash">--hive-overwrite \</span></span><br><span class="line"><span class="language-bash">--hive-table staff_hive</span></span><br></pre></td></tr></table></figure>
<p>提示：该过程分为两步，第一步将数据导入到 HDFS，第二步将导入到 HDFS 的数据迁移到<br>
Hive 仓库，第一步默认的临时目录是/user/atguigu/表名</p>
<h4 id="RDBMS-到-Hbase">RDBMS 到 Hbase</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop import \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--table company \</span></span><br><span class="line"><span class="language-bash">--columns <span class="string">&quot;id,name,sex&quot;</span> \</span></span><br><span class="line"><span class="language-bash">--column-family <span class="string">&quot;info&quot;</span> \</span></span><br><span class="line"><span class="language-bash">--hbase-create-table \</span></span><br><span class="line"><span class="language-bash">--hbase-row-key <span class="string">&quot;id&quot;</span> \</span></span><br><span class="line"><span class="language-bash">--hbase-table <span class="string">&quot;hbase_company&quot;</span> \</span></span><br><span class="line"><span class="language-bash">--num-mappers 1 \</span></span><br><span class="line"><span class="language-bash">--split-by <span class="built_in">id</span></span></span><br></pre></td></tr></table></figure>
<p>提示：sqoop1.4.6 只支持 HBase1.0.1 之前的版本的自动创建 HBase 表的功能解决方案：手动创建 HBase 表</p>
<h3 id="导出数据">导出数据</h3>
<p>在 Sqoop 中，“导出”概念指：从大数据集群（HDFS，HIVE，HBASE）向非大数据集群（RDBMS）中传输数据，叫做：导出，即使用 export 关键字。</p>
<h4 id="HIVE-HDFS-到-RDBMS">HIVE/HDFS 到 RDBMS</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop <span class="built_in">export</span> \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--table staff \</span></span><br><span class="line"><span class="language-bash">--num-mappers 1 \</span></span><br><span class="line"><span class="language-bash">--export-dir /user/hive/warehouse/staff_hive \</span></span><br><span class="line"><span class="language-bash">--input-fields-terminated-by <span class="string">&quot;\t&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>提示：Mysql 中如果表不存在，不会自动创建</p>
<h3 id="脚本打包">脚本打包</h3>
<p>使用 opt 格式的文件打包 sqoop 命令，然后执行</p>
<h4 id="1-创建一个-opt-文件">1) 创建一个.opt 文件</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">mkdir</span> opt</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">touch</span> opt/job_HDFS2RDBMS.opt</span></span><br></pre></td></tr></table></figure>
<h4 id="2-编写-sqoop-脚本">2) 编写 sqoop 脚本</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">vi opt/job_HDFS2RDBMS.opt</span></span><br><span class="line">export</span><br><span class="line">--connect</span><br><span class="line">jdbc:mysql://hadoop102:3306/company</span><br><span class="line">--username</span><br><span class="line">root</span><br><span class="line">--password</span><br><span class="line">000000</span><br><span class="line">--table</span><br><span class="line">staff</span><br><span class="line">--num-mappers</span><br><span class="line">1</span><br><span class="line">--export-dir</span><br><span class="line">/user/hive/warehouse/staff_hive</span><br><span class="line">--input-fields-terminated-by</span><br><span class="line">&quot;\t&quot;</span><br></pre></td></tr></table></figure>
<h4 id="3-执行该脚本">3) 执行该脚本</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop --options-file opt/job_HDFS2RDBMS.opt</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>sqoop</category>
      </categories>
      <tags>
        <tag>sqoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Sqoop常用命令及参数</title>
    <url>/posts/e22156b1.html</url>
    <content><![CDATA[<h2 id="Sqoop-常用命令及参数">Sqoop 常用命令及参数</h2>
<h3 id="常用命令列举">常用命令列举</h3>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">命令</th>
<th style="text-align:left">类</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">import</td>
<td style="text-align:left">ImportTool</td>
<td style="text-align:left">将数据导入到集群</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">export</td>
<td style="text-align:left">ExportTool</td>
<td style="text-align:left">将集群数据导出</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">codegen</td>
<td style="text-align:left">CodeGenTool</td>
<td style="text-align:left">获取数据库中某张表数据生成Java 并打包Jar</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">create-hive-table</td>
<td style="text-align:left">CreateHiveTableTool</td>
<td style="text-align:left">创建 Hive 表</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">eval</td>
<td style="text-align:left">EvalSqlTool</td>
<td style="text-align:left">查看 SQL 执行结果</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">import-all-tables</td>
<td style="text-align:left">ImportAllTablesTool</td>
<td style="text-align:left">导入某个数据库下所有表到 HDFS 中</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">job</td>
<td style="text-align:left">JobTool</td>
<td style="text-align:left">用来生成一个 sqoop的任务，生成后，该任务并不执行，除非使用命令执行该任务</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">list-databases</td>
<td style="text-align:left">ListDatabasesTool</td>
<td style="text-align:left">列出所有数据库名</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">list-tables</td>
<td style="text-align:left">ListTablesTool</td>
<td style="text-align:left">列出某个数据库下所有表</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">merge</td>
<td style="text-align:left">MergeTool</td>
<td style="text-align:left">将 HDFS 中不同目录下面的数据合在一起，并存放在指定的目录中</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left">metastore</td>
<td style="text-align:left">MetastoreTool</td>
<td style="text-align:left">记录 sqoop job 的元数据信息，如果不启动 metastore 实例，则默认的元数据存储目录为：~/.sqoop，如果要更改存储目录，可以 在 配 置 文 件sqoop-site.xml 中进行更改</td>
</tr>
</tbody>
</table>
<h3 id="命令-参数详解">命令&amp;参数详解</h3>
<p>对于不同的命令，有不同的参数.</p>
<h4 id="公用参数：数据库连接">公用参数：数据库连接</h4>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">–connect</td>
<td style="text-align:left">连接关系型数据库的 URL</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">–connection-manager</td>
<td style="text-align:left">指定要使用的连接管理类</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">–driver</td>
<td style="text-align:left">Hadoop 根目录</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">–help</td>
<td style="text-align:left">打印帮助信息</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">–password</td>
<td style="text-align:left">连接数据库的密码</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">–username</td>
<td style="text-align:left">连接数据库的用户名</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">–verbose</td>
<td style="text-align:left">在控制台打印出详细信息</td>
</tr>
</tbody>
</table>
<h4 id="公用参数：import">公用参数：import</h4>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">–enclosed-by <char></td>
<td style="text-align:left">给字段值前加上指定的字符</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">–escaped-by <char></td>
<td style="text-align:left">对字段中的双引号加转义符</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">–fields-terminated-by <char></td>
<td style="text-align:left">设定每个字段是以什么符号作为结束，默认为逗号</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">–lines-terminated-by <char></td>
<td style="text-align:left">设定每行记录之间的分隔符，默认是\n</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">–mysql-delimiters</td>
<td style="text-align:left">Mysql 默认的分隔符设置，字段之间以逗号分隔，行之间以\n 分隔，默认转义符是\，字段值以单引号包裹。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">–optionally-enclosed-by <char></td>
<td style="text-align:left">给带有双引号或单引号的字段值前后加上指定字符。</td>
</tr>
</tbody>
</table>
<h4 id="公用参数：export">公用参数：export</h4>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">–input-enclosed-by <char></td>
<td style="text-align:left">对字段值前后加上指定字符</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">–input-escaped-by <char></td>
<td style="text-align:left">对含有转移符的字段做转义处理</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">–input-fields-terminated-by <char></td>
<td style="text-align:left">字段之间的分隔符</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">–input-lines-terminated-by <char></td>
<td style="text-align:left">行之间的分隔符</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">–input-optionally-enclosed-by <char></td>
<td style="text-align:left">给带有双引号或单引号的字段前后加上指定字符</td>
</tr>
</tbody>
</table>
<h4 id="公用参数：hive">公用参数：hive</h4>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">–hive-delims-replacement <arg></td>
<td style="text-align:left">用自定义的字符串替换掉数据中的\r\n和\013 \010等字符</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">–hive-drop-import-delims</td>
<td style="text-align:left">在导入数据到 hive 时，去掉数据中的\r\n\013\010 这样的字符</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">–map-column-hive <arg></td>
<td style="text-align:left">生成 hive 表时，可以更改生成字段的数据类型</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">–hive-partition-key</td>
<td style="text-align:left">创建分区，后面直接跟分区名，分区字段的默认类型为string</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">–hive-partition-value <v></td>
<td style="text-align:left">导入数据时，指定某个分区的值</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">–hive-home <dir></td>
<td style="text-align:left">hive 的安装目录，可以通过该参数覆盖之前默认配置的目录</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">–hive-import</td>
<td style="text-align:left">将数据从关系数据库中导入到 hive 表中</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">–hive-overwrite</td>
<td style="text-align:left">覆盖掉在 hive 表中已经存在的数据</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">–create-hive-table</td>
<td style="text-align:left">默认是 false，即，如果目标表已经存在了，那么创建任务失败。</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">–hive-table</td>
<td style="text-align:left">后面接要创建的 hive 表,默认使用 MySQL 的表名</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left">–table</td>
<td style="text-align:left">指定关系数据库的表名</td>
</tr>
</tbody>
</table>
<h4 id="命令-参数：import">命令&amp;参数：import</h4>
<p>将关系型数据库中的数据导入到 HDFS（包括 Hive，HBase）中，如果导入的是 Hive，那么当 Hive 中没有对应表时，则自动创建。</p>
<h5 id="1-命令：">1) 命令：</h5>
<h6 id="如：导入数据到-hive-中">如：导入数据到 hive 中</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop import \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--table staff \</span></span><br><span class="line"><span class="language-bash">--hive-import</span></span><br></pre></td></tr></table></figure>
<h6 id="如：增量导入数据到-hive-中，mode-append">如：增量导入数据到 hive 中，mode=append</h6>
<p>append 导入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop import \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--table staff \</span></span><br><span class="line"><span class="language-bash">--num-mappers 1 \</span></span><br><span class="line"><span class="language-bash">--fields-terminated-by <span class="string">&quot;\t&quot;</span> \</span></span><br><span class="line"><span class="language-bash">--target-dir /user/hive/warehouse/staff_hive \</span></span><br><span class="line"><span class="language-bash">--check-column <span class="built_in">id</span> \</span></span><br><span class="line"><span class="language-bash">--incremental append \</span></span><br><span class="line"><span class="language-bash">--last-value 3</span></span><br></pre></td></tr></table></figure>
<p>尖叫提示：append 不能与–hive-等参数同时使用（Append mode for hive imports is not yet supported. Please remove the parameter --append-mode）</p>
<h6 id="如：增量导入数据到-hdfs-中，mode-lastmodified">如：增量导入数据到 hdfs 中，mode=lastmodified</h6>
<p>先在 mysql 中建表并插入几条数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> company.staff_timestamp(id <span class="type">int</span>(<span class="number">4</span>), name <span class="type">varchar</span>(<span class="number">255</span>), sex <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">last_modified <span class="type">timestamp</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span></span><br><span class="line"><span class="built_in">CURRENT_TIMESTAMP</span>);</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> company.staff_timestamp (id, name, sex) <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;AAA&#x27;</span>, <span class="string">&#x27;female&#x27;</span>);</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> company.staff_timestamp (id, name, sex) <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">&#x27;BBB&#x27;</span>, <span class="string">&#x27;female&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>先导入一部分数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop import \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--table staff_timestamp \</span></span><br><span class="line"><span class="language-bash">--delete-target-dir \</span></span><br><span class="line"><span class="language-bash">--m 1</span></span><br></pre></td></tr></table></figure>
<p>再增量导入一部分数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">insert into company.staff_timestamp (<span class="built_in">id</span>, name, sex) values(3, <span class="string">&#x27;CCC&#x27;</span>, <span class="string">&#x27;female&#x27;</span>);</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop import \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--table staff_timestamp \</span></span><br><span class="line"><span class="language-bash">--check-column last_modified \</span></span><br><span class="line"><span class="language-bash">--incremental lastmodified \</span></span><br><span class="line"><span class="language-bash">--last-value <span class="string">&quot;2017-09-28 22:20:38&quot;</span> \</span></span><br><span class="line"><span class="language-bash">--m 1 \</span></span><br><span class="line"><span class="language-bash">--append</span></span><br></pre></td></tr></table></figure>
<p>尖叫提示：使用 lastmodified 方式导入数据要指定增量数据是要–append（追加）还是要–merge-key（合并）尖叫提示：last-value 指定的值是会包含于增量导入的数据中</p>
<h5 id="2-参数：">2) 参数：</h5>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">- -append</td>
<td style="text-align:left">将数据追加到 HDFS 中已经存在的 DataSet 中，如果使用该参数，sqoop 会把数据先导入到临时文件目录，再合并。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">- -as-avrodatafile</td>
<td style="text-align:left">将数据导入到一个 Avro 数据文件中</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">- -as-sequencefile</td>
<td style="text-align:left">将数据导入到一个 sequence文件中</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">- -as-textfile</td>
<td style="text-align:left">将数据导入到一个普通文本文件中</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">- -boundary-query <statement></td>
<td style="text-align:left">边界查询，导入的数据为该参数的值（一条 sql 语句）所执行的结果区间内的数据。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">- -columns &lt;col1, col2, col3&gt;</td>
<td style="text-align:left">指定要导入的字段</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">- -direct</td>
<td style="text-align:left">直接导入模式，使用的是关系数据库自带的导入导出工具，以便加快导入导出过程。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">- -direct-split-size</td>
<td style="text-align:left">在使用上面 direct 直接导入的基础上，对导入的流按字节分块，即达到该阈值就产生一个新的文件</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">- -inline-lob-limit</td>
<td style="text-align:left">设定大对象数据类型的最大值</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">–m 或–num-mappers</td>
<td style="text-align:left">启动 N 个 map 来并行导入数据，默认 4 个。</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left">–query 或–e <statement></td>
<td style="text-align:left">将查询结果的数据导入，使用时必须伴随参–target-dir，–hive-table，如果查询中有where 条件，则条件后必须加上$CONDITIONS 关键字</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left">–split-by <column-name></td>
<td style="text-align:left">按照某一列来切分表的工作单元，不能与–autoreset-to-one-mapper 连用</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left">–table <table-name></td>
<td style="text-align:left">关系数据库的表名</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left">–target-dir <dir></td>
<td style="text-align:left">指定 HDFS 路径</td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left">–warehouse-dir <dir></td>
<td style="text-align:left">与 14 参数不能同时使用，导入数据到 HDFS 时指定的目录</td>
</tr>
<tr>
<td style="text-align:left">16</td>
<td style="text-align:left">–where</td>
<td style="text-align:left">从关系数据库导入数据时的查询条件</td>
</tr>
<tr>
<td style="text-align:left">17</td>
<td style="text-align:left">–z 或–compress</td>
<td style="text-align:left">允许压缩</td>
</tr>
<tr>
<td style="text-align:left">18</td>
<td style="text-align:left">–compression-codec</td>
<td style="text-align:left">指定 hadoop 压缩编码类，默认为 gzip(Use Hadoop codecdefault gzip)</td>
</tr>
<tr>
<td style="text-align:left">19</td>
<td style="text-align:left">–null-string <null-string></td>
<td style="text-align:left">string 类型的列如果 null，替换为指定字符串</td>
</tr>
<tr>
<td style="text-align:left">20</td>
<td style="text-align:left">–null-non-string <null-string></td>
<td style="text-align:left">非 string 类型的列如果 null，替换为指定字符串</td>
</tr>
<tr>
<td style="text-align:left">21</td>
<td style="text-align:left">–check-column <col></td>
<td style="text-align:left">作为增量导入判断的列名</td>
</tr>
<tr>
<td style="text-align:left">22</td>
<td style="text-align:left">–incremental <mode></td>
<td style="text-align:left">mode：append 或 lastmodified</td>
</tr>
<tr>
<td style="text-align:left">23</td>
<td style="text-align:left">–last-value <value></td>
<td style="text-align:left">指定某一个值，用于标记增量导入的位置</td>
</tr>
</tbody>
</table>
<h4 id="命令-参数：export">命令&amp;参数：export</h4>
<p>从 HDFS（包括 Hive 和 HBase）中奖数据导出到关系型数据库中。</p>
<h5 id="1-命令：-2">1) 命令：</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop <span class="built_in">export</span> \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--table staff \</span></span><br><span class="line"><span class="language-bash">--export-dir /user/company \</span></span><br><span class="line"><span class="language-bash">--input-fields-terminated-by <span class="string">&quot;\t&quot;</span> \</span></span><br><span class="line"><span class="language-bash">--num-mappers 1</span></span><br></pre></td></tr></table></figure>
<h5 id="2-参数：-2">2) 参数：</h5>
<table>
<thead>
<tr>
<th>序号</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>–direct</td>
<td>利用数据库自带的导入导出工具，以便于提高效率</td>
</tr>
<tr>
<td>2</td>
<td>–export-dir <dir></td>
<td>存放数据的 HDFS 的源目录</td>
</tr>
<tr>
<td>3</td>
<td>m 或–num-mappers <n></td>
<td>启动 N 个 map 来并行导入数据，默认 4 个</td>
</tr>
<tr>
<td>4</td>
<td>–table <table-name></td>
<td>指定导出到哪个 RDBMS 中的表</td>
</tr>
<tr>
<td>5</td>
<td>–update-key <col-name></td>
<td>对某一列的字段进行更新操作</td>
</tr>
<tr>
<td>6</td>
<td>–update-mode <mode></td>
<td>updateonlyallowinsert(默认)</td>
</tr>
<tr>
<td>7</td>
<td>–input-null-string <null-string></td>
<td>请参考 import</td>
</tr>
<tr>
<td>8</td>
<td>–input-null-non-string <null-string></td>
<td>请参考 import</td>
</tr>
<tr>
<td>9</td>
<td>–staging-table <staging-table-name></td>
<td>创建一张临时表，用于存放所有事务的结果，然后将所有事务结果一次性导入到目标表中，防止错误。</td>
</tr>
<tr>
<td>10</td>
<td>–clear-staging-table</td>
<td>如果第 9 个参数非空，则可以在导出操作执行前，清空临时事务结果表</td>
</tr>
</tbody>
</table>
<h4 id="命令-参数：codegen">命令&amp;参数：codegen</h4>
<p>将关系型数据库中的表映射为一个 Java 类，在该类中有各列对应的各个字段。</p>
<h5 id="1-命令：-3">1) 命令：</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop codegen \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--table staff \</span></span><br><span class="line"><span class="language-bash">--bindir /home/admin/Desktop/staff \</span></span><br><span class="line"><span class="language-bash">--class-name Staff \</span></span><br><span class="line"><span class="language-bash">--fields-terminated-by <span class="string">&quot;\t&quot;</span></span></span><br></pre></td></tr></table></figure>
<h5 id="2-参数：-3">2) 参数：</h5>
<table>
<thead>
<tr>
<th>序号</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>–bindir <dir></td>
<td>指定生成的 Java 文件、编译成的 class 文件及将生成文件打包为 jar 的文件输出路径</td>
</tr>
<tr>
<td>2</td>
<td>–class-name <name></td>
<td>设定生成的 Java 文件指定的名称</td>
</tr>
<tr>
<td>3</td>
<td>–outdir <dir></td>
<td>生成 Java 文件存放的路径</td>
</tr>
<tr>
<td>4</td>
<td>–package-name <name></td>
<td>包名，如 com.z，就会生成 com和 z 两级目录</td>
</tr>
<tr>
<td>5</td>
<td>–input-null-non-string <null-str></td>
<td>在生成的 Java 文件中，可以将 null 字符串或者不存在的字符串设置为想要设定的值（例如空字符串）</td>
</tr>
<tr>
<td>6</td>
<td>–input-null-string <null-str></td>
<td>将 null 字符串替换成想要替换的值（一般与 5 同时使用）</td>
</tr>
<tr>
<td>7</td>
<td>–map-column-java <arg></td>
<td>数据库字段在生成的 Java 文件中会映射成各种属性，且默认的数据类型与数据库类型保持对应关系。该参数可以改变默认类型，例如：–map-column-java id=long,name=String</td>
</tr>
<tr>
<td>8</td>
<td>–null-non-string <null-str></td>
<td>在生成 Java 文件时，可以将不存在或者 null 的字符串设置为其他值</td>
</tr>
<tr>
<td>9</td>
<td>–null-string <null-str></td>
<td>在生成 Java 文件时，将 null字符串设置为其他值（一般与8 同时用）</td>
</tr>
<tr>
<td>10</td>
<td>–table <table-name></td>
<td>对应关系数据库中的表名，生成的 Java 文件中的各个属性与该表的各个字段一一对应</td>
</tr>
</tbody>
</table>
<h4 id="命令-参数：create-hive-table">命令&amp;参数：create-hive-table</h4>
<p>生成与关系数据库表结构对应的 hive 表结构。</p>
<h5 id="1-命令：-4">1) 命令：</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop create-hive-table \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--table staff \</span></span><br><span class="line"><span class="language-bash">--hive-table hive_staff</span></span><br></pre></td></tr></table></figure>
<h5 id="2-参数：-4">2) 参数：</h5>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">–hive-home <dir></td>
<td style="text-align:left">Hive 的安装目录，可以通过该参数覆盖掉默认的 Hive 目录</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">–hive-overwrite</td>
<td style="text-align:left">覆盖掉在 Hive 表中已经存在的数据</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">–create-hive-table</td>
<td style="text-align:left">默认是 false，如果目标表已经存在了，那么创建任务会失败</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">–hive-table</td>
<td style="text-align:left">后面接要创建的 hive 表</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">–table</td>
<td style="text-align:left">指定关系数据库的表名</td>
</tr>
</tbody>
</table>
<h4 id="命令-参数：eval">命令&amp;参数：eval</h4>
<p>可以快速的使用 SQL 语句对关系型数据库进行操作，经常用于在 import 数据之前，了解一下 SQL 语句是否正确，数据是否正常，并可以将结果显示在控制台。</p>
<h5 id="1-命令：-5">1) 命令：</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop <span class="built_in">eval</span> \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--query <span class="string">&quot;SELECT * FROM staff&quot;</span></span></span><br></pre></td></tr></table></figure>
<h5 id="2-参数：-5">2) 参数：</h5>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">–query 或–e</td>
<td style="text-align:left">后跟查询的 SQL 语句</td>
</tr>
</tbody>
</table>
<h4 id="命令-参数：import-all-tables">命令&amp;参数：import-all-tables</h4>
<p>可以将 RDBMS 中的所有表导入到 HDFS 中，每一个表都对应一个 HDFS 目录</p>
<h5 id="1-命令：-6">1) 命令：</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop import-all-tables \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--warehouse-dir /all_tables</span></span><br></pre></td></tr></table></figure>
<h5 id="2-参数">2) 参数</h5>
<p>这些参数的含义均和 import 对应的含义一致</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">参数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">–as-avrodatafile</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">–as-sequencefile</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">–as-textfile</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">–direct</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">–direct-split-size <n></td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">–inline-lob-limit <n></td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">–m 或—num-mappers <n></td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">–warehouse-dir <dir></td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">-z 或–compress</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">–compression-codec</td>
</tr>
</tbody>
</table>
<h4 id="命令-参数：job">命令&amp;参数：job</h4>
<p>用来生成一个 sqoop 任务，生成后不会立即执行，需要手动执行。</p>
<h5 id="1-命令：-7">1) 命令：</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop job \</span></span><br><span class="line"><span class="language-bash">--create myjob -- import-all-tables \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop job \</span></span><br><span class="line"><span class="language-bash">--list</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop job \</span></span><br><span class="line"><span class="language-bash">--<span class="built_in">exec</span> myjob</span></span><br></pre></td></tr></table></figure>
<p>尖叫提示：注意 import-all-tables 和它左边的–之间有一个空格尖叫提示：如果需要连接 metastore，则–meta-connect jdbc:hsqldb:hsql://linux01:16000/sqoop</p>
<h5 id="2-参数-2">2) 参数</h5>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">–create <job-id></td>
<td style="text-align:left">创建 job 参数</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">–delete <job-id></td>
<td style="text-align:left">删除一个 job</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">–exec <job-id></td>
<td style="text-align:left">执行一个 job</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">–help</td>
<td style="text-align:left">显示 job 帮助</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">–list</td>
<td style="text-align:left">显示 job 列表</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">–meta-connect <jdbc-uri></td>
<td style="text-align:left">用来连接 metastore 服务</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">–show <job-id></td>
<td style="text-align:left">显示一个 job 的信息</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">–verbose</td>
<td style="text-align:left">打印命令运行时的详细信息</td>
</tr>
<tr>
<td style="text-align:left">尖叫提示：在执行一个 job 时，如果需要手动输入数据库密码，可以做如下优化</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>sqoop.metastore.client.record.password<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>If true, allow saved passwords in the metastore.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="命令-参数：list-databases">命令&amp;参数：list-databases</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop list-databases \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/ \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000</span></span><br></pre></td></tr></table></figure>
<h4 id="命令-参数：list-tables">命令&amp;参数：list-tables</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop list-tables \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000</span></span><br></pre></td></tr></table></figure>
<h4 id="命令-参数：merge">命令&amp;参数：merge</h4>
<p>将 HDFS 中不同目录下面的数据合并在一起并放入指定目录中</p>
<h5 id="数据环境：">数据环境：</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">new_staff</span><br><span class="line">1 AAA male</span><br><span class="line">2 BBB male</span><br><span class="line">3 CCC male</span><br><span class="line">4 DDD male</span><br><span class="line">old_staff</span><br><span class="line">1 AAA female</span><br><span class="line">2 CCC female</span><br><span class="line">3 BBB female</span><br><span class="line">6 DDD female</span><br></pre></td></tr></table></figure>
<p>尖叫提示：上边数据的列之间的分隔符应该为\t，行与行之间的分割符为\n，如果直接复制，请检查之。</p>
<h5 id="命令：-2">命令：</h5>
<p>创建 JavaBean：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop codegen \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--table staff \</span></span><br><span class="line"><span class="language-bash">--bindir /home/admin/Desktop/staff \</span></span><br><span class="line"><span class="language-bash">--class-name Staff \</span></span><br><span class="line"><span class="language-bash">--fields-terminated-by <span class="string">&quot;\t&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>开始合并：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop merge \</span></span><br><span class="line"><span class="language-bash">--new-data /test/new/ \</span></span><br><span class="line"><span class="language-bash">--onto /test/old/ \</span></span><br><span class="line"><span class="language-bash">--target-dir /test/merged \</span></span><br><span class="line"><span class="language-bash">--jar-file /home/admin/Desktop/staff/Staff.jar \</span></span><br><span class="line"><span class="language-bash">--class-name Staff \</span></span><br><span class="line"><span class="language-bash">--merge-key <span class="built_in">id</span></span></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 AAA MALE</span><br><span class="line">2 BBB MALE</span><br><span class="line">3 CCC MALE</span><br><span class="line">4 DDD MALE</span><br><span class="line">6 DDD FEMALE</span><br></pre></td></tr></table></figure>
<h5 id="参数：">参数：</h5>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">–new-data <path></td>
<td style="text-align:left">HDFS 待合并的数据目录，合并后在新的数据集中保留</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">–onto <path></td>
<td style="text-align:left">HDFS 合并后，重复的部分在新的数据集中被覆盖</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">–merge-key <col></td>
<td style="text-align:left">合并键，一般是主键 ID</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">–jar-file <file></td>
<td style="text-align:left">合并时引入的 jar 包，该 jar包是通过 Codegen 工具生成的 jar 包</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">–class-name <class></td>
<td style="text-align:left">对应的表名或对象名，该class 类是包含在 jar 包中的</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">–target-dir <path></td>
<td style="text-align:left">合并后的数据在 HDFS 里存放的目录</td>
</tr>
</tbody>
</table>
<h4 id="命令-参数：metastore">命令&amp;参数：metastore</h4>
<p>记录了 Sqoop job 的元数据信息，如果不启动该服务，那么默认 job 元数据的存储目录为<br>
~/.sqoop，可在 sqoop-site.xml 中修改。启动 sqoop 的 metastore 服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop metastore</span></span><br></pre></td></tr></table></figure>
<p>关闭 sqoop 的 metastore 服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop metastore --shutdown</span>  </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大数据组件</category>
        <category>sqoop</category>
      </categories>
      <tags>
        <tag>sqoop</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper使用场景</title>
    <url>/posts/59a1d908.html</url>
    <content><![CDATA[<h2 id="ZooKeeper-是什么">ZooKeeper 是什么</h2>
<p>  ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 Google 的 Chubby 一个开源的实现，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。<br>
  客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上注册了监听器，这个监听器也是由所连接的 zookeeper 机器来处理。对于写请求，这些请求会同时发给其他 zookeeper 机器并且达成一致后，请求才会返回成功。因此，随着 zookeeper 的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。有序性是 zookeeper 中非常重要的一个特性，所有的更新都是全局有序的，每个更新都有一个唯一的时间戳，这个时间戳称为 zxid（Zookeeper Transaction Id）。而读请求只会相对于更新有序，也就是读请求的返回结果中会带有这个 zookeeper 最新的 zxid。</p>
<h2 id="Zookeeper-工作原理">Zookeeper 工作原理</h2>
<p>  Zookeeper 的核心是原子广播，这个机制保证了各个 Server 之间的同步。实现这个机制的协议叫做 Zab 协议。Zab 协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab 就进入了恢复模式，当领导者被选举出来，且大多数 Server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 Server 具有相同的系统状态。</p>
<h2 id="ZooKeeper-提供了什么">ZooKeeper 提供了什么</h2>
<p>1、文件系统<br>
2、通知机制</p>
<h3 id="Zookeeper-文件系统">Zookeeper 文件系统</h3>
<p>  Zookeeper 提供一个多层级的节点命名空间（节点称为 znode）。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。Zookeeper 为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得 Zookeeper 不能用于存放大量的数据，每个节点的存放数据上限为 1M。</p>
<h4 id="四种类型的-znode">四种类型的 znode</h4>
<p>1、PERSISTENT-持久化目录节点客户端与 zookeeper 断开连接后，该节点依旧存在<br>
2、PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点客户端与 zookeeper 断开连接后，该节点依旧存在，只是 Zookeeper 给该节点名称进行顺序编号<br>
3、EPHEMERAL-临时目录节点客户端与 zookeeper 断开连接后，该节点被删除<br>
4、EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点</p>
<p>  客户端与 zookeeper 断开连接后，该节点被删除，只是 Zookeeper 给该节点名称进行顺序编号</p>
<h3 id="Zookeeper-通知机制">Zookeeper 通知机制</h3>
<p>  client 端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些 client 会收到 zk 的通知，然后 client 可以根据 znode 变化来做出业务上的改变等。</p>
<h4 id="zookeeper-watch-机制">zookeeper watch 机制</h4>
<p>  Watch 机制官方声明：一个 Watch 事件是一个一次性的触发器，当被设置了 Watch 的数据发生了改变的时候，则服务器将这个改变发送给设置了 Watch 的客户端，以便通知它们。<br>
Zookeeper 机制的特点：</p>
<ol>
<li class="lvl-3">
<p>一次性触发数据发生改变时，一个 watcher event 会被发送到 client，但是 client 只会收到一次这样的信息。</p>
</li>
<li class="lvl-3">
<p>watcher event 异步发送 watcher 的通知事件从 server 发送到 client 是异步的，这就存在一个问题，不同的客户端和服务器之间通过 socket 进行通信，由于网络延迟或其他因素导致客户端在不通的时刻监听到事件，由于 Zookeeper 本身提供了 ordering guarantee，即客户端监听事件后，才会感知它所监视 znode 发生了变化。所以我们使用 Zookeeper 不能期望能够监控到节点每次的变化。Zookeeper 只能保证最终的一致性，而无法保证强一致性。</p>
</li>
<li class="lvl-3">
<p>数据监视 Zookeeper 有数据监视和子数据监视 getdata() and exists()设置数据监视，getchildren()设置了子节点监视。</p>
</li>
<li class="lvl-3">
<p>注册 watcher getData、exists、getChildren</p>
</li>
<li class="lvl-3">
<p>触发 watcher create、delete、setData</p>
</li>
<li class="lvl-3">
<p>setData()会触发 znode 上设置的 data watch（如果 set 成功的话）。一个成功的 create() 操作会触发被创建的 znode 上的数据 watch，以及其父节点上的 child watch。而一个成功的 delete()操作将会同时触发一个 znode 的 data watch 和 child watch（因为这样就没有子节点了），同时也会触发其父节点的 childwatch。</p>
</li>
<li class="lvl-3">
<p>当一个客户端连接到一个新的服务器上时，watch 将会被以任意会话事件触发。当与一个服务器失去连接的时候，是无法接收到 watch 的。而当 client 重新连接时，如果需要的话，所有先前注册过的 watch，都会被重新注册。通常这是完全透明的。只有在一个特殊情况下，watch 可能会丢失：对于一个未创建的 znode 的exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上之前又删除了，这种情况下，这个 watch 事件可能会被丢失。</p>
</li>
<li class="lvl-3">
<p>Watch 是轻量级的，其实就是本地 JVM 的 Callback，服务器端只是存了是否有设置了 Watcher 的布尔类型</p>
</li>
</ol>
<h2 id="Zookeeper-做了什么">Zookeeper 做了什么</h2>
<p>1、命名服务<br>
2、配置管理<br>
3、集群管理<br>
4、分布式锁<br>
5、队列管理</p>
<h3 id="zk-的命名服务（文件系统）">zk 的命名服务（文件系统）</h3>
<p>  命名服务是指通过指定的名字来获取资源或者服务的地址，利用 zk 创建一个全局的路径，即是唯一的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等等。</p>
<h3 id="zk-的配置管理（文件系统、通知机制）">zk 的配置管理（文件系统、通知机制）</h3>
<p>  程序分布式的部署在不同的机器上，将程序的配置信息放在 zk 的 znode 下，当有配置发生改变时，也就是znode 发生变化时，可以通过改变 zk 中某个目录节点的内容，利用 watcher 通知给各个客户端，从而更改配置。</p>
<h3 id="Zookeeper-集群管理（文件系统、通知机制）">Zookeeper 集群管理（文件系统、通知机制）</h3>
<p>  所谓集群管理无在乎两点：是否有机器退出和加入、选举 master。<br>
  对于第一点，所有机器约定在父目录下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与zookeeper 的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除，于是，所有人都知道：它上船了。<br>
  新机器加入也是类似，所有机器收到通知：新兄弟目录加入，highcount 又有了，对于第二点，我们稍微改变一下，所有机器创建临时顺序编号目录节点，每次选取编号最小的机器作为 master 就好。</p>
<h3 id="Zookeeper-分布式锁（文件系统、通知机制）">Zookeeper 分布式锁（文件系统、通知机制）</h3>
<p>  有了 zookeeper 的一致性文件系统，锁的问题变得容易。锁服务可以分为两类，一个是保持独占，另一个是控制时序。<br>
  对于第一类，我们将 zookeeper 上的一个 znode 看作是一把锁，通过 createznode 的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的distribute_lock 节点就释放出锁。<br>
  对于第二类， /distribute_lock 已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选master 一样，编号最小的获得锁，用完删除，依次方便。</p>
<h4 id="获取分布式锁的流程">获取分布式锁的流程</h4>
<p>  在获取分布式锁的时候在 locker 节点下创建临时顺序节点，释放锁的时候删除该临时节点。客户端调用createNode 方法在 locker 下创建临时顺序节点，然后调用 getChildren(“locker”)来获取 locker 下面的所有子节点，注意此时不用设置任何 Watcher。客户端获取到所有的子节点 path 之后，如果发现自己创建的节点在所有创建的子节点序号最小，那么就认为该客户端获取到了锁。如果发现自己创建的节点并非 locker 所有子节点中最小的，说明自己还没有获取到锁，此时客户端需要找到比自己小的那个节点，然后对其调用 exist()方法，同时对其注册事件监听器。之后，让这个被关注的节点删除，则客户端的 Watcher 会收到相应通知，此时再次判断自己创建的节点是否是 locker 子节点中序号最小的，如果是则获取到了锁，如果不是则重复以上步骤继续获取到比自己小的一个节点并注册监听。当前这个过程中还需要许多的逻辑判断。<br>
  代码的实现主要是基于互斥锁，获取分布式锁的重点逻辑在于BaseDistributedLock，实现了基于Zookeeper 实现分布式锁的细节。</p>
<h3 id="Zookeeper-队列管理（文件系统、通知机制）">Zookeeper 队列管理（文件系统、通知机制）</h3>
<p>两种类型的队列：<br>
1、同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。<br>
2、队列按照 FIFO 方式进行入队和出队操作。第一类，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。第二类，和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。在特定的目录下创建PERSISTENT_SEQUENTIAL 节点，创建成功时 Watcher 通知等待的队列，队列删除序列号最小的节点用以消费。此场景下 Zookeeper 的 znode 用于消息存储，znode 存储的数据就是消息队列中的消息内容，<br>
SEQUENTIAL 序列号就是消息的编号，按序取出即可。由于创建的节点是持久化的，所以不必担心队列消息的丢失问题。</p>
<h2 id="Zookeeper其他问题">Zookeeper其他问题</h2>
<h3 id="Zookeeper-数据复制">Zookeeper 数据复制</h3>
<p>Zookeeper 作为一个集群提供一致的数据服务，自然，它要在所有机器间做数据复制。数据复制的好处：<br>
1、容错：一个节点出错，不致于让整个系统停止工作，别的节点可以接管它的工作；<br>
2、提高系统的扩展能力 ：把负载分布到多个节点上，或者增加节点来提高系统的负载能力；<br>
3、提高性能：让客户端本地访问就近的节点，提高用户访问速度。从客户端读写访问的透明度来看，数据复制集群系统分下面两种：<br>
1、写主(WriteMaster) ：对数据的修改提交给指定的节点。读无此限制，可以读取任何一个节点。这种情况下客户端需要对读与写进行区别，俗称读写分离；<br>
2、写任意(Write Any)：对数据的修改可提交给任意的节点，跟读一样。这种情况下，客户端对集群节点的角色与变化透明。</p>
<p>对 zookeeper 来说，它采用的方式是写任意。通过增加机器，它的读吞吐能力和响应能力扩展性非常好，而写，随着机器的增多吞吐能力肯定下降（这也是它建立 observer 的原因），而响应能力则取决于具体实现方式，是延迟复制保持最终一致性，还是立即复制快速响应。</p>
<h3 id="zookeeper-保证事务的顺序一致性">zookeeper 保证事务的顺序一致性</h3>
<p>  zookeeper 采用了递增的事务 Id 来标识，所有的 proposal（提议）都在被提出的时候加上了 zxid，zxid 实际上是一个 64 位的数字，高 32 位是 epoch（时期; 纪元; 世; 新时代）用来标识 leader 是否发生改变，如果有新的 leader 产生出来，epoch 会自增，低 32 位用来递增计数。当新产生 proposal 的时候，会依据数据库的两阶段过程，首先会向其他的 server 发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行。</p>
<h3 id="Zookeeper-下-Server-工作状态">Zookeeper 下 Server 工作状态</h3>
<p>每个 Server 在工作过程中有三种状态：<br>
LOOKING：当前 Server 不知道 leader 是谁，正在搜寻<br>
LEADING：当前 Server 即为选举出来的 leader<br>
FOLLOWING：leader 已经选举出来，当前 Server 与之同步</p>
<h3 id="zookeeper-如何选取主-leader">zookeeper 如何选取主 leader</h3>
<p>当 leader 崩溃或者 leader 失去大多数的 follower，这时 zk 进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的 Server 都恢复到一个正确的状态。Zk 的选举算法有两种：一种是基于 basic paxos 实现的，另外一种是基于 fast paxos 算法实现的。系统默认的选举算法为 fast paxos。</p>
<p>1、Zookeeper 选主流程(basic paxos)<br>
（1）选举线程由当前 Server 发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的Server；（2）选举线程首先向所有 Server 发起一次询问(包括自己)；（3）选举线程收到回复后，验证是否是自己发起的询问(验证 zxid 是否一致)，然后获取对方的 id(myid)，并存储到当前询问对象列表中，最后获取对方提议的 leader 相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中；（4）收到所有 Server 回复以后，就计算出 zxid 最大的那个 Server，并将这个 Server 相关信息设置成下一次要投票的 Server；（5）线程将当前 zxid 最大的 Server 设置为当前 Server 要推荐的 Leader，如果此时获胜的 Server 获得 n/2+ 1 的 Server 票数，设置当前推荐的 leader 为获胜的 Server，将根据获胜的 Server 相关信息设置自己的状态，否则，继续这个过程，直到 leader 被选举出来。 通过流程分析我们可以得出：要使 Leader 获得多数Server 的支持，则 Server 总数必须是奇数 2n+1，且存活的 Server 的数目不得少于 n+1. 每个 Server 启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的 server 还会从磁盘快照中恢复数据和会话信息，zk 会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。</p>
<p>2、Zookeeper 选主流程(basic paxos)<br>
fast paxos 流程是在选举过程中，某 Server 首先向所有 Server 提议自己要成为 leader，当其它 Server 收到提议以后，解决 epoch 和 zxid 的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出 Leader。</p>
<h3 id="Zookeeper-同步流程">Zookeeper 同步流程</h3>
<p>选完 Leader 以后，zk 就进入状态同步过程。<br>
1、Leader 等待 server 连接；<br>
2、Follower 连接 leader，将最大的 zxid 发送给 leader；<br>
3、Leader 根据 follower 的 zxid 确定同步点；<br>
4、完成同步后通知 follower 已经成为 uptodate 状态；<br>
5、Follower 收到 uptodate 消息后，又可以重新接受 client 的请求进行服务了。</p>
<h4 id="机器中为什么会有-leader">机器中为什么会有 leader</h4>
<p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，于是就需要进行 leader 选举。</p>
<h3 id="zk-节点宕机如何处理">zk 节点宕机如何处理</h3>
<p>Zookeeper 本身也是集群，推荐配置不少于 3 个服务器。Zookeeper 自身也要保证当一个节点宕机时，其他节点会继续提供服务。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果是一个 Follower 宕机，还有 2 台服务器提供访问，因为 Zookeeper 上的数据是有多个副本的，数据并不会丢失；</p>
</li>
<li class="lvl-2">
<p>如果是一个 Leader 宕机，Zookeeper 会选举出新的 Leader。</p>
</li>
</ul>
<p>ZK 集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在 ZK 节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。所以<br>
3 个节点的 cluster 可以挂掉 1 个节点(leader 可以得到 2 票&gt;1.5)<br>
2 个节点的 cluster 就不能挂掉任何 1 个节点了(leader 可以得到 1 票&lt;=1)</p>
<h4 id="zookeeper-负载均衡和-nginx-负载均衡区别">zookeeper 负载均衡和 nginx 负载均衡区别</h4>
<p>zk 的负载均衡是可以调控，nginx 只是能调权重，其他需要可控的都需要自己写插件；但是 nginx 的吞吐量比zk 大很多，应该说按业务选择用哪种方式。</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start">Quick Start</h2>
<h3 id="Create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Hive的简介及核心概念</title>
    <url>/posts/43fb02f4.html</url>
    <content><![CDATA[<h2 id="一、简介-2">一、简介</h2>
<p>Hive 是一个构建在 Hadoop 之上的数据仓库，它可以将结构化的数据文件映射成表，并提供类 SQL 查询功能，用于查询的 SQL 语句会被转化为 MapReduce 作业，然后提交到 Hadoop 上运行。</p>
<p><strong>特点</strong>：</p>
<ol>
<li class="lvl-3">
<p>简单、容易上手 (提供了类似 sql 的查询语言 hql)，使得精通 sql 但是不了解 Java 编程的人也能很好地进行大数据分析；</p>
</li>
<li class="lvl-3">
<p>灵活性高，可以自定义用户函数 (UDF) 和存储格式；</p>
</li>
<li class="lvl-3">
<p>为超大的数据集设计的计算和存储能力，集群扩展容易;</p>
</li>
<li class="lvl-3">
<p>统一的元数据管理，可与 presto／impala／sparksql 等共享数据；</p>
</li>
<li class="lvl-3">
<p>执行延迟高，不适合做数据的实时处理，但适合做海量数据的离线处理。</p>
</li>
</ol>
<h2 id="二、Hive的体系架构">二、Hive的体系架构</h2>
<div align="center"> <img width="600px" src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive体系架构.png"/> </div>
<h3 id="2-1-command-line-shell-thrift-jdbc">2.1 command-line shell &amp; thrift/jdbc</h3>
<p>可以用 command-line shell 和 thrift／jdbc 两种方式来操作数据：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>command-line shell</strong>：通过 hive 命令行的的方式来操作数据；</p>
</li>
<li class="lvl-2">
<p><strong>thrift／jdbc</strong>：通过 thrift 协议按照标准的 JDBC 的方式操作数据。</p>
</li>
</ul>
<h3 id="2-2-Metastore">2.2 Metastore</h3>
<p>在 Hive 中，表名、表结构、字段名、字段类型、表的分隔符等统一被称为元数据。所有的元数据默认存储在 Hive 内置的 derby 数据库中，但由于 derby 只能有一个实例，也就是说不能有多个命令行客户端同时访问，所以在实际生产环境中，通常使用 MySQL 代替 derby。</p>
<p>Hive 进行的是统一的元数据管理，就是说你在 Hive 上创建了一张表，然后在 presto／impala／sparksql 中都是可以直接使用的，它们会从 Metastore 中获取统一的元数据信息，同样的你在 presto／impala／sparksql 中创建一张表，在 Hive 中也可以直接使用。</p>
<h3 id="2-3-HQL的执行流程">2.3 HQL的执行流程</h3>
<p>Hive 在执行一条 HQL 的时候，会经过以下步骤：</p>
<ol>
<li class="lvl-3">
<p>语法解析：Antlr 定义 SQL 的语法规则，完成 SQL 词法，语法解析，将 SQL 转化为抽象 语法树 AST Tree；</p>
</li>
<li class="lvl-3">
<p>语义解析：遍历 AST Tree，抽象出查询的基本组成单元 QueryBlock；</p>
</li>
<li class="lvl-3">
<p>生成逻辑执行计划：遍历 QueryBlock，翻译为执行操作树 OperatorTree；</p>
</li>
<li class="lvl-3">
<p>优化逻辑执行计划：逻辑层优化器进行 OperatorTree 变换，合并不必要的 ReduceSinkOperator，减少 shuffle 数据量；</p>
</li>
<li class="lvl-3">
<p>生成物理执行计划：遍历 OperatorTree，翻译为 MapReduce 任务；</p>
</li>
<li class="lvl-3">
<p>优化物理执行计划：物理层优化器进行 MapReduce 任务的变换，生成最终的执行计划。</p>
</li>
</ol>
<blockquote>
<p>关于 Hive SQL 的详细执行流程可以参考美团技术团队的文章：<a href="https://tech.meituan.com/2014/02/12/hive-sql-to-mapreduce.html">Hive SQL 的编译过程</a></p>
</blockquote>
<h2 id="三、数据类型">三、数据类型</h2>
<h3 id="3-1-基本数据类型">3.1 基本数据类型</h3>
<p>Hive 表中的列支持以下基本数据类型：</p>
<table>
<thead>
<tr>
<th>大类</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Integers（整型）</strong></td>
<td>TINYINT—1 字节的有符号整数 <br/>SMALLINT—2 字节的有符号整数<br/> INT—4 字节的有符号整数<br/> BIGINT—8 字节的有符号整数</td>
</tr>
<tr>
<td><strong>Boolean（布尔型）</strong></td>
<td>BOOLEAN—TRUE/FALSE</td>
</tr>
<tr>
<td><strong>Floating point numbers（浮点型）</strong></td>
<td>FLOAT— 单精度浮点型 <br/>DOUBLE—双精度浮点型</td>
</tr>
<tr>
<td><strong>Fixed point numbers（定点数）</strong></td>
<td>DECIMAL—用户自定义精度定点数，比如 DECIMAL(7,2)</td>
</tr>
<tr>
<td><strong>String types（字符串）</strong></td>
<td>STRING—指定字符集的字符序列<br/> VARCHAR—具有最大长度限制的字符序列 <br/>CHAR—固定长度的字符序列</td>
</tr>
<tr>
<td><strong>Date and time types（日期时间类型）</strong></td>
<td>TIMESTAMP —  时间戳 <br/>TIMESTAMP WITH LOCAL TIME ZONE — 时间戳，纳秒精度<br/> DATE—日期类型</td>
</tr>
<tr>
<td><strong>Binary types（二进制类型）</strong></td>
<td>BINARY—字节序列</td>
</tr>
</tbody>
</table>
<blockquote>
<p>TIMESTAMP 和 TIMESTAMP WITH LOCAL TIME ZONE 的区别如下：</p>
<ul class="lvl-1">
<li class="lvl-2"><strong>TIMESTAMP WITH LOCAL TIME ZONE</strong>：用户提交时间给数据库时，会被转换成数据库所在的时区来保存。查询时则按照查询客户端的不同，转换为查询客户端所在时区的时间。</li>
<li class="lvl-2"><strong>TIMESTAMP</strong> ：提交什么时间就保存什么时间，查询时也不做任何转换。</li>
</ul>
</blockquote>
<h3 id="3-2-隐式转换">3.2 隐式转换</h3>
<p>Hive 中基本数据类型遵循以下的层次结构，按照这个层次结构，子类型到祖先类型允许隐式转换。例如 INT 类型的数据允许隐式转换为 BIGINT 类型。额外注意的是：按照类型层次结构允许将 STRING 类型隐式转换为 DOUBLE 类型。</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-data-type.png"/> </div>
<h3 id="3-3-复杂类型">3.3 复杂类型</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>STRUCT</strong></td>
<td>类似于对象，是字段的集合，字段的类型可以不同，可以使用 <code>名称.字段名</code> 方式进行访问</td>
<td>STRUCT (‘xiaoming’, 12 , ‘2018-12-12’)</td>
</tr>
<tr>
<td><strong>MAP</strong></td>
<td>键值对的集合，可以使用 <code> 名称[key]</code> 的方式访问对应的值</td>
<td>map(‘a’, 1, ‘b’, 2)</td>
</tr>
<tr>
<td><strong>ARRAY</strong></td>
<td>数组是一组具有相同类型和名称的变量的集合，可以使用 <code> 名称[index]</code> 访问对应的值</td>
<td>ARRAY(‘a’, ‘b’, ‘c’, ‘d’)</td>
</tr>
</tbody>
</table>
<h3 id="3-4-示例">3.4 示例</h3>
<p>如下给出一个基本数据类型和复杂数据类型的使用示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students(</span><br><span class="line">  name      STRING,   <span class="comment">-- 姓名</span></span><br><span class="line">  age       <span class="type">INT</span>,      <span class="comment">-- 年龄</span></span><br><span class="line">  subject   <span class="keyword">ARRAY</span><span class="operator">&lt;</span>STRING<span class="operator">&gt;</span>,   <span class="comment">--学科</span></span><br><span class="line">  score     MAP<span class="operator">&lt;</span>STRING,<span class="type">FLOAT</span><span class="operator">&gt;</span>,  <span class="comment">--各个学科考试成绩</span></span><br><span class="line">  address   STRUCT<span class="operator">&lt;</span>houseNumber:<span class="type">int</span>, street:STRING, city:STRING, province：STRING<span class="operator">&gt;</span>  <span class="comment">--家庭居住地址</span></span><br><span class="line">) <span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> &quot;\t&quot;;</span><br></pre></td></tr></table></figure>
<h2 id="四、内容格式">四、内容格式</h2>
<p>当数据存储在文本文件中，必须按照一定格式区别行和列，如使用逗号作为分隔符的 CSV 文件 (Comma-Separated Values) 或者使用制表符作为分隔值的 TSV 文件 (Tab-Separated Values)。但此时也存在一个缺点，就是正常的文件内容中也可能出现逗号或者制表符。</p>
<p>所以 Hive 默认使用了几个平时很少出现的字符，这些字符一般不会作为内容出现在文件中。Hive 默认的行和列分隔符如下表所示。</p>
<table>
<thead>
<tr>
<th>分隔符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>\n</strong></td>
<td>对于文本文件来说，每行是一条记录，所以可以使用换行符来分割记录</td>
</tr>
<tr>
<td><strong>^A (Ctrl+A)</strong></td>
<td>分割字段 (列)，在 CREATE TABLE 语句中也可以使用八进制编码 <code>\001</code> 来表示</td>
</tr>
<tr>
<td><strong>^B</strong></td>
<td>用于分割 ARRAY 或者 STRUCT 中的元素，或者用于 MAP 中键值对之间的分割，<br/>在 CREATE TABLE 语句中也可以使用八进制编码 <code>\002</code> 表示</td>
</tr>
<tr>
<td><strong>^C</strong></td>
<td>用于 MAP 中键和值之间的分割，在 CREATE TABLE 语句中也可以使用八进制编码 <code>\003</code> 表示</td>
</tr>
</tbody>
</table>
<p>使用示例如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> page_view(viewTime <span class="type">INT</span>, userid <span class="type">BIGINT</span>)</span><br><span class="line"> <span class="type">ROW</span> FORMAT DELIMITED</span><br><span class="line">   FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\001&#x27;</span></span><br><span class="line">   COLLECTION ITEMS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\002&#x27;</span></span><br><span class="line">   MAP KEYS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\003&#x27;</span></span><br><span class="line"> STORED <span class="keyword">AS</span> SEQUENCEFILE;</span><br></pre></td></tr></table></figure>
<h2 id="五、存储格式">五、存储格式</h2>
<h3 id="5-1-支持的存储格式">5.1 支持的存储格式</h3>
<p>Hive 会在 HDFS 为每个数据库上创建一个目录，数据库中的表是该目录的子目录，表中的数据会以文件的形式存储在对应的表目录下。Hive 支持以下几种文件存储格式：</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>TextFile</strong></td>
<td>存储为纯文本文件。 这是 Hive 默认的文件存储格式。这种存储方式数据不做压缩，磁盘开销大，数据解析开销大。</td>
</tr>
<tr>
<td><strong>SequenceFile</strong></td>
<td>SequenceFile 是 Hadoop API 提供的一种二进制文件，它将数据以&lt;key,value&gt;的形式序列化到文件中。这种二进制文件内部使用 Hadoop 的标准的 Writable 接口实现序列化和反序列化。它与 Hadoop API 中的 MapFile 是互相兼容的。Hive 中的 SequenceFile 继承自 Hadoop API 的 SequenceFile，不过它的 key 为空，使用 value 存放实际的值，这样是为了避免 MR 在运行 map 阶段进行额外的排序操作。</td>
</tr>
<tr>
<td><strong>RCFile</strong></td>
<td>RCFile 文件格式是 FaceBook 开源的一种 Hive 的文件存储格式，首先将表分为几个行组，对每个行组内的数据按列存储，每一列的数据都是分开存储。</td>
</tr>
<tr>
<td><strong>ORC Files</strong></td>
<td>ORC 是在一定程度上扩展了 RCFile，是对 RCFile 的优化。</td>
</tr>
<tr>
<td><strong>Avro Files</strong></td>
<td>Avro 是一个数据序列化系统，设计用于支持大批量数据交换的应用。它的主要特点有：支持二进制序列化方式，可以便捷，快速地处理大量数据；动态语言友好，Avro 提供的机制使动态语言可以方便地处理 Avro 数据。</td>
</tr>
<tr>
<td><strong>Parquet</strong></td>
<td>Parquet 是基于 Dremel 的数据模型和算法实现的，面向分析型业务的列式存储格式。它通过按列进行高效压缩和特殊的编码技术，从而在降低存储空间的同时提高了 IO 效率。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>以上压缩格式中 ORC 和 Parquet 的综合性能突出，使用较为广泛，推荐使用这两种格式。</p>
</blockquote>
<h3 id="5-2-指定存储格式">5.2 指定存储格式</h3>
<p>通常在创建表的时候使用 <code>STORED AS</code> 参数指定：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> page_view(viewTime <span class="type">INT</span>, userid <span class="type">BIGINT</span>)</span><br><span class="line"> <span class="type">ROW</span> FORMAT DELIMITED</span><br><span class="line">   FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\001&#x27;</span></span><br><span class="line">   COLLECTION ITEMS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\002&#x27;</span></span><br><span class="line">   MAP KEYS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\003&#x27;</span></span><br><span class="line"> STORED <span class="keyword">AS</span> SEQUENCEFILE;</span><br></pre></td></tr></table></figure>
<p>各个存储文件类型指定方式如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>STORED AS TEXTFILE</p>
</li>
<li class="lvl-2">
<p>STORED AS SEQUENCEFILE</p>
</li>
<li class="lvl-2">
<p>STORED AS ORC</p>
</li>
<li class="lvl-2">
<p>STORED AS PARQUET</p>
</li>
<li class="lvl-2">
<p>STORED AS AVRO</p>
</li>
<li class="lvl-2">
<p>STORED AS RCFILE</p>
</li>
</ul>
<h2 id="六、内部表和外部表">六、内部表和外部表</h2>
<p>内部表又叫做管理表 (Managed/Internal Table)，创建表时不做任何指定，默认创建的就是内部表。想要创建外部表 (External Table)，则需要使用 External 进行修饰。 内部表和外部表主要区别如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>内部表</th>
<th>外部表</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据存储位置</td>
<td>内部表数据存储的位置由 hive.metastore.warehouse.dir 参数指定，默认情况下表的数据存储在 HDFS 的 <code>/user/hive/warehouse/数据库名.db/表名/</code>  目录下</td>
<td>外部表数据的存储位置创建表时由 <code>Location</code> 参数指定；</td>
</tr>
<tr>
<td>导入数据</td>
<td>在导入数据到内部表，内部表将数据移动到自己的数据仓库目录下，数据的生命周期由 Hive 来进行管理</td>
<td>外部表不会将数据移动到自己的数据仓库目录下，只是在元数据中存储了数据的位置</td>
</tr>
<tr>
<td>删除表</td>
<td>删除元数据（metadata）和文件</td>
<td>只删除元数据（metadata）</td>
</tr>
</tbody>
</table>
<h2 id="参考资料-20">参考资料</h2>
<ol>
<li class="lvl-3">
<p><a href="https://cwiki.apache.org/confluence/display/Hive/GettingStarted">Hive Getting Started</a></p>
</li>
<li class="lvl-3">
<p><a href="https://tech.meituan.com/2014/02/12/hive-sql-to-mapreduce.html">Hive SQL 的编译过程</a></p>
</li>
<li class="lvl-3">
<p><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL">LanguageManual DDL</a></p>
</li>
<li class="lvl-3">
<p><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Types">LanguageManual Types</a></p>
</li>
<li class="lvl-3">
<p><a href="https://cwiki.apache.org/confluence/display/Hive/Managed+vs.+External+Tables">Managed vs. External Tables</a>                            |</p>
</li>
</ol>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>hive</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive常用查询函数</title>
    <url>/posts/682cece4.html</url>
    <content><![CDATA[<h2 id="1-空字段赋值NVL函数">1 空字段赋值NVL函数</h2>
<p>1.函数说明<br>
  NVL：给值为NULL的数据赋值，它的格式是NVL( string1, replace_with)。它的功能是如果string1为NULL，则NVL函数返回replace_with的值，否则返回string1的值，如果两个参数都为NULL ，则返回NULL。</p>
<p>2.数据准备：采用员工表</p>
<p>3.查询：如果员工的comm为NULL，则用-1代替</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; select nvl(comm,-1) from emp;</span><br></pre></td></tr></table></figure>
<p>4.查询：如果员工的comm为NULL，则用领导id代替</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; select nvl(comm,mgr) from emp;</span><br></pre></td></tr></table></figure>
<h2 id="2-CASE-WHEN函数">2.CASE WHEN函数</h2>
<ol>
<li class="lvl-3">
<p>数据准备</p>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">name</th>
<th style="text-align:center">dept_id</th>
<th style="text-align:center">sex</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">悟空</td>
<td style="text-align:center">A</td>
<td style="text-align:center">男</td>
</tr>
<tr>
<td style="text-align:center">大海</td>
<td style="text-align:center">A</td>
<td style="text-align:center">男</td>
</tr>
<tr>
<td style="text-align:center">宋宋</td>
<td style="text-align:center">B</td>
<td style="text-align:center">男</td>
</tr>
<tr>
<td style="text-align:center">凤姐</td>
<td style="text-align:center">A</td>
<td style="text-align:center">女</td>
</tr>
<tr>
<td style="text-align:center">婷姐</td>
<td style="text-align:center">B</td>
<td style="text-align:center">女</td>
</tr>
<tr>
<td style="text-align:center">婷婷</td>
<td style="text-align:center">B</td>
<td style="text-align:center">女</td>
</tr>
</tbody>
</table>
<p>2．需求求出不同部门男女各多少人。结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A     2       1</span><br><span class="line">B     1       2</span><br></pre></td></tr></table></figure>
<p>3．创建本地emp_sex.txt，导入数据<br>
[ihadu@hadoop102 datas]$ vi emp_sex.txt<br>
悟空	A	男大海	A	男宋宋	B	男凤姐	A	女婷姐	B	女婷婷	B	女</p>
<p>4．创建hive表并导入数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp_sex(</span><br><span class="line">name string,</span><br><span class="line">dept_id string,</span><br><span class="line">sex string)</span><br><span class="line"><span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> &quot;\t&quot;;</span><br><span class="line"></span><br><span class="line">load data <span class="keyword">local</span> inpath <span class="string">&#x27;/opt/module/datas/emp_sex.txt&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> emp_sex;</span><br></pre></td></tr></table></figure>
<p>5．按需求查询数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">  dept_id,</span><br><span class="line">  <span class="built_in">sum</span>(<span class="keyword">case</span> sex <span class="keyword">when</span> <span class="string">&#x27;男&#x27;</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) male_count,</span><br><span class="line">  <span class="built_in">sum</span>(<span class="keyword">case</span> sex <span class="keyword">when</span> <span class="string">&#x27;女&#x27;</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) female_count</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  emp_sex</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">  dept_id;</span><br></pre></td></tr></table></figure>
<h2 id="3-行转列">3.行转列</h2>
<p>1．相关函数说明<br>
  CONCAT(string A/col, string B/col…)：返回输入字符串连接后的结果，支持任意个输入字符串;<br>
  CONCAT_WS(separator, str1, str2,…)：它是一个特殊形式的 CONCAT()。第一个参数剩余参数间的分隔符。分隔符可以是与剩余参数一样的字符串。如果分隔符是 NULL，返回值也将为 NULL。这个函数会跳过分隔符参数后的任何 NULL 和空字符串。分隔符将被加到被连接的字符串之间;<br>
  COLLECT_SET(col)：函数只接受基本数据类型，它的主要作用是将某字段的值进行去重汇总，产生array类型字段。</p>
<p>2．数据准备</p>
<table>
<thead>
<tr>
<th style="text-align:center">name</th>
<th style="text-align:center">constellation</th>
<th style="text-align:center">blood_type</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">孙悟空</td>
<td style="text-align:center">白羊座</td>
<td style="text-align:center">A</td>
</tr>
<tr>
<td style="text-align:center">大海</td>
<td style="text-align:center">射手座</td>
<td style="text-align:center">A</td>
</tr>
<tr>
<td style="text-align:center">宋宋</td>
<td style="text-align:center">白羊座</td>
<td style="text-align:center">B</td>
</tr>
<tr>
<td style="text-align:center">猪八戒</td>
<td style="text-align:center">白羊座</td>
<td style="text-align:center">A</td>
</tr>
<tr>
<td style="text-align:center">凤姐</td>
<td style="text-align:center">射手座</td>
<td style="text-align:center">A</td>
</tr>
</tbody>
</table>
<p>3．需求把星座和血型一样的人归类到一起。结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">射手座,A            大海|凤姐</span><br><span class="line">白羊座,A            孙悟空|猪八戒</span><br><span class="line">白羊座,B            宋宋</span><br></pre></td></tr></table></figure>
<p>4．创建本地constellation.txt，导入数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ihadu@hadoop102 datas]$ vi person_info.txt</span><br><span class="line">孙悟空	白羊座	A</span><br><span class="line">大海	 射手座	A</span><br><span class="line">宋宋	 白羊座	B</span><br><span class="line">猪八戒   白羊座	A</span><br><span class="line">凤姐	  射手座	A</span><br></pre></td></tr></table></figure>
<p>5．创建hive表并导入数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> person_info(</span><br><span class="line">name string,</span><br><span class="line">constellation string,</span><br><span class="line">blood_type string)</span><br><span class="line"><span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> &quot;\t&quot;;</span><br><span class="line"></span><br><span class="line">load data <span class="keyword">local</span> inpath “<span class="operator">/</span>opt<span class="operator">/</span><span class="keyword">module</span><span class="operator">/</span>datas<span class="operator">/</span>person_info.txt” <span class="keyword">into</span> <span class="keyword">table</span> person_info;</span><br></pre></td></tr></table></figure>
<p>6．按需求查询数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    t1.base,</span><br><span class="line">    concat_ws(<span class="string">&#x27;|&#x27;</span>, collect_set(t1.name)) name</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span></span><br><span class="line">        name,</span><br><span class="line">        concat(constellation, &quot;,&quot;, blood_type) base</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">        person_info) t1</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">    t1.base;</span><br></pre></td></tr></table></figure>
<h2 id="4-列转行">4.列转行</h2>
<p>1．函数说明<br>
Explode(col)：将hive一列中复杂的array或者map结构拆分成多行。</p>
<p>Lateral view<br>
用法：LATERAL VIEW udtf(expression) tableAlias AS columnAlias<br>
解释：用于和split, explode等UDTF一起使用，它能够将一列数据拆成多行数据，在此基础上可以对拆分后的数据进行聚合。</p>
<p>2．数据准备</p>
<table>
<thead>
<tr>
<th style="text-align:center">movie</th>
<th style="text-align:center">category</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">《金刚川》</td>
<td style="text-align:center">悬疑,动作,科幻,剧情</td>
</tr>
<tr>
<td style="text-align:center">《我和我的家乡》</td>
<td style="text-align:center">悬疑,警匪,动作,心理,剧情</td>
</tr>
<tr>
<td style="text-align:center">《心灵奇旅》</td>
<td style="text-align:center">战争,动作,灾难</td>
</tr>
</tbody>
</table>
<p>3．需求将电影分类中的数组数据展开。结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">《金刚川》      悬疑</span><br><span class="line">《金刚川》      动作</span><br><span class="line">《金刚川》      科幻</span><br><span class="line">《金刚川》      剧情</span><br><span class="line">《我和我的家乡》   悬疑</span><br><span class="line">《我和我的家乡》   警匪</span><br><span class="line">《我和我的家乡》   动作</span><br><span class="line">《我和我的家乡》   心理</span><br><span class="line">《我和我的家乡》   剧情</span><br><span class="line">《心灵奇旅》      战争</span><br><span class="line">《心灵奇旅》      动作</span><br><span class="line">《心灵奇旅》      灾难</span><br></pre></td></tr></table></figure>
<p>4．创建本地movie.txt，导入数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ihadu@hadoop102 datas]$ vi movie.txt</span><br><span class="line">《疑犯追踪》	悬疑,动作,科幻,剧情</span><br><span class="line">《Lie to me》	悬疑,警匪,动作,心理,剧情</span><br><span class="line">《战狼2》	战争,动作,灾难</span><br></pre></td></tr></table></figure>
<p>5．创建hive表并导入数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> movie_info(</span><br><span class="line">    movie string,</span><br><span class="line">    category <span class="keyword">array</span><span class="operator">&lt;</span>string<span class="operator">&gt;</span>)</span><br><span class="line"><span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> &quot;\t&quot;</span><br><span class="line">collection items terminated <span class="keyword">by</span> &quot;,&quot;;</span><br><span class="line"></span><br><span class="line">load data <span class="keyword">local</span> inpath &quot;/opt/module/datas/movie.txt&quot; <span class="keyword">into</span> <span class="keyword">table</span> movie_info;</span><br></pre></td></tr></table></figure>
<p>6．按需求查询数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    movie,</span><br><span class="line">    category_name</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    movie_info <span class="keyword">lateral</span> <span class="keyword">view</span> explode(category) table_tmp <span class="keyword">as</span> category_name;</span><br></pre></td></tr></table></figure>
<h2 id="5-窗口函数">5.窗口函数</h2>
<p>1．相关函数说明<br>
OVER()：指定分析函数工作的数据窗口大小，这个数据窗口大小可能会随着行的变而变化<br>
CURRENT ROW：当前行<br>
n PRECEDING：往前n行数据<br>
n FOLLOWING：往后n行数据<br>
UNBOUNDED：起点，UNBOUNDED PRECEDING 表示从前面的起点， UNBOUNDED FOLLOWING表示到后面的终点<br>
LAG(col,n)：往前第n行数据<br>
LEAD(col,n)：往后第n行数据<br>
NTILE(n)：把有序分区中的行分发到指定数据的组中，各个组有编号，编号从1开始，对于每一行，NTILE返回此行所属的组的编号。注意：n必须为int类型。</p>
<p>2．数据准备：name，orderdate，cost</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jack,2017-01-01,10</span><br><span class="line">tony,2017-01-02,15</span><br><span class="line">jack,2017-02-03,23</span><br><span class="line">tony,2017-01-04,29</span><br><span class="line">jack,2017-01-05,46</span><br><span class="line">jack,2017-04-06,42</span><br><span class="line">tony,2017-01-07,50</span><br><span class="line">jack,2017-01-08,55</span><br><span class="line">mart,2017-04-08,62</span><br><span class="line">mart,2017-04-09,68</span><br><span class="line">neil,2017-05-10,12</span><br><span class="line">mart,2017-04-11,75</span><br><span class="line">neil,2017-06-12,80</span><br><span class="line">mart,2017-04-13,94</span><br></pre></td></tr></table></figure>
<p>3．需求（1）查询在2017年4月份购买过的顾客及总人数（2）查询顾客的购买明细及月购买总额（3）上述的场景,要将cost按照日期进行累加（4）查询顾客上次的购买时间（5）查询前20%时间的订单信息</p>
<p>4．创建本地business.txt，导入数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ihadu@hadoop102 datas]$ vi business.txt</span><br></pre></td></tr></table></figure>
<p>5．创建hive表并导入数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> business(</span><br><span class="line">name string,</span><br><span class="line">orderdate string,</span><br><span class="line">cost <span class="type">int</span></span><br><span class="line">) <span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line"></span><br><span class="line">load data <span class="keyword">local</span> inpath &quot;/opt/module/datas/business.txt&quot; <span class="keyword">into</span> <span class="keyword">table</span> business;</span><br></pre></td></tr></table></figure>
<p>6．按需求查询数据（1）查询在2017年4月份购买过的顾客及总人数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">over</span> ()</span><br><span class="line"><span class="keyword">from</span> business</span><br><span class="line"><span class="keyword">where</span> <span class="built_in">substring</span>(orderdate,<span class="number">1</span>,<span class="number">7</span>) <span class="operator">=</span> <span class="string">&#x27;2017-04&#x27;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> name;</span><br></pre></td></tr></table></figure>
<p>（2）查询顾客的购买明细及月购买总额</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">	name,</span><br><span class="line">	orderdate,</span><br><span class="line">	cost,</span><br><span class="line">	<span class="built_in">sum</span>(cost) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">month</span>(orderdate))</span><br><span class="line"><span class="keyword">from</span> business;</span><br></pre></td></tr></table></figure>
<p>（3）上述的场景,要将cost按照日期进行累加</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name,orderdate,cost,</span><br><span class="line"><span class="built_in">sum</span>(cost) <span class="keyword">over</span>() <span class="keyword">as</span> sample1,<span class="comment">--所有行相加</span></span><br><span class="line"><span class="built_in">sum</span>(cost) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> name) <span class="keyword">as</span> sample2,<span class="comment">--按name分组，组内数据相加</span></span><br><span class="line"><span class="built_in">sum</span>(cost) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> name <span class="keyword">order</span> <span class="keyword">by</span> orderdate) <span class="keyword">as</span> sample3,<span class="comment">--按name分组，组内数据累加</span></span><br><span class="line"><span class="built_in">sum</span>(cost) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> name <span class="keyword">order</span> <span class="keyword">by</span> orderdate <span class="keyword">rows</span> <span class="keyword">between</span> UNBOUNDED PRECEDING <span class="keyword">and</span> <span class="keyword">current</span> <span class="type">row</span> ) <span class="keyword">as</span> sample4 ,<span class="comment">--和sample3一样,由起点到当前行的聚合</span></span><br><span class="line"><span class="built_in">sum</span>(cost) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> name <span class="keyword">order</span> <span class="keyword">by</span> orderdate <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">1</span> PRECEDING <span class="keyword">and</span> <span class="keyword">current</span> <span class="type">row</span>) <span class="keyword">as</span> sample5, <span class="comment">--当前行和前面一行做聚合</span></span><br><span class="line"><span class="built_in">sum</span>(cost) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> name <span class="keyword">order</span> <span class="keyword">by</span> orderdate <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">1</span> PRECEDING <span class="keyword">AND</span> <span class="number">1</span> FOLLOWING ) <span class="keyword">as</span> sample6,<span class="comment">--当前行和前边一行及后面一行</span></span><br><span class="line"><span class="built_in">sum</span>(cost) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> name <span class="keyword">order</span> <span class="keyword">by</span> orderdate <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">current</span> <span class="type">row</span> <span class="keyword">and</span> UNBOUNDED FOLLOWING ) <span class="keyword">as</span> sample7 <span class="comment">--当前行及后面所有行</span></span><br><span class="line"><span class="keyword">from</span> business;</span><br></pre></td></tr></table></figure>
<p>（4）查看顾客上次的购买时间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name,orderdate,cost,</span><br><span class="line"><span class="built_in">lag</span>(orderdate,<span class="number">1</span>,<span class="string">&#x27;1900-01-01&#x27;</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> name <span class="keyword">order</span> <span class="keyword">by</span> orderdate ) <span class="keyword">as</span> time1,</span><br><span class="line"><span class="built_in">lag</span>(orderdate,<span class="number">2</span>) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> name <span class="keyword">order</span> <span class="keyword">by</span> orderdate) <span class="keyword">as</span> time2</span><br><span class="line"><span class="keyword">from</span> business;</span><br></pre></td></tr></table></figure>
<p>（5）查询前20%时间的订单信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> name,orderdate,cost, <span class="built_in">ntile</span>(<span class="number">5</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> orderdate) sorted</span><br><span class="line">    <span class="keyword">from</span> business</span><br><span class="line">) t</span><br><span class="line"><span class="keyword">where</span> sorted <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>6.Rank函数<br>
1．函数说明</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>RANK() 排序相同时会重复，总数不会变</p>
</li>
<li class="lvl-2">
<p>DENSE_RANK() 排序相同时会重复，总数会减少</p>
</li>
<li class="lvl-2">
<p>ROW_NUMBER() 会根据顺序计算</p>
</li>
</ul>
<p>2．数据准备</p>
<table>
<thead>
<tr>
<th style="text-align:center">name</th>
<th style="text-align:center">subject</th>
<th style="text-align:center">score</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">孙悟空</td>
<td style="text-align:center">语文</td>
<td style="text-align:center">87</td>
</tr>
<tr>
<td style="text-align:center">孙悟空</td>
<td style="text-align:center">数学</td>
<td style="text-align:center">95</td>
</tr>
<tr>
<td style="text-align:center">孙悟空</td>
<td style="text-align:center">英语</td>
<td style="text-align:center">68</td>
</tr>
<tr>
<td style="text-align:center">大海</td>
<td style="text-align:center">语文</td>
<td style="text-align:center">94</td>
</tr>
<tr>
<td style="text-align:center">大海</td>
<td style="text-align:center">数学</td>
<td style="text-align:center">56</td>
</tr>
<tr>
<td style="text-align:center">大海</td>
<td style="text-align:center">英语</td>
<td style="text-align:center">84</td>
</tr>
<tr>
<td style="text-align:center">宋宋</td>
<td style="text-align:center">语文</td>
<td style="text-align:center">64</td>
</tr>
<tr>
<td style="text-align:center">宋宋</td>
<td style="text-align:center">数学</td>
<td style="text-align:center">86</td>
</tr>
<tr>
<td style="text-align:center">宋宋</td>
<td style="text-align:center">英语</td>
<td style="text-align:center">84</td>
</tr>
<tr>
<td style="text-align:center">婷婷</td>
<td style="text-align:center">语文</td>
<td style="text-align:center">65</td>
</tr>
<tr>
<td style="text-align:center">婷婷</td>
<td style="text-align:center">数学</td>
<td style="text-align:center">85</td>
</tr>
<tr>
<td style="text-align:center">婷婷</td>
<td style="text-align:center">英语</td>
<td style="text-align:center">78</td>
</tr>
</tbody>
</table>
<p>3．需求计算每门学科成绩排名。</p>
<p>4．创建本地movie.txt，导入数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ihadu@hadoop102 datas]$ vi score.txt</span><br></pre></td></tr></table></figure>
<p>5．创建hive表并导入数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> score(</span><br><span class="line">name string,</span><br><span class="line">subject string, </span><br><span class="line">score <span class="type">int</span>) </span><br><span class="line"><span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> &quot;\t&quot;;</span><br><span class="line">load data <span class="keyword">local</span> inpath <span class="string">&#x27;/opt/module/datas/score.txt&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> score;</span><br></pre></td></tr></table></figure>
<p>6．按需求查询数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name,</span><br><span class="line">subject,</span><br><span class="line">score,</span><br><span class="line"><span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> subject <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) rp,</span><br><span class="line"><span class="built_in">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> subject <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) drp,</span><br><span class="line"><span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> subject <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) rmp</span><br><span class="line"><span class="keyword">from</span> score;</span><br></pre></td></tr></table></figure>
<p>查询结果：</p>
<pre><code class="language-shell">name    subject score   rp      drp     rmp
孙悟空  数学    95      1       1       1
宋宋    数学    86      2       2       2
婷婷    数学    85      3       3       3
大海    数学    56      4       4       4
宋宋    英语    84      1       1       1
大海    英语    84      1       1       2
婷婷    英语    78      3       2       3
孙悟空  英语    68      4       3       4
大海    语文    94      1       1       1
孙悟空  语文    87      2       2       2
婷婷    语文    65      3       3       3
宋宋    语文    64      4       4       4
</code></pre>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>hive</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>java7 教程</title>
    <url>/posts/71ba5c83.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Hive自定义UDF函数</title>
    <url>/posts/f43f73d6.html</url>
    <content><![CDATA[<h3 id="1-Hive自定义函数介绍">1. Hive自定义函数介绍</h3>
<p>当Hive提供的内置函数无法满足你的业务处理需要时，此时可以考虑使用用户自定义函数（UDF: user-defined function）。<br>
Hive 中常用的UDF有如下三种:</p>
<ul class="lvl-0">
<li class="lvl-2">UDF<br>
一条记录使用函数后输出还是一条记录，比如:upper/substr;</li>
<li class="lvl-2">UDAF(User-Defined Aggregation Funcation)<br>
多条记录使用函数后输出还是一条记录，比如: count/max/min/sum/avg;</li>
<li class="lvl-2">UDTF(User-Defined Table-Generating Functions)<br>
一条记录使用函数后输出多条记录，比如: lateral view explore();</li>
</ul>
<h3 id="2-Hive自定义函数开发">2. Hive自定义函数开发</h3>
<p>需求:开发自定义函数，使得在指定字段前加上“Hello:”字样。Hive 中 UDF函数开发步骤:<br>
(1）继承UDF 类。<br>
(2）重写evaluate方法，该方法支持重载，每行记录执行一次evaluate方法。</p>
<h4 id="注意：">##### 注意：</h4>
<p>1 UDF必须要有返回值,可以是null,但是不能为 void.<br>
2 推荐使用 Text/LongWritable等Hadoop的类型,而不是Java类型(当然使用 Java类型也是可以的)。</p>
<p>功能实现:</p>
<h5 id="1-pom-xml中添加UDF函数开发的依赖包。">( 1)pom.xml中添加UDF函数开发的依赖包。</h5>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hadoop.version</span>&gt;</span>2.6.0-cdh5.7.0<span class="tag">&lt;/<span class="name">hadoop.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hive.version</span>&gt;</span>1.1.0-cdh5.7.0<span class="tag">&lt;/<span class="name">hive.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--CDH 版本建议大家添加一个repository--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>cloudera<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repository.cloudera.com/artifactory/cloudera-repos/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Hadoop依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupld</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-common<span class="tag">&lt;/<span class="name">artifactld</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$ &#123;hadoop.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--Hive依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupld</span>&gt;</span>org.apache.hive<span class="tag">&lt;/<span class="name">groupld</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hive-exec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$ &#123; hive.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupld</span>&gt;</span>org.apacne.hive<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactld</span>&gt;</span>hive-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$ &#123; hive.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="2）开发UDF函数。">(2）开发UDF函数。</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kgc.bigdata.hadoop.hive;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.exec.UDF;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*功能:输入xxx，输出:Hello: xxx</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*开发UDF 函数的步骤</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">* 1) extends UDF</span></span><br><span class="line"><span class="comment">*2）重写evaluate方法，注意该方法是支持重载的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloUDF</span> <span class="keyword">extends</span> <span class="title class_">UDF</span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*对于UDF 函数的evaluate的参数和返回值，个人建议使用Writable* <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Text <span class="title function_">evaluate</span><span class="params">(Text name)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot;Hello: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> Text <span class="title function_">evaluate</span><span class="params">(Text name,IntWritable age)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot;Hello: &quot;</span> +name + <span class="string">&quot; , age :&quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">/功能测试</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">HelloUDF</span> <span class="variable">udf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloUDF</span>(</span><br><span class="line">System.out.println(udf.evaluate(<span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot;zhangsan&quot;</span>)));</span><br><span class="line">System.out.println(udf.evaluate(<span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot;zhangsan&quot;</span>), <span class="keyword">new</span> <span class="title class_">IntWritable</span>(<span class="number">20</span>)));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3）编译jar包上传到服务器。<br>
(4)将自定义UDF 函数添加到Hive 中去。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">add JAR/home/hadoop/lib/hive-1.0.jar;</span><br><span class="line">create temporary function sayHello as &#x27;com.kgc.bigdata.hadoop.hive.HelloUDF&#x27;;</span><br></pre></td></tr></table></figure>
<p>(5)使用自定义函数。<br>
//通过show functions可以看到我们自定义的sayHello函数show functions;<br>
//将员工表的ename作为自定义UDF函数的参数值，即可查看到最终的输出结果</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> empno, ename, sayHello(ename) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>hive</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka分区</title>
    <url>/posts/33744480.html</url>
    <content><![CDATA[<h2 id="设置topic下的分区数">设置topic下的分区数</h2>
<ol>
<li class="lvl-3">在 config/server.properties 配置文件中, 可以设置一个全局的分区数量, 这个分区数量的含义是: <strong>每个主题下的分区数量</strong>, 默认为 1</li>
</ol>
<img src="https://img2018.cnblogs.com/blog/1629331/201911/1629331-20191129230058746-945280798.png" referrerpolicy="no-referrer">
<ol start="2">
<li class="lvl-3">
<p>也可以在创建主题的时候, 使用 --partitions 参数指定分区数量</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --zookeeper localhost:2181 --create --topic my_topic --partitions 2 --replication-factor 1 </span><br></pre></td></tr></table></figure>
<p>3.查看已创建主题的分区数量:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic my_topic </span><br></pre></td></tr></table></figure>
<img src="https://img2018.cnblogs.com/blog/1629331/201911/1629331-20191129230212246-1072040750.png" referrerpolicy="no-referrer">
<h2 id="生产者与分区">生产者与分区</h2>
<p><strong>org.apache.kafka.clients.producer.internals.DefaultPartitioner</strong></p>
<p>默认的分区策略是：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果在发消息的时候指定了分区，则消息投递到指定的分区</p>
</li>
<li class="lvl-2">
<p>如果没有指定分区，但是消息的key不为空，则基于key的哈希值来选择一个分区</p>
</li>
<li class="lvl-2">
<p>如果既没有指定分区，且消息的key也是空，则用轮询的方式选择一个分区</p>
</li>
</ul>
<h2 id="消费者与分区">消费者与分区</h2>
<p>首先需要了解的是:</p>
<ol>
<li class="lvl-3">
<p>消费者是以组的名义订阅主题消息, 消费者组里边包含多个消费者实例.</p>
</li>
<li class="lvl-3">
<p>主题下边包含多个分区</p>
</li>
</ol>
<p>消费者实例与主题下分区的分配关系</p>
<img src="https://img2018.cnblogs.com/blog/1629331/201911/1629331-20191129230325655-792813000.png" referrerpolicy="no-referrer">
<p>kafka 集群上有两个节点, 4 个分区</p>
<p>A组有 2 个消费者实例 (两个消费线程)</p>
<p>B组有 4 个消费者实例</p>
<p>由图可以看出, A组的消费者C1, C2 平均要消费两个分区的数据, 而 B 组的消费者平均消费 一 个分区的数据 ( 最理想的状态 ), 得到的结论是 : <strong>一条消息只能被一个消费组中的一个消费者实例消费到</strong>, (换句话说, 不可能出现组中的两个消费者负责同一个分区, 同组内消费者不会重复消费 )</p>
<p>等等, 考虑的场景还不够, 下边再提些问题 :</p>
<p>如果分区数大于或等于组中的消费者实例数, 那就没有问题, 但是如果消费者实例的数量 &gt; 主题下分区数量, 那么按照默认的策略 ( 之所以强调默认策略是因为可以自定义策略 ), 有一些消费者是多余的, 一直接不到消息而处于空闲状态.</p>
<p>但是假设有消费者实例就是不安分, 就造成了多个消费者负责同一个分区, 这样会造成什么 ? (重复消费就太可怕了)</p>
<p>我们知道，Kafka它在设计的时候就是要保证分区下消息的顺序，也就是说消息在一个分区中的顺序是怎样的，那么消费者在消费的时候看到的就是什么样的顺序，那么要做到这一点就首先要保证消息是由消费者主动拉取的（pull），其次还要保证一个分区只能由一个消费者负责。倘若，两个消费者负责同一个分区，那么就意味着两个消费者同时读取分区的消息，由于消费者自己可以控制读取消息的offset (偏移量)，就有可能C1才读到2，而C2读到1，C1还没提交 offset，这时C2读到2了，相当于多线程读取同一个消息，会造成消息处理的重复，且不能保证消息的顺序，这就跟主动推送（push）无异。</p>
<h2 id="消费者分区分配策略-两种">消费者分区分配策略 (两种)</h2>
<p>range策略是基于每个主题的，对于每个主题，我们以数字顺序排列可用分区，以字典顺序排列消费者。然后，将分区数量除以消费者总数，以确定分配给每个消费者的分区数量。如果没有平均划分（PS：除不尽），那么最初的几个消费者将有一个额外的分区。</p>
<p>简而言之:</p>
<ol>
<li class="lvl-3">
<p>range分配策略针对的是主题（也就是说，这里所说的分区指的某个主题的分区，消费者值的是订阅这个主题的消费者组中的消费者实例）</p>
</li>
<li class="lvl-3">
<p>首先，将分区按数字顺序排行序，消费者按消费者名称的字典顺序排好序.</p>
</li>
<li class="lvl-3">
<p>然后，用分区总数除以消费者总数。如果能够除尽，则皆大欢喜，平均分配；若除不尽，则位于排序前面的消费者将多负责一个分区.</p>
</li>
</ol>
<p>例如，假设有两个消费者C0和C1，两个主题t0和t1，并且每个主题有3个分区，分区的情况是这样的：t0p0，t0p1，t0p2，t1p0，t1p1，t1p2</p>
<p>那么，基于以上信息，最终消费者分配分区的情况是这样的：</p>
<p>C0: [t0p0, t0p1, t1p0, t1p1]</p>
<p>C1: [t0p2, t1p2]</p>
<p>因为，对于主题t0，分配的结果是C0负责P0和P1，C1负责P2；对于主题t2，也是如此，综合起来就是这个结果</p>
<p>上面的过程用图形表示的话大概是这样的 :</p>
<img src="https://img2018.cnblogs.com/blog/1629331/201911/1629331-20191129230609350-1656648320.png" referrerpolicy="no-referrer">
<p>roundrobin (轮询)</p>
<p>roundronbin分配策略的具体实现是org.apache.kafka.clients.consumer.RoundRobinAssignor</p>
<p>轮询分配策略是基于所有可用的消费者和所有可用的分区的</p>
<p>与前面的range策略最大的不同就是它不再局限于某个主题</p>
<p>如果所有的消费者实例的订阅都是相同的，那么这样最好了，可用统一分配，均衡分配</p>
<p>例如，假设有两个消费者C0和C1，两个主题t0和t1，每个主题有3个分区，分别是t0p0，t0p1，t0p2，t1p0，t1p1，t1p2</p>
<p>那么，最终分配的结果是这样的：</p>
<p>C0: [t0p0, t0p2, t1p1]</p>
<p>C1: [t0p1, t1p0, t1p2]</p>
<p>用图形表示大概是这样的:</p>
<img src="https://img2018.cnblogs.com/blog/1629331/201911/1629331-20191129230645759-1165797262.png" referrerpolicy="no-referrer">
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka本地安装</title>
    <url>/posts/a111c625.html</url>
    <content><![CDATA[<h3 id="安装zookeeper">安装zookeeper</h3>
<p>地址：<a href="http://apache.org/dist/zookeeper/zookeeper-3.4.14/">zookeeper-3.4.14</a>，下载后解压</p>
<ol>
<li class="lvl-3">
<p>进入zookeeper的相关设置所在的文件目录，例如本文的：D: \ …\zookeeper-3.4.10\conf</p>
</li>
<li class="lvl-3">
<p>将&quot;zoo_sample.cfg&quot;重命名为&quot;zoo.cfg&quot;</p>
</li>
<li class="lvl-3">
<p>dataDir=/tmp/zookeeper  to  D:/ …/zookeeper-3.4.10/data</p>
</li>
<li class="lvl-3">
<p>添加系统环境变量</p>
<ul class="lvl-2">
<li class="lvl-6">
<p>系统变量中添加ZOOKEEPER_HOME=D:\ …\zookeeper-3.4.10</p>
</li>
<li class="lvl-6">
<p>编辑系统变量中的path变量，增加%ZOOKEEPER_HOME%\bin</p>
</li>
</ul>
</li>
</ol>
<h3 id="安装kafka">安装kafka</h3>
<p>地址: <a href="http://apache.org/dist/kafka/2.1.1/">kafka-2.11_2.1.1</a>，下载后解压</p>
<p>同样加入到环境变量中</p>
<h3 id="启动kafka">启动kafka</h3>
<ol>
<li class="lvl-3">
<p>启动zookeeper</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">zkserver.cmd</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>启动kafka</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.\bin\windows\kafka-server-start.bat .\config\server.properties</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>申请生产者</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.\bin\windows\kafka-console-producer.bat --broker-list localhost:<span class="number">9092</span> --topic test</span><br></pre></td></tr></table></figure>
<ol start="4">
<li class="lvl-3">
<p>申请消费者</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.\bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:<span class="number">9092</span> --topic test --from-beginning</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式计算框架—MapReduce</title>
    <url>/posts/9c03dda8.html</url>
    <content><![CDATA[<h2 id="一、MapReduce概述">一、MapReduce概述</h2>
<p>Hadoop MapReduce 是一个分布式计算框架，用于编写批处理应用程序。编写好的程序可以提交到 Hadoop 集群上用于并行处理大规模的数据集。</p>
<p>MapReduce 作业通过将输入的数据集拆分为独立的块，这些块由 <code>map</code> 以并行的方式处理，框架对 <code>map</code> 的输出进行排序，然后输入到 <code>reduce</code> 中。MapReduce 框架专门用于 <code>&lt;key，value&gt;</code> 键值对处理，它将作业的输入视为一组 <code>&lt;key，value&gt;</code> 对，并生成一组 <code>&lt;key，value&gt;</code> 对作为输出。输出和输出的 <code>key</code> 和 <code>value</code> 都必须实现<a href="http://hadoop.apache.org/docs/stable/api/org/apache/hadoop/io/Writable.html">Writable</a> 接口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(input) &lt;k1, v1&gt; -&gt; map -&gt; &lt;k2, v2&gt; -&gt; combine -&gt; &lt;k2, v2&gt; -&gt; reduce -&gt; &lt;k3, v3&gt; (output)</span><br></pre></td></tr></table></figure>
<h2 id="二、MapReduce编程模型简述">二、MapReduce编程模型简述</h2>
<p>这里以词频统计为例进行说明，MapReduce 处理的流程如下：</p>
<div align="center"> <img width="600px" src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/mapreduceProcess.png"/> </div>
<ol>
<li class="lvl-3">
<p><strong>input</strong> : 读取文本文件；</p>
</li>
<li class="lvl-3">
<p><strong>splitting</strong> : 将文件按照行进行拆分，此时得到的 <code>K1</code> 行数，<code>V1</code> 表示对应行的文本内容；</p>
</li>
<li class="lvl-3">
<p><strong>mapping</strong> : 并行将每一行按照空格进行拆分，拆分得到的 <code>List(K2,V2)</code>，其中 <code>K2</code> 代表每一个单词，由于是做词频统计，所以 <code>V2</code> 的值为 1，代表出现 1 次；</p>
</li>
<li class="lvl-3">
<p><strong>shuffling</strong>：由于 <code>Mapping</code> 操作可能是在不同的机器上并行处理的，所以需要通过 <code>shuffling</code> 将相同 <code>key</code> 值的数据分发到同一个节点上去合并，这样才能统计出最终的结果，此时得到 <code>K2</code> 为每一个单词，<code>List(V2)</code> 为可迭代集合，<code>V2</code> 就是 Mapping 中的 V2；</p>
</li>
<li class="lvl-3">
<p><strong>Reducing</strong> : 这里的案例是统计单词出现的总次数，所以 <code>Reducing</code> 对 <code>List(V2)</code> 进行归约求和操作，最终输出。</p>
</li>
</ol>
<p>MapReduce 编程模型中 <code>splitting</code> 和 <code>shuffing</code> 操作都是由框架实现的，需要我们自己编程实现的只有 <code>mapping</code> 和 <code>reducing</code>，这也就是 MapReduce 这个称呼的来源。</p>
<h2 id="三、combiner-partitioner">三、combiner &amp; partitioner</h2>
<div align="center"> <img width="600px" src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/Detailed-Hadoop-MapReduce-Data-Flow-14.png"/> </div>
<h3 id="3-1-InputFormat-RecordReaders">3.1 InputFormat &amp; RecordReaders</h3>
<p><code>InputFormat</code> 将输出文件拆分为多个 <code>InputSplit</code>，并由 <code>RecordReaders</code> 将 <code>InputSplit</code> 转换为标准的&lt;key，value&gt;键值对，作为 map 的输出。这一步的意义在于只有先进行逻辑拆分并转为标准的键值对格式后，才能为多个 <code>map</code> 提供输入，以便进行并行处理。</p>
<h3 id="3-2-Combiner">3.2 Combiner</h3>
<p><code>combiner</code> 是 <code>map</code> 运算后的可选操作，它实际上是一个本地化的 <code>reduce</code> 操作，它主要是在 <code>map</code> 计算出中间文件后做一个简单的合并重复 <code>key</code> 值的操作。这里以词频统计为例：</p>
<p><code>map</code> 在遇到一个 hadoop 的单词时就会记录为 1，但是这篇文章里 hadoop 可能会出现 n 多次，那么 <code>map</code> 输出文件冗余就会很多，因此在 <code>reduce</code> 计算前对相同的 key 做一个合并操作，那么需要传输的数据量就会减少，传输效率就可以得到提升。</p>
<p>但并非所有场景都适合使用 <code>combiner</code>，使用它的原则是 <code>combiner</code> 的输出不会影响到 <code>reduce</code> 计算的最终输入，例如：求总数，最大值，最小值时都可以使用 <code>combiner</code>，但是做平均值计算则不能使用 <code>combiner</code>。</p>
<p>不使用 combiner 的情况：</p>
<div align="center"> <img  width="600px"  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/mapreduce-without-combiners.png"/> </div>
<p>使用 combiner 的情况：</p>
<div align="center"> <img width="600px"  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/mapreduce-with-combiners.png"/> </div>
<p>可以看到使用 combiner 的时候，需要传输到 reducer 中的数据由 12keys，降低到 10keys。降低的幅度取决于你 keys 的重复率，下文词频统计案例会演示用 combiner 降低数百倍的传输量。</p>
<h3 id="3-3-Partitioner">3.3 Partitioner</h3>
<p><code>partitioner</code> 可以理解成分类器，将 <code>map</code> 的输出按照 key 值的不同分别分给对应的 <code>reducer</code>，支持自定义实现，下文案例会给出演示。</p>
<h2 id="四、MapReduce词频统计案例">四、MapReduce词频统计案例</h2>
<h3 id="4-1-项目简介">4.1 项目简介</h3>
<p>这里给出一个经典的词频统计的案例：统计如下样本数据中每个单词出现的次数。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">Spark</span>	<span class="string">HBase</span></span><br><span class="line"><span class="attr">Hive</span>	<span class="string">Flink	Storm	Hadoop	HBase	Spark</span></span><br><span class="line"><span class="attr">Flink</span></span><br><span class="line"><span class="attr">HBase</span>	<span class="string">Storm</span></span><br><span class="line"><span class="attr">HBase</span>	<span class="string">Hadoop	Hive	Flink</span></span><br><span class="line"><span class="attr">HBase</span>	<span class="string">Flink	Hive	Storm</span></span><br><span class="line"><span class="attr">Hive</span>	<span class="string">Flink	Hadoop</span></span><br><span class="line"><span class="attr">HBase</span>	<span class="string">Hive</span></span><br><span class="line"><span class="attr">Hadoop</span>	<span class="string">Spark	HBase	Storm</span></span><br><span class="line"><span class="attr">HBase</span>	<span class="string">Hadoop	Hive	Flink</span></span><br><span class="line"><span class="attr">HBase</span>	<span class="string">Flink	Hive	Storm</span></span><br><span class="line"><span class="attr">Hive</span>	<span class="string">Flink	Hadoop</span></span><br><span class="line"><span class="attr">HBase</span>	<span class="string">Hive</span></span><br></pre></td></tr></table></figure>
<p>为方便大家开发，我在项目源码中放置了一个工具类 <code>WordCountDataUtils</code>，用于模拟产生词频统计的样本，生成的文件支持输出到本地或者直接写到 HDFS 上。</p>
<blockquote>
<p>项目完整源码下载地址：<a href="https://github.com/oicio/BigData-Notes/tree/master/code/Hadoop/hadoop-word-count">hadoop-word-count</a></p>
</blockquote>
<h3 id="4-2-项目依赖">4.2 项目依赖</h3>
<p>想要进行 MapReduce 编程，需要导入 <code>hadoop-client</code> 依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hadoop.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-3-WordCountMapper">4.3 WordCountMapper</h3>
<p>将每行数据按照指定分隔符进行拆分。这里需要注意在 MapReduce 中必须使用 Hadoop 定义的类型，因为 Hadoop 预定义的类型都是可序列化，可比较的，所有类型均实现了 <code>WritableComparable</code> 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCountMapper</span> <span class="keyword">extends</span> <span class="title class_">Mapper</span>&lt;LongWritable, Text, Text, IntWritable&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, </span><br><span class="line">                                                                      InterruptedException &#123;</span><br><span class="line">        String[] words = value.toString().split(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            context.write(<span class="keyword">new</span> <span class="title class_">Text</span>(word), <span class="keyword">new</span> <span class="title class_">IntWritable</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>WordCountMapper</code> 对应下图的 Mapping 操作：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hadoop-code-mapping.png"/> </div>
<p><code>WordCountMapper</code> 继承自 <code>Mappe</code> 类，这是一个泛型类，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WordCountMapper <span class="keyword">extends</span> <span class="title class_">Mapper</span>&lt;LongWritable, Text, Text, IntWritable&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mapper</span>&lt;KEYIN, VALUEIN, KEYOUT, VALUEOUT&gt; &#123;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>KEYIN</strong> : <code>mapping</code> 输入 key 的类型，即每行的偏移量 (每行第一个字符在整个文本中的位置)，<code>Long</code> 类型，对应 Hadoop 中的 <code>LongWritable</code> 类型；</p>
</li>
<li class="lvl-2">
<p><strong>VALUEIN</strong> : <code>mapping</code> 输入 value 的类型，即每行数据；<code>String</code> 类型，对应 Hadoop 中 <code>Text</code> 类型；</p>
</li>
<li class="lvl-2">
<p><strong>KEYOUT</strong> ：<code>mapping</code> 输出的 key 的类型，即每个单词；<code>String</code> 类型，对应 Hadoop 中 <code>Text</code> 类型；</p>
</li>
<li class="lvl-2">
<p><strong>VALUEOUT</strong>：<code>mapping</code> 输出 value 的类型，即每个单词出现的次数；这里用 <code>int</code> 类型，对应 <code>IntWritable</code> 类型。</p>
</li>
</ul>
<h3 id="4-4-WordCountReducer">4.4 WordCountReducer</h3>
<p>在 Reduce 中进行单词出现次数的统计：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCountReducer</span> <span class="keyword">extends</span> <span class="title class_">Reducer</span>&lt;Text, IntWritable, Text, IntWritable&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, </span><br><span class="line">                                                                                  InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (IntWritable value : values) &#123;</span><br><span class="line">            count += value.get();</span><br><span class="line">        &#125;</span><br><span class="line">        context.write(key, <span class="keyword">new</span> <span class="title class_">IntWritable</span>(count));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下图，<code>shuffling</code> 的输出是 reduce 的输入。这里的 key 是每个单词，values 是一个可迭代的数据类型，类似 <code>(1,1,1,...)</code>。</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hadoop-code-reducer.png"/> </div>
<h3 id="4-4-WordCountApp">4.4 WordCountApp</h3>
<p>组装 MapReduce 作业，并提交到服务器运行，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组装作业 并提交到集群运行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCountApp</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里为了直观显示参数 使用了硬编码，实际开发中可以通过外部传参</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HDFS_URL</span> <span class="operator">=</span> <span class="string">&quot;hdfs://192.168.0.107:8020&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HADOOP_USER_NAME</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  文件输入路径和输出路径由外部传参指定</span></span><br><span class="line">        <span class="keyword">if</span> (args.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Input and output paths are necessary!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要指明 hadoop 用户名，否则在 HDFS 上创建目录时可能会抛出权限不足的异常</span></span><br><span class="line">        System.setProperty(<span class="string">&quot;HADOOP_USER_NAME&quot;</span>, HADOOP_USER_NAME);</span><br><span class="line"></span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">        <span class="comment">// 指明 HDFS 的地址</span></span><br><span class="line">        configuration.set(<span class="string">&quot;fs.defaultFS&quot;</span>, HDFS_URL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个 Job</span></span><br><span class="line">        <span class="type">Job</span> <span class="variable">job</span> <span class="operator">=</span> Job.getInstance(configuration);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置运行的主类</span></span><br><span class="line">        job.setJarByClass(WordCountApp.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 Mapper 和 Reducer</span></span><br><span class="line">        job.setMapperClass(WordCountMapper.class);</span><br><span class="line">        job.setReducerClass(WordCountReducer.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 Mapper 输出 key 和 value 的类型</span></span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(IntWritable.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 Reducer 输出 key 和 value 的类型</span></span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(IntWritable.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果输出目录已经存在，则必须先删除，否则重复运行程序时会抛出异常</span></span><br><span class="line">        <span class="type">FileSystem</span> <span class="variable">fileSystem</span> <span class="operator">=</span> FileSystem.get(<span class="keyword">new</span> <span class="title class_">URI</span>(HDFS_URL), configuration, HADOOP_USER_NAME);</span><br><span class="line">        <span class="type">Path</span> <span class="variable">outputPath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Path</span>(args[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (fileSystem.exists(outputPath)) &#123;</span><br><span class="line">            fileSystem.delete(outputPath, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置作业输入文件和输出文件的路径</span></span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> <span class="title class_">Path</span>(args[<span class="number">0</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, outputPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将作业提交到群集并等待它完成，参数设置为 true 代表打印显示对应的进度</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> job.waitForCompletion(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭之前创建的 fileSystem</span></span><br><span class="line">        fileSystem.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据作业结果,终止当前运行的 Java 虚拟机,退出程序</span></span><br><span class="line">        System.exit(result ? <span class="number">0</span> : -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是：如果不设置 <code>Mapper</code> 操作的输出类型，则程序默认它和 <code>Reducer</code> 操作输出的类型相同。</p>
<h3 id="4-5-提交到服务器运行">4.5 提交到服务器运行</h3>
<p>在实际开发中，可以在本机配置 hadoop 开发环境，直接在 IDE 中启动进行测试。这里主要介绍一下打包提交到服务器运行。由于本项目没有使用除 Hadoop 外的第三方依赖，直接打包即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">mvn clean package</span></span><br></pre></td></tr></table></figure>
<p>使用以下命令提交作业：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop jar /usr/appjar/hadoop-word-count-1.0.jar \</span><br><span class="line">com.oicio.WordCountApp \</span><br><span class="line">/wordcount/input.txt /wordcount/output/WordCountApp</span><br></pre></td></tr></table></figure>
<p>作业完成后查看 HDFS 上生成目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">查看目录</span></span><br><span class="line">hadoop fs -ls /wordcount/output/WordCountApp</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看统计结果</span></span><br><span class="line">hadoop fs -cat /wordcount/output/WordCountApp/part-r-00000</span><br></pre></td></tr></table></figure>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hadoop-wordcountapp.png"/> </div>
<h2 id="五、词频统计案例进阶之Combiner">五、词频统计案例进阶之Combiner</h2>
<h3 id="5-1-代码实现">5.1 代码实现</h3>
<p>想要使用 <code>combiner</code> 功能只要在组装作业时，添加下面一行代码即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置 Combiner</span></span><br><span class="line">job.setCombinerClass(WordCountReducer.class);</span><br></pre></td></tr></table></figure>
<h3 id="5-2-执行结果">5.2 执行结果</h3>
<p>加入 <code>combiner</code> 后统计结果是不会有变化的，但是可以从打印的日志看出 <code>combiner</code> 的效果：</p>
<p>没有加入 <code>combiner</code> 的打印日志：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hadoop-no-combiner.png"/> </div>
<p>加入 <code>combiner</code> 后的打印日志如下：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hadoop-combiner.png"/> </div>
<p>这里我们只有一个输入文件并且小于 128M，所以只有一个 Map 进行处理。可以看到经过 combiner 后，records 由 <code>3519</code> 降低为 <code>6</code>(样本中单词种类就只有 6 种)，在这个用例中 combiner 就能极大地降低需要传输的数据量。</p>
<h2 id="六、词频统计案例进阶之Partitioner">六、词频统计案例进阶之Partitioner</h2>
<h3 id="6-1-默认的Partitioner">6.1  默认的Partitioner</h3>
<p>这里假设有个需求：将不同单词的统计结果输出到不同文件。这种需求实际上比较常见，比如统计产品的销量时，需要将结果按照产品种类进行拆分。要实现这个功能，就需要用到自定义 <code>Partitioner</code>。</p>
<p>这里先介绍下 MapReduce 默认的分类规则：在构建 job 时候，如果不指定，默认的使用的是 <code>HashPartitioner</code>：对 key 值进行哈希散列并对 <code>numReduceTasks</code> 取余。其实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashPartitioner</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">Partitioner</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPartition</span><span class="params">(K key, V value,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> numReduceTasks)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (key.hashCode() &amp; Integer.MAX_VALUE) % numReduceTasks;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-自定义Partitioner">6.2 自定义Partitioner</h3>
<p>这里我们继承 <code>Partitioner</code> 自定义分类规则，这里按照单词进行分类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomPartitioner</span> <span class="keyword">extends</span> <span class="title class_">Partitioner</span>&lt;Text, IntWritable&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPartition</span><span class="params">(Text text, IntWritable intWritable, <span class="type">int</span> numPartitions)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> WordCountDataUtils.WORD_LIST.indexOf(text.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构建 <code>job</code> 时候指定使用我们自己的分类规则，并设置 <code>reduce</code> 的个数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置自定义分区规则</span></span><br><span class="line">job.setPartitionerClass(CustomPartitioner.class);</span><br><span class="line"><span class="comment">// 设置 reduce 个数</span></span><br><span class="line">job.setNumReduceTasks(WordCountDataUtils.WORD_LIST.size());</span><br></pre></td></tr></table></figure>
<h3 id="6-3-执行结果">6.3  执行结果</h3>
<p>执行结果如下，分别生成 6 个文件，每个文件中为对应单词的统计结果：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hadoop-wordcountcombinerpartition.png"/> </div>
<h2 id="参考资料-21">参考资料</h2>
<ol>
<li class="lvl-3">
<p><a href="https://zhuanlan.zhihu.com/p/28682581">分布式计算框架 MapReduce</a></p>
</li>
<li class="lvl-3">
<p><a href="http://hadoop.apache.org/docs/stable/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapReduceTutorial.html">Apache Hadoop 2.9.2 &gt; MapReduce Tutorial</a></p>
</li>
<li class="lvl-3">
<p><a href="https://www.tutorialscampus.com/tutorials/map-reduce/combiners.htm">MapReduce - Combiners</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>linux环境变量加载顺序</title>
    <url>/posts/9104f7ba.html</url>
    <content><![CDATA[<h1>01、环境变量文件描述</h1>
<p><strong>/etc/profile</strong>: 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行,并从/etc/profile.d目录的配置文件中搜集shell的设置.<br>
<strong>/etc/bashrc</strong>: 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取.</p>
<p>//用户级别的环境变量，用户可以覆盖全局变量<br>
<strong>~/.bash_profile</strong>: 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件.<br>
<strong>~/.bashrc</strong>: 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取.<br>
<strong>~/.bash_logout</strong>: 当每次退出系统(退出bash shell)时,执行该文件.</p>
<p>/etc/profile中设定的变量(全局)的可以作用于任何用户,<br>
而~/.bashrc等中设定的变量(局部)只能继承/etc/profile中的变量,他们是&quot;父子&quot;关系.</p>
<p>~/.bash_profile 是交互式、login 方式进入 bash 运行的<br>
~/.bashrc 是交互式 non-login 方式进入 bash 运行的通常二者设置大致相同，所以通常前者会调用后者</p>
<h2 id="一、系统环境变量：">一、系统环境变量：</h2>
<p><strong>/etc/profile</strong> ：这个文件预设了几个重要的变量，例如PATH, USER, LOGNAME, MAIL, INPUTRC, HOSTNAME, HISTSIZE, umask等等。</p>
<p>为系统的每个用户设置环境信息。当用户第一次登陆时，该文件执行，并从/etc/profile.d目录中的配置文件搜索shell的设置（可以用于设定针对全系统所有用户的环境变量，环境变量周期是永久的）</p>
<p><strong>/etc/bashrc</strong> ：这个文件主要预设umask以及PS1。这个PS1就是我们在敲命令时，前面那串字符了，例如 [root@localhost ~]#,当bash shell被打开时,该文件被读取</p>
<p>这个文件是针对所有用户的bash初始化文件，在此设定中的环境信息将应用与所有用户的shell中，此文件会在用户每次打开shell时执行一次。（即每次新开一个终端，都会执行/etc/bashrc）**</p>
<h2 id="二、用户环境变量：">二、用户环境变量：</h2>
<p><strong>.bash_profile</strong> ：定义了用户的个人化路径与环境变量的文件名称。每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次。（在这个文件中有执行.bashrc的脚本）</p>
<p><strong>.bashrc</strong> ：该文件包含专用于你的shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。例如你可以将用户自定义的alias或者自定义变量写到这个文件中。</p>
<p><strong>.bash_history</strong> ：记录命令历史用的。</p>
<p><strong>.bash_logout</strong> ：当退出shell时，会执行该文件。可以把一些清理的工作放到这个文件中。</p>
<p>linux加载配置项时通过下面方式首先 加载/etc/profile配置</p>
<p>然后 加载/ect/profile.d/下面的所有脚本</p>
<p>然后 加载当前用户 .bash_profile</p>
<p>然后 加载.bashrc</p>
<p>最后 加载 [/etc/bashrc]</p>
<p>/etc/profile → /etc/profile.d/*.sh → ~/.bash_profile → ~/.bashrc → [/etc/bashrc]</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>基于ZooKeeper搭建Hadoop</title>
    <url>/posts/89e1e826.html</url>
    <content><![CDATA[<h2 id="一、高可用简介">一、高可用简介</h2>
<p>Hadoop 高可用 (High Availability) 分为 HDFS 高可用和 YARN 高可用，两者的实现基本类似，但 HDFS NameNode 对数据存储及其一致性的要求比 YARN ResourceManger 高得多，所以它的实现也更加复杂，故下面先进行讲解：</p>
<h3 id="1-1-高可用整体架构">1.1 高可用整体架构</h3>
<p>HDFS 高可用架构如下：</p>
<p><img src="https://camo.githubusercontent.com/b0b8e7bfcf3d75fc2048d0fb1671e7c7ffa234f8/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f484446532d48412d4172636869746563747572652d45647572656b612e706e67" alt="img"></p>
<blockquote>
<p><em>图片引用自：<a href="https://www.edureka.co/blog/how-to-set-up-hadoop-cluster-with-hdfs-high-availability/">https://www.edureka.co/blog/how-to-set-up-hadoop-cluster-with-hdfs-high-availability/</a></em></p>
</blockquote>
<p>HDFS 高可用架构主要由以下组件所构成：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Active NameNode 和 Standby NameNode</strong>：两台 NameNode 形成互备，一台处于 Active 状态，为主 NameNode，另外一台处于 Standby 状态，为备 NameNode，只有主 NameNode 才能对外提供读写服务。</p>
</li>
<li class="lvl-2">
<p><strong>主备切换控制器 ZKFailoverController</strong>：ZKFailoverController  作为独立的进程运行，对 NameNode 的主备切换进行总体控制。ZKFailoverController 能及时检测到 NameNode  的健康状况，在主 NameNode 故障时借助 Zookeeper 实现自动的主备选举和切换，当然 NameNode 目前也支持不依赖于  Zookeeper 的手动主备切换。</p>
</li>
<li class="lvl-2">
<p><strong>Zookeeper 集群</strong>：为主备切换控制器提供主备选举支持。</p>
</li>
<li class="lvl-2">
<p><strong>共享存储系统</strong>：共享存储系统是实现 NameNode 的高可用最为关键的部分，共享存储系统保存了  NameNode 在运行过程中所产生的 HDFS 的元数据。主 NameNode 和 NameNode  通过共享存储系统实现元数据同步。在进行主备切换的时候，新的主 NameNode 在确认元数据完全同步之后才能继续对外提供服务。</p>
</li>
<li class="lvl-2">
<p><strong>DataNode 节点</strong>：除了通过共享存储系统共享 HDFS 的元数据信息之外，主 NameNode 和备 NameNode 还需要共享 HDFS 的数据块和 DataNode 之间的映射关系。DataNode 会同时向主 NameNode 和备  NameNode 上报数据块的位置信息。</p>
</li>
</ul>
<h3 id="1-2-基于-QJM-的共享存储系统的数据同步机制分析">1.2 基于 QJM 的共享存储系统的数据同步机制分析</h3>
<p>目前 Hadoop 支持使用 Quorum Journal Manager (QJM) 或 Network File System  (NFS) 作为共享的存储系统，这里以 QJM 集群为例进行说明：Active NameNode 首先把 EditLog 提交到  JournalNode 集群，然后 Standby NameNode 再从 JournalNode 集群定时同步 EditLog，当  Active NameNode  宕机后， Standby  NameNode 在确认元数据完全同步之后就可以对外提供服务。</p>
<p>需要说明的是向 JournalNode 集群写入 EditLog 是遵循 “过半写入则成功” 的策略，所以你至少要有 3 个  JournalNode 节点，当然你也可以继续增加节点数量，但是应该保证节点总数是奇数。同时如果有 2N+1 台  JournalNode，那么根据过半写的原则，最多可以容忍有 N 台 JournalNode 节点挂掉。</p>
<p><img src="https://camo.githubusercontent.com/3f5274ffc21109f2390bdd2e1ec37d3e837b4cc1/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f6861646f6f702d514a4d2de5908ce6ada5e69cbae588b62e706e67" alt="img"></p>
<h3 id="1-3-NameNode-主备切换">1.3 NameNode 主备切换</h3>
<p>NameNode 实现主备切换的流程下图所示：</p>
<p><img src="https://camo.githubusercontent.com/33bb0d7c919a1ef21c959460dc3e5e116070b5bb/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f6861646f6f702d6e616d656e6f6465e4b8bbe5a487e58887e68da22e706e67" alt="img"></p>
<p>\1. HealthMonitor 初始化完成之后会启动内部的线程来定时调用对应 NameNode 的 HAServiceProtocol RPC 接口的方法，对 NameNode 的健康状态进行检测。 2. HealthMonitor 如果检测到 NameNode 的健康状态发生变化，会回调 ZKFailoverController 注册的相应方法进行处理。 3. 如果 ZKFailoverController 判断需要进行主备切换，会首先使用 ActiveStandbyElector 来进行自动的主备选举。 4. ActiveStandbyElector 与 Zookeeper 进行交互完成自动的主备选举。 5. ActiveStandbyElector 在主备选举完成后，会回调 ZKFailoverController 的相应方法来通知当前的 NameNode 成为主 NameNode 或备 NameNode。 6. ZKFailoverController 调用对应 NameNode 的 HAServiceProtocol RPC 接口的方法将 NameNode 转换为 Active 状态或 Standby 状态。</p>
<h3 id="1-4-YARN高可用">1.4 YARN高可用</h3>
<p>YARN ResourceManager 的高可用与 HDFS NameNode 的高可用类似，但是 ResourceManager 不像 NameNode ，没有那么多的元数据信息需要维护，所以它的状态信息可以直接写到 Zookeeper 上，并依赖 Zookeeper  来进行主备选举。</p>
<p><img src="https://camo.githubusercontent.com/9e7d4c0e0db498ab5f8663d58ad38deeaa330218/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f6861646f6f702d726d2d68612d6f766572766965772e706e67" alt="img"></p>
<h2 id="二、集群规划">二、集群规划</h2>
<p>按照高可用的设计目标：需要保证至少有两个 NameNode (一主一备)  和 两个 ResourceManager (一主一备)   ，同时为满足“过半写入则成功”的原则，需要至少要有 3 个 JournalNode 节点。这里使用三台主机进行搭建，集群规划如下：</p>
<p><img src="https://camo.githubusercontent.com/9d815ddad1f979ac693a6d96f2e59c0962a72c14/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f6861646f6f70e9ab98e58fafe794a8e99b86e7bea4e8a784e588922e706e67" alt="img"></p>
<h2 id="三、前置条件">三、前置条件</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>所有服务器都安装有 JDK，安装步骤可以参见：<a href="https://github.com/ihadyou/BigData-Notes/blob/master/notes/installation/Linux%E4%B8%8BJDK%E5%AE%89%E8%A3%85.md">Linux 下 JDK 的安装</a>；</p>
</li>
<li class="lvl-2">
<p>搭建好 ZooKeeper 集群，搭建步骤可以参见：<a href="https://github.com/ihadyou/BigData-Notes/blob/master/notes/installation/Zookeeper%E5%8D%95%E6%9C%BA%E7%8E%AF%E5%A2%83%E5%92%8C%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md">Zookeeper 单机环境和集群环境搭建</a></p>
</li>
<li class="lvl-2">
<p>所有服务器之间都配置好 SSH 免密登录。</p>
</li>
</ul>
<h2 id="四、集群配置">四、集群配置</h2>
<h3 id="4-1-下载并解压">4.1 下载并解压</h3>
<p>下载 Hadoop。这里我下载的是 CDH 版本 Hadoop，下载地址为：<a href="http://archive.cloudera.com/cdh5/cdh/5/">http://archive.cloudera.com/cdh5/cdh/5/</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># tar -zvxf hadoop-2.6.0-cdh5.15.2.tar.gz </span><br></pre></td></tr></table></figure>
<h3 id="4-2-配置环境变量">4.2 配置环境变量</h3>
<p>编辑 <code>profile</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># vim /etc/profile</span><br></pre></td></tr></table></figure>
<p>增加如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export HADOOP_HOME=/usr/app/hadoop-2.6.0-cdh5.15.2</span><br><span class="line">export  PATH=$&#123;HADOOP_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>执行 <code>source</code> 命令，使得配置立即生效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># source /etc/profile</span><br></pre></td></tr></table></figure>
<h3 id="4-3-修改配置">4.3 修改配置</h3>
<p>进入 <code>$&#123;HADOOP_HOME&#125;/etc/hadoop</code> 目录下，修改配置文件。各个配置文件内容如下：</p>
<h4 id="1-hadoop-env-sh-3">1. <a href="http://hadoop-env.sh">hadoop-env.sh</a></h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 指定JDK的安装位置</span><br><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_201/</span><br></pre></td></tr></table></figure>
<h4 id="2-core-site-xml-3">2.  core-site.xml</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- 指定 namenode 的 hdfs 协议文件系统的通信地址 --&gt;</span><br><span class="line">        &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hdfs://hadoop001:8020&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- 指定 hadoop 集群存储临时文件的目录 --&gt;</span><br><span class="line">        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;/home/hadoop/tmp&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- ZooKeeper 集群的地址 --&gt;</span><br><span class="line">        &lt;name&gt;ha.zookeeper.quorum&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hadoop001:2181,hadoop002:2181,hadoop002:2181&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- ZKFC 连接到 ZooKeeper 超时时长 --&gt;</span><br><span class="line">        &lt;name&gt;ha.zookeeper.session-timeout.ms&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;10000&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<h4 id="3-hdfs-site-xml-3">3. hdfs-site.xml</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- 指定 HDFS 副本的数量 --&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;3&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- namenode 节点数据（即元数据）的存放位置，可以指定多个目录实现容错，多个目录用逗号分隔 --&gt;</span><br><span class="line">        &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;/home/hadoop/namenode/data&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- datanode 节点数据（即数据块）的存放位置 --&gt;</span><br><span class="line">        &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;/home/hadoop/datanode/data&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- 集群服务的逻辑名称 --&gt;</span><br><span class="line">        &lt;name&gt;dfs.nameservices&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;mycluster&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- NameNode ID 列表--&gt;</span><br><span class="line">        &lt;name&gt;dfs.ha.namenodes.mycluster&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;nn1,nn2&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- nn1 的 RPC 通信地址 --&gt;</span><br><span class="line">        &lt;name&gt;dfs.namenode.rpc-address.mycluster.nn1&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hadoop001:8020&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- nn2 的 RPC 通信地址 --&gt;</span><br><span class="line">        &lt;name&gt;dfs.namenode.rpc-address.mycluster.nn2&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hadoop002:8020&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- nn1 的 http 通信地址 --&gt;</span><br><span class="line">        &lt;name&gt;dfs.namenode.http-address.mycluster.nn1&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hadoop001:50070&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- nn2 的 http 通信地址 --&gt;</span><br><span class="line">        &lt;name&gt;dfs.namenode.http-address.mycluster.nn2&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hadoop002:50070&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- NameNode 元数据在 JournalNode 上的共享存储目录 --&gt;</span><br><span class="line">        &lt;name&gt;dfs.namenode.shared.edits.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;qjournal://hadoop001:8485;hadoop002:8485;hadoop003:8485/mycluster&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- Journal Edit Files 的存储目录 --&gt;</span><br><span class="line">        &lt;name&gt;dfs.journalnode.edits.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;/home/hadoop/journalnode/data&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- 配置隔离机制，确保在任何给定时间只有一个 NameNode 处于活动状态 --&gt;</span><br><span class="line">        &lt;name&gt;dfs.ha.fencing.methods&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;sshfence&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- 使用 sshfence 机制时需要 ssh 免密登录 --&gt;</span><br><span class="line">        &lt;name&gt;dfs.ha.fencing.ssh.private-key-files&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;/root/.ssh/id_rsa&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- SSH 超时时间 --&gt;</span><br><span class="line">        &lt;name&gt;dfs.ha.fencing.ssh.connect-timeout&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;30000&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- 访问代理类，用于确定当前处于 Active 状态的 NameNode --&gt;</span><br><span class="line">        &lt;name&gt;dfs.client.failover.proxy.provider.mycluster&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- 开启故障自动转移 --&gt;</span><br><span class="line">        &lt;name&gt;dfs.ha.automatic-failover.enabled&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<h4 id="4-yarn-site-xml-2">4. yarn-site.xml</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!--配置 NodeManager 上运行的附属服务。需要配置成 mapreduce_shuffle 后才可以在 Yarn 上运行 MapReduce 程序。--&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- 是否启用日志聚合 (可选) --&gt;</span><br><span class="line">        &lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- 聚合日志的保存时间 (可选) --&gt;</span><br><span class="line">        &lt;name&gt;yarn.log-aggregation.retain-seconds&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;86400&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- 启用 RM HA --&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.ha.enabled&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- RM 集群标识 --&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.cluster-id&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;my-yarn-cluster&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- RM 的逻辑 ID 列表 --&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.ha.rm-ids&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;rm1,rm2&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- RM1 的服务地址 --&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.hostname.rm1&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hadoop002&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- RM2 的服务地址 --&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.hostname.rm2&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hadoop003&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- RM1 Web 应用程序的地址 --&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.webapp.address.rm1&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hadoop002:8088&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- RM2 Web 应用程序的地址 --&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.webapp.address.rm2&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hadoop003:8088&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- ZooKeeper 集群的地址 --&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.zk-address&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hadoop001:2181,hadoop002:2181,hadoop003:2181&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- 启用自动恢复 --&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.recovery.enabled&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- 用于进行持久化存储的类 --&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.store.class&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;org.apache.hadoop.yarn.server.resourcemanager.recovery.ZKRMStateStore&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<h4 id="5-mapred-site-xml-2">5.  mapred-site.xml</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!--指定 mapreduce 作业运行在 yarn 上--&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<h4 id="5-slaves-2">5. slaves</h4>
<p>配置所有从属节点的主机名或 IP 地址，每行一个。所有从属节点上的 <code>DataNode</code> 服务和 <code>NodeManager</code> 服务都会被启动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hadoop001</span><br><span class="line">hadoop002</span><br><span class="line">hadoop003</span><br></pre></td></tr></table></figure>
<h3 id="4-4-分发程序">4.4 分发程序</h3>
<p>将 Hadoop 安装包分发到其他两台服务器，分发后建议在这两台服务器上也配置一下 Hadoop 的环境变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将安装包分发到hadoop002</span><br><span class="line">scp -r /usr/app/hadoop-2.6.0-cdh5.15.2/  hadoop002:/usr/app/</span><br><span class="line"># 将安装包分发到hadoop003</span><br><span class="line">scp -r /usr/app/hadoop-2.6.0-cdh5.15.2/  hadoop003:/usr/app/</span><br></pre></td></tr></table></figure>
<h2 id="五、启动集群">五、启动集群</h2>
<h3 id="5-1-启动ZooKeeper">5.1 启动ZooKeeper</h3>
<p>分别到三台服务器上启动 ZooKeeper 服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zkServer.sh start</span><br></pre></td></tr></table></figure>
<h3 id="5-2-启动Journalnode">5.2 启动Journalnode</h3>
<p>分别到三台服务器的的 <code>$&#123;HADOOP_HOME&#125;/sbin</code> 目录下，启动 <code>journalnode</code> 进程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hadoop-daemon.sh start journalnode</span><br></pre></td></tr></table></figure>
<h3 id="5-3-初始化NameNode">5.3 初始化NameNode</h3>
<p>在 <code>hadop001</code> 上执行 <code>NameNode</code> 初始化命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hdfs namenode -format</span><br></pre></td></tr></table></figure>
<p>执行初始化命令后，需要将 <code>NameNode</code> 元数据目录的内容，复制到其他未格式化的 <code>NameNode</code> 上。元数据存储目录就是我们在 <code>hdfs-site.xml</code> 中使用 <code>dfs.namenode.name.dir</code> 属性指定的目录。这里我们需要将其复制到 <code>hadoop002</code> 上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp -r /home/hadoop/namenode/data hadoop002:/home/hadoop/namenode/</span><br></pre></td></tr></table></figure>
<h3 id="5-4-初始化HA状态">5.4 初始化HA状态</h3>
<p>在任意一台 <code>NameNode</code> 上使用以下命令来初始化 ZooKeeper 中的 HA 状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hdfs zkfc -formatZK</span><br></pre></td></tr></table></figure>
<h3 id="5-5-启动HDFS">5.5 启动HDFS</h3>
<p>进入到 <code>hadoop001</code> 的 <code>$&#123;HADOOP_HOME&#125;/sbin</code> 目录下，启动 HDFS。此时 <code>hadoop001</code> 和 <code>hadoop002</code> 上的 <code>NameNode</code> 服务，和三台服务器上的 <code>DataNode</code> 服务都会被启动：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start-dfs.sh</span><br></pre></td></tr></table></figure>
<h3 id="5-6-启动YARN">5.6 启动YARN</h3>
<p>进入到 <code>hadoop002</code> 的 <code>$&#123;HADOOP_HOME&#125;/sbin</code> 目录下，启动 YARN。此时 <code>hadoop002</code> 上的 <code>ResourceManager</code> 服务，和三台服务器上的 <code>NodeManager</code> 服务都会被启动：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start-yarn.sh</span><br></pre></td></tr></table></figure>
<p>需要注意的是，这个时候 <code>hadoop003</code> 上的 <code>ResourceManager</code> 服务通常是没有启动的，需要手动启动：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn-daemon.sh start resourcemanager</span><br></pre></td></tr></table></figure>
<h2 id="六、查看集群">六、查看集群</h2>
<h3 id="6-1-查看进程">6.1 查看进程</h3>
<p>成功启动后，每台服务器上的进程应该如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@hadoop001 sbin]# jps</span><br><span class="line">4512 DFSZKFailoverController</span><br><span class="line">3714 JournalNode</span><br><span class="line">4114 NameNode</span><br><span class="line">3668 QuorumPeerMain</span><br><span class="line">5012 DataNode</span><br><span class="line">4639 NodeManager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@hadoop002 sbin]# jps</span><br><span class="line">4499 ResourceManager</span><br><span class="line">4595 NodeManager</span><br><span class="line">3465 QuorumPeerMain</span><br><span class="line">3705 NameNode</span><br><span class="line">3915 DFSZKFailoverController</span><br><span class="line">5211 DataNode</span><br><span class="line">3533 JournalNode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@hadoop003 sbin]# jps</span><br><span class="line">3491 JournalNode</span><br><span class="line">3942 NodeManager</span><br><span class="line">4102 ResourceManager</span><br><span class="line">4201 DataNode</span><br><span class="line">3435 QuorumPeerMain</span><br></pre></td></tr></table></figure>
<h3 id="6-2-查看Web-UI">6.2 查看Web UI</h3>
<p>HDFS 和 YARN 的端口号分别为 <code>50070</code> 和 <code>8080</code>，界面应该如下：</p>
<p>此时 hadoop001 上的 <code>NameNode</code> 处于可用状态：</p>
<p><img src="https://camo.githubusercontent.com/0dfee81cee0e0ea059224ad0a0df2b04b91339ef/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f6861646f6f70e9ab98e58fafe794a8e99b86e7bea4312e706e67" alt="img"></p>
<p>而 hadoop002 上的 <code>NameNode</code> 则处于备用状态：</p>
<p><img src="https://camo.githubusercontent.com/f0adb502fb1dc9f1b4d524b7ee954bb3e9ca04a2/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f6861646f6f70e9ab98e58fafe794a8e99b86e7bea4332e706e67" alt="img"></p>
<p>hadoop002 上的 <code>ResourceManager</code> 处于可用状态：</p>
<p><img src="https://camo.githubusercontent.com/afbb05472c97edf7c1f06b33c65f97a80171a1de/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f6861646f6f70e9ab98e58fafe794a8e99b86e7bea4342e706e67" alt="img"></p>
<p>hadoop003 上的 <code>ResourceManager</code> 则处于备用状态：</p>
<p><img src="https://camo.githubusercontent.com/dbed5c91d8834f4203f1ea9206767d3efc3b1491/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f6861646f6f70e9ab98e58fafe794a8e99b86e7bea4352e706e67" alt="img"></p>
<p>同时界面上也有 <code>Journal Manager</code> 的相关信息：</p>
<p><img src="https://camo.githubusercontent.com/00e35f7ac2eb2e8638bc6013be956ce728df2283/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f6861646f6f70e9ab98e58fafe794a8e99b86e7bea4322e706e67" alt="img"></p>
<p>## 七、集群的二次启动</p>
<p>上面的集群初次启动涉及到一些必要初始化操作，所以过程略显繁琐。但是集群一旦搭建好后，想要再次启用它是比较方便的，步骤如下（首选需要确保 ZooKeeper 集群已经启动）：</p>
<p>在 <code> hadoop001</code> 启动 HDFS，此时会启动所有与 HDFS 高可用相关的服务，包括 NameNode，DataNode 和 JournalNode：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start-dfs.sh</span><br></pre></td></tr></table></figure>
<p>在 <code>hadoop002</code> 启动 YARN：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start-yarn.sh</span><br></pre></td></tr></table></figure>
<p>这个时候 <code>hadoop003</code> 上的 <code>ResourceManager</code> 服务通常还是没有启动的，需要手动启动：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn-daemon.sh start resourcemanager</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大数据组件</category>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>拉链表</title>
    <url>/posts/2e5ad32b.html</url>
    <content><![CDATA[<!--markdown-->
<p>历史拉链表是一种数据模型，主要是针对数据仓库设计中表存储数据的方式而定义的。所谓历史拉链表，就是指记录一个事物从开始一直到当前状态的所有变化信息。拉所有记录链表可以避免按每一天存储造成的海量存储问题，同时也是处理缓慢变化数据的一种常见方式</p>
<h2 id="一、应用场景">一、应用场景</h2>
<p>现假设有如下场景：<br>
  一个企业拥有5000万会员信息，每天有20万会员资料变更，需要在数仓中记录会员表的历史变化以备分析使用，即每天都要保留一个快照供查询，反映历史数据的情况。在此场景中，需要反映5000万会员的历史变化，如果保留快照，存储两年就需要2X365X5000W条数据存储空间，数据量为365亿，如果存储更长时间，则无法估计需要的存储空间。而利用拉链算法存储，每日只向历史表中添加新增和变化的数据，每日不过20万条，存储4年也只需要3亿存储空间。</p>
<h2 id="二、实现步骤">二、实现步骤</h2>
<p>  在拉链表中，每一条数据都有一个生效日期(effective_date)和失效日期(expire_date)。假设在一个用户表中，在2019年11月8日新增了两个用户，如下表所示，则这两条记录的生效时间为当天，由于到2019年11月8日为止,这两条就还没有被修改过，所以失效时间为一个给定的比较大的值，比如：3000-12-31。</p>
<table>
<thead>
<tr>
<th style="text-align:center">member_id</th>
<th style="text-align:center">phoneno</th>
<th style="text-align:center">create_time</th>
<th style="text-align:center">update_time</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">10001</td>
<td style="text-align:center">13300000001</td>
<td style="text-align:center">2019-11-08</td>
<td style="text-align:center">3000-12-31</td>
</tr>
<tr>
<td style="text-align:center">10002</td>
<td style="text-align:center">13500000002</td>
<td style="text-align:center">2019-11-08</td>
<td style="text-align:center">3000-12-31</td>
</tr>
</tbody>
</table>
<p>  第二天(2019-11-09)，用户10001被删除了，用户10002的电话号码被修改成13600000002.为了保留历史状态，用户10001的失效时间被修改为2019-11-09，用户10002则变成了两条记录，如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">member_id</th>
<th style="text-align:center">phoneno</th>
<th style="text-align:center">create_time</th>
<th style="text-align:center">update_time</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">10001</td>
<td style="text-align:center">13300000001</td>
<td style="text-align:center">2019-11-08</td>
<td style="text-align:center">2019-11-09</td>
</tr>
<tr>
<td style="text-align:center">10002</td>
<td style="text-align:center">13500000002</td>
<td style="text-align:center">2019-11-08</td>
<td style="text-align:center">2019-11-09</td>
</tr>
<tr>
<td style="text-align:center">10002</td>
<td style="text-align:center">13600000002</td>
<td style="text-align:center">2019-11-09</td>
<td style="text-align:center">3000-12-31</td>
</tr>
</tbody>
</table>
<p>  第三天(2019-11-10),又新增了用户10003，则用户表数据如小表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">member_id</th>
<th style="text-align:center">phoneno</th>
<th style="text-align:center">create_time</th>
<th style="text-align:center">update_time</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">10001</td>
<td style="text-align:center">13300000001</td>
<td style="text-align:center">2019-11-08</td>
<td style="text-align:center">2019-11-09</td>
</tr>
<tr>
<td style="text-align:center">10002</td>
<td style="text-align:center">13500000002</td>
<td style="text-align:center">2019-11-08</td>
<td style="text-align:center">2019-11-09</td>
</tr>
<tr>
<td style="text-align:center">10002</td>
<td style="text-align:center">13600000002</td>
<td style="text-align:center">2019-11-09</td>
<td style="text-align:center">3000-12-31</td>
</tr>
<tr>
<td style="text-align:center">10003</td>
<td style="text-align:center">13600000006</td>
<td style="text-align:center">2019-11-10</td>
<td style="text-align:center">3000-12-31</td>
</tr>
</tbody>
</table>
<p>  如果要查询最新的数据，那么只要查询失效时间为3000-12-31的数据即可，如果要查11月8号的历史数据，则筛选生效时间&lt;= 2019-11-08并且失效时间&gt;2019-11-08的数据即可。如果查询11月9号的数据，那么筛选条件则是生效时间&lt;=2019-11-09并且失效时间&gt;2019-11-09.</p>
<h2 id="三、表结构">三、表结构</h2>
<p>MySQL源member表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">member</span>(</span><br><span class="line">             member_id <span class="type">VARCHAR</span> ( <span class="number">64</span> ),</span><br><span class="line">             phoneno <span class="type">VARCHAR</span> ( <span class="number">20</span> ),</span><br><span class="line">             create_time datetime,</span><br><span class="line">             update_time datetime );</span><br></pre></td></tr></table></figure>
<p>ODS层增量表member_delta,每天一个分区:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> member_delta(</span><br><span class="line">             member_id string,</span><br><span class="line">             phoneno string,</span><br><span class="line">             create_time string,</span><br><span class="line">             update_time string)</span><br><span class="line">PARTITIONED <span class="keyword">BY</span> (<span class="keyword">DAY</span> string);</span><br></pre></td></tr></table></figure>
<p>临时表:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> member_his_tmp(</span><br><span class="line">             member_id string,</span><br><span class="line">             phoneno string,</span><br><span class="line">             effective_date <span class="type">date</span>,</span><br><span class="line">             expire_date <span class="type">date</span></span><br><span class="line">             );</span><br></pre></td></tr></table></figure>
<p>DW层历史拉链表:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> member_his(</span><br><span class="line">             member_id string,</span><br><span class="line">             phoneno string,</span><br><span class="line">             effective_date <span class="type">date</span>,</span><br><span class="line">             expire_date <span class="type">date</span>);</span><br></pre></td></tr></table></figure>
<h2 id="四、Demo数据准备">四、Demo数据准备</h2>
<p>2019-11-08的数据为：</p>
<table><tbody><tr><td>member_id</td><td>phoneno</td><td>create_time</td><td>update_time</td></tr><tr><td>10001</td><td>13500000001</td><td>2019-11-08 14:47:55</td><td>2019-11-08 14:47:55</td></tr><tr><td>10002</td><td>13500000002</td><td>2019-11-08 14:48:33</td><td>2019-11-08 14:48:33</td></tr><tr><td>10003</td><td>13500000003</td><td>2019-11-08 14:48:53</td><td>2019-11-08 14:48:53</td></tr><tr><td>10004</td><td>13500000004</td><td>2019-11-08 14:49:02</td><td>2019-11-08 14:49:02</td></tr></tbody></table>
<p>2019-11-09的数据为：其中蓝色代表新增数据，红色代表修改的数据：</p>
<table><tbody><tr><td>member_id</td><td>phoneno</td><td>create_time</td><td>update_time</td></tr><tr><td>10001</td><td>13500000001</td><td>2019-11-08 14:47:55</td><td>2019-11-08 14:47:55</td></tr><tr><td bgcolor="#DC143C">10002</td><td bgcolor="#DC143C">13600000002</td><td bgcolor="#DC143C">2019-11-08 14:48:33</td><td bgcolor="#DC143C">2019-11-09 14:48:33</td></tr><tr><td>10003</td><td>13500000003</td><td>2019-11-08 14:48:53</td><td>2019-11-08 14:48:53</td></tr><tr><td>10004</td><td>13500000004</td><td>2019-11-08 14:49:02</td><td>2019-11-08 14:49:02</td></tr><tr><td bgcolor="#6495ED">10005</td><td bgcolor="#6495ED">13500000005</td><td bgcolor="#6495ED">2019-11-09 08:54:03</td><td bgcolor="#6495ED">2019-11-09 08:54:03</td></tr><tr><td bgcolor="#6495ED">10006</td><td bgcolor="#6495ED">13500000006</td><td bgcolor="#6495ED">2019-11-09 09:54:25</td><td bgcolor="#6495ED">2019-11-09 09:54:25</td></tr></tbody></table>
<p>2019-11-10的数据：其中蓝色代表新增数据，红色代表修改的数据：</p>
<table><tbody><tr><td>member_id</td><td>phoneno</td><td>create_time</td><td>update_time</td></tr><tr><td>10001</td><td>13500000001</td><td>2019-11-08 14:47:55</td><td>2019-11-08 14:47:55</td></tr><tr><td>10002</td><td>13600000002</td><td>2019-11-08 14:48:33</td><td>2019-11-09 14:48:33</td></tr><tr><td>10003</td><td>13500000003</td><td>2019-11-08 14:48:53</td><td>2019-11-08 14:48:53</td></tr><tr><td bgcolor="#DC143C">10004</td><td bgcolor="#DC143C">13600000004</td><td bgcolor="#DC143C">2019-11-08 14:49:02</td><td bgcolor="#DC143C">2019-11-10 14:49:02</td></tr><tr><td>10005</td><td>13500000005</td><td>2019-11-09 08:54:03</td><td>2019-11-09 08:54:03</td></tr><tr><td>10006</td><td>13500000006</td><td>2019-11-09 09:54:25</td><td>2019-11-09 09:54:25</td></tr><tr><td bgcolor="#6495ED">10007</td><td bgcolor="#6495ED">13500000007</td><td bgcolor="#6495ED">2019-11-10 17:41:49</td><td bgcolor="#6495ED">2019-11-10 17:41:49</td></tr></tbody></table>
<h2 id="五、全量初始装载">五、全量初始装载</h2>
<p>在启用拉链表时，先对其进行初始装载，比如以2019-11-08为开始时间，那么将MySQL源表全量抽取到ODS层member_delta表的2018-11-08的分区中，然后初始装载DW层的拉链表member_his。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> overwrite <span class="keyword">TABLE</span> member_his </span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">   member_id,</span><br><span class="line">   phoneno,</span><br><span class="line">   to_date ( create_time ) <span class="keyword">AS</span> effective_date,</span><br><span class="line">  <span class="string">&#x27;3000-12-31&#x27;</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	member_delta </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	<span class="keyword">DAY</span> <span class="operator">=</span> <span class="string">&#x27;2019-11-08&#x27;</span></span><br></pre></td></tr></table></figure>
<p>查询初始的历史拉链表数据:<br>
<img src="https://img-blog.csdnimg.cn/img_convert/b7b2455db73f3992a2dd519d052be2ec.png" alt=""></p>
<h2 id="六、增量抽取数据">六、增量抽取数据</h2>
<p>  每天，从源系统member表中，将前一天的增量数据抽取到ODS层的增量数据表member_delta对应的分区中。这里的增量需要通过member表中的创建时间和修改时间来确定，或者使用sqoop job监控update时间来进行增联抽取。比如，本案例中2019-11-09和2019-11-10为两个分区，分别存储了2019-11-09和2019-11-10日的增量数据。<br>
2019-11-09分区的数据为:<br>
<img src="https://img-blog.csdnimg.cn/img_convert/bf52c4d3d45507868059227dff275a86.png" alt=""></p>
<p>2019-11-10分区的数据为：<br>
<img src="https://img-blog.csdnimg.cn/img_convert/ccb1deaca665346cff84cbf1c8e694af.png" alt=""></p>
<h2 id="七、增量刷新历史拉链数据">七、增量刷新历史拉链数据</h2>
<h3 id="2019-11-09增量刷新历史拉链表：">2019-11-09增量刷新历史拉链表：</h3>
<h4 id="将数据放进临时表：">将数据放进临时表：</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> overwrite <span class="keyword">TABLE</span> member_his_tmp</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  (</span><br><span class="line"><span class="comment">-- 2019-11-09增量数据，代表最新的状态，该数据的生效时间是2019-11-09，过期时间为3000-12-31</span></span><br><span class="line"><span class="comment">-- 这些增量的数据需要被全部加载到历史拉链表中</span></span><br><span class="line"><span class="keyword">SELECT</span> member_id,</span><br><span class="line">       phoneno,</span><br><span class="line">       <span class="string">&#x27;2019-11-09&#x27;</span> effective_date,</span><br><span class="line">                    <span class="string">&#x27;3000-12-31&#x27;</span> expire_date</span><br><span class="line">   <span class="keyword">FROM</span> member_delta</span><br><span class="line">   <span class="keyword">WHERE</span> <span class="keyword">DAY</span><span class="operator">=</span><span class="string">&#x27;2019-11-09&#x27;</span></span><br><span class="line">   <span class="keyword">UNION</span> <span class="keyword">ALL</span> </span><br><span class="line"><span class="comment">-- 用当前为生效状态的拉链数据，去left join 增量数据，</span></span><br><span class="line"><span class="comment">-- 如果匹配得上，则表示该数据已发生了更新，</span></span><br><span class="line"><span class="comment">-- 此时，需要将发生更新的数据的过期时间更改为当前时间.</span></span><br><span class="line"><span class="comment">-- 如果匹配不上，则表明该数据没有发生更新，此时过期时间不变</span></span><br><span class="line"><span class="keyword">SELECT</span> a.member_id,</span><br><span class="line">       a.phoneno,</span><br><span class="line">       a.effective_date,</span><br><span class="line">       if(b.member_id <span class="keyword">IS</span> <span class="keyword">NULL</span>, to_date(a.expire_date), to_date(b.day)) expire_date</span><br><span class="line">   <span class="keyword">FROM</span></span><br><span class="line">     (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">      <span class="keyword">FROM</span> member_his</span><br><span class="line">    ) a</span><br><span class="line">   <span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">     (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">      <span class="keyword">FROM</span> member_delta</span><br><span class="line">      <span class="keyword">WHERE</span> <span class="keyword">DAY</span><span class="operator">=</span><span class="string">&#x27;2019-11-09&#x27;</span>) b <span class="keyword">ON</span> a.member_id<span class="operator">=</span>b.member_id)his</span><br></pre></td></tr></table></figure>
<h4 id="将数据覆盖到历史拉链表">将数据覆盖到历史拉链表:</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> overwrite <span class="keyword">TABLE</span> member_his</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> member_his_tmp</span><br></pre></td></tr></table></figure>
<h4 id="查看历史拉链表">查看历史拉链表:</h4>
<p><img src="https://img-blog.csdnimg.cn/img_convert/cbd380e301b1096d4c404c102cd79854.png" alt=""></p>
<h3 id="2019-11-10增量刷新历史拉链表">2019-11-10增量刷新历史拉链表</h3>
<h4 id="将数据放进临时表">将数据放进临时表</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> overwrite <span class="keyword">TABLE</span> member_his_tmp</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  (</span><br><span class="line"><span class="comment">-- 2019-11-10增量数据，代表最新的状态，该数据的生效时间是2019-11-10，过期时间为3000-12-31</span></span><br><span class="line"><span class="comment">-- 这些增量的数据需要被全部加载到历史拉链表中</span></span><br><span class="line"><span class="keyword">SELECT</span> member_id,</span><br><span class="line">       phoneno,</span><br><span class="line">       <span class="string">&#x27;2019-11-10&#x27;</span> effective_date,</span><br><span class="line">                    <span class="string">&#x27;3000-12-31&#x27;</span> expire_date</span><br><span class="line">   <span class="keyword">FROM</span> member_delta</span><br><span class="line">   <span class="keyword">WHERE</span> <span class="keyword">DAY</span><span class="operator">=</span><span class="string">&#x27;2019-11-10&#x27;</span></span><br><span class="line">   <span class="keyword">UNION</span> <span class="keyword">ALL</span> </span><br><span class="line"><span class="comment">-- 用当前为生效状态的拉链数据，去left join 增量数据，</span></span><br><span class="line"><span class="comment">-- 如果匹配得上，则表示该数据已发生了更新，</span></span><br><span class="line"><span class="comment">-- 此时，需要将发生更新的数据的过期时间更改为当前时间.</span></span><br><span class="line"><span class="comment">-- 如果匹配不上，则表明该数据没有发生更新，此时过期时间不变</span></span><br><span class="line"><span class="keyword">SELECT</span> a.member_id,</span><br><span class="line">       a.phoneno,</span><br><span class="line">       a.effective_date,</span><br><span class="line">       if(b.member_id <span class="keyword">IS</span> <span class="keyword">NULL</span>, to_date(a.expire_date), to_date(b.day)) expire_date</span><br><span class="line">   <span class="keyword">FROM</span></span><br><span class="line">     (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">      <span class="keyword">FROM</span> member_his</span><br><span class="line">    ) a</span><br><span class="line">   <span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">     (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">      <span class="keyword">FROM</span> member_delta</span><br><span class="line">      <span class="keyword">WHERE</span> <span class="keyword">DAY</span><span class="operator">=</span><span class="string">&#x27;2019-11-10&#x27;</span>) b <span class="keyword">ON</span> a.member_id<span class="operator">=</span>b.member_id)his</span><br></pre></td></tr></table></figure>
<h4 id="查看历史拉链表-2">查看历史拉链表:</h4>
<p><img src="https://pic.downk.cc/item/5ff6ab7d3ffa7d37b311909b.png" alt=""></p>
<h4 id="将以上脚本封装成shell调度的脚本">将以上脚本封装成shell调度的脚本:</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">如果是输入的日期按照取输入日期；如果没输入日期取当前时间的前一天</span></span><br><span class="line">if [ -n &quot;$1&quot; ] ;then</span><br><span class="line">	do_date=$1</span><br><span class="line">else </span><br><span class="line">	do_date=`date -d &quot;-1 day&quot; +%F`  </span><br><span class="line">fi </span><br><span class="line"></span><br><span class="line">sql=&quot;</span><br><span class="line"></span><br><span class="line">INSERT overwrite TABLE member_his_tmp</span><br><span class="line">SELECT *</span><br><span class="line">FROM</span><br><span class="line">  (</span><br><span class="line">-- 2019-11-10增量数据，代表最新的状态，该数据的生效时间是2019-11-10，过期时间为3000-12-31</span><br><span class="line">-- 这些增量的数据需要被全部加载到历史拉链表中</span><br><span class="line">SELECT member_id,</span><br><span class="line">       phoneno,</span><br><span class="line">       &#x27;$do_date&#x27; effective_date,</span><br><span class="line">       &#x27;3000-12-31&#x27; expire_date</span><br><span class="line">   FROM member_delta</span><br><span class="line">   WHERE DAY=&#x27;$do_date&#x27;</span><br><span class="line">   UNION ALL </span><br><span class="line">-- 用当前为生效状态的拉链数据，去left join 增量数据，</span><br><span class="line">-- 如果匹配得上，则表示该数据已发生了更新，</span><br><span class="line">-- 此时，需要将发生更新的数据的过期时间更改为当前时间.</span><br><span class="line">-- 如果匹配不上，则表明该数据没有发生更新，此时过期时间不变</span><br><span class="line">SELECT a.member_id,</span><br><span class="line">       a.phoneno,</span><br><span class="line">       a.effective_date,</span><br><span class="line">       if(b.member_id IS NULL, to_date(a.expire_date), to_date(b.day)) expire_date</span><br><span class="line">   FROM</span><br><span class="line">     (SELECT *</span><br><span class="line">      FROM member_his</span><br><span class="line"> ) a</span><br><span class="line">   LEFT JOIN</span><br><span class="line">     (SELECT *</span><br><span class="line">      FROM member_delta</span><br><span class="line">      WHERE DAY=&#x27;$do_date&#x27;) b ON a.member_id=b.member_id)his;</span><br><span class="line">&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">hive -e <span class="string">&quot;<span class="variable">$sql</span>&quot;</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>初识kudu</title>
    <url>/posts/220952e4.html</url>
    <content><![CDATA[<h2 id="1-1、kudu是什么">1.1、kudu是什么</h2>
<p>简单来说:dudu是一个与hbase类似的列式存储分布式数据库。官方给kudu的定位是:在更新更及时的基础上实现更快的数据分析</p>
<h2 id="1-2、为什么需要kudu">1.2、为什么需要kudu</h2>
<h3 id="1-2-1、hdfs与hbase数据存储的缺点">1.2.1、hdfs与hbase数据存储的缺点</h3>
<p>目前数据存储有了HDFS与hbase，为什么还要额外的弄一个kudu呢。<br>
HDFS:使用列式存储格式Apache Parquet，Apache ORC，适合离线分析，不支持单条纪录级别的update操作，随机读写性能差。<br>
HBASE:可以进行高效随机读写，却并不适用于基于SQL的数据分析方向，大批量数据获取时的性能较差。正因为HDFS与HBASE有上面这些缺点，KUDU较好的解决了HDFS与HBASE的这些缺点，它不及HDFS批处理快，也不及HBase随机读写能力强，但是反过来它比HBase批处理快（适用于OLAP的分析场景），而且比HDFS随机读写能力强（适用于实时写入或者更新的场景），这就是它能解决的问题。</p>
<h1>2、架构介绍</h1>
<h2 id="2-1、基本架构">2.1、基本架构</h2>
<img src="https://img-blog.csdnimg.cn/20190422091319780.png" referrerpolicy="no-referrer">
<h2 id="2-1-1、概念">2.1.1、概念</h2>
<p> Table（表）：一张table是数据存储在kudu的位置。Table具有schema和全局有序的primary key(主键)。Table被分为很多段，也就是tablets.<br>
 Tablet (段)：一个tablet是一张table连续的segment，与其他数据存储引擎或关系型数据的partition相似。Tablet存在副本机制，其中一个副本为leader tablet。任何副本都可以对读取进行服务，并且写入时需要在所有副本对应的tablet server之间达成一致性。<br>
 Tablet server：存储tablet和为tablet向client提供服务。对于给定的tablet，一个tablet server充当leader，其他tablet server充当该tablet的follower副本。只有leader服务写请求，leader与follower为每个服务提供读请求。<br>
 Master：主要用来管理元数据(元数据存储在只有一个tablet的catalog table中)，即tablet与表的基本信息，监听tserver的状态<br>
 Catalog Table: 元数据表，用来存储table(schema、locations、states)与tablet（现有的tablet列表，每个tablet及其副本所处tserver，tablet当前状态以及开始和结束键）的信息。</p>
<h1>3、存储机制</h1>
<h2 id="3-1-存储结构全景图">3.1 存储结构全景图</h2>
<img src="https://img-blog.csdnimg.cn/20190422091359222.png" referrerpolicy="no-referrer">
<h2 id="3-2-存储结构解析">3.2 存储结构解析</h2>
<p> 一个Table包含多个Tablet，其中Tablet的数量是根据hash或者range进行设置<br>
 一个Tablet中包含MetaData信息和多个RowSet信息<br>
 一个Rowset中包含一个MemRowSet与0个或多个DiskRowset，其中MemRowSet存储insert的数据，一旦MemRowSet写满会flush到磁盘生成一个或多个DiskRowSet，此时MemRowSet清空。MemRowSet默认写满1G或者120s flush一次<br>
(注意:memRowSet是行式存储，DiskRowSet是列式存储，MemRowSet基于primary key有序)。每隔tablet中会定期对一些diskrowset做compaction操作，目的是对多个diskRowSet进行重新排序，以此来使其更有序并减少diskRowSet的数量，同时在compaction的过程中慧慧resolve掉deltaStores当中的delete记录<br>
 一个DiskRowSet包含baseData与DeltaStores两部分，其中baseData存储的数据看起来不可改变，DeltaStores中存储的是改变的数据<br>
 DeltaStores包含一个DeltaMemStores和多个DeltaFile,其中DeltaMemStores放在内存，用来存储update与delete数据，一旦DeltaMemStores写满，会flush成DeltaFile。当DeltaFile过多会影响查询性能，所以KUDU每隔一段时间会执行compaction操作，将其合并到baseData中，主要是resolve掉update数据。</p>
<h1>4、kudu的工作机制</h1>
<h2 id="4-1-概述">4.1 概述</h2>
<p>1、kudu主要角色分为master与tserver<br>
2、master主要负责:管理元数据信息，监听server，当server宕机后负责tablet的重分配<br>
3、tserver主要负责tablet的存储与和数据的增删改查</p>
<h2 id="4-2-内部实现原理图">4.2 内部实现原理图</h2>
<h2 id="img-src-https-img-blog-csdnimg-cn-20190422091414844-png-referrerpolicy-no-referrer"><img src="https://img-blog.csdnimg.cn/20190422091414844.png" referrerpolicy="no-referrer"></h2>
<h2 id="4-3-读流程">4.3 读流程</h2>
<h3 id="4-3-1-概述">4.3.1 概述</h3>
<p>客户端将要读取的数据信息发送给master，master对其进行一定的校验，比如表是否存在，字段是否存在。Master返回元数据信息给client，然后client与tserver建立连接，通过metaData找到数据所在的RowSet，首先加载内存里面的数据(MemRowSet与DeltMemStore),然后加载磁盘里面的数据，最后返回最终数据给client.</p>
<h3 id="4-3-2-详细步骤图">4.3.2 详细步骤图</h3>
 <img src="https://img-blog.csdnimg.cn/20190422091428943.png" referrerpolicy="no-referrer">
<h3 id="4-3-3-详细步骤解析">4.3.3 详细步骤解析</h3>
<p>1、客户端master请求查询表指定数据<br>
2、master对请求进行校验，校验表是否存在，schema中是否存在指定查询的字段，主键是否存在<br>
3、master通过查询catalog Table返回表，将tablet对应的tserver信息、tserver状态等元数据信息返回给client<br>
4、client与tserver建立连接，通过metaData找到primary key对应的RowSet。<br>
5、首先加载RowSet内存中MemRowSet与DeltMemStore中的数据<br>
6、然后加载磁盘中的数据，也就是DiskRowSet中的BaseData与DeltFile中的数据<br>
7、返回数据给Client<br>
8、继续4-7步骤，直到拿到所有数据返回给client</p>
<h2 id="4-4、插入流程">4.4、插入流程</h2>
<h3 id="4-4-1-概述">4.4.1 概述</h3>
<p>Client首先连接master，获取元数据信息。然后连接tserver，查找MemRowSet与DeltMemStore中是否存在相同primary key，如果存在，则报错;如果不存在，则将待插入的数据写入WAL日志，然后将数据写入MemRowSet。</p>
<h3 id="4-4-2-详细步骤图">4.4.2 详细步骤图</h3>
<img src="https://img-blog.csdnimg.cn/20190422091442719.png" referrerpolicy="no-referrer"> 
<h3 id="4-4-3-详细步骤解析">4.4.3 详细步骤解析</h3>
<p>1、client向master请求预写表的元数据信息<br>
2、master会进行一定的校验，表是否存在，字段是否存在等<br>
3、如果master校验通过，则返回表的分区、tablet与其对应的tserver给client；如果校验失败则报错给client。<br>
4、client根据master返回的元数据信息，将请求发送给tablet对应的tserver.<br>
5、tserver首先会查询内存中MemRowSet与DeltMemStore中是否存在与待插入数据主键相同的数据，如果存在则报错<br>
6、tserver会讲写请求预写到WAL日志，用来server宕机后的恢复操作<br>
7、将数据写入内存中的MemRowSet中，一旦MemRowSet的大小达到1G或120s后，MemRowSet会flush成一个或DiskRowSet,用来将数据持久化<br>
8、返回client数据处理完毕</p>
<h2 id="4-5、数据更新流程">4.5、数据更新流程</h2>
<h3 id="4-5-1-概述">4.5.1 概述</h3>
<p>Client首先向master请求元数据，然后根据元数据提供的tablet信息，连接tserver，根据数据所处位置的不同，有不同的操作:在内存MemRowSet中的数据，会将更新信息写入数据所在行的mutation链表中；在磁盘中的数据，会将更新信息写入DeltMemStore中。</p>
<h3 id="4-5-2、详细步骤图">4.5.2、详细步骤图</h3>
 <img src="https://img-blog.csdnimg.cn/20190422091450166.png" referrerpolicy="no-referrer">
<h3 id="4-5-3-详细步骤解析">4.5.3 详细步骤解析</h3>
<p>1、client向master请求预更新表的元数据，首先master会校验表是否存在，字段是否存在，如果校验通过则会返回给client表的分区、tablet、tablet所在tserver信息<br>
2、client向tserver发起更新请求<br>
3、将更新操作预写如WAL日志，用来在server宕机后的数据恢复<br>
4、根据tserver中待更新的数据所处位置的不同，有不同的处理方式:<br>
如果数据在内存中，则从MemRowSet中找到数据所处的行，然后在改行的mutation链表中写入更新信息，在MemRowSet flush的时候，将更新合并到baseData中如果数据在DiskRowSet中，则将更新信息写入DeltMemStore中，DeltMemStore达到一定大小后会flush成DeltFile。<br>
5、更新完毕后返回消息给client。</p>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>kudu</category>
      </categories>
      <tags>
        <tag>kudu</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建Kafka高可用集群</title>
    <url>/posts/20c2960d.html</url>
    <content><![CDATA[<h2 id="一、Zookeeper集群搭建">一、Zookeeper集群搭建</h2>
<p>为保证集群高可用，Zookeeper 集群的节点数最好是奇数，最少有三个节点，所以这里搭建一个三个节点的集群。</p>
<h3 id="1-1-下载-解压">1.1 下载 &amp; 解压</h3>
<p>下载对应版本 Zookeeper，这里我下载的版本 <code>3.4.14</code>。官方下载地址：<a href="https://archive.apache.org/dist/zookeeper/">https://archive.apache.org/dist/zookeeper/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">下载</span></span><br><span class="line">wget https://archive.apache.org/dist/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz</span><br><span class="line"><span class="meta"># </span><span class="language-bash">解压</span></span><br><span class="line">tar -zxvf zookeeper-3.4.14.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="1-2-修改配置">1.2 修改配置</h3>
<p>拷贝三份 zookeeper 安装包。分别进入安装目录的 <code>conf</code> 目录，拷贝配置样本 <code>zoo_sample.cfg </code> 为 <code>zoo.cfg</code> 并进行修改，修改后三份配置文件内容分别如下：</p>
<p>zookeeper01 配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line">initLimit=10</span><br><span class="line">syncLimit=5</span><br><span class="line">dataDir=/usr/local/zookeeper-cluster/data/01</span><br><span class="line">dataLogDir=/usr/local/zookeeper-cluster/log/01</span><br><span class="line">clientPort=2181</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">server.1 这个1是服务器的标识，可以是任意有效数字，标识这是第几个服务器节点，这个标识要写到dataDir目录下面myid文件里</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">指名集群间通讯端口和选举端口</span></span><br><span class="line">server.1=127.0.0.1:2287:3387</span><br><span class="line">server.2=127.0.0.1:2288:3388</span><br><span class="line">server.3=127.0.0.1:2289:3389</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果是多台服务器，则集群中每个节点通讯端口和选举端口可相同，IP 地址修改为每个节点所在主机 IP 即可。</p>
</blockquote>
<p>zookeeper02 配置，与 zookeeper01 相比，只有 <code>dataLogDir</code>、<code>dataLogDir</code> 和 <code>clientPort</code> 不同：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line">initLimit=10</span><br><span class="line">syncLimit=5</span><br><span class="line">dataDir=/usr/local/zookeeper-cluster/data/02</span><br><span class="line">dataLogDir=/usr/local/zookeeper-cluster/log/02</span><br><span class="line">clientPort=2182</span><br><span class="line"></span><br><span class="line">server.1=127.0.0.1:2287:3387</span><br><span class="line">server.2=127.0.0.1:2288:3388</span><br><span class="line">server.3=127.0.0.1:2289:3389</span><br></pre></td></tr></table></figure>
<p>zookeeper03 配置，与 zookeeper01，02 相比，也只有 <code>dataLogDir</code>、<code>dataLogDir</code> 和 <code>clientPort</code> 不同：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line">initLimit=10</span><br><span class="line">syncLimit=5</span><br><span class="line">dataDir=/usr/local/zookeeper-cluster/data/03</span><br><span class="line">dataLogDir=/usr/local/zookeeper-cluster/log/03</span><br><span class="line">clientPort=2183</span><br><span class="line"></span><br><span class="line">server.1=127.0.0.1:2287:3387</span><br><span class="line">server.2=127.0.0.1:2288:3388</span><br><span class="line">server.3=127.0.0.1:2289:3389</span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置参数说明：</p>
<ul class="lvl-1">
<li class="lvl-2"><strong>tickTime</strong>：用于计算的基础时间单元。比如 session 超时：N*tickTime；</li>
<li class="lvl-2"><strong>initLimit</strong>：用于集群，允许从节点连接并同步到 master 节点的初始化连接时间，以 tickTime 的倍数来表示；</li>
<li class="lvl-2"><strong>syncLimit</strong>：用于集群， master 主节点与从节点之间发送消息，请求和应答时间长度（心跳机制）；</li>
<li class="lvl-2"><strong>dataDir</strong>：数据存储位置；</li>
<li class="lvl-2"><strong>dataLogDir</strong>：日志目录；</li>
<li class="lvl-2"><strong>clientPort</strong>：用于客户端连接的端口，默认 2181</li>
</ul>
</blockquote>
<h3 id="1-3-标识节点">1.3 标识节点</h3>
<p>分别在三个节点的数据存储目录下新建 <code>myid</code> 文件,并写入对应的节点标识。Zookeeper 集群通过 <code>myid</code> 文件识别集群节点，并通过上文配置的节点通信端口和选举端口来进行节点通信，选举出 leader 节点。</p>
<p>创建存储目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">dataDir</span></span><br><span class="line">mkdir -vp  /usr/local/zookeeper-cluster/data/01</span><br><span class="line"><span class="meta"># </span><span class="language-bash">dataDir</span></span><br><span class="line">mkdir -vp  /usr/local/zookeeper-cluster/data/02</span><br><span class="line"><span class="meta"># </span><span class="language-bash">dataDir</span></span><br><span class="line">mkdir -vp  /usr/local/zookeeper-cluster/data/03</span><br></pre></td></tr></table></figure>
<p>创建并写入节点标识到 <code>myid</code> 文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">server1</span></span><br><span class="line">echo &quot;1&quot; &gt; /usr/local/zookeeper-cluster/data/01/myid</span><br><span class="line"><span class="meta">#</span><span class="language-bash">server2</span></span><br><span class="line">echo &quot;2&quot; &gt; /usr/local/zookeeper-cluster/data/02/myid</span><br><span class="line"><span class="meta">#</span><span class="language-bash">server3</span></span><br><span class="line">echo &quot;3&quot; &gt; /usr/local/zookeeper-cluster/data/03/myid</span><br></pre></td></tr></table></figure>
<h3 id="1-4-启动集群">1.4 启动集群</h3>
<p>分别启动三个节点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">启动节点1</span></span><br><span class="line">/usr/app/zookeeper-cluster/zookeeper01/bin/zkServer.sh start</span><br><span class="line"><span class="meta"># </span><span class="language-bash">启动节点2</span></span><br><span class="line">/usr/app/zookeeper-cluster/zookeeper02/bin/zkServer.sh start</span><br><span class="line"><span class="meta"># </span><span class="language-bash">启动节点3</span></span><br><span class="line">/usr/app/zookeeper-cluster/zookeeper03/bin/zkServer.sh start</span><br></pre></td></tr></table></figure>
<h3 id="1-5-集群验证">1.5 集群验证</h3>
<p>使用 jps 查看进程，并且使用 <code>zkServer.sh status</code> 查看集群各个节点状态。如图三个节点进程均启动成功，并且两个节点为 follower 节点，一个节点为 leader 节点。</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/zookeeper-cluster.png"/> </div>
<h2 id="二、Kafka集群搭建">二、Kafka集群搭建</h2>
<h3 id="2-1-下载解压">2.1 下载解压</h3>
<p>Kafka 安装包官方下载地址：<a href="http://kafka.apache.org/downloads">http://kafka.apache.org/downloads</a> ，本用例下载的版本为 <code>2.2.0</code>，下载命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">下载</span></span><br><span class="line">wget https://www-eu.apache.org/dist/kafka/2.2.0/kafka_2.12-2.2.0.tgz</span><br><span class="line"><span class="meta"># </span><span class="language-bash">解压</span></span><br><span class="line">tar -xzf kafka_2.12-2.2.0.tgz</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里 j 解释一下 kafka 安装包的命名规则：以 <code>kafka_2.12-2.2.0.tgz</code> 为例，前面的 2.12 代表 Scala 的版本号（Kafka 采用 Scala 语言进行开发），后面的 2.2.0 则代表 Kafka 的版本号。</p>
</blockquote>
<h3 id="2-2-拷贝配置文件">2.2 拷贝配置文件</h3>
<p>进入解压目录的 <code> config</code> 目录下 ，拷贝三份配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">cp</span> server.properties server-1.properties</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">cp</span> server.properties server-2.properties</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">cp</span> server.properties server-3.properties</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-修改配置">2.3 修改配置</h3>
<p>分别修改三份配置文件中的部分配置，如下：</p>
<p>server-1.properties：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The id of the broker. 集群中每个节点的唯一标识</span></span><br><span class="line"><span class="attr">broker.id</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"># 监听地址</span></span><br><span class="line"><span class="attr">listeners</span>=<span class="string">PLAINTEXT://hadoop001:9092</span></span><br><span class="line"><span class="comment"># 数据的存储位置</span></span><br><span class="line"><span class="attr">log.dirs</span>=<span class="string">/usr/local/kafka-logs/00</span></span><br><span class="line"><span class="comment"># Zookeeper连接地址</span></span><br><span class="line"><span class="attr">zookeeper.connect</span>=<span class="string">hadoop001:2181,hadoop001:2182,hadoop001:2183</span></span><br></pre></td></tr></table></figure>
<p>server-2.properties：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">broker.id</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">listeners</span>=<span class="string">PLAINTEXT://hadoop001:9093</span></span><br><span class="line"><span class="attr">log.dirs</span>=<span class="string">/usr/local/kafka-logs/01</span></span><br><span class="line"><span class="attr">zookeeper.connect</span>=<span class="string">hadoop001:2181,hadoop001:2182,hadoop001:2183</span></span><br></pre></td></tr></table></figure>
<p>server-3.properties：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">broker.id</span>=<span class="string">2</span></span><br><span class="line"><span class="attr">listeners</span>=<span class="string">PLAINTEXT://hadoop001:9094</span></span><br><span class="line"><span class="attr">log.dirs</span>=<span class="string">/usr/local/kafka-logs/02</span></span><br><span class="line"><span class="attr">zookeeper.connect</span>=<span class="string">hadoop001:2181,hadoop001:2182,hadoop001:2183</span></span><br></pre></td></tr></table></figure>
<p>这里需要说明的是 <code>log.dirs</code> 指的是数据日志的存储位置，确切的说，就是分区数据的存储位置，而不是程序运行日志的位置。程序运行日志的位置是通过同一目录下的 <code>log4j.properties</code> 进行配置的。</p>
<h3 id="2-4-启动集群">2.4 启动集群</h3>
<p>分别指定不同配置文件，启动三个 Kafka 节点。启动后可以使用 jps 查看进程，此时应该有三个 zookeeper 进程和三个 kafka 进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-server-start.sh config/server-1.properties</span><br><span class="line">bin/kafka-server-start.sh config/server-2.properties</span><br><span class="line">bin/kafka-server-start.sh config/server-3.properties</span><br></pre></td></tr></table></figure>
<h3 id="2-5-创建测试主题">2.5 创建测试主题</h3>
<p>创建测试主题：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --bootstrap-server hadoop001:9092 \</span><br><span class="line">					--replication-factor 3 \</span><br><span class="line">					--partitions 1 --topic my-replicated-topic</span><br></pre></td></tr></table></figure>
<p>创建后可以使用以下命令查看创建的主题信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --describe --bootstrap-server hadoop001:9092 --topic my-replicated-topic</span><br></pre></td></tr></table></figure>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka-cluster-shell.png"/> </div>
<p>可以看到分区 0 的有 0,1,2 三个副本，且三个副本都是可用副本，都在 ISR(in-sync Replica 同步副本) 列表中，其中 1 为首领副本，此时代表集群已经搭建成功。</p>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>canal 基础入门(基于1.1.4)</title>
    <url>/posts/249c59e6.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="27b5fcb1739495f52fc766fd51b50417359da9db0b0f640b85652e41763eaa75">a8cefacc35a4b9cc130a23421f1e88bcd3da19bc85c03fe1ed0e9e63bbb759353c16dbc78f2aef8cc1d17774c43cfdafd82c229b72143c11fd6134bd3c1ecabcc3dfbbbba1b1b226f372f12094b387b3b7b78ac12a9c893a10da4dd077db42b8a9833ec73d59624f6d36730c080ff2b40442804e3f83b7607dc86e35862665fad9d3874f3eb174bb2cfd17a00a42ab6dbee3208a026140b55cbd2f356674adfab174028cd4710249bdbfcbc52c8b6def79f4f4a80906e4e7b1602d7eb3f64da57bc61b62e4c3f78604f4a80bfe34a053873e85b406124d006fcd0e426391d6ad313c4529595f8a7b0f529e0528fd1891b9a3689e073a0a27111066aa4877e136fab7df74b6d365b9bfff7fd28e8092cd368750a579e2a7f30cc8e3779adf1fd2e6888bfa2baf03ff1e69b0aa7b340d809eaf603db86760a0a145a6cf8e0dcc295935933456dce67a158c30b1aca409ad6a738727293ec06a4909892d5c807d70223a154b76ae42b73a87dfd34f7c4121fd398cb06a8f8fc1f1a6e0692b3fe9409f1f833269cee20b9a774a62a1aa0b3539d62967d385f452428f716d573d11a9f9d4a2b7204a1bbf8935c75fe2d122ea1ff8477efc1670b1fca48fd27c56529b3fa15ead629d34b8fb46a0eb877a16e1a73d61da5a6dc385f944ea4a698b0ffa6dc92ebaf13c7a11cc6658e8d8f385cd196bcc7ddd0e724b95c746b58828af422869cd661499dae22ac864a87ab18371cff542bc49d62d09ae23bbd6614d422aadc5e54bc311f1e4293022536940bd20872b9ea775df2f27332e96cd61ac30fb1c482cb35d9ad2141cddb6c948002863d9efb58f31cda81b2ab755f71fab34db4e5ae2bbccc6646545aa83e31d4f46f82d6ca93a69f9e4b7e76e2f0395b4a8304d69120408e1e2867ecfcbaae09f2e1ec3f91b5d13791dd55a67638ab4f860b010af585c0848b09f3bb522a524ec654db012d7bbd79c4d4735f20e8d0c521a4a38f676068e687fc8a1097f3f814e9fe8a196316d90ea65dd64b0476a8d6888d93eaf6862f03053fc163794c63004041d2b56ad682353b26e5b36698bcb8e0145d8413cf8cccc9d6530669edfc2d2f9ffc1a4f24eef6af0c42434e9da531b4637d526f6e3d6d83e2c84ba0aea4380801f98dbd1ec70f45edb8475f6dbdadcdeb9402f71cf1c2fa6a0cd2c45b3d48613d8261afd93b39d2c88dd4df11ca462a850f2424c287f3a9316828a6d1440fdd41df8077ac9d3db21a175d68bca3219cc4f360c42450bfb735ca5a161e0c44097eec26c444e3c436ec32a2a663c27b230a11d5de1b572423462749469ad8043ac627ea71cab177ca3877c8e30eb502a03d2c0d4244873627b2ab827540e89b298bfb42d5cc6834cb43f895c8f3282586fa27e54363f8a99361b96819243b2f45a56d63ce466f348991530a636471baf9591af4142c423c2f5fefdc5a1d6862d22e1422e9c1db312d1fe8d6341c76891b970b7e6fd023d9feb6a9befdd2af325c131567a3ec42dfa558743fb1e7ec1999da7a107d02a79968a9ba69bdfb45a987248c5274e3dcb33c809deeb530b02bab584ff515c880b42b154c329a9a3d4ee19237cdfdad6fdff4992dd4bb67c191a48fc325e56df1c4f45cb2ada4c4b70d4d0c374c44cb0984b832e8f495296883db707c590b2d361aabe3a27f395b05cb1d77fc91c48fa203cf2c82fe11cf2af8da90159d6c698fe1eb6887f971583fac9da5b72cdf6771a38edde76f6fe682f8f6257ed97c99b283f02b458b50d6aae67ab39e1ac3c5862fc787576696650c63b529d643f790b07c55580aa4cf5770b887ec274e5359d19010b77d15504b8d7bdd8074114a818cf09a5a8bee242667cc8e81b120bee675f83e8f51cb39c0f267cfbb4c89658898106e7124bb58e68d6ea325f78e8bb5bbccfd2051219d52c1ee4e0d2c0241e48b766a552c3fdba47b3451d4e8da42fd7476cc720df2f6ecd3f72fedb2446782a7c8fa8fc85271a5390d25ea2d979802e7a6c821fe7893978e48cdddba0ea97064aaf756b6036ed690de0517f72942d9c266cf9fa0722621011324275403e3e11c049327e5067327393dc72b9c262ff5437bbd4423dd4f15ce3024209c79f509054d3cb423d77b39b426203a80824fc517b215ba2a068e1ae520973b616f2263812ff4728b7d7da970940aaf02a9bc8d550e097d9c27b177e00d46a7587d8476fd15edb5c48bd96b38b4dcf6ebea5fcaddbb9f77b71d3e793584e37d1d131cf7280d5e242fb246e27856ccc4d030a74306e2990763cae664dc6fcd8c4244c6e47767754fad68cf4276ee617f7ca4df8e95ae174f74efb257b03af0f5b60da6a6f52947103c2dd8df52bcdedb21861ce39553f18c8bae693bb5953973a62838af927f10d775b3cf1afb52404a2e0cb8a229baefa8c518c1016db91674433122893d19b5d90f08431ee8a1a989f545cbbce2c3722919b8c476291c9b1c293fec545feb059ab6ae1dc2c12f0e8c04ad2f2a0ad8af90387cdde23a04f0d1628e479c030fb09b0263f979cc9944627e2cb978b313444e5672b0f9fdaa41e624b23692556839f1ffe336a4fd664fcf4a8bb2285ac9fe4c13cf30beffb3a895f8b53430cbedffa89b6734f0b701c2fc980287d9c30ac9dca73d98e4fc26f5cb976d19c9cbafd4f5ef4ba89ec1d274d420ff7563c0714841e24be589f37de028718dfc22ef7a551b6685d7408ab82d7ddc9acd36e5f33b75b604ffbb033113a87b79dfd3164858fbeba5ed18c0fc83f4b14f1c775eef584ca1481e1ab3da4f355330f3a83c05e0ecd681064a3554c97aa2a873109a3564881c70298535c3a0035d6adeb8c3300960e314639e1973e30f52c1d7b14cb76dbdbd140afa375bb02b7ed4e527cd0cc87254ba70cc94499a0b5964c51875c4132233b303b0a61adb5545952505c5c611cf41fa802da11d164f49550c17beb5ed0f634a5392c74b93e70334d84f1141344eb203cb9018af3937f484e6c4b714536cea440e3235effe17a27dc997f40ac5b04b8693356e6d70cf6e91698e6e621e2e9a804b448ab5699207d36b54ebd1e45458eb74c8c6d38c12cb2d28ecf772b873d98bc3c5bc0ac5809c99d320adeb1271f1b1f64e6ec9d95a97f5700fc47948d9c9c991791d849c774198d345d5818d03c48fcc732583ab4c2f7b39ef4100454dff4a8940258e792ad4604caf2520bfba3eb0eadfc203a300b357474097213eed4a5bef20557eeb8cf51e1c429d5391f2215bc8d505a45c65f8ee3de39a66f3863b3e6429e47d1a784702b105552236fb19ea419fd03e8dfe20635f62d8aab5dda7b5175f7a8fd8cf1ea991944b6237a35335a87cc1f874406c54f29929171bc5535ae033cde6c94f89d4db7eb0eb4034053194454b9bd7bf1ea4a9ba382e0cb002b6ca6d31a7fc9a0cd6d566acf02c3d7e98e2628cb58a1f1fc1ed82218ac4e8d01911dab442987cc4eedd6bd40cc8bc2d8cac8e2aeb33c78ace436895798d9770e9d2bd3fc309be3214b584770b46995ffc9115df1e09ae67a90f25bb550eb3b6f803fdbbdf309ad966b2bb7e4723f62c141d1fceac5f98d183da7e3f7cf8f26187daa9e4d1ed155686045ac92abfff6889e50a6a851c22f2a973a0f6d66710f018120b46302f819e697f1d33e52978d78815107926ba50d14db06d0f46f4ffc25d33a20181dcbd0105cd668aeb408a1da3a3c0e287e111d608eae976c781d846ba0349ccc5d2956c18678a0cf7cd483dd47ecd249c4ad2f8fc4d42c50f3a6054e9d528fb6934eaacc5d3f120a3ba031a4aa8d485c792d1997ab641877f799458cfd8d6f1683d62389c5e605e969a7e1259d10131cdcc59a3b4563d8e9a24c90ec03a8cfd5f3c5f3181589fc0734fa471d9109b1758e1513797ebbbc34d4970bf9c61e434bd1a7783a00ba3be3180e7b87c39f3fedb0e083b074ee31f4cdcb983ed1c874d2dec41ca6dff7289a65afe573e64ad365a0aafdd190ad6ebd67021d581d514a34600d7f98874edf31274042965865bf57d0ef72e86d43b63ea8b66f9495a53efb5bcfbe3747204c4335717f49330936399a4c8a7e1b9f05c7e6f43d5986d04d5560d629c7c71eb27ccb7603ce0ce795006de5c9d24c2735cbcb2bd2b2e92e65210afd37ee089d384df95aaf397af75cec82c0f32e3fcb54abc43fce0f3e8101c8127a46a08c0bf01b761fefc03bade95f4b18cc2b2297eb853df63abc24bd49984beaaedd7afbc7958da6031175ad909e1c703815ee5dd14c7ed057a71dff413da17a425dff3ce90c2e3ca476c2960a077f86b4df687f2bb0b7cfdaa093efd94d30f94fc523647d5d12ecdf87064ee9cfee0e62169d8e2bd8545d14552a6e02bbe56baa4134f5ecf0ad1e71e84d77eaff320caf8bd8c40f1c0c9eca585d225de47e1db54d0b6a0a02354e8a3f3b28531c84e0558c2485516606733c3f35c88243959c8e48eeada7d8076326ad1af038373367c376eba9e668468ab001321f535f22d4d3b653e050ca646d711a0571ef69a5239455b3b4b8b707db35c8fab66f0fbc413d3de387f242a1f78cea80343e25d18baffb41f03990a7b33c9214dfc1caa02d125aa586fb4f90dd76e2df6d48d59bf351cc1667e5f68b6c920fedb08f37f01cd801de7dc70d1f016cf2a322c0f4a0ff390aa8b3349a3c61bdf61091ee9caadac6dba91a885346bff785adefefa3972c8b884018fa030b50a126966183c34d6cd9d1a6b04863270a8295691e96e12e4f0b67794fe6d1af606d7e24d3ae1ee8856866c67d0e2a521ed92d634f51e9ed7c4926378c412344fe00a3a799aa89102ac085e40bb9136d9d94a57cd73623ae915b87b91c8039570f0abe4da4a60d172df521351faaf16bf6d9d42f8eb1509ecf31cc1b02b6838a011c31b97ee9cc0686a0805110bd6123056c0354a9596a47bcd5042cbfd232528cef2eab6a17913299687aecaf9349f868e7041897d3a3cb324d0fe656b1c4cee3a14fd32c8c1594af95345345d355217195b204da21b235ef87bb4f2954007acdc80cd09c3d8d6343b6c92fb33b3f9726e6ea1bdfdac501947cc41871cd48a744741ed5107bb69272a129ee53a384294185ce7002bce301c851efdbd288fce60b11b224960022b220ddcf5730300a74a1ef465217525ae3aad9a1cdced7af463322cc313c20f6fb998212dde91a5802338ae68662e8d9d7cc6699330f28c2bd53d655bead7e3742e1e4612f01266e9cf34d5c0bef29c7982b107412cf21c2eb01f89dbd4517b6f9f6b62a518faddc83966e24a7f154dbf01e6de35538f8bec93620c82118e3d6f2ad25a4867e9ae5cc02341352938a62d379bbb19e0eb4f29b36e0cb4c120920ea58a4fc574be21c0ca25b3e15fa486ad855cf1bfeabc5074c99656307a7e90a2c594fe12594e57d365c642b29e1ab79a373be9f297e80a00567a0a4f508787d3f693f2e5a3a433ed7a81ac84835ac8be1b815b85fd99040172c2d1c7a2c35c7079cf171f727a91cc5c64b2f4da2134bb5a694c244786ef33a4feb12c2a8872e88cb1a9c6ea462edac7be2cf0ab6a7bb5df4e0f045d4b60243e552781a15a7d2cbc60d2c7888eee8add3c46835abfb13cb175be0f1878e48fdcceebb02d0df21edcac222cb93e775cb1287cfb83fb5c9701e7c91c5b3cc845a85c4579f7a5d54c29a4f1939ea6cc860601f7d9e17fd032ed3a07c6dcef46a55a709cf5bdb3d12c77bb843562b39e5c43772d42d9a5040415d90da53522ba1e9294c535ef8cfa46c5dedb4994ef7613d6d81757d3153191eaa340f70622f3c9aee1a4ec669b9cc89e19e8b5fc08114f3603c1bfe305cdeebf9918b44cf75b4c84308becef404189e635eea7a32c49cbeef2c0d720eaaab6a1406762c75534daa576be94e8d37cee32df216df23351430e16ccb9ca45ede53cd716accc23ebc4fa53f426eb927c6194198fcd81c5682ec084c08f8396e4f3a726decc68fe3ee731437b213894cc597492c5df7f886470affc9990983145e5f447fcff0fd7cb6bbb81d4e83343f54aa1be51ded2b59477559d402164fbfa5ab3cb259650c5e5cb7fc69d60ac35e97c0b477015489624f0fa07d408ccd3e7f86c8c461c99402adaf70f0b06b3384206247388c04eea34a8d59943c332c98dc1c0654a99782fee837cf746b8899e60b380fbae7b6b9598f5dd2400dc4c5612e915608c67a9864e9640403a7fdd388db93663e8407352f84472acb87bfceb9da1c7bfafe2dc9d06b8d6507339fa327546aa10a6afe7ae78a86eb51bb55da5f19be8b2d872bc2fafa8229e14b494e45fb7914d296d9ff401456ed1884ca63b12386c7de127d5a5c869ed2dc7050b418e8e1f940cdd8ecf14a10d408b4e4582bfdd3982704b98d96c8c28a3827d718ad6af0c82b7f4017b2ba04adae0fc708b056351d28a9aa57cd2252ec31f58b849ac871fba9c0050619f2a50a4c67c1dc7f527243cfab6f634cb4e71d069785d5e50289d09949df76e2902f894b6990df2581e4188d6259f1e207b9d3abd7a519d6f5d4f14e49553e68b88a24b435eb6076cbfbc7d40914362e9719794bec689b670e3af3da35cbbe707953a5b8fc6b17ab2eb22839f9020c3af87f295d6761cb0befae5cc2c2f482979c907d9eea02fb0031f351020144809cecf6c984d53298a805ed1ff442e29c673235af78de09463c6c5e1ae0a81d405687d93bfe6ee1743f88ff49517a91af7420704f47f40ebd3ec8aeb43fa6ac94f3cbd7c9303f6e2e1e30cd26ee792629ac43afad061bbc70bc9c4fc2ee9975e5333f24c0a0dd3c94b9772eec14dd3237abd70f989f1930982bc0991e8f358e93b97173ec122a3e74ef73b470feeb255cc7e18b59f6649285e3e0c5ef121edbaa68e98a69984fbf859a31b96f3e4acfc3727f3ae64d780c824ff45968653a4c0ac1254df28df688dcf5318473cb5a87e453fceba1e0c74cbf2d3b86922cdd75a00aa435f088afd8bd3faf5887a46626341b0ef0655162ece67071908cbe1046ecc71e63e888be78c862ac0fdbfe56cd8a79377d63cf606665eea4ec52b2f0eae2f96b3582f97ed4eebb8636eba391c5d18760f7b3fa6fcb313200669b9b4c048e5acb9915f3a395ea758f5ef68f11bd6d1cf42478de839a46b9178ade0c8ac61bc4e703d2503df345ab7fc4dccaa0ea1006d02c30a57f01bf175d6120a8deb8626e5131ae832637fd1672ab9314ccbb4c86fef12f349c77e075c4abeb3207e5a6172f8f7108651c4cc5466865293c6bc49cd6d6d1b996c53fc502cb085f21dc25371becccb18728876e2102c71f9724d3b603b7c7115185940d0dcb30071327ae80845cf89a6422210eaedd2d5ca6615867afae7c7583608d3d105e9d03d74c14a22947e3f346e0f322f7e2abf1c8a5ab4eddac7b4159788f02df6ebea1d640b10fe6ec65e1307ca0fe6999c1070f6c8244fe38ea2366ecf74f94c89fe2c73b3cf11e7ad66529dc5a11dcc7fdd076db434c533c9221a55b3f1784704dacccc004915ee0dc0fd3e5d4f59d11f7dcde6047f0620c8f6bb1a112fcdfb7debbde21d63ac0e30dcdd7cf54146c15fe6df14b9ef20356d8a2de48856fff958dc7cfc25142f41de9d5d0a3963e43bc9fc142f51c4521dca271665505a1c9e53a7440547d74ae207d2278b1e15401f10a23ba356293eda1aa1e85c1bceb889e7f888e1ee767ce46a38e635a5927ab395b98c720807e2a697d54944f95234dafb3131d15fc495b6e50bdc841b48716d66466cac7a1c0deae4d9a6166a4109ac2860657abcf277374364fd7ea4126d940a57e7d7fbc7a95afd15629751dad13e84a601b5d2b86b59e8ae6bcdde5ab26a7617296512aac7bd135f101ba76a41830bd64453c08597b9163d43af69c62c867dc9c76acb6677cc2bd4c633a97c7ee499c5519af65abce9793eb83ab21b5218f7b54c52148ef4934c95d2d6a748e47b26f9d0592bb55d888e48beafcda544a7952fc8d06bae57820cff85d568560bc565d0a61f37793fdfc482351bbed939d092970cf26e3a7c7e2af9f6ea49085e8883260d1c75521f71fbb8be8ef70a0075b64a3935233994550cee34d30bfab6bf698c93f2f27bcfabd43da85130554c69ed39f6cb73ae481f31d8f07d7b3c2ab1c0f6e785344715f13fe471baacb42172cea5dd843726bc78b405a95e53565ca6a9a834a39d0bffe78ba0063e0e0aecfc839c38e99e75c84dd7f1988e35aa558e108c36aba50c773d9dfb521031ac22713f57b111762fddb24eb9d2478a8aa673c950001c51eee85e3600e043816d81c8e543731226ae4cd76a7126af26d3a3841fc2e56bfe118206fa03f730358059b239963295800420af6b3506838bd69402629c887f9bcf3bf44c5efa21773fe9156825102ccfa71268141ae57fca14e09b4145ac78178428c9725a49b4227a6ef479c865c8a1486ff43178eb05fddb230cb36315f6cff0a9891a0b78a6ded0f81fc25dcdbf8cd2fa5df4ff1154ce6785d292b57023be5d2511661ddb58c211273afe0fa5b2d9d856df7910cb5c257eebe306ef8715dbb1dc5be0a4945ca700d3f1c5b9fb6d0e0e9c800ee41e750de1f33b9b870a18153d3e84ce19c689b819e3e6d4a38c64f7712d612df2da08e4b0e4da98a4ca063f1b80eca146a5d991371f407feadf7e28a85435746940af201338dec139a801ac6be18c3dce7cd3d5d536b5ea82e75a00bd0721679a0e796ad56ae811b57d443e7e3d497dc5f073669506c3b50b423a78e9e4ff341bb96a0ceb22cdbee2ae32df0d6f78efb31f19b9a9a6119bcdd590222476037bafb2ddcb104ca92959f1d3d90fb4355e47a2448453e17020d2d65124186a495272a0a377c83b2f62a93631287083270e0dce816097f96e7654066b0e798331bcb96e8b5e0aad8d873f410c3db63c6aca20427650eb540398c0d6942bd12fff231529356b4ef5a4ed96bb714570a1447b3359783bc7caba6c770db4f385d1ad7c1465624f590605bb6eef4224695d48368d74ef863bcacfa40c82cc202cab5c50b9c908aeddb3ad106f81369d12ae13aba7b24509bccfa3d7a6939ee61212130fdbf6216545ce8938d2170d8b0876eeb11560ea29df095b6ef66e2a0e81892c8a4c9388b687f01dc554601fbd798b7741215e7df085031f8368cd1afaafc01f4c0c69db0864f9916e904c0a62616dac672010f55a08c44db1cfdbd64ee967559cd55632adc24a64bfc264882a2750d1df648a140e7da9c59a1ad8a6450d26eb290050a83f6cc34faef38eef9f30cf0eeed842d6a6c5a938c690dac49f4828c9e42d40310f274760342b3458cdee9dc6074ba938b45c5ce767a5db012d702517e23baf1f967ce8a2f5bac20a7fb742cbcc550b7a9ca7f397eda6b4ffbe55c96fecea60d28595e57fe112e6c59f64e6a288f555986540146225a311ed85a7ac4ae55eb1edfc8294cd79734cf4fc4fb5094c48b3dc82b99b8efd06ab38afd63b45c947e5d0c64a20f79d1c091d3274c68bbf215a0a020b52ab6556f7e41cdbc0ad47d4012e04d81b6d8da3bef3768fec56a380f8f0392770c650f958223aecdff12cc132ac19f9afdd9cee3b7b27c0dc186cdb7bdcfa8be6e05d64a87819f6c26b53d469ec858fea0470b37913a15ae920fe6cbd84b98a6f03780c6faabc4586035050a748ee5e46cff7e6c10ed9bce498a391d6bc9f64496e3397114fd8a3772051de10681626979bb18cb695b02ee67ec19bdc457190a5b911237766c4c3432f8e7b17dfb79d2aec03d1409dc83e3d6ecd6d2232321a04da5ffd33eb1571cf122b8620475eb6f1bd981e4b0f3ca1c7537523998631915b119c699d4f141bbacf0cb3b71bb1fabbc900b98a42618f4098df89b0f146f298402ef206d2b981d3d88b8a1f6c3083194643f928d3f5901b8fd450fd0fd59ce5c094cd40235a4e748b8dc2a11c102aeba0b356ebd3fcfccb027226dbb50bbd0a4ff52b8cf1e9199e56f34cac28e21af01fab855d4d12483f77f7fc592681e2cb21ee5fc31aed72772c1d232183717e9863d82881c8505b5c50c0e0943718d0b2f6b10bb253046de4ecbe2acf11eb0d035b2b4b657bd1d7a9acb67fad522f24fcdb81713e55ebebbcc1c7b0afe15332cce8662f911a4e1e21fe1a7e3ea5f87ee71ec466a82f5cb94b2b2066db845df8d5be8a87e6873e0c7744a884ef3d185252dcf9320adb8690f483cdee5484b974096a7a328cb30b990fe1627f67122f011702f6d9e3a001c4118065829147d1ad540da2e8bfec73ae8ce9541dc5cabd1e0d828988d74a0fc82271176fe9945aa1e8270e9a010e6e79c35d3e3e34bb4b46dd4f23a49c55dcd4159ff72298d8e82102a82e7ad1b66ea197d22565be444fbc13d3c6de4d24c3a77307d260dbbf61da9882dc56f97475483ddea581730cfbfb013ff26088a69f497d9c511d1cd5e21f33f688fe2fafd3fc45940594a6026a1d52449074d938bbe6398b5c00ad3ee5feb04807bb53754a146eb6810a11bf98f1570234810c0e41d27402460aac455d0f194e33800e355ca583325825b6f1055ac5684e134cb840aba2c90efe57cf5f74706dcd0742ddb82a64e2942212b2f1ba786325258b89af264d7a5e0e853c22a08645d4b953633fb01f11e2377f576dd709ae3aa2c282a1ab335b4bbdb6a38e0bd27ab55804a86f178b69f0a998737505103be0db0825a6e1cb6bebc4946f1aa4606efea3d197bdb02b142fa712b9fc9e904eee3c84106a7d7aabd6745358893e0ac98790cacf6e2fb77a8155aa22965db7bc15e7dba54203a49b0b63f2411d6b954a6a64dbadad7f6c264cc285442092d95e21768cc48ee0471b0b89452b7ad69d90f04dafbe964fb7c833cf620b9865d26695bb6bc464a0fe8463b6dd22c172c595421e10d3ef1210a1d3170f1b78525656af849101cb984b8cb8e90aafbaf8a12e1bd315ed350efe6e3c799b2b6ead59b51800397d5e8aa7d69919d0ba4ceb2b80dd05b2e815b8e68eb0c968cd29e8bb628d5563719b618dfd73f17775eb6e990fa145f6664a5c4b637eb886c4685680e2d7970263a47aed6b012d1351f0741c125fd3ad55d13cc5d0fc85936ddc9d65d797d2986043c0f19eee21d46d2ffab9c2ee7820ad01e24d0ec6de967419ba44a64c215b8815a8348a61bfca9f6773331895547746fed13162439fa1df741ee6d4968dbb503b01db14d29a4998a2b2cfcea452542bc0a41531c75fa7265c0f61ce0850705365afd013da6ed8893b0b2d3e40b379f9e94a63af005f8f5195835853322cdbbdab7524a4c4e5ec5da92980bc33eb779ff1a8f7c18b3e3d7ccd4f04ef4d5d8aa91af998c907dddf5124fef230a75545433001c28d967524f9fbf0f864d0c470c6f1234f1d0f230b3353eaed8bfa24b016946933532f0f13843ab1ad2ce3159a06e2c2626373aa0769833fc7da44ae6ce925df216aaf63cb97824c74dbb8f80be50bcdb3cf4a60251df1ee920a8281f91b887725a3e6fdec9a370a46bdf328aef0659e1a990cfd21683d765608dcbf70d4302fd30637714ef7553e1825a70a0bb5d4b2c2ac769f90cc32798bbd029d47a9d9b9db0dc2e638d64af89a414ce29fd96326dac1090a771263d96c2a50e9223008919b87eedd6f9b40c70db7e61cdd695676a0f10bcb7b7a15427991f788d3c6142eb93d1908029f6e895b68eb65b899eac514c0fca555b16ef5c47f23d96b041d8ff57f55777df30fa8e143cdf9eb23269682aa12911c73f24dee94aa2331521cc0e132a42dcfbe16e45d3cbaf7195b52097cae57866df5236fbde8d6b1b42f8f4dc2226e42eba0900423cf11cb3869981e45f13f7cc59ea84c51f70a0dec66183188c6f975aad5fe94749eb47454cf4e719da1c6c2b6d84b7271a6409bfa8ead35fdb42e25ef7fb34820a3c0df4b5456159c65379c4af37eb5845ff116f1319824fdcd027a715a6e15570d4efcd52962442682c079e43f143970b2153020eb5e2b6a37660a8b880e1efcbaad722b57408e93480d09cd660a0ebd6e0751f0bc84d006b4358f1126367e821863b7137c86122ff70415850af33351af1fcfd2f2fc48115b1efc0d8776250b6ec44a5586280cffade2043caa75a467606f9378396b69ab133467880ab6006681e0ca31ce9775fc1fbf1980f0d4290f38e7efc8be9ab88e99c034a65df9c70fd24960c55000999351d802c216de534b02b7845ae688931f409142148146623ddc6101d2a6ee40a29ae54e8c24a4c621286fc03cecf096950b3e7d012e5f883abe390d685334d2dbe94709c5ee2e27f719b62a4d1e353aba6ab481f1a2c60daee840584ba5e449d3916ea78f8383ae9e7d58abc062041dc319b633716253517e10cb78269be0ae4dd3c109eac557470f806c8a3b082ee9dfb1b0ca95f46c72ef119f091080d331c38fabd532e61bc5c2b38c9b205e401730fef3b40dc3000c35bfbb28e46446bc1e40c828520dd348b0a0ede95583522f1fd6a7ebec9c1c397c39315ecc7c20677d8a6354aa0684188e36b786d6341c7b06dfaf32fd28cc11d31d246d79628aee1808b6f1c5394365343d9da0061999c87b63cb86ecbc7d4a54df3ecb6f68eef32269dc88536b0a8029b0430dba36f26d1f2679e47bb6ca9e6d91360745b12434adf25f24f1a01598aba8dac57d9ce6d954613cecc0d7ffeb0a75ddc08de948028e3ac1eb67bad55ddc09b3c9118a23ae095b9773b03dd80d4b6e54db9be5c66de29a31ec4c26fbe5765f991e8b3815c60e68175fb9691cc22bd208d5696a45d454ba63744707890193e47b892b19c8525b6a7a229e1b6cfc6d08a929f6ace188e3330bba21501dc6462aef6501943b2400e496388ed52e6ddd3668327dd17e6cb4e7c6a89e9b2f931ed490309b6bffc51ce79345bfae9c19458558155f2bbc287c54c7c8051f46a5c347a9a19b326211106a7faac33a0163d12c71e32a53601d87131e6ca173db4b9b02836380b0905404628c96434b01842f75f94deef3c885f933aa5f7b58d9fbb2a352de7ce375ccb3d33b71d39e4ef923703eba092bfeab22ea7c2b394baf140ebe9b1b09fec97e8f39c0f54a520466006401e8e953fc035dd2d88256eb0fcebcd0c5651f2efdf4f07f5ea8ce26f75d3402269762f47c306cfa7d9cc5c04f66e9df9733aaac049870fd5b335e12ac4658540bb11b6daf46bda5b057cb9a789e26ba5aebb5adde77cd4c5f8f66e8c8487e81f2f1f021f387c9cfb2ee3315cd9b87cc3539264e336c2b958f40b90f43097c578062847a29439bbe43471aff9d3b26963c6f5176011e069bab73f7de998f8fd08921ec1cb6cfddca69daeb769761209c67e7c1ae0324e13446ba4142c38dd6e1a42cf5a4d7cfda3f7eb7e85cdc75cb421d8b1b3d5669c107e144f9ae257e921e864a40bdb9dfac6a6d8933865339937ef1d3a26076e83ea99275a4d729917b36f776206a8455d2b9ae0289735e1b757b84cf33950a89a83d23cf669cd019a127707ebce1a95ded7ad9763cccda34ef24af76ab3c0ea424ae54127c1c408500af9bb89ca733472b22606b3d53a862cf283d875d136aa363d16e1af30bbeb27b244795531e271372301b816eba67b7d429b89fb66c98592e309d3df1816bfbfe3e02025e51f7daa975c96a1fe6facd119624bdb4796daccc0d71cc55f3c6e610f3c11197072f35fc452b14c990f46b1d58b5dcbef211537d1f875f135f0895d8db0d7c2fa08ec1c6b2ff5f94545ce92b254fa76f516262834165f987e5f75617d00e662f2a59cf0bc0e18585bb16d2aa78e3d8d3343206f16a2c32ce5a2d45c43832f057f868e373bbd8080d850b15f698e4bda092b66e325e01ca8667cd4118c1b369af60fb3580dce3af545218d6d2e834257217a155b1594b5e36d9560efca962c6e1f3de296becd9b0b5b8d085235894e4c26564f020b40c65e3bd221659fdb5fce668b74d56f366c4b3280325ca98e8f0ecc3957a813d9c6a5b41f9174d11671989d93dfcce47e7a2cd36f12ca859ddf5a9211d5754deac18ecb090710c27c048ac71ce3515f4d54e067ec360150928cc7e40449ec69dd823359feb6b5e7c3ac8ea8c41f5fc248f6c66672b427e29678ed4a4744b4970641a4665f1c1e498010271c4e174b1707f0d054d5033c230558282f6316f9ee07a7ad0db01f11bfa9e34b92c89973a70e54815e8fea84ac2bde3ef6b62ff88a18d750eaaebf54b9e667d70c3a61c487a9dcdac5c0d7f304792715c20b932ff421172c9eabe8752c47458104d061db323a6dbfd96a463b7736052fc7d3620e16b6bb69b4c2ae34dc82183059a8fc439e9b866a6ffbaed2ba0ce4764657689f2fcb1ae861d8e462098eb2771d005759cce1cf06d208e2257d8710feda86620699c0d2c064dfb9a0271a1f093ecd9dd89a16f3260cd786c9ccb0bd1d2cf93d9d00823f5ddc3772ee70c288130a7b42afda98571ca72ce775ca34a17aff980d0a23e489a4056c3692887e08e067ec86ffef9846fe0d5f24c6a1efdc79b37abfc25b249e1c7db7f370302072dcf0ceb387ec73796aa462060aeb12e371b4ca295e714761c744d60e810429785d7716195a4e2a37cd5e5bcacded5d771f69e1d0fbaafa66b9ea41622aa462e8d064b6dfe8bfc2e1cdd2ba72b68c207630d52beb2ceea4571fcf5fa66c6f2422367722fab0848ee86264f73e74dcf572dda40dbe68108d168fa25658ed4ed5559e91122ceadddfab5052c4bedc48c80330</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>大数据组件</category>
        <category>canal</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列易错指南</title>
    <url>/posts/c942750e.html</url>
    <content><![CDATA[<h2 id="1-消息队列的坑之非幂等">1.消息队列的坑之非幂等</h2>
<h3 id="（1）幂等性概念">（1）幂等性概念</h3>
<p>所谓幂等性就是无论多少次操作和第一次的操作结果一样。如果消息被多次消费，很有可能造成数据的不一致。而如果消息不可避免地被消费多次，如果我们开发人员能通过技术手段保证数据的前后一致性，那也是可以接受的 。</p>
<p><code>RabbitMQ</code>、<code>RocketMQ</code>、<code>Kafka</code> 消息队列中间件都有可能出现消息重复消费问题。这种问题并不是 MQ 自己保证的，而是需要开发人员来保证。</p>
<p>这几款消息队列中间都是是全球最牛的分布式消息队列，那肯定考虑到了消息的幂等性。我们以 Kafka 为例，看看 Kafka 是怎么保证消息队列的幂等性。</p>
<p>Kafka 有一个 <code>偏移量</code> 的概念，代表着消息的序号，每条消息写到消息队列都会有一个偏移量，消费者消费了数据之后，每过一段固定的时间，就会把消费过的消息的偏移量提交一下，表示已经消费过了，下次消费就从偏移量后面开始消费。</p>
<h3 id="（2）避坑指南">（2）避坑指南</h3>
<p>微信支付结果通知场景</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>微信官方文档上提到微信支付通知结果可能会推送多次，需要开发者自行保证幂等性。第一次我们可以直接修改订单状态（如支付中 -&gt; 支付成功），第二次就根据订单状态来判断，如果不是支付中，则不进行订单处理逻辑。</p>
</li>
</ul>
<p>插入数据库场景</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>每次插入数据时，先检查下数据库中是否有这条数据的主键 id，如果有，则进行更新操作。</p>
</li>
</ul>
<p>写 Redis 场景</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Redis 的 <code>Set</code> 操作天然幂等性，所以不用考虑 Redis 写数据的问题。</p>
</li>
</ul>
<p>其他场景方案</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>生产者发送每条数据时，增加一个全局唯一 id，类似订单 id。每次消费时，先去 Redis 查下是否有这个 id，如果没有，则进行正常处理消息，且将 id 存到 Redis。如果查到有这个 id，说明之前消费过，则不要进行重复处理这条消息。</p>
</li>
<li class="lvl-2">
<p>不同业务场景，可能会有不同的幂等性方案，大家选择合适的即可，上面的几种方案只是提供常见的解决思路。</p>
</li>
</ul>
<h2 id="2-消息队列的坑之消息丢失">2.消息队列的坑之消息丢失</h2>
<blockquote>
<p>消息丢失会带来什么问题？如果是订单下单、支付结果通知、扣费相关的消息丢失，则可能造成财务损失，如果量很大，就会给甲方带来巨大损失</p>
</blockquote>
<h3 id="（1）生产者存放消息的过程中丢失消息">（1）生产者存放消息的过程中丢失消息</h3>
<h4 id="解决方案">解决方案</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>事务机制（不推荐，异步方式）</p>
</li>
</ul>
<p>对于 RabbitMQ 来说，生产者发送数据之前开启 RabbitMQ 的<strong>事务机制</strong><code>channel.txselect</code> ，如果消息没有进队列，则生产者受到异常报错，并进行回滚 <code>channel.txRollback</code>，然后重试发送消息；如果收到了消息，则可以提交事务 <code>channel.txCommit</code>。但这是一个同步的操作，会影响性能。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>confirm 机制（推荐，异步方式）</p>
</li>
</ul>
<p>我们可以采用另外一种模式： <code>confirm</code> 模式来解决同步机制的性能问题。每次生产者发送的消息都会分配一个唯一的 id，如果写入到了 RabbitMQ 队列中，则 RabbitMQ 会回传一个 <code>ack</code> 消息，说明这个消息接收成功。如果 RabbitMQ 没能处理这个消息，则回调 <code>nack</code> 接口。说明需要重试发送消息。</p>
<p>也可以自定义超时时间 + 消息 id 来实现超时等待后重试机制。但可能出现的问题是调用 ack 接口时失败了，所以会出现消息被发送两次的问题，这个时候就需要保证消费者消费消息的幂等性。</p>
<h4 id="事务模式-和-confirm-模式的区别："><code>事务模式</code> 和 <code>confirm</code> 模式的区别：</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>事务机制是同步的，提交事务后悔被<strong>阻塞</strong>直到提交事务完成后。</p>
</li>
<li class="lvl-2">
<p>confirm 模式异步接收通知，但可能<strong>接收不到通知</strong>。需要考虑接收不到通知的场景。</p>
</li>
</ul>
<h3 id="（2）消息队列丢失消息">（2）消息队列丢失消息</h3>
<p>消息队列的消息可以放到内存中，或将内存中的消息转到硬盘（比如数据库）中，一般都是内存和硬盘中都存有消息。如果只是放在内存中，那么当机器重启了，消息就全部丢失了。如果是硬盘中，则可能存在一种极端情况，就是将内存中的数据转换到硬盘的期间中，消息队列出问题了，未能将消息持久化到硬盘。</p>
<p><strong>解决方案</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>创建 <code>Queue</code> 的时候将其设置为持久化。这个地方没搞懂，欢迎探讨解答。</p>
</li>
<li class="lvl-2">
<p>发送消息的时候将消息的 <code>deliveryMode</code> 设置为 2 。</p>
</li>
<li class="lvl-2">
<p>开启生产者 <code>confirm</code> 模式，可以重试发送消息。</p>
</li>
</ul>
<h3 id="（3）消费者丢失消息">（3）消费者丢失消息</h3>
<p>消费者刚拿到数据，还没开始处理消息，结果进程因为异常退出了，消费者没有机会再次拿到消息。</p>
<p><strong>解决方案</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>关闭 RabbitMQ 的自动 <code>ack</code>，每次生产者将消息写入消息队列后，就自动回传一个 <code>ack</code> 给生产者。</p>
</li>
<li class="lvl-2">
<p>消费者处理完消息再主动 <code>ack</code>，告诉消息队列我处理完了。</p>
</li>
</ul>
<p><strong>问题：</strong> 那这种主动 <code>ack</code> 有什么漏洞了？如果 主动 <code>ack</code> 的时候挂了，怎么办？</p>
<p>则可能会被再次消费，这个时候就需要幂等处理了。</p>
<p><strong>问题：</strong> 如果这条消息一直被重复消费怎么办？</p>
<p>则需要有加上重试次数的监测，如果超过一定次数则将消息丢失，记录到异常表或发送异常通知给值班人员。</p>
<h3 id="（4）Kafka-消息丢失">（4）Kafka 消息丢失</h3>
<p><strong>场景：</strong><code>Kafka</code> 的某个 broker（节点）宕机了，重新选举 leader （写入的节点）。如果 leader 挂了，follower 还有些数据未同步完，则 follower 成为 leader 后，消息队列会丢失一部分数据。</p>
<p><strong>解决方案</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>给 topic 设置 <code>replication.factor</code> 参数，值必须大于 1，要求每个 partition 必须有至少 2 个副本。</p>
</li>
<li class="lvl-2">
<p>给 kafka 服务端设置 <code>min.insyc.replicas</code> 必须大于 1，表示一个 leader 至少一个 follower 还跟自己保持联系。</p>
</li>
</ul>
<h2 id="3-消息队列的坑之消息乱序">3. 消息队列的坑之消息乱序</h2>
<blockquote>
<p>用户先下单成功，然后取消订单，如果顺序颠倒，则最后数据库里面会有一条下单成功的订单。</p>
</blockquote>
<p><strong>RabbitMQ 场景：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>生产者向消息队列按照顺序发送了 2 条消息，消息1：增加数据 A，消息2：删除数据 A。</p>
</li>
<li class="lvl-2">
<p>期望结果：数据 A 被删除。</p>
</li>
<li class="lvl-2">
<p>但是如果有两个消费者，消费顺序是：消息2、消息 1。则最后结果是增加了数据 A。</p>
</li>
</ul>
<p><strong>RabbitMQ 解决方案：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>将 Queue 进行拆分，创建多个内存 Queue，消息 1 和 消息 2 进入同一个 Queue。</p>
</li>
<li class="lvl-2">
<p>创建多个消费者，每一个消费者对应一个 Queue。</p>
</li>
</ul>
<p><strong>Kafka 场景：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>创建了 topic，有 3 个 partition。</p>
</li>
<li class="lvl-2">
<p>创建一条订单记录，订单 id 作为 key，订单相关的消息都丢到同一个 partition 中，同一个生产者创建的消息，顺序是正确的。</p>
</li>
<li class="lvl-2">
<p>为了快速消费消息，会创建多个消费者去处理消息，而为了提高效率，每个消费者可能会创建多个线程来并行的去拿消息及处理消息，处理消息的顺序可能就乱序了。</p>
</li>
</ul>
<p><strong>Kafka 解决方案：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>解决方案和 RabbitMQ 类似，利用多个 内存 Queue，每个线程消费 1个 Queue。</p>
</li>
<li class="lvl-2">
<p>具有相同 key 的消息 进同一个 Queue。</p>
</li>
</ul>
<h2 id="4-消息队列的坑之消息积压">4. 消息队列的坑之消息积压</h2>
<p>消息积压：消息队列里面有很多消息来不及消费。</p>
<p><strong>场景 1：</strong> 消费端出了问题，比如消费者都挂了，没有消费者来消费了，导致消息在队列里面不断积压。</p>
<p><strong>场景 2：</strong> 消费端出了问题，比如消费者消费的速度太慢了，导致消息不断积压。</p>
<blockquote>
<p>比如线上正在做订单活动，下单全部走消息队列，如果消息不断积压，订单都没有下单成功 ，那么会造成很大的损失</p>
</blockquote>
<p>解决方案：<strong>解铃还须系铃人</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>修复代码层面消费者的问题，确保后续消费速度恢复或尽可能加快消费的速度。</p>
</li>
<li class="lvl-2">
<p>停掉现有的消费者。</p>
</li>
<li class="lvl-2">
<p>临时建立好原先 5 倍的 Queue 数量。</p>
</li>
<li class="lvl-2">
<p>临时建立好原先 5 倍数量的 消费者。</p>
</li>
<li class="lvl-2">
<p>将堆积的消息全部转入临时的 Queue，消费者来消费这些 Queue。</p>
</li>
</ul>
<h2 id="5-消息队列的坑之消息过期失效">5. 消息队列的坑之消息过期失效</h2>
<blockquote>
<p>RabbitMQ 可以设置过期时间，如果消息超过一定的时间还没有被消费，则会被 RabbitMQ 给清理掉。消息就丢失了</p>
</blockquote>
<p>解决方案：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>准备好批量重导的程序</p>
</li>
<li class="lvl-2">
<p>手动将消息闲时批量重导</p>
</li>
</ul>
<h2 id="6-消息队列的坑之队列写满">6. 消息队列的坑之队列写满</h2>
<blockquote>
<p>当消息队列因消息积压导致的队列快写满，所以不能接收更多的消息了。生产者生产的消息将被丢弃。</p>
</blockquote>
<p>解决方案：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>判断哪些是无用的消息，RabbitMQ 可以进行 <code>Purge Message</code> 操作。</p>
</li>
<li class="lvl-2">
<p>如果是有用的消息，则需要将消息快速消费，将消息里面的内容转存到数据库。</p>
</li>
<li class="lvl-2">
<p>准备好程序将转存在数据库中的消息再次重导到消息队列。</p>
</li>
<li class="lvl-2">
<p>闲时重导消息到消息队列。</p>
</li>
</ul>
<p>原文链接：<a href="https://www.cnblogs.com/jackson0714/p/fenbushi.html">https://www.cnblogs.com/jackson0714/p/fenbushi.html</a></p>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Kafka副本机制</title>
    <url>/posts/c6a82497.html</url>
    <content><![CDATA[<h2 id="一、Kafka集群">一、Kafka集群</h2>
<p>Kafka 使用 Zookeeper 来维护集群成员 (brokers) 的信息。每个 broker 都有一个唯一标识 <code>broker.id</code>，用于标识自己在集群中的身份，可以在配置文件 <code>server.properties</code> 中进行配置，或者由程序自动生成。下面是 Kafka brokers 集群自动创建的过程：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>每一个 broker 启动的时候，它会在 Zookeeper 的 <code>/brokers/ids</code> 路径下创建一个 <code>临时节点</code>，并将自己的 <code>broker.id</code> 写入，从而将自身注册到集群；</p>
</li>
<li class="lvl-2">
<p>当有多个 broker 时，所有 broker 会竞争性地在 Zookeeper 上创建 <code>/controller</code> 节点，由于 Zookeeper 上的节点不会重复，所以必然只会有一个 broker 创建成功，此时该 broker 称为 controller broker。它除了具备其他 broker 的功能外，<strong>还负责管理主题分区及其副本的状态</strong>。</p>
</li>
<li class="lvl-2">
<p>当 broker 出现宕机或者主动退出从而导致其持有的 Zookeeper 会话超时时，会触发注册在 Zookeeper 上的 watcher 事件，此时 Kafka 会进行相应的容错处理；如果宕机的是 controller broker 时，还会触发新的 controller 选举。</p>
</li>
</ul>
<h2 id="二、副本机制">二、副本机制</h2>
<p>为了保证高可用，kafka 的分区是多副本的，如果一个副本丢失了，那么还可以从其他副本中获取分区数据。但是这要求对应副本的数据必须是完整的，这是 Kafka 数据一致性的基础，所以才需要使用 <code>controller broker</code> 来进行专门的管理。下面将详解介绍 Kafka 的副本机制。</p>
<h3 id="2-1-分区和副本">2.1 分区和副本</h3>
<p>Kafka 的主题被分为多个分区 ，分区是 Kafka 最基本的存储单位。每个分区可以有多个副本 (可以在创建主题时使用 <code> replication-factor</code> 参数进行指定)。其中一个副本是首领副本 (Leader replica)，所有的事件都直接发送给首领副本；其他副本是跟随者副本 (Follower replica)，需要通过复制来保持与首领副本数据一致，当首领副本不可用时，其中一个跟随者副本将成为新首领。</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka-cluster.png"/> </div>
<h3 id="2-2-ISR机制">2.2 ISR机制</h3>
<p>每个分区都有一个 ISR(in-sync Replica) 列表，用于维护所有同步的、可用的副本。首领副本必然是同步副本，而对于跟随者副本来说，它需要满足以下条件才能被认为是同步副本：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>与 Zookeeper 之间有一个活跃的会话，即必须定时向 Zookeeper 发送心跳；</p>
</li>
<li class="lvl-3">
<p>在规定的时间内从首领副本那里低延迟地获取过消息。</p>
</li>
</ul>
<p>如果副本不满足上面条件的话，就会被从 ISR 列表中移除，直到满足条件才会被再次加入。</p>
<p>这里给出一个主题创建的示例：使用 <code>--replication-factor</code> 指定副本系数为 3，创建成功后使用 <code>--describe </code> 命令可以看到分区 0 的有 0,1,2 三个副本，且三个副本都在 ISR 列表中，其中 1 为首领副本。</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka-分区副本.png"/> </div>
<h3 id="2-3-不完全的首领选举">2.3 不完全的首领选举</h3>
<p>对于副本机制，在 broker 级别有一个可选的配置参数 <code>unclean.leader.election.enable</code>，默认值为 fasle，代表禁止不完全的首领选举。这是针对当首领副本挂掉且 ISR 中没有其他可用副本时，是否允许某个不完全同步的副本成为首领副本，这可能会导致数据丢失或者数据不一致，在某些对数据一致性要求较高的场景 (如金融领域)，这可能无法容忍的，所以其默认值为 false，如果你能够允许部分数据不一致的话，可以配置为 true。</p>
<h3 id="2-4-最少同步副本">2.4 最少同步副本</h3>
<p>ISR 机制的另外一个相关参数是 <code>min.insync.replicas</code> , 可以在 broker 或者主题级别进行配置，代表 ISR 列表中至少要有几个可用副本。这里假设设置为 2，那么当可用副本数量小于该值时，就认为整个分区处于不可用状态。此时客户端再向分区写入数据时候就会抛出异常 <code>org.apache.kafka.common.errors.NotEnoughReplicasExceptoin: Messages are rejected since there are fewer in-sync replicas than required。</code></p>
<h3 id="2-5-发送确认">2.5 发送确认</h3>
<p>Kafka 在生产者上有一个可选的参数 ack，该参数指定了必须要有多少个分区副本收到消息，生产者才会认为消息写入成功：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>acks=0</strong> ：消息发送出去就认为已经成功了，不会等待任何来自服务器的响应；</p>
</li>
<li class="lvl-2">
<p><strong>acks=1</strong> ： 只要集群的首领节点收到消息，生产者就会收到一个来自服务器成功响应；</p>
</li>
<li class="lvl-2">
<p><strong>acks=all</strong> ：只有当所有参与复制的节点全部收到消息时，生产者才会收到一个来自服务器的成功响应。</p>
</li>
</ul>
<h2 id="三、数据请求">三、数据请求</h2>
<h3 id="3-1-元数据请求机制">3.1 元数据请求机制</h3>
<p>在所有副本中，只有领导副本才能进行消息的读写处理。由于不同分区的领导副本可能在不同的 broker 上，如果某个 broker 收到了一个分区请求，但是该分区的领导副本并不在该 broker 上，那么它就会向客户端返回一个 <code>Not a Leader for Partition</code> 的错误响应。 为了解决这个问题，Kafka 提供了元数据请求机制。</p>
<p>首先集群中的每个 broker 都会缓存所有主题的分区副本信息，客户端会定期发送发送元数据请求，然后将获取的元数据进行缓存。定时刷新元数据的时间间隔可以通过为客户端配置 <code>metadata.max.age.ms</code> 来进行指定。有了元数据信息后，客户端就知道了领导副本所在的 broker，之后直接将读写请求发送给对应的 broker 即可。</p>
<p>如果在定时请求的时间间隔内发生的分区副本的选举，则意味着原来缓存的信息可能已经过时了，此时还有可能会收到 <code>Not a Leader for Partition</code> 的错误响应，这种情况下客户端会再次求发出元数据请求，然后刷新本地缓存，之后再去正确的 broker 上执行对应的操作，过程如下图：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka-元数据请求.png"/> </div>
<h3 id="3-2-数据可见性">3.2 数据可见性</h3>
<p>需要注意的是，并不是所有保存在分区首领上的数据都可以被客户端读取到，为了保证数据一致性，只有被所有同步副本 (ISR 中所有副本) 都保存了的数据才能被客户端读取到。</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka-数据可见性.png"/> </div>
<h3 id="3-3-零拷贝">3.3 零拷贝</h3>
<p>Kafka 所有数据的写入和读取都是通过零拷贝来实现的。传统拷贝与零拷贝的区别如下：</p>
<h4 id="传统模式下的四次拷贝与四次上下文切换">传统模式下的四次拷贝与四次上下文切换</h4>
<p>以将磁盘文件通过网络发送为例。传统模式下，一般使用如下伪代码所示的方法先将文件数据读入内存，然后通过 Socket 将内存中的数据发送出去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer = File.read</span><br><span class="line">Socket.send(buffer)</span><br></pre></td></tr></table></figure>
<p>这一过程实际上发生了四次数据拷贝。首先通过系统调用将文件数据读入到内核态 Buffer（DMA 拷贝），然后应用程序将内存态 Buffer 数据读入到用户态 Buffer（CPU 拷贝），接着用户程序通过 Socket 发送数据时将用户态 Buffer 数据拷贝到内核态 Buffer（CPU 拷贝），最后通过 DMA 拷贝将数据拷贝到 NIC Buffer。同时，还伴随着四次上下文切换，如下图所示：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka-BIO.png"/> </div>
<h4 id="sendfile和transferTo实现零拷贝">sendfile和transferTo实现零拷贝</h4>
<p>Linux 2.4+ 内核通过 <code>sendfile</code> 系统调用，提供了零拷贝。数据通过 DMA 拷贝到内核态 Buffer 后，直接通过 DMA 拷贝到 NIC Buffer，无需 CPU 拷贝。这也是零拷贝这一说法的来源。除了减少数据拷贝外，因为整个读文件到网络发送由一个 <code>sendfile</code> 调用完成，整个过程只有两次上下文切换，因此大大提高了性能。零拷贝过程如下图所示：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka-零拷贝.png"/> </div>
<p>从具体实现来看，Kafka 的数据传输通过 TransportLayer 来完成，其子类 <code>PlaintextTransportLayer</code> 的 <code>transferFrom</code> 方法通过调用 Java NIO 中 FileChannel 的 <code>transferTo</code> 方法实现零拷贝，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">transferFrom</span><span class="params">(FileChannel fileChannel, <span class="type">long</span> position, <span class="type">long</span> count)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> fileChannel.transferTo(position, count, socketChannel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong> <code>transferTo</code> 和 <code>transferFrom</code> 并不保证一定能使用零拷贝。实际上是否能使用零拷贝与操作系统相关，如果操作系统提供 <code>sendfile</code> 这样的零拷贝系统调用，则这两个方法会通过这样的系统调用充分利用零拷贝的优势，否则并不能通过这两个方法本身实现零拷贝。</p>
<h2 id="四、物理存储">四、物理存储</h2>
<h3 id="4-1-分区分配">4.1 分区分配</h3>
<p>在创建主题时，Kafka 会首先决定如何在 broker 间分配分区副本，它遵循以下原则：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在所有 broker 上均匀地分配分区副本；</p>
</li>
<li class="lvl-2">
<p>确保分区的每个副本分布在不同的 broker 上；</p>
</li>
<li class="lvl-2">
<p>如果使用了 <code>broker.rack</code> 参数为 broker 指定了机架信息，那么会尽可能的把每个分区的副本分配到不同机架的 broker 上，以避免一个机架不可用而导致整个分区不可用。</p>
</li>
</ul>
<p>基于以上原因，如果你在一个单节点上创建一个 3 副本的主题，通常会抛出下面的异常：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">Error</span> <span class="string">while executing topic command : org.apache.kafka.common.errors.InvalidReplicationFactor   </span></span><br><span class="line"><span class="attr">Exception</span>: <span class="string">Replication factor: 3 larger than available brokers: 1.</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-分区数据保留规则">4.2 分区数据保留规则</h3>
<p>保留数据是 Kafka 的一个基本特性， 但是 Kafka 不会一直保留数据，也不会等到所有消费者都读取了消息之后才删除消息。相反， Kafka 为每个主题配置了数据保留期限，规定数据被删除之前可以保留多长时间，或者清理数据之前可以保留的数据量大小。分别对应以下四个参数：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>log.retention.bytes</code> ：删除数据前允许的最大数据量；默认值-1，代表没有限制；</p>
</li>
<li class="lvl-2">
<p><code>log.retention.ms</code>：保存数据文件的毫秒数，如果未设置，则使用 <code>log.retention.minutes</code> 中的值，默认为 null；</p>
</li>
<li class="lvl-2">
<p><code>log.retention.minutes</code>：保留数据文件的分钟数，如果未设置，则使用 <code>log.retention.hours</code> 中的值，默认为 null；</p>
</li>
<li class="lvl-2">
<p><code>log.retention.hours</code>：保留数据文件的小时数，默认值为 168，也就是一周。</p>
</li>
</ul>
<p>因为在一个大文件里查找和删除消息是很费时的，也很容易出错，所以 Kafka 把分区分成若干个片段，当前正在写入数据的片段叫作活跃片段。活动片段永远不会被删除。如果按照默认值保留数据一周，而且每天使用一个新片段，那么你就会看到，在每天使用一个新片段的同时会删除一个最老的片段，所以大部分时间该分区会有 7 个片段存在。</p>
<h3 id="4-3-文件格式">4.3 文件格式</h3>
<p>通常保存在磁盘上的数据格式与生产者发送过来消息格式是一样的。 如果生产者发送的是压缩过的消息，那么同一个批次的消息会被压缩在一起，被当作“包装消息”进行发送 (格式如下所示) ，然后保存到磁盘上。之后消费者读取后再自己解压这个包装消息，获取每条消息的具体信息。</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka-compress-message.png"/> </div>]]></content>
      <categories>
        <category>大数据组件</category>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>集群资源管理器—YARN</title>
    <url>/posts/1cd6a8e1.html</url>
    <content><![CDATA[<h2 id="一、hadoop-yarn-简介">一、hadoop yarn 简介</h2>
<p><strong>Apache YARN</strong> (Yet Another Resource Negotiator)  是 hadoop 2.0 引入的集群资源管理系统。用户可以将各种服务框架部署在 YARN 上，由 YARN 进行统一地管理和资源分配。</p>
<div align="center"> <img width="600px"  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/yarn-base.png"/> </div>
<h2 id="二、YARN架构">二、YARN架构</h2>
<div align="center"> <img width="600px" src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/Figure3Architecture-of-YARN.png"/> </div>
<h3 id="1-ResourceManager">1. ResourceManager</h3>
<p><code>ResourceManager</code> 通常在独立的机器上以后台进程的形式运行，它是整个集群资源的主要协调者和管理者。<code>ResourceManager</code> 负责给用户提交的所有应用程序分配资源，它根据应用程序优先级、队列容量、ACLs、数据位置等信息，做出决策，然后以共享的、安全的、多租户的方式制定分配策略，调度集群资源。</p>
<h3 id="2-NodeManager">2. NodeManager</h3>
<p><code>NodeManager</code> 是 YARN 集群中的每个具体节点的管理者。主要负责该节点内所有容器的生命周期的管理，监视资源和跟踪节点健康。具体如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>启动时向 <code>ResourceManager</code> 注册并定时发送心跳消息，等待 <code>ResourceManager</code> 的指令；</p>
</li>
<li class="lvl-2">
<p>维护 <code>Container</code> 的生命周期，监控 <code>Container</code> 的资源使用情况；</p>
</li>
<li class="lvl-2">
<p>管理任务运行时的相关依赖，根据 <code>ApplicationMaster</code> 的需要，在启动 <code>Container</code> 之前将需要的程序及其依赖拷贝到本地。</p>
</li>
</ul>
<h3 id="3-ApplicationMaster">3. ApplicationMaster</h3>
<p>在用户提交一个应用程序时，YARN 会启动一个轻量级的进程 <code>ApplicationMaster</code>。<code>ApplicationMaster</code> 负责协调来自 <code>ResourceManager</code> 的资源，并通过 <code>NodeManager</code> 监视容器内资源的使用情况，同时还负责任务的监控与容错。具体如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>根据应用的运行状态来决定动态计算资源需求；</p>
</li>
<li class="lvl-2">
<p>向 <code>ResourceManager</code> 申请资源，监控申请的资源的使用情况；</p>
</li>
<li class="lvl-2">
<p>跟踪任务状态和进度，报告资源的使用情况和应用的进度信息；</p>
</li>
<li class="lvl-2">
<p>负责任务的容错。</p>
</li>
</ul>
<h3 id="4-Contain">4. Contain</h3>
<p><code>Container</code> 是 YARN 中的资源抽象，它封装了某个节点上的多维度资源，如内存、CPU、磁盘、网络等。当 AM 向 RM 申请资源时，RM 为 AM 返回的资源是用 <code>Container</code> 表示的。YARN 会为每个任务分配一个 <code>Container</code>，该任务只能使用该 <code>Container</code> 中描述的资源。<code>ApplicationMaster</code> 可在 <code>Container</code> 内运行任何类型的任务。例如，<code>MapReduce ApplicationMaster</code> 请求一个容器来启动 map 或 reduce 任务，而 <code>Giraph ApplicationMaster</code> 请求一个容器来运行 Giraph 任务。</p>
<h2 id="三、YARN工作原理简述">三、YARN工作原理简述</h2>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/yarn工作原理简图.png"/> </div>
<ol>
<li class="lvl-3">
<p><code>Client</code> 提交作业到 YARN 上；</p>
</li>
<li class="lvl-3">
<p><code>Resource Manager</code> 选择一个 <code>Node Manager</code>，启动一个 <code>Container</code> 并运行 <code>Application Master</code> 实例；</p>
</li>
<li class="lvl-3">
<p><code>Application Master</code> 根据实际需要向 <code>Resource Manager</code> 请求更多的 <code>Container</code> 资源（如果作业很小, 应用管理器会选择在其自己的 JVM 中运行任务）；</p>
</li>
<li class="lvl-3">
<p><code>Application Master</code> 通过获取到的 <code>Container</code> 资源执行分布式计算。</p>
</li>
</ol>
<h2 id="四、YARN工作原理详述">四、YARN工作原理详述</h2>
<div align="center"> <img width="600px" src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/yarn工作原理.png"/> </div>
<h4 id="1-作业提交">1. 作业提交</h4>
<p>client 调用 job.waitForCompletion 方法，向整个集群提交 MapReduce 作业 (第 1 步) 。新的作业 ID(应用 ID) 由资源管理器分配 (第 2 步)。作业的 client 核实作业的输出, 计算输入的 split, 将作业的资源 (包括 Jar 包，配置文件, split 信息) 拷贝给 HDFS(第 3 步)。 最后, 通过调用资源管理器的 submitApplication() 来提交作业 (第 4 步)。</p>
<h4 id="2-作业初始化">2. 作业初始化</h4>
<p>当资源管理器收到 submitApplciation() 的请求时, 就将该请求发给调度器 (scheduler), 调度器分配 container, 然后资源管理器在该 container 内启动应用管理器进程, 由节点管理器监控 (第 5 步)。</p>
<p>MapReduce 作业的应用管理器是一个主类为 MRAppMaster 的 Java 应用，其通过创造一些 bookkeeping 对象来监控作业的进度,  得到任务的进度和完成报告 (第 6 步)。然后其通过分布式文件系统得到由客户端计算好的输入 split(第 7 步)，然后为每个输入 split 创建一个 map 任务, 根据 mapreduce.job.reduces 创建 reduce 任务对象。</p>
<h4 id="3-任务分配">3. 任务分配</h4>
<p>如果作业很小, 应用管理器会选择在其自己的 JVM 中运行任务。</p>
<p>如果不是小作业,  那么应用管理器向资源管理器请求 container 来运行所有的 map 和 reduce 任务 (第 8 步)。这些请求是通过心跳来传输的,  包括每个 map 任务的数据位置，比如存放输入 split 的主机名和机架 (rack)，调度器利用这些信息来调度任务，尽量将任务分配给存储数据的节点, 或者分配给和存放输入 split 的节点相同机架的节点。</p>
<h4 id="4-任务运行">4. 任务运行</h4>
<p>当一个任务由资源管理器的调度器分配给一个 container 后，应用管理器通过联系节点管理器来启动 container(第 9 步)。任务由一个主类为 YarnChild 的 Java 应用执行， 在运行任务之前首先本地化任务需要的资源，比如作业配置，JAR 文件,  以及分布式缓存的所有文件 (第 10 步。 最后, 运行 map 或 reduce 任务 (第 11 步)。</p>
<p>YarnChild 运行在一个专用的 JVM 中, 但是 YARN 不支持 JVM 重用。</p>
<h4 id="5-进度和状态更新">5. 进度和状态更新</h4>
<p>YARN 中的任务将其进度和状态 (包括 counter) 返回给应用管理器, 客户端每秒 (通 mapreduce.client.progressmonitor.pollinterval 设置) 向应用管理器请求进度更新, 展示给用户。</p>
<h4 id="6-作业完成">6. 作业完成</h4>
<p>除了向应用管理器请求作业进度外,  客户端每 5 分钟都会通过调用 waitForCompletion() 来检查作业是否完成，时间间隔可以通过 mapreduce.client.completion.pollinterval 来设置。作业完成之后,  应用管理器和 container 会清理工作状态， OutputCommiter 的作业清理方法也会被调用。作业的信息会被作业历史服务器存储以备之后用户核查。</p>
<h2 id="五、提交作业到YARN上运行">五、提交作业到YARN上运行</h2>
<p>这里以提交 Hadoop Examples 中计算 Pi 的 MApReduce 程序为例，相关 Jar 包在 Hadoop 安装目录的 <code>share/hadoop/mapreduce</code> 目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">提交格式: hadoop jar jar包路径 主类名称 主类参数</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">hadoop jar hadoop-mapreduce-examples-2.6.0-cdh5.15.2.jar pi 3 3</span></span><br></pre></td></tr></table></figure>
<h2 id="参考资料-22">参考资料</h2>
<ol>
<li class="lvl-3">
<p><a href="https://www.cnblogs.com/codeOfLife/p/5492740.html">初步掌握 Yarn 的架构及原理</a></p>
</li>
<li class="lvl-3">
<p><a href="http://hadoop.apache.org/docs/stable/hadoop-yarn/hadoop-yarn-site/YARN.html">Apache Hadoop 2.9.2 &gt; Apache Hadoop YARN</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>大数据组件</category>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux服务器存在大量log日志,如何快速定位错误</title>
    <url>/posts/5a8eb3c9.html</url>
    <content><![CDATA[<h1>针对大量log日志快速定位错误地方</h1>
<blockquote>
<p>动态查看日志</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -f catalina.out</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从头打开日志文件</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat catalina.out</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以使用 &gt;nanjiangtest.txt 输出某个新日志去查看</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@yesky logs]# cat -n catalina.out |grep 717892466 &gt;nanjiangtest.txt</span><br></pre></td></tr></table></figure>
<h2 id="tail-head简单命令使用">tail/head简单命令使用</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@yesky logs]# tail -n number catalina.out 查询日志尾部最后number行的日志</span><br><span class="line">[root@yesky logs]# tail -n +number catalina.out 查询number行之后的所有日志</span><br><span class="line">[root@yesky logs]# head -n number catalina.out 查询日志文件中的前number行日志</span><br><span class="line">[root@yesky logs]# head -n -number catalina.out 查询日志文件除了最后number行的其他所有日志</span><br></pre></td></tr></table></figure>
<h3 id="第一种方式（根据关键字查找出行号）">第一种方式（根据关键字查找出行号）</h3>
<blockquote>
<p>用grep拿到的日志很少，我们需要查看附近的日志。我是这样做的，首先: cat -n test.log | grep “关键词” 得到关键日志的行号</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@yesky logs]# cat -n catalina.out |grep 717892466</span><br><span class="line">13230539        [11:07 17:47:11] INFO nanjiang:Edit Old Article：717892466-2020-11-07 17:47:11</span><br><span class="line">13230593        [11:07 17:47:15] INFO nanjiangSave Article ID IS：717892466</span><br><span class="line">13230595        717892466 article.getDisplayTime()1 = 2020-11-07 16:25:11</span><br><span class="line">13230596        717892466 article.getDisplayTime()2 = 2020-11-07 16:25:11</span><br><span class="line">13230601        [11:07 17:47:15] INFO 南江 10.10.10.39  edit    article 717892466       编辑文章</span><br></pre></td></tr></table></figure>
<p>「cat -n catalina.out|tail -n +13230539|head -n 10」</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>tail -n +13230539表示查询13230539行之后的日志</p>
</li>
<li class="lvl-2">
<p>head -n 10则表示在前面的查询结果里再查前10条记录</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@yesky logs]# cat -n catalina.out |tail -n +13230539|head -n 10</span><br><span class="line">13230539        [11:07 17:47:11] INFO nanjiang:Edit Old Article：717892466-2020-11-07 17:47:11</span><br><span class="line">13230540        [11:07 17:47:11] INFO Takes:2 ms class com.tmg.cms.manager.dao.article.impl.ArticleContentDaoImpl       getListByArticleId      [NzE3ODkyNDY2]       [int]</span><br><span class="line">13230541        [11:07 17:47:11] INFO Takes:1 ms class com.tmg.cms.manager.dao.resourceImage.impl.ResourceImageDaoImpl  load    </span><br><span class="line">13230542        [11:07 17:47:11] INFO Takes:0 ms class com.tmg.cms.manager.dao.resourceImage.impl.ResourceImageDaoImpl  load    </span><br><span class="line">13230543        [11:07 17:47:11] INFO Takes:1 ms class com.tmg.cms.manager.dao.resourceImage.impl.ResourceImageDaoImpl  load    </span><br><span class="line">13230544        [11:07 17:47:11] INFO article.getImage3：/uploadImages/2020/312/02/3NXCRK4U3589_2.jpg</span><br><span class="line">13230545        [11:07 17:47:11] INFO Takes:0 ms class com.tmg.cms.manager.dao.resourceImage.impl.ResourceImageDaoImpl  load   </span><br><span class="line">13230546        [11:07 17:47:11] INFO Takes:2 ms class com.tmg.cms.manager.dao.privilege.impl.UserDaoImpl       getUserByid     </span><br><span class="line">13230547        [11:07 17:47:11] INFO Takes:57 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl     selectSitemapWithoutAudit       [MQ==]  [int]</span><br><span class="line">13230548        [11:07 17:47:11] INFO Takes:5 ms class com.tmg.cms.manager.dao.forbidword.impl.ForbidwordDaoImpl        getForbidwordBysiteid   [MjI=]  [int]</span><br></pre></td></tr></table></figure>
<h3 id="第二种方式：查看指定时间段内的日志">第二种方式：查看指定时间段内的日志</h3>
<blockquote>
<p>首先要进行范围时间段内日志查询先查看是否在当前日之内存在</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &#x27;11:07 18:29:20&#x27; catalina.out</span><br><span class="line">grep &#x27;11:07 18:31:11&#x27; catalina.out</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间范围内的查询</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -n &#x27;/11:07 18:29:20/,/11:07 18:31:11/p&#x27; catalina.out </span><br><span class="line">sed -n &#x27;/11:07 18:29:/,/11:07 18:31:/p&#x27; catalina.out</span><br></pre></td></tr></table></figure>
<h3 id="第三种方式：查看日志中特定字符的匹配数目">第三种方式：查看日志中特定字符的匹配数目</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@yesky logs]# grep &#x27;1175109632&#x27; catalina.out | wc -l</span><br></pre></td></tr></table></figure>
<h3 id="第四种方式：查询最后number行，并查找关键字“结果”">第四种方式：查询最后number行，并查找关键字“结果”</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@yesky logs]# tail -n 20 catalina.out | grep &#x27;INFO Takes:1&#x27;</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.config.impl.ConfigInfoDaoImpl load </span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [NTkwOTQ5] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MzI0] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MzI3] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MzMw] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MzA5NA==] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [Mzc4Mg==] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [OTM1MA==] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MTE5MDMw] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [NTQ2MzQw] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [NTg2NzYy] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MzYyMjA=] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.configModule.impl.ConfigModuleDaoImpl getPersonMenuList</span><br></pre></td></tr></table></figure>
<h3 id="第五种方式：查询最后number行，并查找关键字“结果”并且对结果进行标红，上下扩展两行">第五种方式：查询最后number行，并查找关键字“结果”并且对结果进行标红，上下扩展两行</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@yesky logs]# tail -n 20 catalina.out | grep &#x27;INFO Takes:1&#x27; --color -a2</span><br><span class="line">[11:11 22:02:51] INFO Takes:0 ms class com.tmg.cms.manager.dao.article.impl.ArticleContentDaoImpl getArticlePageNum [NzE4MTM2ODky] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.config.impl.ConfigInfoDaoImpl load [com.tmg.cms.manager.model.config.ConfigInfo]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [NTkwOTQ5] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MzI0] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:0 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MzI1] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MzI3] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MzMw] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:0 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MzAzNg==] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MzA5NA==] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [Mzc4Mg==] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [OTM1MA==] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:0 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MTE0MjQ4] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:0 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MTE4MDc4] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MTE5MDMw] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [NTQ2MzQw] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:0 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [NTQ3MTIw] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:0 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [NTY4OTYx] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [NTg2NzYy] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MzYyMjA=] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.configModule.impl.ConfigModuleDaoImpl getPersonMenuList [com.tmg.cms.manager.model.config.ConfigPersonMenu]</span><br></pre></td></tr></table></figure>
<h3 id="第七种方式：分页查看，使用空格翻页-使用more-less">第七种方式：分页查看，使用空格翻页(使用more/less)</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@yesky logs]# tail -n 2000 catalina.out | grep &#x27;INFO Takes:1&#x27; --color -a2 | more</span><br><span class="line">[root@yesky logs]# tail -n 2000 catalina.out | grep &#x27;INFO Takes:1&#x27; --color -a2 | less</span><br></pre></td></tr></table></figure>
<h2 id="附加">附加</h2>
<h3 id="1-全屏导航">1.全屏导航</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>ctrl + F - 向前移动一屏</p>
</li>
<li class="lvl-2">
<p>ctrl + B - 向后移动一屏</p>
</li>
<li class="lvl-2">
<p>ctrl + D - 向前移动半屏</p>
</li>
<li class="lvl-2">
<p>ctrl + U - 向后移动半屏</p>
</li>
</ul>
<h3 id="2-单行导航">2.单行导航</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>j - 向前移动一行</p>
</li>
<li class="lvl-2">
<p>k - 向后移动一行</p>
</li>
</ul>
<h3 id="3-其它导航">3.其它导航</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>G - 移动到最后一行</p>
</li>
<li class="lvl-2">
<p>g - 移动到第一行</p>
</li>
<li class="lvl-2">
<p>q / ZZ - 退出 less 命令</p>
</li>
</ul>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>Python `If-else`语句</title>
    <url>/posts/394067ff.html</url>
    <content><![CDATA[<h1>Python <code>If-else</code>语句</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-if-else">https://www.javatpoint.com/python-if-else</a></p>
</blockquote>
<p>决策是几乎所有编程语言中最重要的方面。顾名思义，决策允许我们为特定的决策运行特定的代码块。在这里，决策是根据特定条件的有效性做出的。条件检查是决策的支柱。</p>
<p>在 python 中，决策由以下语句执行。</p>
<p>| 声明 | 描述 |<br>
| 如果语句 | <code>if</code>语句用于测试特定条件。如果条件为真，将执行一个代码块(if-block)。 |<br>
| If - else 语句 | <code>If-else</code>语句类似于 <code>if</code>语句，除了它还为要检查的条件的 false 情况提供代码块。如果 <code>if</code>语句中提供的条件为 false，则将执行 else 语句。 |<br>
| 嵌套 <code>if</code>语句 | 嵌套的 <code>if</code>语句使我们能够使用 if。外部 <code>if</code>语句中的 else 语句。 |</p>
<h2 id="Python-中的缩进">Python 中的缩进</h2>
<p>为了便于编程和实现简单性，python 不允许在块级代码中使用括号。在 Python 中，缩进用于声明一个块。如果两个语句处于相同的缩进级别，那么它们就是同一个块的一部分。</p>
<p>一般来说，四个空格用来缩进语句，这是 python 中典型的缩进量。</p>
<p>缩进是 python 语言中最常用的部分，因为它声明了代码块。一个块的所有语句都位于同一缩进级别。我们将在 python 中看到实际的缩进是如何在决策和其他事情中发生的。</p>
<h2 id="if语句"><code>if</code>语句</h2>
<p><code>if</code>语句用于测试特定条件，如果条件为真，它将执行一个称为 if-block 的代码块。<code>if</code>语句的条件可以是任何有效的逻辑表达式，可以计算为真或假。</p>
<p><img src="img/c88f3d683a3ad3e73025fdf2899a8ab6.png" alt="Python If-else statements"></p>
<p><code>if</code>语句的语法如下。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> expression:</span><br><span class="line">	statement</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例-1">例 1</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;enter the number?&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> num%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Number is even&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">enter the number?<span class="number">10</span></span><br><span class="line">Number <span class="keyword">is</span> even</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="示例-2-打印三个数字中最大的一个的程序。">示例 2:打印三个数字中最大的一个的程序。</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter a? &quot;</span>));</span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter b? &quot;</span>));</span><br><span class="line">c = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter c? &quot;</span>));</span><br><span class="line"><span class="keyword">if</span> a&gt;b <span class="keyword">and</span> a&gt;c:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a is largest&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> b&gt;a <span class="keyword">and</span> b&gt;c:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b is largest&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> c&gt;a <span class="keyword">and</span> c&gt;b:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;c is largest&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter a? <span class="number">100</span></span><br><span class="line">Enter b? <span class="number">120</span></span><br><span class="line">Enter c? <span class="number">130</span></span><br><span class="line">c <span class="keyword">is</span> largest</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="If-else语句"><code>If-else</code>语句</h2>
<p><code>If-else</code>语句提供了一个与 <code>if</code>语句相结合的 else 块，它在条件为 false 的情况下执行。</p>
<p>如果条件为真，则执行 If 块。否则，执行 else 块。</p>
<p><img src="img/c4c6b7641a9d7ad8960edd358c3c066a.png" alt="Python If-else statements"></p>
<p><code>If-else</code>语句的语法如下。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition:</span><br><span class="line">	<span class="comment">#block of statements </span></span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line">	<span class="comment">#another block of statements (else-block) </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例-1-检查一个人是否有资格投票的程序。">例 1:检查一个人是否有资格投票的程序。</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">age = <span class="built_in">int</span> (<span class="built_in">input</span>(<span class="string">&quot;Enter your age? &quot;</span>))</span><br><span class="line"><span class="keyword">if</span> age&gt;=<span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You are eligible to vote !!&quot;</span>);</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Sorry! you have to wait !!&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter your age? <span class="number">90</span></span><br><span class="line">You are eligible to vote !!</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例-2-检查一个数是否为偶数的程序。">例 2:检查一个数是否为偶数的程序。</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;enter the number?&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> num%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Number is even...&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Number is odd...&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">enter the number?<span class="number">10</span></span><br><span class="line">Number <span class="keyword">is</span> even</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="elif-声明">elif 声明</h2>
<p><code>elif</code>语句使我们能够检查多个条件，并根据其中的真实条件执行特定的语句块。根据我们的需要，我们的程序中可以有任意数量的 <code>elif</code>语句。但是，使用 elif 是可选的。</p>
<p><code>elif</code>语句的工作方式类似于 c 语言中的 if-else-if 梯形语句。它必须由 <code>if</code>语句继承。</p>
<p><code>elif</code>语句的语法如下。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> expression <span class="number">1</span>: </span><br><span class="line">	<span class="comment"># block of statements </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> expression <span class="number">2</span>: </span><br><span class="line">	<span class="comment"># block of statements </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> expression <span class="number">3</span>: </span><br><span class="line">	<span class="comment"># block of statements </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line">	<span class="comment"># block of statements</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="img/5c831a224686421d7ac32b490ce81407.png" alt="Python If-else statements"></p>
<h3 id="例-1-2">例 1</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">number = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the number?&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> number==<span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;number is equals to 10&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> number==<span class="number">50</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;number is equal to 50&quot;</span>);</span><br><span class="line"><span class="keyword">elif</span> number==<span class="number">100</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;number is equal to 100&quot;</span>);</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;number is not equal to 10, 50 or 100&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the number?<span class="number">15</span></span><br><span class="line">number <span class="keyword">is</span> <span class="keyword">not</span> equal to <span class="number">10</span>, <span class="number">50</span> <span class="keyword">or</span> <span class="number">100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例-2">例 2</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"> marks = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the marks? &quot;</span>))</span><br><span class="line"><span class="keyword">if</span> marks &gt; <span class="number">85</span> <span class="keyword">and</span> marks &lt;= <span class="number">100</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Congrats ! you scored grade A ...&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> marks &gt; <span class="number">60</span> <span class="keyword">and</span> marks &lt;= <span class="number">85</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You scored grade B + ...&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> marks &gt; <span class="number">40</span> <span class="keyword">and</span> marks &lt;= <span class="number">60</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You scored grade B ...&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> (marks &gt; <span class="number">30</span> <span class="keyword">and</span> marks &lt;= <span class="number">40</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You scored grade C ...&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Sorry you are fail ?&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python JSON</title>
    <url>/posts/45338182.html</url>
    <content><![CDATA[<h1>Python JSON</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-json">https://www.javatpoint.com/python-json</a></p>
</blockquote>
<p>JSON 代表 <strong>JavaScript 对象符号</strong>，这是一种广泛用于网络数据交换的数据格式。JSON 是在客户机和服务器之间组织数据的理想格式。它的语法类似于 JavaScript 编程语言。JSON 的主要目标是在客户端和网络服务器之间传输数据。这很容易学习，也是交换数据最有效的方法。可以和**<a href="https://www.javatpoint.com/perl-tutorial">Perl</a><a href="https://www.javatpoint.com/java-tutorial">Java</a>**等各种编程语言配合使用。</p>
<p><a href="https://www.javatpoint.com/json-tutorial">JSON</a> 主要支持 6 种数据类型在 <a href="https://www.javatpoint.com/javascript-tutorial">JavaScript</a> 中:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>String</p>
</li>
<li class="lvl-2">
<p>Number</p>
</li>
<li class="lvl-2">
<p>Boolean</p>
</li>
<li class="lvl-2">
<p>Null</p>
</li>
<li class="lvl-2">
<p>Object</p>
</li>
<li class="lvl-2">
<p>Array</p>
</li>
</ul>
<p>JSON 建立在两种结构之上:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>它将数据存储在名称/值对中。它被视为<strong>对象、记录、字典、哈希表、键控列表</strong>。</p>
</li>
<li class="lvl-4">
<p>值的有序列表被视为数组、向量、列表或序列。</p>
</li>
</ul>
<p>JSON 数据表示类似于 Python 字典。下面是一个 JSON 数据的例子:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;book&quot;</span>: [</span><br><span class="line">  &#123; </span><br><span class="line">       <span class="string">&quot;id&quot;</span>: 01,</span><br><span class="line"><span class="string">&quot;language&quot;</span>: <span class="string">&quot;English&quot;</span>,</span><br><span class="line"><span class="string">&quot;edition&quot;</span>: <span class="string">&quot;Second&quot;</span>,</span><br><span class="line"><span class="string">&quot;author&quot;</span>: <span class="string">&quot;Derrick Mwiti&quot;</span> </span><br><span class="line">],</span><br><span class="line">   &#123;</span><br><span class="line">  &#123; </span><br><span class="line">	<span class="string">&quot;id&quot;</span>: 02,</span><br><span class="line"><span class="string">&quot;language&quot;</span>: <span class="string">&quot;French&quot;</span>,</span><br><span class="line"><span class="string">&quot;edition&quot;</span>: <span class="string">&quot;Third&quot;</span>,</span><br><span class="line"><span class="string">&quot;author&quot;</span>: <span class="string">&quot;Vladimir&quot;</span> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="使用-Python-JSON">使用 Python JSON</h2>
<p>Python 提供了一个名为 <strong>json</strong> 的模块。Python 支持标准库封送和 <code>pickle</code>模块，JSON API 的行为与这些库类似。Python 本身支持 JSON 特性。</p>
<p>JSON 数据的编码称为<strong>序列化</strong>。序列化是一种技术，其中数据在<strong>字节序列</strong>中转换，并通过网络传输。</p>
<p>反序列化是对转换为 JSON 格式的数据进行解码的反向过程。</p>
<p>该模块包括许多内置功能。</p>
<p>让我们来看看这些功能:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(json))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;JSONDecodeError&#x27;</span>, <span class="string">&#x27;JSONDecoder&#x27;</span>, <span class="string">&#x27;JSONEncoder&#x27;</span>, <span class="string">&#x27;__all__&#x27;</span>, <span class="string">&#x27;__author__&#x27;</span>, <span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;__cached__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__file__&#x27;</span>, <span class="string">&#x27;__loader__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;__path__&#x27;</span>, <span class="string">&#x27;__spec__&#x27;</span>, <span class="string">&#x27;__version__&#x27;</span>, <span class="string">&#x27;_default_decoder&#x27;</span>, <span class="string">&#x27;_default_encoder&#x27;</span>, <span class="string">&#x27;codecs&#x27;</span>, <span class="string">&#x27;decoder&#x27;</span>, <span class="string">&#x27;detect_encoding&#x27;</span>, <span class="string">&#x27;dump&#x27;</span>, <span class="string">&#x27;dumps&#x27;</span>, <span class="string">&#x27;encoder&#x27;</span>, <span class="string">&#x27;load&#x27;</span>, <span class="string">&#x27;loads&#x27;</span>, <span class="string">&#x27;scanner&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在本节中，我们将学习以下方法:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>load()</strong></p>
</li>
<li class="lvl-4">
<p><strong>loads()</strong></p>
</li>
<li class="lvl-4">
<p><strong>dump()</strong></p>
</li>
<li class="lvl-4">
<p><strong>dumps()</strong></p>
</li>
</ul>
<h2 id="序列化-JSON">序列化 JSON</h2>
<p>序列化是将 Python 对象转换为 JSON 的技术。有时，计算机需要处理大量的信息，因此将这些信息存储到文件中是很好的。我们可以使用 JSON 函数将 JSON 数据存储到文件中。json 模块提供了用于转换 Python 对象的 <strong>dump()</strong> 和**dump()**方法。</p>
<p>Python 对象被转换为以下 JSON 对象。清单如下:</p>
<p>| 序列号 | Python 对象 | 数据 |<br>
| <strong>1</strong> | Dict | Object |<br>
| <strong>2</strong> | list, tuple | Array |<br>
| <strong>3</strong> | Str | String |<br>
| <strong>4</strong> | int，float | Number |<br>
| <strong>5</strong> | True | true |<br>
| <strong>6</strong> | False | false |<br>
| <strong>7</strong> | None | null |</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>dump()功能</strong></p>
</li>
</ul>
<p><strong>将 JSON 数据写入文件</strong></p>
<p>Python 提供了 <strong>dump()</strong> 功能，以 JSON 格式传输(编码)数据。它接受两个位置参数，第一个是要序列化的数据对象，第二个是需要写入字节的类似文件的对象。</p>
<p>让我们考虑简单的序列化示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Import json</span><br><span class="line"><span class="comment"># Key:value mapping</span></span><br><span class="line">student  = &#123;</span><br><span class="line"><span class="string">&quot;Name&quot;</span> : <span class="string">&quot;Peter&quot;</span>,</span><br><span class="line"><span class="string">&quot;Roll_no&quot;</span> : <span class="string">&quot;0090014&quot;</span>,</span><br><span class="line"><span class="string">&quot;Grade&quot;</span> : <span class="string">&quot;A&quot;</span>,</span><br><span class="line"><span class="string">&quot;Age&quot;</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">&quot;Subject&quot;</span>: [<span class="string">&quot;Computer Graphics&quot;</span>, <span class="string">&quot;Discrete Mathematics&quot;</span>, <span class="string">&quot;Data Structure&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.json&quot;</span>,<span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> write_file:</span><br><span class="line">    json.dump(student,write_file)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;Name&quot;</span> : <span class="string">&quot;Peter&quot;</span>, <span class="string">&quot;Roll_no&quot;</span> : <span class="string">&quot;0090014&quot;</span> , <span class="string">&quot;Grade&quot;</span> : <span class="string">&quot;A&quot;</span>,  <span class="string">&quot;Age&quot;</span> : <span class="number">20</span>, <span class="string">&quot;Subject&quot;</span> : [<span class="string">&quot;Computer Graphics&quot;</span>, <span class="string">&quot;Discrete Mathematics&quot;</span>, <span class="string">&quot;Data Structure&quot;</span>] &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的程序中，我们已经在写入模式下打开了一个名为 <strong>data.json</strong> 的文件。我们以写入模式打开了该文件，因为如果该文件不存在，它将被创建。 <strong>json.dump()</strong> 方法将字典转换为 json 字符串。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>转储()功能</strong></p>
</li>
</ul>
<p>**转储()**函数用于将序列化数据存储在 Python 文件中。它只接受一个参数，即用于序列化的 Python 数据。没有使用类似文件的参数，因为我们没有将数据写入磁盘。让我们考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment"># Key:value mapping</span></span><br><span class="line">student  = &#123;</span><br><span class="line"><span class="string">&quot;Name&quot;</span> : <span class="string">&quot;Peter&quot;</span>,</span><br><span class="line"><span class="string">&quot;Roll_no&quot;</span> : <span class="string">&quot;0090014&quot;</span>,</span><br><span class="line"><span class="string">&quot;Grade&quot;</span> : <span class="string">&quot;A&quot;</span>,</span><br><span class="line"><span class="string">&quot;Age&quot;</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">b = json.dumps(student)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;Peter&quot;</span>, <span class="string">&quot;Roll_no&quot;</span>: <span class="string">&quot;0090014&quot;</span>, <span class="string">&quot;Grade&quot;</span>: <span class="string">&quot;A&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">20</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JSON 支持原始数据类型，如字符串和数字，以及嵌套列表、元组和对象。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment">#Python  list conversion to JSON  Array </span></span><br><span class="line"><span class="built_in">print</span>(json.dumps([<span class="string">&#x27;Welcome&#x27;</span>, <span class="string">&quot;to&quot;</span>, <span class="string">&quot;javaTpoint&quot;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment">#Python  tuple conversion to JSON Array </span></span><br><span class="line"><span class="built_in">print</span>(json.dumps((<span class="string">&quot;Welcome&quot;</span>, <span class="string">&quot;to&quot;</span>, <span class="string">&quot;javaTpoint&quot;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python string conversion to JSON String </span></span><br><span class="line"><span class="built_in">print</span>(json.dumps(<span class="string">&quot;Hello&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python int conversion to JSON Number </span></span><br><span class="line"><span class="built_in">print</span>(json.dumps(<span class="number">1234</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python float conversion to JSON Number </span></span><br><span class="line"><span class="built_in">print</span>(json.dumps(<span class="number">23.572</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Boolean conversion to their respective values </span></span><br><span class="line"><span class="built_in">print</span>(json.dumps(<span class="literal">True</span>))</span><br><span class="line"><span class="built_in">print</span>(json.dumps(<span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># None value to null </span></span><br><span class="line"><span class="built_in">print</span>(json.dumps(<span class="literal">None</span>)) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&quot;Welcome&quot;</span>, <span class="string">&quot;to&quot;</span>, <span class="string">&quot;javaTpoint&quot;</span>]</span><br><span class="line">[<span class="string">&quot;Welcome&quot;</span>, <span class="string">&quot;to&quot;</span>, <span class="string">&quot;javaTpoint&quot;</span>]</span><br><span class="line"><span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="number">1234</span></span><br><span class="line"><span class="number">23.572</span></span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">null</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="反序列化-JSON">反序列化 JSON</h3>
<p>反序列化是将 JSON 数据解码成 Python 对象的过程。json 模块提供了 <strong>load()</strong> 和**loads()**两种方法，用于将 JSON 数据转换为实际的 Python 对象形式。清单如下:</p>
<p>| 序号 | json | Python |<br>
| <strong>1</strong> | Object | dict |<br>
| <strong>2</strong> | Array | list |<br>
| <strong>3</strong> | String | str |<br>
| <strong>4</strong> | number(int) | int |<br>
| <strong>5</strong> | true | True |<br>
| <strong>6</strong> | false | False |<br>
| <strong>7</strong> | null | None |</p>
<p>上表显示了序列化表的逆表，但从技术上讲，它不是 JSON 数据的完美转换。这意味着，如果我们对对象进行编码，并在一段时间后再次解码；我们可能拿不回同样的东西。</p>
<p>让我们举一个现实生活中的例子，一个人把一些东西翻译成中文，另一个人把它翻译回英文，这可能不完全是翻译。考虑一个简单的例子:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">a = (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line">b = json.dumps(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(json.loads(b)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>负载()功能</strong></p>
</li>
</ul>
<p><strong>load()</strong> 函数用于将 JSON 数据从文件反序列化为 Python 对象。考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment"># Key:value mapping</span></span><br><span class="line">student  = &#123;</span><br><span class="line"><span class="string">&quot;Name&quot;</span> : <span class="string">&quot;Peter&quot;</span>,</span><br><span class="line"><span class="string">&quot;Roll_no&quot;</span> : <span class="string">&quot;0090014&quot;</span>,</span><br><span class="line"><span class="string">&quot;Grade&quot;</span> : <span class="string">&quot;A&quot;</span>,</span><br><span class="line"><span class="string">&quot;Age&quot;</span>: <span class="number">20</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.json&quot;</span>,<span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> write_file:</span><br><span class="line">    json.dump(student,write_file)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.json&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> read_file:</span><br><span class="line">    b = json.load(read_file)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Peter&#x27;</span>, <span class="string">&#x27;Roll_no&#x27;</span>: <span class="string">&#x27;0090014&#x27;</span>, <span class="string">&#x27;Grade&#x27;</span>: <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">20</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的程序中，我们已经使用 <strong>dump()</strong> 函数对文件中的 Python 对象进行了编码。之后我们使用 <strong>load()</strong> 函数读取 JSON 文件，这里我们已经传递了 <strong>read_file</strong> 作为参数。</p>
<p>json 模块还提供了 <strong>loads()</strong> 函数，用于将 JSON 数据转换为 Python 对象。这与**加载()**功能非常相似。考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Import json</span><br><span class="line">a = [<span class="string">&quot;Mathew&quot;</span>,<span class="string">&quot;Peter&quot;</span>,(<span class="number">10</span>,<span class="number">32.9</span>,<span class="number">80</span>),&#123;<span class="string">&quot;Name&quot;</span> : <span class="string">&quot;Tokyo&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python object into JSON </span></span><br><span class="line">b = json.dumps(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># JSON into Python Object</span></span><br><span class="line">c = json.loads(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;Mathew&#x27;</span>, <span class="string">&#x27;Peter&#x27;</span>, [<span class="number">10</span>, <span class="number">32.9</span>, <span class="number">80</span>], &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Tokyo&#x27;</span>&#125;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="json-load-与-json-loads">json.load()与 json.loads()</h3>
<p><strong>json.load()</strong> 函数用于加载 json 文件，而 <strong>json.loads()</strong> 函数用于加载字符串。</p>
<h3 id="json-dump-与-JSON-dumps">json.dump()与 JSON.dumps()</h3>
<p>当我们想要将 Python 对象序列化为 json 文件时，使用 <strong>json.dump()</strong> 函数，使用**JSON . dump()**函数将 JSON 数据转换为字符串进行解析和打印。</p>
<h2 id="Python-漂亮打印-JSON">Python 漂亮打印 JSON</h2>
<p>有时我们需要分析和调试大量的 JSON 数据。这可以通过在 json.dump()和 JSON . dump()方法中传递额外的参数 indent 和 sort_keys 来实现。</p>
<h4 id="注意-dump-和-dumps-函数都接受缩进和短键参数。">注意:dump()和 dumps()函数都接受缩进和短键参数。</h4>
<p>考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">person = <span class="string">&#x27;&#123;&quot;Name&quot;: &quot;Andrew&quot;,&quot;City&quot;:&quot;English&quot;, &quot;Number&quot;:90014, &quot;Age&quot;: 23,&quot;Subject&quot;: [&quot;Data Structure&quot;,&quot;Computer Graphics&quot;, &quot;Discrete mathematics&quot;]&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">per_dict = json.loads(person)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(json.dumps(per_dict, indent = <span class="number">5</span>, sort_keys= <span class="literal">True</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;Age&quot;</span>: <span class="number">23</span>,</span><br><span class="line">    <span class="string">&quot;City&quot;</span>: <span class="string">&quot;English&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;Andrew&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Number&quot;</span>: <span class="number">90014</span>,</span><br><span class="line">    <span class="string">&quot;Subject&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;Data Structure&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Computer Graphics&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Discrete mathematics&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们为缩进参数提供了 5 个空格，并且键是按升序排序的。缩进的默认值为<strong>False</strong>，** Sort_key<strong>的默认值为</strong>False**。</p>
<h2 id="编码和解码">编码和解码</h2>
<p>编码是将文本或值转换成加密形式的技术。加密数据只能由首选用户通过解码来使用。编码也称为<strong>序列化</strong>，解码也称为<strong>反序列化</strong>。对 JSON(对象)格式进行编码和解码。Python 为此类操作提供了一个流行的包。我们可以通过以下命令在 Windows 上安装它:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install demjson</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>编码</strong>-demjson 包提供了 <strong>encode()</strong> 函数，用于将 Python 对象转换为 json 字符串表示。语法如下:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">demjson.encode(self,obj,nest_level = <span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例:1 -使用 demjson 包进行编码</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> demjson</span><br><span class="line">a = [&#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&#x27;Peter&#x27;</span>,<span class="string">&quot;Age&quot;</span>:<span class="number">20</span>, <span class="string">&quot;Subject&quot;</span>:<span class="string">&quot;Electronics&quot;</span>&#125;]</span><br><span class="line"><span class="built_in">print</span>(demjson.encode(a))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="string">&quot;Age&quot;</span>:<span class="number">20</span>,<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;Peter&quot;</span>,<span class="string">&quot;Subject&quot;</span>:<span class="string">&quot;Electronics&quot;</span>&#125;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>解码</strong>-<strong>demjson</strong>模块提供**解码()**功能，用于将 json 对象转换为 Python 格式类型。语法如下:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Import demjson</span><br><span class="line">a = <span class="string">&quot;[&#x27;Peter&#x27;, &#x27;Smith&#x27;, &#x27;Ricky&#x27;, &#x27;Hayden&#x27;]&quot;</span></span><br><span class="line"><span class="built_in">print</span>(demjson.decode(a))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;Peter&#x27;</span>, <span class="string">&#x27;Smith&#x27;</span>, <span class="string">&#x27;Ricky&#x27;</span>, <span class="string">&#x27;Hayden&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在本教程中，我们已经了解了 Python JSON。JSON 是客户端和 web 服务器之间传输数据最有效的方式。</p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python OpenCV对象检测</title>
    <url>/posts/828582a3.html</url>
    <content><![CDATA[<h1>Python OpenCV 对象检测</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-opencv-object-detection">https://www.javatpoint.com/python-opencv-object-detection</a></p>
</blockquote>
<p>OpenCV 是用于图像处理、机器学习和计算机视觉的巨大开源库。它在实时操作中也发挥着重要作用。在 OpenCV 库的帮助下，我们可以轻松地处理图像和视频，以识别文件中的对象、人脸甚至笔迹。在本教程中，我们将只关注使用 OpenCV 从图像中检测对象。我们将学习如何使用 Python 程序使用 OpenCV 从给定的图像中进行对象检测。</p>
<h2 id="对象检测">对象检测</h2>
<p>基本上，对象检测是与图像处理、深度学习和计算机视觉相关的现代计算机技术，以检测图像文件中存在的对象。对象检测技术中使用的所有技术(正如我们前面提到的)都处理检测图像或视频中对象的实例。</p>
<h2 id="基于-OpenCV-的对象检测">基于 OpenCV 的对象检测</h2>
<p>我们在上一节中已经学习了对象检测，在这一节中，我们将学习如何使用 OpenCV 库在图像或视频中进行对象检测。我们将首先在 Python 程序中导入 OpenCV 库，然后我们将使用函数对给我们的图像文件执行对象检测。但是，在使用和导入库函数之前，让我们先安装使用对象检测技术的要求。</p>
<p>在本教程中，我们将使用哈尔级联技术来进行对象检测。让我们先简单了解一下哈尔级联技术。</p>
<h3 id="Haar级联技术">Haar级联技术:</h3>
<p>基本上，哈尔级联技术是一种基于机器学习的方法，其中我们使用大量正图像和负图像来训练分类器以在图像之间进行分类。哈尔级联分类器被认为是利用 OpenCV 库进行对象检测的有效方法。现在，让我们理解前面讨论过的正面和负面形象的概念:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>**Positive images:**这些图像包含我们希望从分类器中识别的对象。</p>
</li>
<li class="lvl-4">
<p>**Negative Images:**这些是不包含任何我们希望被分类器检测到的物体的图像，这些可以是其他一切的图像。</p>
</li>
</ul>
<h3 id="使用-Python-OpenCV-进行对象检测的要求">使用 Python OpenCV 进行对象检测的要求:</h3>
<p>我们必须首先在系统中安装一些重要的库，因为这是执行对象检测任务的重要要求。作为执行对象检测的要求，我们必须在系统中安装以下库:</p>
<h3 id="1-OpenCV-库的安装">1.OpenCV 库的安装:</h3>
<p>首先，使用 OpenCV 库执行对象检测的要求是 OpenCV 库应该存在于我们的设备中，以便我们可以将其导入 Python 程序并使用其对象检测功能。如果这个库不在我们的系统中，我们可以使用命令提示符终端中的以下命令来安装它:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install opencv-python</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/9a65f0ac64d7a8bce92e8185698aa66f.png" alt="Python OpenCV object detection"></p>
<p>当我们在终端写完这个命令后按回车键，命令提示符下的 pip 安装程序会开始将 OpenCV 库安装到我们的系统中。</p>
<p><img src="/img/31354ca5b16ba2d9e7d4a477f755c2d6.png" alt="Python OpenCV object detection"></p>
<p>我们可以看到，OpenCV 库已经成功安装在我们的系统中，现在我们可以将其导入到 Python 程序中使用它的功能。</p>
<h3 id="2-matplotlib-库的安装">2.matplotlib 库的安装:</h3>
<p>Matplotlib 在开篇、结尾、阅读等方面很有帮助。，Python 程序中的图像，这就是为什么安装这个用于对象检测的库成为一项重要要求的原因。如果 matplotlib 库不在我们的系统中，我们必须在命令提示符终端中使用以下命令来安装它:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install matplotlib</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/17047dfe9fa3301d5bafd3951330b44a.png" alt="Python OpenCV object detection"></p>
<p>当我们在终端中写完这个命令后按回车键，命令提示符中的 pip 安装程序将开始将其安装到我们的系统中。</p>
<p><img src="/img/adec4c14adfb1ace475b0b858085cb7f.png" alt="Python OpenCV object detection"></p>
<p>我们可以看到，matplotlib 库已经成功安装在我们的系统中，现在我们可以将其导入到 Python 程序中，使用其功能进行打开、读取等。，图像。</p>
<p>我们已经安装了执行对象检测所需的所有库，现在我们可以继续这个任务的实现部分了。</p>
<h3 id="对象检测在-Python-中的实现；">对象检测在 Python 中的实现；</h3>
<p>在这一部分，我们将编写 Python 程序来进行对象检测，并了解它的实现。我们将在 Python 程序中使用以下图像对其执行对象检测:</p>
<p><img src="/img/375d017fa4d2c447c521a96cb2840059.png" alt="Python OpenCV object detection"></p>
<h3 id="打开图像">打开图像</h3>
<p>我们将首先打开上面给出的图像，并创建图片的环境以在输出中显示它。我们先看一个示例程序来了解实现，然后再看解释部分。</p>
<p><strong>示例 1:</strong> 在 Python 程序中使用 OpenCV 和 matplotlib 库打开图像:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Import OpenCV module</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="comment"># Import pyplot from matplotlib as pltd</span></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> pltd</span><br><span class="line"><span class="comment"># Opening the image from files</span></span><br><span class="line">imaging = cv2.imread(<span class="string">&quot;opencv-od.png&quot;</span>)</span><br><span class="line"><span class="comment"># Altering properties of image with cv2</span></span><br><span class="line">/img_gray = cv2.cvtColor(imaging, cv2.COLOR_BGR2GRAY)</span><br><span class="line">imaging_rgb = cv2.cvtColor(imaging, cv2.COLOR_BGR2RGB)</span><br><span class="line"><span class="comment"># Plotting image with subplot() from plt</span></span><br><span class="line">pltd.subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># Displaying image in the output</span></span><br><span class="line">pltd.imshow(imaging_rgb)</span><br><span class="line">pltd.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<p><img src="/img/1f5765a01cb18ba3596d311e651e9cdc.png" alt="Python OpenCV object detection"></p>
<p><strong>说明:</strong></p>
<p>首先，我们将 OpenCV(作为 cv2)和 matplotlib(作为 plt)库导入到程序中，以便在代码中使用它们的功能。之后，我们使用 cv2 的 imread()函数打开了图像文件。</p>
<p>然后，我们使用 cv2 函数定义了在程序中打开的图像的属性。然后，我们使用 plt 的子图()函数对图像进行子图，并在其中给出参数。最后，我们使用了 plt 模块的 imshow()和 show()函数来显示输出中的图像。</p>
<p>正如我们在输出中看到的，图像是作为程序的结果显示的，并且它的边界已经被细分。</p>
<h3 id="图像中的识别或物体检测">图像中的识别或物体检测</h3>
<p>现在，我们将使用程序中的检测多尺度()来检测图像中存在的对象。下面是在代码中使用 detectMultiScale()函数的语法:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">found = xml_data.detectMultiScale(/img_gray, </span><br><span class="line">                                   minSize = (<span class="number">30</span>, <span class="number">30</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们将在程序中使用带有此功能的条件语句来检查是否检测到图像中的任何对象，并突出显示检测到的部分。让我们通过一个示例程序来了解图像中对象检测的实现。</p>
<p><strong>示例 2:</strong> 使用以下 Python 程序中的检测多尺度()在图像中检测对象:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Import OpenCV module</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="comment"># Import pyplot from matplotlib as plt</span></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> pltd</span><br><span class="line"><span class="comment"># Opening the image from files</span></span><br><span class="line">imaging = cv2.imread(<span class="string">&quot;opencv-od.png&quot;</span>)</span><br><span class="line"><span class="comment"># Altering properties of image with cv2</span></span><br><span class="line">imaging_gray = cv2.cvtColor(imaging, cv2.COLOR_BGR2GRAY)</span><br><span class="line">imaging_rgb = cv2.cvtColor(imaging, cv2.COLOR_BGR2RGB)</span><br><span class="line"><span class="comment"># Importing Haar cascade classifier xml data</span></span><br><span class="line">xml_data = cv2.CascadeClassifier(<span class="string">&#x27;XML-data.xml&#x27;</span>)</span><br><span class="line"><span class="comment"># Detecting object in the image with Haar cascade classifier </span></span><br><span class="line">detecting = xml_data.detectMultiScale(imaging_gray, </span><br><span class="line">                                   minSize = (<span class="number">30</span>, <span class="number">30</span>))</span><br><span class="line"><span class="comment"># Amount of object detected</span></span><br><span class="line">amountDetecting = <span class="built_in">len</span>(detecting)</span><br><span class="line"><span class="comment"># Using if condition to highlight the object detected</span></span><br><span class="line"><span class="keyword">if</span> amountDetecting != <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">for</span> (a, b, width, height) <span class="keyword">in</span> detecting:</span><br><span class="line">        cv2.rectangle(imaging_rgb, (a, b), <span class="comment"># Highlighting detected object with rectangle</span></span><br><span class="line">                      (a + height, b + width), </span><br><span class="line">                      (<span class="number">0</span>, <span class="number">275</span>, <span class="number">0</span>), <span class="number">9</span>)</span><br><span class="line"><span class="comment"># Plotting image with subplot() from plt</span></span><br><span class="line">pltd.subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># Displaying image in the output</span></span><br><span class="line">pltd.imshow(imaging_rgb)</span><br><span class="line">pltd.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<p><img src="/img/bfd4406c2ac6114374d1941c78640745.png" alt="Python OpenCV object detection"></p>
<p><strong>说明:</strong></p>
<p>在程序中打开图像后，我们已经将级联分类器 XML 文件导入到程序中。然后，我们使用导入的级联文件的**检测多尺度()**功能来检测图像中是否存在对象。</p>
<p>我们在程序中使用 if 条件来检查对象是否被检测到，如果对象被检测到，我们已经使用 <code>for</code>循环和 cv2 函数高亮显示了检测到的对象部分。高亮显示图像中检测到的物体部分后，我们使用 plt <strong>show()</strong> 和 <strong>imshow()</strong> 功能显示处理后的图像。</p>
<p>正如我们在输出中所看到的，当我们运行程序时，带有突出显示的对象检测部分的图像会显示给我们。</p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Lambda函数</title>
    <url>/posts/41f913f0.html</url>
    <content><![CDATA[<h1>Python Lambda函数</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-lambda-functions">https://www.javatpoint.com/python-lambda-functions</a></p>
</blockquote>
<p>Python Lambda 函数被称为匿名函数，它是在没有名称的情况下定义的。Python 允许我们不以标准方式声明函数，即使用 <strong>def</strong> 关键字。相反，匿名函数是通过使用<strong>λ</strong>关键字声明的。但是，Lambda 函数可以接受任意数量的参数，但是它们只能以表达式的形式返回一个值。</p>
<p>匿名函数包含一小段代码。它模拟 C 和 C++的内联函数，但并不完全是内联函数。</p>
<p>下面给出了定义匿名函数的语法。</p>
<h3 id="句法">句法</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> arguments: expression     </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它可以接受任意数量的参数，并且只有一个表达式。当需要函数对象时，它很有用。</p>
<p>考虑以下 lambda 函数的例子。</p>
<h3 id="例-1-3">例 1</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a is an argument and a+10 is an expression which got evaluated and returned.  </span></span><br><span class="line">x = <span class="keyword">lambda</span> a:a+<span class="number">10</span> </span><br><span class="line"><span class="comment"># Here we are printing the function object</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sum = &quot;</span>,x(<span class="number">20</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;function &lt;<span class="keyword">lambda</span>&gt; at <span class="number">0x0000019E285D16A8</span>&gt;</span><br><span class="line"><span class="built_in">sum</span> =  <span class="number">30</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们定义了<strong>λa:a+10</strong>匿名函数，其中 <strong>a</strong> 是一个参数， <strong>a+10</strong> 是一个表达式。给定的表达式被求值并返回结果。上述 lambda 函数与普通函数相同。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">x</span>(<span class="params">a</span>):</span><br><span class="line">	<span class="keyword">return</span> a+<span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span> = x(<span class="number">10</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例-2-2">例 2</h3>
<p>Lambda 函数的多个参数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a and b are the arguments and a*b is the expression which gets evaluated and returned.  </span></span><br><span class="line">x = <span class="keyword">lambda</span> a,b: a*b</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mul = &quot;</span>, x(<span class="number">20</span>,<span class="number">10</span>))</span><br><span class="line">**输出:**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>mul =  200</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">为什么要用 <span class="keyword">lambda</span> 函数？</span><br><span class="line">当我们在另一个函数中匿名使用 <span class="keyword">lambda</span> 函数时，在场景中可以更好地描述 <span class="keyword">lambda</span> 函数的主要作用。在 Python 中，<span class="keyword">lambda</span> 函数可以用作**高阶函数**的参数，后者接受其他函数作为参数。</span><br><span class="line">考虑以下示例:</span><br><span class="line">例 <span class="number">1</span>:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#the function table(n) prints the table of n<br>
def table(n):<br>
return lambda a:a*n # a will contain the iteration variable i and a multiple of n is returned at each function call<br>
n = int(input(“Enter the number:”))<br>
b = table(n) #the entered number is passed into the function table. b will contain a lambda function which is called again and again with the iteration variable i<br>
for i in range(1,11):<br>
print(n,“X”,i,“=”,b(i)) #the lambda function b is called with the iteration variable i</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**输出:**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Enter the number:10<br>
10 X 1 = 10<br>
10 X 2 = 20<br>
10 X 3 = 30<br>
10 X 4 = 40<br>
10 X 5 = 50<br>
10 X 6 = 60<br>
10 X 7 = 70<br>
10 X 8 = 80<br>
10 X 9 = 90<br>
10 X 10 = 100</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">lambda</span> 函数常用 Python 内置函数 **<span class="built_in">filter</span>()** 函数和 **<span class="built_in">map</span>()** 函数。</span><br><span class="line">将 <span class="keyword">lambda</span> 函数与过滤器一起使用()</span><br><span class="line">Python 内置的 **<span class="built_in">filter</span>()函数**接受一个函数和一个列表作为参数。它提供了一种有效的方法来过滤掉序列中的所有元素。它返回新的序列，在该序列中，函数评估为**真**。</span><br><span class="line">考虑下面的例子，我们从给定的列表中过滤出唯一的奇数。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#program to filter out the tuple which contains odd numbers<br>
lst = (10,22,37,41,100,123,29)<br>
oddlist = tuple(filter(lambda x:(x%3 == 0),lst)) # the tuple contains all the items of the tuple for which the lambda function evaluates to true<br>
print(oddlist)</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**输出:**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(37, 41, 123, 29)</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">使用 <span class="keyword">lambda</span> 函数和 <span class="built_in">map</span>()</span><br><span class="line">Python 中的 **<span class="built_in">map</span>()函数**接受一个函数和一个列表。它给出了一个新的列表，其中包含了函数为每个项目返回的所有修改过的项目。</span><br><span class="line">考虑以下 **<span class="built_in">map</span>()** 函数的例子。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#program to filter out the list which contains odd numbers<br>
lst = (10,20,30,40,50,60)<br>
square_list = list(map(lambda x:x**2,lst)) # the tuple contains all the items of the list for which the lambda function evaluates to true<br>
print(square_tuple)</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**输出:**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>(100, 400, 900, 1600, 2500, 3600)</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python `assert`关键字</title>
    <url>/posts/5eb69ff5.html</url>
    <content><![CDATA[<h1>Python <code>assert</code>关键字</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-assert-keyword">https://www.javatpoint.com/python-assert-keyword</a></p>
</blockquote>
<p>Python <code>assert</code>关键字被定义为测试条件的调试工具。断言主要是在程序中断言或陈述一个事实的假设。例如，在编写除法函数时，除数不应该为零，您断言除数不等于零。</p>
<p>它只是一个布尔表达式，有一个条件或表达式检查条件是否返回真或假。如果它是真的，程序什么也不做，它移动到下一行代码。但是如果它为假，它会引发一个带有可选错误消息的 <strong>AssertionError</strong> 异常。</p>
<p>断言的主要任务是通知开发人员程序中不可恢复的错误，如“找不到文件”，说断言是程序的内部自检是正确的。它对于任何应用开发领域的测试或质量保证都是最重要的。<code>assert</code>关键字的语法如下。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> condition, error_message(optional)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="为什么使用断言">为什么使用断言</h2>
<p>它是一个调试工具，主要任务是检查条件。如果它发现条件为真，它将移动到下一行代码，如果不是，则停止所有操作并引发错误。它指出了代码中的错误。</p>
<h2 id="Python-中的断言在哪里使用">Python 中的断言在哪里使用</h2>
<ul class="lvl-0">
<li class="lvl-4">
<p>检查功能的输出。</p>
</li>
<li class="lvl-4">
<p>用于测试代码。</p>
</li>
<li class="lvl-4">
<p>在检查参数值时。检查有效输入。</p>
</li>
</ul>
<h3 id="示例-1">示例 1</h3>
<p>此示例显示了使用错误消息处理断言。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">avg</span>(<span class="params">scores</span>):  </span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(scores) != <span class="number">0</span>,<span class="string">&quot;The List is empty.&quot;</span>  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(scores)/<span class="built_in">len</span>(scores)  </span><br><span class="line"></span><br><span class="line">scores2 = [<span class="number">67</span>,<span class="number">59</span>,<span class="number">86</span>,<span class="number">75</span>,<span class="number">92</span>]  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The Average of scores2:&quot;</span>,avg(scores2))  </span><br><span class="line"></span><br><span class="line">scores1 = []  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The Average of scores1:&quot;</span>,avg(scores1))  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The Average of scores2: <span class="number">75.8</span></span><br><span class="line">AssertionError: The <span class="type">List</span> <span class="keyword">is</span> empty.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:<strong>在上例中，我们将一个非空列表</strong>评分 2</strong> 和一个空列表<strong>评分 1</strong> 传递给了 <strong>avg()</strong> 函数。我们成功接收到<strong>评分 2</strong> 列表的输出，但在此之后，我们收到一个错误<strong>评估错误:列表为空</strong>。断言条件由<strong>评分 2</strong> 列表满足，并允许程序继续运行。但是，<strong>分数 1</strong> 不满足条件，给出一个 AssertionError。</p>
<h3 id="示例-2">示例 2:</h3>
<p>此示例显示了控制台中的“除以 0 错误”。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># initializing number   </span></span><br><span class="line">x = <span class="number">7</span>  </span><br><span class="line">y = <span class="number">0</span>  </span><br><span class="line"><span class="comment"># It uses assert to check for 0   </span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;x / y value is : &quot;</span>)   </span><br><span class="line"><span class="keyword">assert</span> y != <span class="number">0</span>, <span class="string">&quot;Divide by 0 error&quot;</span>  </span><br><span class="line"><span class="built_in">print</span> (x / y)   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<p>x / y 值为:</p>
<h3 id="运行时异常">运行时异常:</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):  </span><br><span class="line">  File <span class="string">&quot;main.py&quot;</span>, line <span class="number">6</span>, <span class="keyword">in</span> &lt;module&gt;  </span><br><span class="line">    <span class="keyword">assert</span> y != <span class="number">0</span>, <span class="string">&quot;Divide by 0 error&quot;</span>  </span><br><span class="line">AssertionError: Divide by <span class="number">0</span> error  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的例子中，我们已经初始化了一个整数变量，即 x=7，y=0，并尝试打印 x/y 的值作为输出。Python 解释器生成了一个运行时异常，因为 <code>assert</code>关键字发现除数为零，然后在控制台中显示**“除以 0 错误”**。</p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python SMTP发送电子邮件</title>
    <url>/posts/14808f99.html</url>
    <content><![CDATA[<h1>Python 使用 SMTP 发送电子邮件</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-sending-email">https://www.javatpoint.com/python-sending-email</a></p>
</blockquote>
<p>简单邮件传输协议(SMTP)被用作使用 Python 处理电子邮件传输的协议。它用于在电子邮件服务器之间路由电子邮件。它是一个应用层协议，允许用户向另一个用户发送邮件。接收者使用协议 **POP(邮局协议)**和 **IMAP(互联网消息访问协议)**检索电子邮件。</p>
<p><img src="/img/6dbdbeeafac53cfcf36f471474dcb304.png" alt="Python Sending Email using SMTP"></p>
<p>当服务器侦听来自客户端的 TCP 连接时，它会在端口 587 上启动连接。</p>
<p>Python 提供了一个 <strong>smtplib</strong> 模块，该模块定义了一个用于向互联网机器发送电子邮件的 SMTP 客户端会话对象。为此，我们必须使用 import 语句导入 <strong>smtplib</strong> 模块。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ <span class="keyword">import</span> smtplib</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>SMTP 对象用于电子邮件传输。以下语法用于创建 smtplib 对象。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> smtplib   </span><br><span class="line">smtpObj = smtplib.SMTP(host, port, local_hostname)    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它接受以下参数。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>**主机:**是运行您的 SMTP 服务器的机器的主机名。在这里，我们可以指定服务器的 IP 地址，如(<a href="https://www.javatpoint.com/">https://www.javatpoint.com</a>)或本地主机。这是一个可选参数。</p>
</li>
<li class="lvl-4">
<p>**端口:**是主机监听 SMTP 连接的端口号。默认为 25。</p>
</li>
<li class="lvl-4">
<p><strong>local_hostname:</strong> 如果 SMTP 服务器在你的本地机器上运行，我们可以提到本地机器的主机名。</p>
</li>
</ul>
<p>SMTP 对象的 sendmail()方法用于将邮件发送到所需的计算机。语法如下。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">smtpObj.sendmail(sender, receiver, message)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/python3  </span></span><br><span class="line"><span class="keyword">import</span> smtplib  </span><br><span class="line">sender_mail = <span class="string">&#x27;sender@fromdomain.com&#x27;</span>  </span><br><span class="line">receivers_mail = [<span class="string">&#x27;reciever@todomain.com&#x27;</span>]  </span><br><span class="line">message = <span class="string">&quot;&quot;&quot;From: From Person %s </span></span><br><span class="line"><span class="string">To: To Person %s </span></span><br><span class="line"><span class="string">Subject: Sending SMTP e-mail  </span></span><br><span class="line"><span class="string">This is a test e-mail message. </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>%(sender_mail,receivers_mail)  </span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">   smtpObj = smtplib.SMTP(<span class="string">&#x27;localhost&#x27;</span>)  </span><br><span class="line">   smtpObj.sendmail(sender_mail, receivers_mail, message)  </span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Successfully sent email&quot;</span>)  </span><br><span class="line"><span class="keyword">except</span> Exception:  </span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Error: unable to send email&quot;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="从-gmail-发送电子邮件">从 gmail 发送电子邮件</h2>
<p>有些情况下，电子邮件是使用 Gmail SMTP 服务器发送的。在这种情况下，我们可以将 Gmail 作为 SMTP 服务器传递，而不是使用端口为 587 的 localhost。</p>
<p>使用以下语法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ smtpObj = smtplib.SMTP(<span class="string">&quot;gmail.com&quot;</span>, <span class="number">587</span>)   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这里，我们需要使用 Gmail 用户名和密码登录 Gmail 账户。为此，smtplib 提供了 login()方法，该方法接受发送者的用户名和密码。</p>
<p>如果你正在使用 Gmail，这可能会让你的 Gmail 要求你访问不太安全的应用。您需要暂时打开此功能才能正常工作。</p>
<p><img src="/img/521bc9056eb7c8a53c5fe64f042469c3.png" alt="Python Sending Email using SMTP"></p>
<p>考虑下面的例子。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/python3  </span></span><br><span class="line"><span class="keyword">import</span> smtplib  </span><br><span class="line">sender_mail = <span class="string">&#x27;sender@gmail.com&#x27;</span>  </span><br><span class="line">receivers_mail = [<span class="string">&#x27;reciever@gmail.com&#x27;</span>]  </span><br><span class="line">message = <span class="string">&quot;&quot;&quot;From: From Person %s </span></span><br><span class="line"><span class="string">To: To Person %s </span></span><br><span class="line"><span class="string">Subject: Sending SMTP e-mail  </span></span><br><span class="line"><span class="string">This is a test e-mail message. </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>%(sender_mail,receivers_mail)  </span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">   password = <span class="built_in">input</span>(<span class="string">&#x27;Enter the password&#x27;</span>);  </span><br><span class="line">   smtpObj = smtplib.SMTP(<span class="string">&#x27;gmail.com&#x27;</span>,<span class="number">587</span>)  </span><br><span class="line">   smtpobj.login(sender_mail,password)  </span><br><span class="line">   smtpObj.sendmail(sender_mail, receivers_mail, message)  </span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Successfully sent email&quot;</span>)  </span><br><span class="line"><span class="keyword">except</span> Exception:  </span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Error: unable to send email&quot;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="通过电子邮件发送-HTML">通过电子邮件发送 HTML</h2>
<p>我们可以通过指定发送 HTML 的 MIME 版本、内容类型和字符集来格式化消息中的 HTML。</p>
<p>考虑下面的例子。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/python3  </span></span><br><span class="line"><span class="keyword">import</span> smtplib  </span><br><span class="line">sender_mail = <span class="string">&#x27;sender@fromdomain.com&#x27;</span>  </span><br><span class="line">receivers_mail = [<span class="string">&#x27;reciever@todomain.com&#x27;</span>]  </span><br><span class="line">message = <span class="string">&quot;&quot;&quot;From: From Person %s </span></span><br><span class="line"><span class="string">To: To Person %s </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">MIME-Version:1.0 </span></span><br><span class="line"><span class="string">Content-type:text/html </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Subject: Sending SMTP e-mail  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;h3&gt;Python SMTP&lt;/h3&gt; </span></span><br><span class="line"><span class="string">&lt;strong&gt;This is a test e-mail message.&lt;/strong&gt; </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>%(sender_mail,receivers_mail)  </span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">   smtpObj = smtplib.SMTP(<span class="string">&#x27;localhost&#x27;</span>)  </span><br><span class="line">   smtpObj.sendmail(sender_mail, receivers_mail, message)  </span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Successfully sent email&quot;</span>)  </span><br><span class="line"><span class="keyword">except</span> Exception:  </span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Error: unable to send email&quot;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python `While`循环</title>
    <url>/posts/52a29154.html</url>
    <content><![CDATA[<h1>Python <code>While</code>循环</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-while-loop">https://www.javatpoint.com/python-while-loop</a></p>
</blockquote>
<p>Python <code>While</code>循环允许执行部分代码，直到给定条件返回 false。它也被称为预测试环路。</p>
<p>它可以被看作是一个重复的 <code>if</code>语句。当我们不知道迭代次数时，<code>While</code>循环是最有效的。</p>
<p>语法如下。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> expression:  </span><br><span class="line">    statements  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，语句可以是单个语句或一组语句。表达式应该是任何导致真或假的有效 Python 表达式。true 是任何非零值，false 是 0。</p>
<h3 id="当循环流程图">当循环流程图</h3>
<p><img src="img/942f6f9df8960493f3c336b2683713e1.png" alt="Python While loop"></p>
<h2 id="循环控制语句">循环控制语句</h2>
<p>我们可以在使用循环控制语句执行循环时改变<strong>的正常顺序。当 <code>While</code>循环执行完成时，该范围内定义的所有自动对象都将被拆除。Python 提供了以下控制语句在 <code>While</code>循环中使用。</strong></p>
<p><strong>1。<code>continue</code>语句-</strong> 当遇到 <code>continue</code>语句时，控制转移到循环的开始。让我们理解下面的例子。</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># prints all letters except &#x27;a&#x27; and &#x27;t&#x27; </span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">str1 = <span class="string">&#x27;javatpoint&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">len</span>(str1): </span><br><span class="line">	<span class="keyword">if</span> str1[i] == <span class="string">&#x27;a&#x27;</span> <span class="keyword">or</span> str1[i] == <span class="string">&#x27;t&#x27;</span>: </span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Current Letter :&#x27;</span>, a[i]) </span><br><span class="line">	i += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Current Letter : j</span><br><span class="line">Current Letter : v</span><br><span class="line">Current Letter : p</span><br><span class="line">Current Letter : o</span><br><span class="line">Current Letter : i</span><br><span class="line">Current Letter : n</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>2。<code>break</code>语句-</strong> 当遇到 <code>break</code>语句时，它会将控制带出循环。</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The control transfer is transfered</span></span><br><span class="line"><span class="comment"># when break statement soon it sees t</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">str1 = <span class="string">&#x27;javatpoint&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">len</span>(str1): </span><br><span class="line">	<span class="keyword">if</span> str1[i] == <span class="string">&#x27;t&#x27;</span>: </span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Current Letter :&#x27;</span>, str1[i]) </span><br><span class="line">	i += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Current Letter : j</span><br><span class="line">Current Letter : a</span><br><span class="line">Current Letter : v</span><br><span class="line">Current Letter : a</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>3。<code>pass</code>语句-</strong><code>pass</code>语句用于声明空循环。它也用于定义空类、函数和控制语句。让我们理解下面的例子。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># An empty loop </span></span><br><span class="line">str1 = <span class="string">&#x27;javatpoint&#x27;</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">len</span>(str1): </span><br><span class="line">	i += <span class="number">1</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Value of i :&#x27;</span>, i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Value of i : <span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="示例-1-使用-While循环打印-1-到-10-的程序">示例-1:使用 <code>While</code>循环打印 1 到 10 的程序</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">i=<span class="number">1</span></span><br><span class="line"><span class="comment">#The while loop will iterate until condition becomes false.</span></span><br><span class="line">While(i&lt;=<span class="number">10</span>):  </span><br><span class="line">    <span class="built_in">print</span>(i) </span><br><span class="line">    i=i+<span class="number">1</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="示例-2-打印给定数字表的程序。">示例 2:打印给定数字表的程序。</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">i=<span class="number">1</span>  </span><br><span class="line">number=<span class="number">0</span>  </span><br><span class="line">b=<span class="number">9</span>  </span><br><span class="line">number = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the number:&quot;</span>))  </span><br><span class="line"><span class="keyword">while</span> i&lt;=<span class="number">10</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d X %d = %d \n&quot;</span>%(number,i,number*i))  </span><br><span class="line">    i = i+<span class="number">1</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the number:<span class="number">10</span></span><br><span class="line"><span class="number">10</span> X <span class="number">1</span> = <span class="number">10</span> </span><br><span class="line"></span><br><span class="line"><span class="number">10</span> X <span class="number">2</span> = <span class="number">20</span> </span><br><span class="line"></span><br><span class="line"><span class="number">10</span> X <span class="number">3</span> = <span class="number">30</span> </span><br><span class="line"></span><br><span class="line"><span class="number">10</span> X <span class="number">4</span> = <span class="number">40</span> </span><br><span class="line"></span><br><span class="line"><span class="number">10</span> X <span class="number">5</span> = <span class="number">50</span> </span><br><span class="line"></span><br><span class="line"><span class="number">10</span> X <span class="number">6</span> = <span class="number">60</span> </span><br><span class="line"></span><br><span class="line"><span class="number">10</span> X <span class="number">7</span> = <span class="number">70</span> </span><br><span class="line"></span><br><span class="line"><span class="number">10</span> X <span class="number">8</span> = <span class="number">80</span> </span><br><span class="line"></span><br><span class="line"><span class="number">10</span> X <span class="number">9</span> = <span class="number">90</span> </span><br><span class="line"></span><br><span class="line"><span class="number">10</span> X <span class="number">10</span> = <span class="number">100</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="无限-While循环">无限 <code>While</code>循环</h2>
<p>如果 <code>While</code>循环中给出的条件永远不会变为假，那么 <code>While</code>循环永远不会终止，变成<strong>无限 <code>While</code>循环。</strong></p>
<p><code>While</code>循环中的任何<strong>非零</strong>值表示<strong>始终为真</strong>条件，而零表示始终为假条件。如果我们希望我们的程序在没有任何干扰的情况下连续运行，这种方法是有用的。</p>
<h3 id="例-1-4">例 1</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>):  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hi! we are inside the infinite while loop&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Hi! we are inside the infinite <span class="keyword">while</span> loop</span><br><span class="line">Hi! we are inside the infinite <span class="keyword">while</span> loop</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例-2-3">例 2</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">var = <span class="number">1</span>  </span><br><span class="line"><span class="keyword">while</span>(var != <span class="number">2</span>):  </span><br><span class="line">    i = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the number:&quot;</span>))  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Entered value is %d&quot;</span>%(i))  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the number:<span class="number">10</span></span><br><span class="line">Entered value <span class="keyword">is</span> <span class="number">10</span></span><br><span class="line">Enter the number:<span class="number">10</span></span><br><span class="line">Entered value <span class="keyword">is</span> <span class="number">10</span></span><br><span class="line">Enter the number:<span class="number">10</span></span><br><span class="line">Entered value <span class="keyword">is</span> <span class="number">10</span></span><br><span class="line">Infinite time</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="将-else-与-While循环一起使用">将 else 与 <code>While</code>循环一起使用</h2>
<p>Python 允许我们在 <code>While</code>循环中使用 else 语句。当 while 语句中给出的条件变为 false 时，执行 else 块。就像循环一样，如果 <code>While</code>循环使用 <code>break</code>语句中断，那么 else 块将不会被执行，而 else 块之后的语句将被执行。else 语句可以选择与 <code>While</code>循环一起使用。考虑下面的例子。</p>
<h3 id="例-1-5">例 1</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">i=<span class="number">1</span> </span><br><span class="line"><span class="keyword">while</span>(i&lt;=<span class="number">5</span>):  </span><br><span class="line">    <span class="built_in">print</span>(i)  </span><br><span class="line">    i=i+<span class="number">1</span>  </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The while loop exhausted&quot;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例-2-4">例 2</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">i=<span class="number">1</span>  </span><br><span class="line"><span class="keyword">while</span>(i&lt;=<span class="number">5</span>):  </span><br><span class="line">    <span class="built_in">print</span>(i)  </span><br><span class="line">    i=i+<span class="number">1</span>  </span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">3</span>):  </span><br><span class="line">        <span class="keyword">break</span> </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The while loop exhausted&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，当遇到 <code>break</code>语句时，<code>While</code>循环停止执行并跳过 else 语句。</p>
<h3 id="示例-3-打印斐波那契数列到给定极限的程序">示例-3 打印斐波那契数列到给定极限的程序</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">terms = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the terms &quot;</span>))</span><br><span class="line"><span class="comment"># first two intial terms</span></span><br><span class="line">a = <span class="number">0</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># check if the number of terms is Zero or negative</span></span><br><span class="line"><span class="keyword">if</span> (terms &lt;= <span class="number">0</span>):</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Please enter a valid integer&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> (terms == <span class="number">1</span>):</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Fibonacci sequence upto&quot;</span>,limit,<span class="string">&quot;:&quot;</span>)</span><br><span class="line">   <span class="built_in">print</span>(a)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Fibonacci sequence:&quot;</span>)</span><br><span class="line">   <span class="keyword">while</span> (count &lt; terms) :</span><br><span class="line">       <span class="built_in">print</span>(a, end = <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">       c = a + b</span><br><span class="line">       <span class="comment"># updateing values</span></span><br><span class="line">       a = b</span><br><span class="line">       b = c</span><br><span class="line"></span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the terms <span class="number">10</span></span><br><span class="line">Fibonacci sequence:</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python `break`语句</title>
    <url>/posts/ea0bc080.html</url>
    <content><![CDATA[<h1>Python <code>break</code>语句</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-break">https://www.javatpoint.com/python-break</a></p>
</blockquote>
<p>break 是 python 中的一个关键字，用于将程序控制带出循环。<code>break</code>语句逐个中断循环，即在嵌套循环的情况下，它首先中断内部循环，然后继续到外部循环。换句话说，我们可以说 break 用于中止程序的当前执行，控制转到循环后的下一行。</p>
<p>中断通常用于我们需要为给定条件中断循环的情况。</p>
<p>中断的语法如下。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#loop statements</span></span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="例-1-6">例 1</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">4</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;item matched&quot;</span>)</span><br><span class="line">        count = count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;found at&quot;</span>,count,<span class="string">&quot;location&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">item matched</span><br><span class="line">found at <span class="number">2</span> location</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="例-2-5">例 2</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;python&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(i);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">p</span><br><span class="line">y</span><br><span class="line">t</span><br><span class="line">h</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="示例-3-使用-While循环break语句">示例 3:使用 <code>While</code>循环<code>break</code>语句</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(i,<span class="string">&quot; &quot;</span>,end=<span class="string">&quot;&quot;</span>),</span><br><span class="line">    i=i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;came out of while loop&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  came out of <span class="keyword">while</span> loop</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="例-3">例 3</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">n=<span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> i&lt;=<span class="number">10</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%d X %d = %d\n&quot;</span>%(n,i,n*i));</span><br><span class="line">        i = i+<span class="number">1</span>;</span><br><span class="line">    choice = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Do you want to continue printing the table, press 0 for no?&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> choice == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span>;    </span><br><span class="line">    n=n+<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> X <span class="number">1</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> X <span class="number">2</span> = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> X <span class="number">3</span> = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> X <span class="number">4</span> = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> X <span class="number">5</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> X <span class="number">6</span> = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> X <span class="number">7</span> = <span class="number">14</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> X <span class="number">8</span> = <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> X <span class="number">9</span> = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> X <span class="number">10</span> = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">Do you want to <span class="keyword">continue</span> printing the table, press <span class="number">0</span> <span class="keyword">for</span> no?<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> X <span class="number">1</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> X <span class="number">2</span> = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> X <span class="number">3</span> = <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> X <span class="number">4</span> = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> X <span class="number">5</span> = <span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> X <span class="number">6</span> = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> X <span class="number">7</span> = <span class="number">21</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> X <span class="number">8</span> = <span class="number">24</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> X <span class="number">9</span> = <span class="number">27</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> X <span class="number">10</span> = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">Do you want to <span class="keyword">continue</span> printing the table, press <span class="number">0</span> <span class="keyword">for</span> no?<span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python `collections`模块</title>
    <url>/posts/76d82c1f.html</url>
    <content><![CDATA[<h1>Python <code>collections</code>模块</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-collection-module">https://www.javatpoint.com/python-collection-module</a></p>
</blockquote>
<p>Python <code>collections</code>模块被定义为用于存储数据集合的容器，例如列表、字典、集合和元组等。引入它是为了改进内置收集容器的功能。</p>
<p>Python <code>collections</code>模块最早是在其 2.4 版本中引入的。</p>
<p>有以下不同类型的<code>collections</code>模块:</p>
<h2 id="namedtuple">namedtuple()</h2>
<p>Python <strong>namedtuple()</strong> 函数返回一个类似元组的对象，并为元组中的每个位置指定名称。它用于消除普通元组中记住元组对象的每个字段的索引的问题。</p>
<p><strong>示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pranshu = (<span class="string">&#x27;James&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;M&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(pranshu)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;James&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;M&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="OrderedDict">OrderedDict()</h2>
<p>Python OrderedDict()类似于字典对象，其中键保持插入顺序。如果我们再次尝试插入密钥，该密钥的前一个值将被覆盖。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> collections  </span><br><span class="line">d1=collections.OrderedDict()  </span><br><span class="line">d1[<span class="string">&#x27;A&#x27;</span>]=<span class="number">10</span>  </span><br><span class="line">d1[<span class="string">&#x27;C&#x27;</span>]=<span class="number">12</span>  </span><br><span class="line">d1[<span class="string">&#x27;B&#x27;</span>]=<span class="number">11</span>  </span><br><span class="line">d1[<span class="string">&#x27;D&#x27;</span>]=<span class="number">13</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> d1.items():  </span><br><span class="line">    <span class="built_in">print</span> (k,v)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">A <span class="number">10</span></span><br><span class="line">C <span class="number">12</span></span><br><span class="line">B <span class="number">11</span></span><br><span class="line">D <span class="number">13</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="defaultdict">defaultdict()</h2>
<p>Python defaultdict()被定义为类似字典的对象。它是内置 dict 类的子类。它提供字典提供的所有方法，但将第一个参数作为默认数据类型。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict    </span><br><span class="line">number = defaultdict(<span class="built_in">int</span>)    </span><br><span class="line">number[<span class="string">&#x27;one&#x27;</span>] = <span class="number">1</span>    </span><br><span class="line">number[<span class="string">&#x27;two&#x27;</span>] = <span class="number">2</span>    </span><br><span class="line"><span class="built_in">print</span>(number[<span class="string">&#x27;three&#x27;</span>])  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="计数器">计数器()</h2>
<p>Python 计数器是字典对象的一个子类，它有助于对哈希对象进行计数。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter    </span><br><span class="line">c = Counter()  </span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">10</span>]    </span><br><span class="line">Counter(<span class="built_in">list</span>)  </span><br><span class="line">Counter(&#123;<span class="number">1</span>:<span class="number">5</span>,<span class="number">2</span>:<span class="number">4</span>&#125;)    </span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">1</span>]    </span><br><span class="line">c = Counter(<span class="built_in">list</span>)    </span><br><span class="line"><span class="built_in">print</span>(c[<span class="number">1</span>])   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="德格">德格()</h2>
<p>Python <strong>deque()</strong> 是一个双端队列，允许我们从两端添加和移除元素。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque  </span><br><span class="line"><span class="built_in">list</span> = [<span class="string">&quot;x&quot;</span>,<span class="string">&quot;y&quot;</span>,<span class="string">&quot;z&quot;</span>]  </span><br><span class="line">deq = deque(<span class="built_in">list</span>)  </span><br><span class="line"><span class="built_in">print</span>(deq)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">deque([<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="链图对象">链图对象</h2>
<p>一个<strong>链图</strong>类用于将多个字典组合在一起以创建一个列表。链接字典存储在列表中，并且是公共的，可以通过地图属性进行访问。考虑下面的例子。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> ChainMap</span><br><span class="line">baseline = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Peter&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="string">&#x27;14&#x27;</span>&#125;</span><br><span class="line">adjustments = &#123;<span class="string">&#x27;Age&#x27;</span>: <span class="string">&#x27;14&#x27;</span>, <span class="string">&#x27;Roll_no&#x27;</span>: <span class="string">&#x27;0012&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(ChainMap(adjustments, baseline)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Roll_no&#x27;</span> ]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="用户字典对象">用户字典对象</h2>
<p>用户字典充当字典对象的包装器。字典可以通过使用<strong>用户字典</strong>对象作为属性来访问。它使使用字典变得容易。</p>
<p>它提供以下属性。</p>
<p><strong>数据</strong> -一个用来存储 UserDict 类内容的真实字典。</p>
<h2 id="用户列表对象">用户列表对象</h2>
<p>用户列表表现为列表对象的包装类。当我们想要向列表添加新功能时，它非常有用。它使使用字典变得容易。</p>
<p>它提供以下属性。</p>
<p><strong>数据</strong> -真实列表用于存储 User 类的内容。</p>
<h2 id="UserString对象"><code>UserString</code>对象</h2>
<p><strong>用户列表</strong>表现为列表对象的包装类。字典可以通过使用**<code>UserString</code>**对象作为属性来访问。它使使用字典变得容易。</p>
<p>它提供以下属性。</p>
<p><strong>数据</strong> -一个真实的<strong>字符串</strong>对象用于存储<code>UserString</code>类的内容。</p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python `continue`语句</title>
    <url>/posts/6f2b221c.html</url>
    <content><![CDATA[<h1>Python <code>continue</code>语句</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-continue">https://www.javatpoint.com/python-continue</a></p>
</blockquote>
<p>Python 中的 <code>continue</code>语句用于将程序控制带到循环的开始。<code>continue</code>语句跳过循环中剩余的代码行，并从下一次迭代开始。它主要用于循环中的特定条件，以便我们可以跳过特定条件的某些特定代码。Python 中的 <code>continue</code>语句用于将程序控制带到循环的开始。<code>continue</code>语句跳过循环中剩余的代码行，并从下一次迭代开始。它主要用于循环中的特定条件，以便我们可以跳过特定条件的某些特定代码。</p>
<h3 id="句法-2">句法</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#loop statements  </span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="comment">#the code to be skipped   </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="流程图">流程图</h3>
<p><img src="img/e71573a4080d25e950bab5a4a05a5a91.png" alt="Python continue Statement"></p>
<p>考虑下面的例子。</p>
<h3 id="例-1-7">例 1</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span>                   </span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">10</span>):              </span><br><span class="line">   i = i+<span class="number">1</span></span><br><span class="line">   <span class="keyword">if</span>(i == <span class="number">5</span>):</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">   <span class="built_in">print</span>(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>观察上述代码的输出，值 5 被跳过，因为我们在 <code>While</code>循环中提供了使用 <strong><code>continue</code>语句</strong>的 <strong>if 条件</strong>。当它与给定的条件匹配时，控制转移到 <code>While</code>循环的开始，并跳过代码中的值 5。</p>
<p>让我们看另一个例子:</p>
<h3 id="例-2-6">例 2</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;JavaTpoint&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="string">&#x27;T&#x27;</span>):</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">J</span><br><span class="line">a</span><br><span class="line">v</span><br><span class="line">a</span><br><span class="line">p</span><br><span class="line">o</span><br><span class="line">i</span><br><span class="line">n</span><br><span class="line">t</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="通过声明">通过声明</h2>
<p><code>pass</code>语句是一个空操作，因为当它被执行时什么都不会发生。它用于在语法上需要一条语句，但我们不想在它的位置使用任何可执行语句的情况。</p>
<p>例如，它可以在子类中重写父类方法时使用，但不想在子类中给出它的具体实现。</p>
<p>Pass 也用于代码将被写入某处但尚未写入程序文件的地方。考虑下面的例子。</p>
<h3 id="例子">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]  </span><br><span class="line">flag = <span class="number">0</span>  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Current element:&quot;</span>,i,end=<span class="string">&quot; &quot;</span>);  </span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">3</span>:  </span><br><span class="line">        <span class="keyword">pass</span>  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\nWe are inside pass block\n&quot;</span>);  </span><br><span class="line">        flag = <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">if</span> flag==<span class="number">1</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\nCame out of pass\n&quot;</span>);  </span><br><span class="line">        flag=<span class="number">0</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Current element: <span class="number">1</span> Current element: <span class="number">2</span> Current element: <span class="number">3</span> </span><br><span class="line">We are inside <span class="keyword">pass</span> block</span><br><span class="line"></span><br><span class="line">Came out of <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">Current element: <span class="number">4</span> Current element: <span class="number">5</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们将在下一个教程中了解有关 <code>pass</code>语句的更多信息。</p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python `for`循环</title>
    <url>/posts/a8e29766.html</url>
    <content><![CDATA[<h1>Python <code>for</code>循环</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-for-loop">https://www.javatpoint.com/python-for-loop</a></p>
</blockquote>
<p>Python 中的 for <strong>循环</strong>用于多次迭代语句或程序的一部分。它经常用于遍历数据结构，如列表、元组或字典。</p>
<p>下面给出了 python 中 <code>for</code>循环的语法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> iterating_var <span class="keyword">in</span> sequence:  </span><br><span class="line">    statement(s)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="for循环流程图"><code>for</code>循环流程图</h3>
<p><img src="/img/ee800e9141cde35a9a5db492f878e2b5.png" alt="Python for loop"></p>
<h3 id="对于使用序列的循环">对于使用序列的循环</h3>
<p><strong>示例-1:迭代用于循环的字符串</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;Python&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">P</span><br><span class="line">y</span><br><span class="line">t</span><br><span class="line">h</span><br><span class="line">o</span><br><span class="line">n</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例- 2:打印给定编号表格的程序。</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">n = <span class="number">5</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">    c = n*i</span><br><span class="line">    <span class="built_in">print</span>(c)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">35</span></span><br><span class="line"><span class="number">40</span></span><br><span class="line"><span class="number">45</span></span><br><span class="line">50s</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例-4:打印给定列表总和的程序。</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">10</span>,<span class="number">30</span>,<span class="number">23</span>,<span class="number">43</span>,<span class="number">65</span>,<span class="number">12</span>]</span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">    <span class="built_in">sum</span> = <span class="built_in">sum</span>+i</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The sum is:&quot;</span>,<span class="built_in">sum</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The <span class="built_in">sum</span> <span class="keyword">is</span>: <span class="number">183</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="对于使用范围-函数的循环">对于使用范围()函数的循环</h3>
<p><strong>范围()功能</strong></p>
<p>**范围()**功能用于生成数字序列。如果我们通过范围(10)，它将生成从 0 到 9 的数字。range()函数的语法如下。</p>
<p><strong>语法:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">range</span>(start,stop,step size)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p>开始代表迭代的开始。</p>
</li>
<li class="lvl-4">
<p>stop 表示循环将迭代到 stop-1。<strong>范围(1，5)</strong> 将生成 1 到 4 次迭代。它是可选的。</p>
</li>
<li class="lvl-4">
<p>步长用于跳过迭代中的特定数字。可以选择使用。默认情况下，步长为 1。它是可选的。</p>
</li>
</ul>
<p>请考虑以下示例:</p>
<p><strong>示例-1:按顺序打印数字的程序。</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(i,end = <span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例- 2:打印给定编号表格的程序。</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the number &quot;</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">    c = n*i</span><br><span class="line">    <span class="built_in">print</span>(n,<span class="string">&quot;*&quot;</span>,i,<span class="string">&quot;=&quot;</span>,c)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the number <span class="number">10</span></span><br><span class="line"><span class="number">10</span> * <span class="number">1</span> = <span class="number">10</span></span><br><span class="line"><span class="number">10</span> * <span class="number">2</span> = <span class="number">20</span></span><br><span class="line"><span class="number">10</span> * <span class="number">3</span> = <span class="number">30</span></span><br><span class="line"><span class="number">10</span> * <span class="number">4</span> = <span class="number">40</span></span><br><span class="line"><span class="number">10</span> * <span class="number">5</span> = <span class="number">50</span></span><br><span class="line"><span class="number">10</span> * <span class="number">6</span> = <span class="number">60</span></span><br><span class="line"><span class="number">10</span> * <span class="number">7</span> = <span class="number">70</span></span><br><span class="line"><span class="number">10</span> * <span class="number">8</span> = <span class="number">80</span></span><br><span class="line"><span class="number">10</span> * <span class="number">9</span> = <span class="number">90</span></span><br><span class="line"><span class="number">10</span> * <span class="number">10</span> = <span class="number">100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例-3:使用步长范围()打印偶数的程序。</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the number &quot;</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n,<span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the number <span class="number">20</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们也可以使用带有数字序列的 <strong>range()</strong> 函数。 <strong>len()</strong> 函数与 range()函数相结合，后者使用索引遍历序列。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;Peter&#x27;</span>,<span class="string">&#x27;Joseph&#x27;</span>,<span class="string">&#x27;Ricky&#x27;</span>,<span class="string">&#x27;Devansh&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">list</span>)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>,<span class="built_in">list</span>[i])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Hello Peter</span><br><span class="line">Hello Joseph</span><br><span class="line">Hello Ricky</span><br><span class="line">Hello Devansh</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="python-中的嵌套-for循环">python 中的嵌套 <code>for</code>循环</h2>
<p>Python 允许我们将任意数量的 <code>for</code>循环嵌套在 <strong>for</strong> 循环中。对于外部循环的每次迭代，内部循环被执行 n 次。语法如下。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> iterating_var1 <span class="keyword">in</span> sequence:  <span class="comment">#outer loop</span></span><br><span class="line">    <span class="keyword">for</span> iterating_var2 <span class="keyword">in</span> sequence:  <span class="comment">#inner loop</span></span><br><span class="line">        <span class="comment">#block of statements   </span></span><br><span class="line"><span class="comment">#Other statements  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="示例-1-循环嵌套">示例- 1:循环嵌套</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># User input for number of rows</span></span><br><span class="line">rows = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the rows:&quot;</span>))</span><br><span class="line"><span class="comment"># Outer loop will print number of rows</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,rows+<span class="number">1</span>):</span><br><span class="line"><span class="comment"># Inner loop will print number of Astrisk</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>,end = <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the rows:<span class="number">5</span></span><br><span class="line">*</span><br><span class="line">**</span><br><span class="line">***</span><br><span class="line">****</span><br><span class="line">*****</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="示例-2-数字金字塔程序。">示例-2:数字金字塔程序。</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">rows = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the rows&quot;</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,rows+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">        <span class="built_in">print</span>(i,end = <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">333</span></span><br><span class="line"><span class="number">4444</span></span><br><span class="line"><span class="number">55555</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="将-else-语句与-for循环一起使用">将 else 语句与 <code>for</code>循环一起使用</h2>
<p>与 C、C++或 Java 等其他语言不同，Python 允许我们将 else 语句与 <code>for</code>循环一起使用，该循环只能在所有迭代都用尽时执行。这里，我们必须注意到，如果循环包含任何 <code>break</code>语句，那么 else 语句将不会被执行。</p>
<h2 id="例-1-8">例 1</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">5</span>):  </span><br><span class="line">    <span class="built_in">print</span>(i)  </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;for loop completely exhausted, since there is no break.&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="keyword">for</span> loop completely exhausted, since there <span class="keyword">is</span> no <span class="keyword">break</span>.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>for</code>循环完全耗尽，因为没有中断。</p>
<h2 id="例-2-7">例 2</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">5</span>):  </span><br><span class="line">    <span class="built_in">print</span>(i)  </span><br><span class="line">    <span class="keyword">break</span>;  </span><br><span class="line"><span class="keyword">else</span>:<span class="built_in">print</span>(<span class="string">&quot;for loop is exhausted&quot;</span>);  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The loop is broken due to break statement...came out of the loop&quot;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，循环由于 <code>break</code>语句而中断；因此，else 语句不会被执行。将执行紧挨着 else 块的语句。</p>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于 <code>break</code>语句，循环中断…脱离了循环。我们将在下一个教程中了解更多关于 <code>break</code>语句的信息。</p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python `itertools`</title>
    <url>/posts/95d69c19.html</url>
    <content><![CDATA[<h1>Python <code>itertools</code></h1>
<p>Itertool 是最令人惊叹的 Python 3 标准库之一。这个库有非常酷的功能，可以说它是 Python 编程语言的瑰宝。Python 提供了 itertools 的优秀文档，但是在本教程中，我们将讨论几个重要且有用的 itertools 函数或迭代器。</p>
<p>itertools 的关键之处在于，这个库的功能用于生成内存高效且精确的代码。</p>
<p>在学习 Python itertools 之前，您应该了解 Python 迭代器和生成器。在本文中，我们将描述面向初学者和专业人士的 itertools。</p>
<h2 id="介绍">介绍</h2>
<p>根据 itertools 的官方定义，“<strong>这个模块实现了许多迭代器构建块，灵感来自 APL、Haskell 和 SML</strong> ”简而言之，迭代器的数量可以一起创建“迭代器代数”，这使得完成复杂的任务成为可能。itertools 中的函数用于生成更复杂的迭代器。让我们举个例子: <a href="https://www.javatpoint.com/python-zip-function">Python 内置的 zip()函数</a>接受任意数量的可迭代参数。它迭代元组并返回它们对应的元素。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b= [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">c = <span class="built_in">zip</span>(a,b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们传递了两个列表[1，2，3]和[‘a ‘，’ b ‘，’ c’]作为可在 <strong>zip()</strong> 函数<strong>中迭代的列表。<strong>这些列表一次返回一个元素。在 <a href="https://www.javatpoint.com/python-tutorial">Python</a> 中，实现</strong>的元素。<strong>iter</strong>()</strong> 或**。<strong>getitem</strong>()** 方法称为 iterable。</p>
<p><a href="https://www.javatpoint.com/python-iter-function">Python iter()函数</a>用于调用 iterable 并返回 iterable 的迭代器对象。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a = <span class="built_in">iter</span>(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;str_iterator <span class="built_in">object</span> at <span class="number">0x01505FA0</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://www.javatpoint.com/python-zip-function">Python zip()函数</a>在其每个参数上调用 <strong>iter()</strong> ，然后通过将结果组合成元组来调用 <strong>next()</strong> 。</p>
<h4 id="注意-如果您正在使用-zip-函数和-map-函数，这意味着您已经在使用-itertools。你不需要清楚地导入它。">注意:如果您正在使用 zip()函数和 map()函数，这意味着您已经在使用 itertools。你不需要清楚地导入它。</h4>
<h2 id="迭代器的类型">迭代器的类型</h2>
<p>itertools 模块中有各种类型的迭代器。清单如下:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>无限迭代器</p>
</li>
<li class="lvl-4">
<p>组合迭代器</p>
</li>
<li class="lvl-4">
<p>终止迭代器</p>
</li>
</ul>
<h3 id="无限迭代器">无限迭代器</h3>
<p>在 Python 中，任何可以为循环实现<strong>的对象都被称为迭代器。列表、元组、集合、字典、字符串是迭代器的例子，但是迭代器也可以是无限的，这种类型的迭代器被称为</strong>无限迭代器**。**</p>
<p><img src="/img/WX20230718-171737@2x.png" alt="无限迭代器"></p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>count(start, stop)</strong>:从开始值打印到无穷大。步骤参数是可选的，如果该值被提供给<strong>step</strong>，那么步数将被跳过。考虑以下示例:</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.count(<span class="number">10</span>,<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">50</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(i,end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">15</span> <span class="number">20</span> <span class="number">25</span> <span class="number">30</span> <span class="number">35</span> <span class="number">40</span> <span class="number">45</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>cycle(iterable):</strong>:这个迭代器从传递的参数开始按顺序打印所有值。它以循环方式打印值。考虑以下示例:</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">temp = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.cycle(<span class="string">&quot;123&quot;</span>):</span><br><span class="line">    <span class="keyword">if</span> temp &gt; <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(i,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        temp = temp+<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例- 2:使用 next()功能</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">val = [<span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;Point&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">iter</span> = itertools.cycle(val)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    <span class="comment"># Using next function</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(<span class="built_in">iter</span>), end = <span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Java T Point Java T Point</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>repeat(val,num)</strong> :顾名思义，它无限次重复打印传递的值。 <strong>num</strong> 参数是可选的。考虑以下示例:</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Printing the number repeadtly:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(itertools.repeat(<span class="number">40</span>,<span class="number">15</span>)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>**组合迭代器:**复杂的组合构造被递归生成器简化。排列、组合和笛卡尔乘积是组合构造的例子。</p>
<p>在 Python 中，有四种组合迭代器:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Product() -</strong> 用于计算可迭代输入的笛卡尔乘积。在这个函数中，我们使用可选的 <strong>repeat</strong> 关键字参数来计算可迭代函数与其自身的乘积。<strong>重复</strong>关键词代表重复次数。它以排序元组的形式返回输出。考虑以下示例:</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;We are computing cartesian product using repeat Keyword Argument:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(product([<span class="number">1</span>, <span class="number">2</span>], repeat=<span class="number">2</span>)))</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;We are computing cartesian product of the containers:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(product([<span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;point&#x27;</span>], <span class="string">&#x27;5&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;We are computing product of the containers:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(product(<span class="string">&#x27;CD&#x27;</span>, [<span class="number">4</span>, <span class="number">5</span>])))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Computing cartesian product using repeat Keyword Argument:</span><br><span class="line">[(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>)]</span><br><span class="line"></span><br><span class="line">Computing cartesian product of the containers:</span><br><span class="line">[(<span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;5&#x27;</span>), (<span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;5&#x27;</span>), (<span class="string">&#x27;point&#x27;</span>, <span class="string">&#x27;5&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">Computing product of the containers:</span><br><span class="line">[(<span class="string">&#x27;C&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;C&#x27;</span>, <span class="number">5</span>), (<span class="string">&#x27;D&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;D&#x27;</span>, <span class="number">5</span>)] </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Permutations()</strong>:用于生成可迭代表的所有可能的置换。每个元素的唯一性取决于它们的位置而不是值。它接受两个论点<strong>可重复</strong>和<strong>group_size</strong>。如果 group_size 的值为 <strong>none</strong> 或未指定，那么 group_size 将转换为可迭代的长度。</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Computing all permutation of the following list&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(permutations([<span class="number">3</span>,<span class="string">&quot;Python&quot;</span>],<span class="number">2</span>)))</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Permutations of following string&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(permutations(<span class="string">&#x27;AB&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Permutation of the given container is:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(permutations(<span class="built_in">range</span>(<span class="number">4</span>),<span class="number">2</span>)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Computing <span class="built_in">all</span> permutation of the following <span class="built_in">list</span></span><br><span class="line">[(<span class="number">3</span>, <span class="string">&#x27;Python&#x27;</span>), (<span class="string">&#x27;Python&#x27;</span>, <span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line">Permutations of following string</span><br><span class="line">[(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>), (<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;A&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">Permutation of the given container <span class="keyword">is</span>:</span><br><span class="line">[(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">2</span>), (<span class="number">0</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">0</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">0</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">2</span>)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Combinations()</strong>:用于按排序顺序打印指定组大小中作为参数传递的容器的所有可能组合(不替换)。</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Combination of list in sorted order(without replacement)&quot;</span>,<span class="built_in">list</span>(combinations([<span class="string">&#x27;B&#x27;</span>,<span class="number">3</span>],<span class="number">2</span>)))</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Combination of string in sorted order&quot;</span>,<span class="built_in">list</span>(combinations(<span class="string">&quot;ZX&quot;</span>,<span class="number">2</span>)))</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Combination of list in sorted order&quot;</span>,<span class="built_in">list</span>(combinations(<span class="built_in">range</span>(<span class="number">20</span>),<span class="number">1</span>)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Combination of <span class="built_in">list</span> <span class="keyword">in</span> <span class="built_in">sorted</span> order(without replacement) [(<span class="string">&#x27;B&#x27;</span>, <span class="number">3</span>)]</span><br><span class="line">Combination of string <span class="keyword">in</span> <span class="built_in">sorted</span> order [(<span class="string">&#x27;Z&#x27;</span>, <span class="string">&#x27;X&#x27;</span>)]</span><br><span class="line">Combination of <span class="built_in">list</span> <span class="keyword">in</span> <span class="built_in">sorted</span> order [(<span class="number">0</span>,), (<span class="number">1</span>,), (<span class="number">2</span>,), (<span class="number">3</span>,), (<span class="number">4</span>,), (<span class="number">5</span>,), (<span class="number">6</span>,), (<span class="number">7</span>,), (<span class="number">8</span>,), (<span class="number">9</span>,)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Combination_with_replacement()</strong>:它接受两个参数，第一个参数是 r 长度的元组，第二个参数是 repeat。它从可迭代的元素中返回长度为 n 的子序列，并重复相同的过程。单独的元素可以在<strong>组合中重复出现</strong></p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations_with_replacement</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Combination of string in sorted order(with replacement) is:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(combinations_with_replacement(<span class="string">&quot;XY&quot;</span>, <span class="number">3</span>)))</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Combination of list in sorted order(with replacement) is:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(combinations_with_replacement([<span class="number">4</span>, <span class="number">2</span>], <span class="number">3</span>)))</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Combination of container in sorted order(with replacement) is:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(combinations_with_replacement(<span class="built_in">range</span>(<span class="number">3</span>), <span class="number">2</span>)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Combination of string <span class="keyword">in</span> <span class="built_in">sorted</span> order(<span class="keyword">with</span> replacement) <span class="keyword">is</span>:</span><br><span class="line">[(<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;X&#x27;</span>), (<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>), (<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>), (<span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">Combination of <span class="built_in">list</span> <span class="keyword">in</span> <span class="built_in">sorted</span> order(<span class="keyword">with</span> replacement) <span class="keyword">is</span>:</span><br><span class="line">[(<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>), (<span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>), (<span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>)]</span><br><span class="line"></span><br><span class="line">Combination of container <span class="keyword">in</span> <span class="built_in">sorted</span> order(<span class="keyword">with</span> replacement) <span class="keyword">is</span>:</span><br><span class="line">[(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">2</span>)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="终止迭代器">终止迭代器</h3>
<p>终结迭代器通常用于处理小的输入序列，并根据迭代器中使用的方法的功能生成输出。</p>
<p>有不同类型的终止迭代器:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>accumulate(iter, func)</strong> :它需要两个参数，第一个参数是可迭代的，第二个参数是一个函数，在每次迭代可迭代的值时都会遵循这个函数。如果函数没有在**累加()**迭代器中定义，默认情况下会发生加法。输出变量取决于输入变量；如果输入 iterable 不包含任何值，则输出 iterable 也将为空。</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line"><span class="comment"># initializing list 1</span></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># using accumulate() that will prints the successive summation of elements</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The sum is : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(itertools.accumulate(list1)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># using accumulate() that will prints the successive multiplication of elements</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The product is : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(itertools.accumulate(list1, operator.mul)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># using accumulate() that will prints the successive summation of elements</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The sum is : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(itertools.accumulate(list1)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># using accumulate() that will prints the successive multiplication of elements</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The product is : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(itertools.accumulate(list1, operator.mul)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The <span class="built_in">sum</span> <span class="keyword">is</span> : [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">17</span>, <span class="number">26</span>, <span class="number">37</span>]</span><br><span class="line">The product <span class="keyword">is</span> : [<span class="number">1</span>, <span class="number">4</span>, <span class="number">20</span>, <span class="number">140</span>, <span class="number">1260</span>, <span class="number">13860</span>]</span><br><span class="line">The <span class="built_in">sum</span> <span class="keyword">is</span> : [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">17</span>, <span class="number">26</span>, <span class="number">37</span>]</span><br><span class="line">The product <span class="keyword">is</span> : [<span class="number">1</span>, <span class="number">4</span>, <span class="number">20</span>, <span class="number">140</span>, <span class="number">1260</span>, <span class="number">13860</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>chain(iter1，iter2)</strong> -用于打印 iterable 中以 chain 形式传递并在参数中声明的所有值。考虑以下示例:</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># declaring list 1</span></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># declaring list 2</span></span><br><span class="line">list2 = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># declaring list 3</span></span><br><span class="line">list3 = [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># using chain() function that will to print all elements of lists</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The output is : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(itertools.chain(list1, list2, list3)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The output <span class="keyword">is</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>dropwhile(func，seq)</strong> -仅在 <strong>func</strong> 之后开始打印字符。考虑以下论点:</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="comment"># initializing list</span></span><br><span class="line">list1 = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="comment"># using dropwhile() iterator that will print start displaying after condition is false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The output is : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(itertools.dropwhile(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, list1)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The output <span class="keyword">is</span>  : [<span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>filterfalse(func，seq)</strong> -我们可以通过它的名称来假设它，因为这个迭代器只打印那些为传递的函数返回 false 的值。考虑以下示例:</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># declaring list</span></span><br><span class="line">list1 = [<span class="number">12</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">27</span>, <span class="number">28</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># using filterfalse() iterator that will print false values</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The Output is: &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(itertools.filterfalse(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, list1)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The Output <span class="keyword">is</span> : [<span class="number">15</span>, <span class="number">27</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>islice(iterable,start,stop,step)</strong> -它根据给定的位置对给定的可重复进行切片。它分别接受四个参数，它们是可迭代的、容器的、起始位置的。，结束位置和步骤(可选)。</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="comment"># Declaring list</span></span><br><span class="line">list1 = [<span class="number">12</span>, <span class="number">34</span>, <span class="number">65</span>, <span class="number">73</span>, <span class="number">80</span>, <span class="number">19</span>, <span class="number">20</span>]</span><br><span class="line"><span class="comment"># using islice() iterator that will slice the list acc. to given argument</span></span><br><span class="line"><span class="comment"># starts printing from 3nd index till 8th skipping 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The sliced list values are : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(itertools.islice(list1, <span class="number">2</span>, <span class="number">8</span>, <span class="number">2</span>)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The sliced <span class="built_in">list</span> values are : [<span class="number">34</span>, <span class="number">73</span>, <span class="number">19</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>starmap(func, tuple list)</strong> -需要两个参数；第一个参数是函数，第二个参数是由元组形式的元素组成的列表。考虑下面的例子。</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># Declaring list that contain tuple as element</span></span><br><span class="line">list1 = [(<span class="number">10</span>, <span class="number">20</span>, <span class="number">15</span>), (<span class="number">18</span>, <span class="number">40</span>, <span class="number">19</span>), (<span class="number">53</span>, <span class="number">42</span>, <span class="number">90</span>), (<span class="number">16</span>, <span class="number">12</span>, <span class="number">27</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># using starmap() iterator for selection value acc. to function</span></span><br><span class="line"><span class="comment"># selects max of all tuple values</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The values acc. to function are : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(itertools.starmap(<span class="built_in">max</span>, list1)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The values acc. to function are : [<span class="number">20</span>, <span class="number">40</span>, <span class="number">90</span>, <span class="number">27</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>takewhile(func，iterable)</strong> -这是 **dropwhile()的反方向。**将打印数值，直到返回假状态。考虑以下示例:</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># Defining a list</span></span><br><span class="line">list1 = [<span class="number">20</span>, <span class="number">42</span>, <span class="number">64</span>, <span class="number">77</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># takewhile() iterator is used  to print values till condition return false.</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Print until 1st false value returned : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(itertools.takewhile(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, list1)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The <span class="built_in">list</span> values until false value <span class="keyword">return</span> : [<span class="number">20</span>, <span class="number">42</span>, <span class="number">64</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>tee(iterator, count)</strong> -它将容器分成多个迭代器，这些迭代器在参数中定义。考虑以下示例:</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># Declaring list</span></span><br><span class="line">li = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># storing list in iterator</span></span><br><span class="line">iti = <span class="built_in">iter</span>(li)</span><br><span class="line"><span class="comment"># using tee() iterator to create a list of iterators</span></span><br><span class="line"><span class="comment"># Creating list of 3 iterators having similar values.</span></span><br><span class="line">it = itertools.tee(iti, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># It will print object of iterator</span></span><br><span class="line"><span class="built_in">print</span>(it)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The iterators are : &quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">list</span>(it[i]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(&lt;itertools._tee <span class="built_in">object</span> at <span class="number">0x01B88D88</span>&gt;, &lt;itertools._tee <span class="built_in">object</span> at <span class="number">0x01B88DA8</span>&gt;, &lt;itertools._tee <span class="built_in">object</span> at <span class="number">0x01B88BA8</span>&gt;)</span><br><span class="line">The iterators are : </span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>zip_longest(iterable1, iterable2, fillval)</strong> -它按顺序交替打印 iterable 的值。如果其中一个可重复打印所有值，剩余的值将由分配给填充值的值填充。</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; The combined value of iterrables is :&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(*(itertools.zip_longest(<span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;Tpoint&#x27;</span>, fillvalue=<span class="string">&#x27;_&#x27;</span>)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The combined value of iterables <span class="keyword">is</span> :</span><br><span class="line">(<span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;T&#x27;</span>) (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;p&#x27;</span>) (<span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;o&#x27;</span>) (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;i&#x27;</span>) (<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;n&#x27;</span>) (<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;t&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在本教程中，我们讨论了几个有用的迭代器和 itertools。</p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python `math`模块</title>
    <url>/posts/d2b971a6.html</url>
    <content><![CDATA[<h1>Python <code>math</code>模块</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-math-module">https://www.javatpoint.com/python-math-module</a></p>
</blockquote>
<p>Python <code>math</code>模块被定义为最著名的数学函数，包括三角函数、表示函数、对数函数等。此外，它还定义了两个数学常数，即派和欧拉数等。</p>
<p><strong>Pie (n):</strong> 它是一个众所周知的数学常数，定义为环境与圆直径之比。它的值是 3.141592653589793。</p>
<p><strong>欧拉数(e):</strong> 定义为自然对数的底数，其值为 2.718282849045</p>
<p>下面给出了不同的<code>math</code>模块:</p>
<h3 id="math-log">math.log()</h3>
<p>此方法返回给定数字的自然对数。它是按照基数 e 计算的。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> math  </span><br><span class="line">number = <span class="number">2e-7</span>  <span class="comment"># small value of of x  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;log(fabs(x), base) is :&#x27;</span>, math.log(math.fabs(number), <span class="number">10</span>))  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">log(fabs(x), base) <span class="keyword">is</span> : -<span class="number">6.698970004336019</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&lt;</p>
<h3 id="math-log10">math.log10()</h3>
<p>此方法返回给定数字的以 10 为底的对数，称为标准对数。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> math  </span><br><span class="line">x=<span class="number">13</span>  <span class="comment"># small value of of x  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;log10(x) is :&#x27;</span>, math.log10(x))  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">log10(x) <span class="keyword">is</span> : <span class="number">1.1139433523068367</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="math-exp">math.exp()</h3>
<p>此方法在将 e 提升到给定数字后返回一个浮点数。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> math  </span><br><span class="line">number = <span class="number">5e-2</span>  <span class="comment"># small value of of x  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The given number (x) is :&#x27;</span>, number)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;e^x (using exp() function) is :&#x27;</span>, math.exp(number)-<span class="number">1</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The given number (x) <span class="keyword">is</span> : <span class="number">0.05</span></span><br><span class="line">e^x (using exp() function) <span class="keyword">is</span> : <span class="number">0.05127109637602412</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="math-pow-x，y">math.pow(x，y)</h3>
<p>此方法返回 x 的幂对应于 y 的值。如果 x 的值为负值或 y 不是整数值，则会引发值错误。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">number = math.<span class="built_in">pow</span>(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The power of number:&quot;</span>,number)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The power of number: <span class="number">100.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="math-floor-x">math.floor(x)</h3>
<p>此方法返回 x 的底值。它返回小于或等于 x 的值</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">number = math.floor(<span class="number">10.25201</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The floor value is:&quot;</span>,number)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The floor value <span class="keyword">is</span>: <span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="math-ceil-x">math.ceil(x)</h3>
<p>此方法返回 x 的上限值。它返回大于或等于 x 的值</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">number = math.ceil(<span class="number">10.25201</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The floor value is:&quot;</span>,number)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The floor value <span class="keyword">is</span>: <span class="number">11</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="math-fabs-x">math.fabs(x)</h3>
<p>这个方法返回 x 的绝对值。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">number = math.fabs(<span class="number">10.001</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The floor absolute is:&quot;</span>,number)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The absolute value <span class="keyword">is</span>: <span class="number">10.001</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="math-阶乘">math .阶乘()</h3>
<p>此方法返回给定数字 x 的阶乘。如果 x 不是整数，它将引发<strong>值错误</strong>。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">number = math.factorial(<span class="number">7</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The factorial of number:&quot;</span>,number)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The factorial of number: <span class="number">5040</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="数学-modf-x">数学. modf(x)</h3>
<p>这个方法返回 x 的小数部分和整数部分。它带有 x 是浮点数的符号。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">number = math.modf(<span class="number">44.5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The modf of number:&quot;</span>,number)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The modf of number: (<span class="number">0.5</span>, <span class="number">44.0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Python 提供了几个<code>math</code>模块，可以用单行代码执行复杂的任务。在本教程中，我们讨论了几个重要的<code>math</code>模块。</p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python `os`模块</title>
    <url>/posts/57598349.html</url>
    <content><![CDATA[<h1>Python <code>os</code>模块</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-os-module">https://www.javatpoint.com/python-os-module</a></p>
</blockquote>
<p>Python <code>os</code>模块提供了在用户和操作系统之间建立交互的工具。它提供了许多有用的操作系统功能，用于执行基于操作系统的任务和获取操作系统的相关信息。</p>
<p>该操作系统属于 Python 的标准实用程序模块。该模块提供了一种使用操作系统相关功能的可移植方式。</p>
<p>Python <code>os</code>模块允许我们处理文件和目录。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">To work <span class="keyword">with</span> the OS module, we need to <span class="keyword">import</span> the OS module.</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>os</code>模块中有一些功能如下:</p>
<h2 id="os-name（）"><a href="http://os.name">os.name</a>（）</h2>
<p>此函数提供它导入的<code>os</code>模块的名称。</p>
<p>目前，它注册了’ posix ‘，’ nt ‘，’ os2 ‘，’ ce ‘，’ java ‘和’ riscos '。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="built_in">print</span>(os.name) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">nt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="os-mkdir">os.mkdir()</h2>
<p><strong>os.mkdir()</strong> 功能用于新建目录。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.mkdir(<span class="string">&quot;d:\\newdir&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它将在名为 newdir 的 D 驱动器中创建函数字符串参数路径的新目录。</p>
<h2 id="os-getcwd">os . getcwd()</h2>
<p>它返回文件的当前工作目录(CWD)。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os   </span><br><span class="line"><span class="built_in">print</span>(os.getcwd())   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">C:\Users\Python\Desktop\ModuleOS</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="if-chdir（）">if.chdir（）</h2>
<p><strong>os</strong> 模块提供 <strong>chdir()</strong> 功能，用于更改当前工作目录。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.chdir(<span class="string">&quot;d:\\&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">d:\\</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="OS-rmr">OS . rmr()</h2>
<p><strong>rmdir()</strong> 函数删除具有绝对或相关路径的指定目录。首先，我们必须更改当前的工作目录并删除文件夹。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># It will throw a Permission error; that&#x27;s why we have to change the current working directory.</span></span><br><span class="line">os.rmdir(<span class="string">&quot;d:\\newdir&quot;</span>)</span><br><span class="line">os.chdir(<span class="string">&quot;..&quot;</span>)</span><br><span class="line">os.rmdir(<span class="string">&quot;newdir&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="os-error">os.error()</h2>
<p>函数的作用是:定义操作系统级错误。在文件名和路径无效或不可访问的情况下，它会引发错误。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># If file does not exist,</span></span><br><span class="line">    <span class="comment"># then it throw an IOError</span></span><br><span class="line">    filename = <span class="string">&#x27;Python.txt&#x27;</span></span><br><span class="line">    f = <span class="built_in">open</span>(filename, <span class="string">&#x27;rU&#x27;</span>)</span><br><span class="line">    text = f.read()</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># The Control jumps directly to here if</span></span><br><span class="line"><span class="comment"># any lines throws IOError.</span></span><br><span class="line"><span class="keyword">except</span> IOError:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(os.error) will &lt;class &#x27;OSError&#x27;&gt;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Problem reading: &#x27;</span> + filename)   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Problem reading: Python.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="os-popen">os.popen()</h2>
<p>此函数打开一个文件或从指定的命令，它返回一个连接到管道的文件对象。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os   </span><br><span class="line">fd = <span class="string">&quot;python.txt&quot;</span>    </span><br><span class="line"></span><br><span class="line"><span class="comment"># popen() is similar to open()   </span></span><br><span class="line">file = <span class="built_in">open</span>(fd, <span class="string">&#x27;w&#x27;</span>)   </span><br><span class="line">file.write(<span class="string">&quot;This is awesome&quot;</span>)   </span><br><span class="line">file.close()   </span><br><span class="line">file = <span class="built_in">open</span>(fd, <span class="string">&#x27;r&#x27;</span>)   </span><br><span class="line">text = file.read()   </span><br><span class="line"><span class="built_in">print</span>(text)   </span><br><span class="line"></span><br><span class="line"><span class="comment"># popen() provides gateway and accesses the file directly   </span></span><br><span class="line">file = os.popen(fd, <span class="string">&#x27;w&#x27;</span>)   </span><br><span class="line">file.write(<span class="string">&quot;This is awesome&quot;</span>)   </span><br><span class="line"><span class="comment"># File not closed, shown in next function.    </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">This <span class="keyword">is</span> awesome</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="os-close">os.close()</h2>
<p>该功能关闭描述符为 <strong>fr</strong> 的关联文件。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os   </span><br><span class="line">fr = <span class="string">&quot;Python1.txt&quot;</span>  </span><br><span class="line">file = <span class="built_in">open</span>(fr, <span class="string">&#x27;r&#x27;</span>)   </span><br><span class="line">text = file.read()   </span><br><span class="line"><span class="built_in">print</span>(text)   </span><br><span class="line">os.close(file)     </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;main.py&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> </span><br><span class="line">    file = <span class="built_in">open</span>(fr, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">FileNotFoundError: [Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">&#x27;Python1.txt&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="os-rename">os.rename()</h2>
<p>可以使用 <strong>os.rename()</strong> 函数重命名文件或目录。如果用户有权更改文件，则可以重命名该文件。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os   </span><br><span class="line">fd = <span class="string">&quot;python.txt&quot;</span>  </span><br><span class="line">os.rename(fd,<span class="string">&#x27;Python1.txt&#x27;</span>)   </span><br><span class="line">os.rename(fd,<span class="string">&#x27;Python1.txt&#x27;</span>)   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;main.py&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> </span><br><span class="line">    os.rename(fd,<span class="string">&#x27;Python1.txt&#x27;</span>)</span><br><span class="line">FileNotFoundError: [Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">&#x27;python.txt&#x27;</span> -&gt; <span class="string">&#x27;Python1.txt&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="os-access">os.access()</h2>
<p>该函数使用真实的 <strong>uid/gid</strong> 来测试调用用户是否可以访问路径。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os   </span><br><span class="line"><span class="keyword">import</span> sys  </span><br><span class="line"></span><br><span class="line">path1 = os.access(<span class="string">&quot;Python.txt&quot;</span>, os.F_OK)   </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Exist path:&quot;</span>, path1)   </span><br><span class="line"></span><br><span class="line"><span class="comment"># Checking access with os.R_OK   </span></span><br><span class="line">path2 = os.access(<span class="string">&quot;Python.txt&quot;</span>, os.R_OK)   </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;It access to read the file:&quot;</span>, path2)   </span><br><span class="line"></span><br><span class="line"><span class="comment"># Checking access with os.W_OK   </span></span><br><span class="line">path3 = os.access(<span class="string">&quot;Python.txt&quot;</span>, os.W_OK)   </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;It access to write the file:&quot;</span>, path3)   </span><br><span class="line"></span><br><span class="line"><span class="comment"># Checking access with os.X_OK   </span></span><br><span class="line">path4 = os.access(<span class="string">&quot;Python.txt&quot;</span>, os.X_OK)   </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Check if path can be executed:&quot;</span>, path4)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Exist path: <span class="literal">False</span></span><br><span class="line">It access to read the file: <span class="literal">False</span></span><br><span class="line">It access to write the file: <span class="literal">False</span></span><br><span class="line">Check <span class="keyword">if</span> path can be executed: <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python `pass`</title>
    <url>/posts/d77b8894.html</url>
    <content><![CDATA[<h1>Python <code>pass</code></h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-pass">https://www.javatpoint.com/python-pass</a></p>
</blockquote>
<p>在 Python 中，<code>pass</code>关键字用于不执行任何内容；这意味着，当我们不想执行代码时，可以使用 pass 来执行 empty。它和名字所指的一样。它只是让控件在不执行任何代码的情况下通过。如果我们想绕过任何代码，可以使用 <code>pass</code>语句。</p>
<p>当一条语句在语法上是必需的时，这是有益的，但是我们希望我们不希望以后执行它。注释和 pass 的区别在于，注释完全被 Python 解释器忽略，而 <code>pass</code>语句没有被忽略。</p>
<p>假设我们有一个循环，我们现在不想执行，但我们将在未来执行。这里我们可以使用通行证。</p>
<p>考虑下面的例子。</p>
<p><strong>示例-通过声明</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pass is just a placeholder for</span></span><br><span class="line"><span class="comment"># we will adde functionality later.</span></span><br><span class="line">values = &#123;<span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;n&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> values:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例- 2:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]: </span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This is pass block&quot;</span>,i)</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">This <span class="keyword">is</span> <span class="keyword">pass</span> block <span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以使用 <code>pass</code>语句创建空的类或函数。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Empty Function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function_name</span>(<span class="params">args</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment">#Empty Class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python `random`模块</title>
    <url>/posts/80bcbda7.html</url>
    <content><![CDATA[<h1>Python <code>random</code>模块</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-random-module">https://www.javatpoint.com/python-random-module</a></p>
</blockquote>
<p>Python <code>random</code>模块函数依赖于伪随机数生成器函数 random()，该函数生成 0.0 到 1.0 之间的浮点数。</p>
<p><code>random</code>模块中使用了不同类型的函数，如下所示:</p>
<h3 id="random-random">random.random()</h3>
<p>该函数生成 0.0 到 1.0 之间的随机浮点数。</p>
<h3 id="random-randint">random.randint()</h3>
<p>此函数返回指定整数之间的随机整数。</p>
<h3 id="random-choice">random.choice()</h3>
<p>该函数从非空序列中返回随机选择的元素。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># importing &quot;random&quot;  module.</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment"># We are using the choice() function to generate a random number from</span></span><br><span class="line"><span class="comment"># the given list of numbers.</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;The random number from list is : &quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> (random.choice([<span class="number">50</span>, <span class="number">41</span>, <span class="number">84</span>, <span class="number">40</span>, <span class="number">31</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The random number <span class="keyword">from</span> <span class="built_in">list</span> <span class="keyword">is</span> : <span class="number">84</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="random-shuffle">random.shuffle()</h3>
<p>这个函数随机地重新排序列表中的元素。</p>
<h3 id="random-randrange-求、结束、步">random.randrange(求、结束、步)</h3>
<p>此函数用于生成一个在其参数中指定的范围内的数字。它接受三个参数，开始数字、最后数字和步长，用于跳过范围内的数字。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># We are using randrange() function to generate in range from 100</span></span><br><span class="line"><span class="comment"># to 500\. The last parameter 10 is step size to skip</span></span><br><span class="line"><span class="comment"># ten numbers when selecting.</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;A random number from range is : &quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> (random.randrange(<span class="number">100</span>, <span class="number">500</span>, <span class="number">10</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">A random number <span class="keyword">from</span> <span class="built_in">range</span> <span class="keyword">is</span> : <span class="number">290</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="random-seed">random.seed()</h3>
<p>此函数用于应用带有种子参数的特定随机数。它返回映射器值。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># importing &quot;random&quot; module.</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment"># using random() to generate a random number</span></span><br><span class="line"><span class="comment"># between 0 and 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The random number between 0 and 1 is : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(random.random())</span><br><span class="line"></span><br><span class="line"><span class="comment"># using seed() to seed a random number</span></span><br><span class="line">random.seed(<span class="number">4</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The random number between <span class="number">0</span> <span class="keyword">and</span> <span class="number">1</span> <span class="keyword">is</span> : <span class="number">0.4405576668981033</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python `sklearn.impute`模块</title>
    <url>/posts/475a55ae.html</url>
    <content><![CDATA[<h1>Python <code>sklearn.impute</code>模块</h1>
<p>在本教程中，我们将学习 Sklearn 库的 simple Current 模块，它以前被称为 Current 模块，但在 Sklearn 库的最新版本中进行了更新。我们将讨论 SimpleImputer 类，以及如何使用它来处理数据集中缺失的数据，并使用 Python 程序替换数据集中缺失的值。</p>
<h2 id="simpleinputer-类">simpleinputer 类</h2>
<p>我们可以用来处理预测模型数据集中缺失值的 scikit-learn 类称为 simple Current 类。在这个类的帮助下，我们可以用指定的占位符替换数据集中的 NaN(缺失值)值。我们可以通过在程序中使用 simpleCurrent()方法来实现和使用这个模块类。</p>
<h3 id="SimpleImputer-方法的语法">SimpleImputer()方法的语法:</h3>
<p>要在 Python 程序中实现 SimpleCurrent()类方法，我们必须使用以下语法:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">SimpleImputer(missingValues, strategy)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>**参数:**以下是使用简单估算()方法时必须定义的参数:</p>
<ol>
<li class="lvl-4">
<p><strong>missingValues:</strong> 是 SimpleImputer()方法中的缺失值占位符，必须在执行过程中进行估算，缺省情况下，缺失值占位符的值为 NaN。</p>
</li>
<li class="lvl-4">
<p><strong>strategy</strong>:是要替换数据集中缺失值(NaN 值)的数据，默认情况下，这个参数的取值方法是‘Mean’。简单估算()方法的策略参数可以采用“平均值”、“模式”、“中位数”(中心趋势测量方法)和“常数”值输入。</p>
</li>
<li class="lvl-4">
<p><strong>fillValue:</strong> 如果我们给出‘常量’作为替代值的方法，这个参数只在策略参数中使用。我们必须为策略参数定义常数值，它将替换数据集中的 NaN 值。</p>
</li>
</ol>
<p>SimpleImputer 类是 Sklearn 库的模块类，要使用这个类，首先我们必须在系统中安装 Sklearn 库，如果它还不存在的话。</p>
<h3 id="Sklearn-库的安装">Sklearn 库的安装:</h3>
<p>我们可以通过在系统的命令终端提示符下使用以下命令来安装 Sklearn:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install sklearn</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>按下回车键后，sklearn 模块将开始在我们的设备中安装，如下所示:</p>
<p><img src="/img/e2c586b8d07713fbfc826a1261ed9e87.png" alt="Python SimpleImputer module"></p>
<p>现在，我们的系统中安装了 Sklearn 模块，我们可以继续使用 simple Current 类函数。</p>
<h3 id="用-simple-Current-类处理数据集中的-NaN-值">用 simple Current 类处理数据集中的 NaN 值</h3>
<p>现在，我们将在 Python 程序中使用 SimpleImputer 类来处理数据集中缺少的值(我们将在程序中使用)。我们将在示例程序中定义一个数据集，同时给出其中一些缺失的值，然后我们使用 SimpleImputer 类方法通过定义数据集的参数来处理这些值。让我们通过一个示例 Python 程序来理解这一点的实现。</p>
<p><strong>示例 1:</strong> 看看下面的 Python 程序，其中定义了一个数据集，其中定义了 NaN 值:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Import numpy module as nmp</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> nmp</span><br><span class="line"><span class="comment"># Importing SimpleImputer class from sklearn impute module</span></span><br><span class="line"><span class="keyword">from</span> sklearn.impute <span class="keyword">import</span> SimpleImputer</span><br><span class="line"><span class="comment"># Setting up imputer function variable</span></span><br><span class="line">imputerFunc = SimpleImputer(missing_values = nmp.nan, strategy =<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line"><span class="comment"># Defining a dataset</span></span><br><span class="line">dataSet = [[<span class="number">32</span>, nmp.nan, <span class="number">34</span>, <span class="number">47</span>], [<span class="number">17</span>, nmp.nan, <span class="number">71</span>, <span class="number">53</span>], [<span class="number">19</span>, <span class="number">29</span>, nmp.nan, <span class="number">79</span>], [nmp.nan, <span class="number">31</span>, <span class="number">23</span>, <span class="number">37</span>], [<span class="number">19</span>, nmp.nan, <span class="number">79</span>, <span class="number">53</span>]]</span><br><span class="line"><span class="comment"># Print original dataset</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The Original Dataset we defined in the program: \n&quot;</span>, dataSet)</span><br><span class="line"><span class="comment"># Imputing dataset by replacing missing values</span></span><br><span class="line">imputerFunc = imputerFunc.fit(dataSet)</span><br><span class="line">dataSet2 = imputerFunc.transform(dataSet)</span><br><span class="line"><span class="comment"># Printing imputed dataset</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The imputed dataset after replacing missing values from it: \n&quot;</span>, dataSet2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The Original Dataset we defined <span class="keyword">in</span> the program: </span><br><span class="line"> [[<span class="number">32</span>, nan, <span class="number">34</span>, <span class="number">47</span>], [<span class="number">17</span>, nan, <span class="number">71</span>, <span class="number">53</span>], [<span class="number">19</span>, <span class="number">29</span>, nan, <span class="number">79</span>], [nan, <span class="number">31</span>, <span class="number">23</span>, <span class="number">37</span>], [<span class="number">19</span>, nan, <span class="number">79</span>, <span class="number">53</span>]]</span><br><span class="line">The imputed dataset after replacing missing values <span class="keyword">from</span> it: </span><br><span class="line"> [[<span class="number">32</span>\.   <span class="number">30</span>\.   <span class="number">34</span>\.   <span class="number">47</span>\.  ]</span><br><span class="line"> [<span class="number">17</span>\.   <span class="number">30</span>\.   <span class="number">71</span>\.   <span class="number">53</span>\.  ]</span><br><span class="line"> [<span class="number">19</span>\.   <span class="number">29</span>\.   <span class="number">51.75</span> <span class="number">79</span>\.  ]</span><br><span class="line"> [<span class="number">21.75</span> <span class="number">31</span>\.   <span class="number">23</span>\.   <span class="number">37</span>\.  ]</span><br><span class="line"> [<span class="number">19</span>\.   <span class="number">30</span>\.   <span class="number">79</span>\.   <span class="number">53</span>\.  ]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>我们首先将 numpy 模块(用于定义数据集)和 sklearn 模块(用于使用 SimpleImputer 类方法)导入到程序中。然后，我们使用简单估算器类方法定义估算器来处理缺失值，并使用“平均”策略来替换数据集中的缺失值。之后，我们在程序中使用 numpy 模块函数定义了一个数据集，并给出了数据集中的一些缺失值(NaN 值)。然后，我们在输出中打印原始数据集。之后，我们对数据集中缺失的值进行了估算，并用我们之前在简单估算类的程序中定义的估算值进行了替换。在输入数据集并替换其中缺失的值后，我们打印了新的数据集。</p>
<p>正如我们在输出中所看到的，估算值数据集在缺少值的地方有平均值，这就是我们如何使用 simple Current 模块类来处理数据集中的 NaN 值。</p>
<h2 id="结论">结论</h2>
<p>我们已经阅读了该方法中的 simple Current 类方法，并了解了如何使用它来处理数据集中存在的 NaN 值。我们了解了策略值参数，我们使用它来定义替换数据集的 NaN 值的方法。我们还了解了 Sklearn 库的安装，最后，我们在一个示例中使用了 simple Current 类方法来估算数据集。</p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python `statistics`模块</title>
    <url>/posts/ead347d8.html</url>
    <content><![CDATA[<h1>Python <code>statistics</code>模块</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-statistics-module">https://www.javatpoint.com/python-statistics-module</a></p>
</blockquote>
<p>Python <code>statistics</code>模块提供了对数值数据进行数理统计的功能。本模块中定义了一些流行的统计函数。</p>
<h2 id="均值-函数">均值()函数</h2>
<p>mean()函数用于计算列表中数字的算术平均值。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> statistics  </span><br><span class="line"><span class="comment"># list of positive integer numbers </span></span><br><span class="line">datasets = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>]   </span><br><span class="line">x = statistics.mean(datasets)   </span><br><span class="line"><span class="comment"># Printing the mean </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Mean is :&quot;</span>, x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Mean <span class="keyword">is</span> : <span class="number">4.857142857142857</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="中值-函数">中值()函数</h2>
<p>中值()函数用于返回列表中数值数据的中间值。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> statistics   </span><br><span class="line">datasets = [<span class="number">4</span>, -<span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">5</span>, -<span class="number">2</span>]    </span><br><span class="line"><span class="comment"># Printing median of the </span></span><br><span class="line"><span class="comment"># random data-set </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Median of data-set is : % s &quot;</span></span><br><span class="line">        % (statistics.median(datasets)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Median of data-<span class="built_in">set</span> <span class="keyword">is</span> : <span class="number">4.5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="mode-函数">mode()函数</h2>
<p>mode()函数返回列表中最常见的数据。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> statistics   </span><br><span class="line"><span class="comment"># declaring a simple data-set consisting of real valued positive integers. </span></span><br><span class="line">dataset =[<span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">8</span>]   </span><br><span class="line"><span class="comment"># Printing out the mode of given data-set </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Calculated Mode % s&quot;</span> % (statistics.mode(dataset)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Calculated Mode <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="stdev-函数">stdev()函数</h2>
<p>stdev()函数用于计算给定样本的标准偏差，该样本以列表形式提供。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> statistics   </span><br><span class="line"><span class="comment"># creating a simple data - set </span></span><br><span class="line">sample = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]   </span><br><span class="line"><span class="comment"># Prints standard deviation </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Standard Deviation of sample is % s &quot;</span> </span><br><span class="line">                % (statistics.stdev(sample))) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Standard Deviation of sample <span class="keyword">is</span> <span class="number">1.5811388300841898</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="中位数-低">中位数 _ 低()</h2>
<p>中值低函数用于返回列表中数值数据的低中值。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> statistics   </span><br><span class="line"><span class="comment"># simple list of a set of integers </span></span><br><span class="line">set1 = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>]   </span><br><span class="line"><span class="comment"># Note: low median will always be a member of the data-set.   </span></span><br><span class="line"><span class="comment"># Print low median of the data-set </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Low median of data-set is % s &quot;</span> </span><br><span class="line">        % (statistics.median_low(set1)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Low median of the data-<span class="built_in">set</span> <span class="keyword">is</span> <span class="number">5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="中位数-高">中位数 _ 高()</h2>
<p>中值高函数用于返回列表中数值数据的高中值。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> statistics   </span><br><span class="line"><span class="comment"># list of set of the integers </span></span><br><span class="line">dataset = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>]   </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;High median of data-set is %s &quot;</span> </span><br><span class="line">        % (statistics.median_high(dataset)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">High median of the data-<span class="built_in">set</span> <span class="keyword">is</span> <span class="number">6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python `sys`模块</title>
    <url>/posts/8e495c40.html</url>
    <content><![CDATA[<h1>Python <code>sys</code>模块</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-sys-module">https://www.javatpoint.com/python-sys-module</a></p>
</blockquote>
<p>python <code>sys</code>模块提供了用于操作 python 运行时环境不同部分的函数和变量。它允许我们访问系统特定的参数和功能。</p>
<p><strong>导入系统</strong></p>
<p>首先，在运行任何函数之前，我们必须在程序中导入 <code>sys</code>模块。</p>
<p><strong><code>sys</code>模块</strong></p>
<p>该函数提供已导入的现有 python 模块的名称。</p>
<p>【T0 缝合. argv】t1</p>
<p>该函数返回传递给 Python 脚本的命令行参数列表。脚本的名称始终是索引 0 处的项，其余的参数存储在后续的索引中。</p>
<p><strong>sys.base_exec_prefix</strong></p>
<p>该函数提供了一种有效的方法来获得与 exec_prefix 相同的值。如果不运行虚拟环境，该值将保持不变。</p>
<p><strong>sys.base_prefix</strong></p>
<p>它在 Python 启动期间，在 <a href="http://site.py">site.py</a> 运行之前被设置为与前缀相同的值。</p>
<p><strong>缝.字节顺序</strong></p>
<p>这是本机 byteorder 的一个指示，它提供了一种有效的方式来做某事。</p>
<p>【T0 缝合.最大尺寸】T1</p>
<p>此函数返回变量的最大整数。</p>
<p><strong>系统路径</strong></p>
<p>该函数显示当前系统中的 PYTHONPATH 集。它是一个环境变量，是所有 python 模块的搜索路径。</p>
<p><strong>系统</strong></p>
<p>它是一个对象，在程序开始时包含 stdin 的原始值，并在结束时使用。它可以恢复文件。</p>
<p><strong>系统命中计数</strong></p>
<p>此函数返回对象的引用计数。</p>
<p><strong>系统退出</strong></p>
<p>该函数用于从 Python 控制台或命令提示符退出，也用于在出现异常时退出程序。</p>
<p><strong>系统可执行文件</strong></p>
<p>这个函数的值是 Python 解释器的绝对路径。了解 python 在其他机器上的安装位置非常有用。</p>
<p><strong>系统平台</strong></p>
<p>该函数的这个值用于标识我们工作的平台。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 中的第二大数字</title>
    <url>/posts/66b1a133.html</url>
    <content><![CDATA[<h1>Python 中的第二大数字</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/second-largest-number-in-python">https://www.javatpoint.com/second-largest-number-in-python</a></p>
</blockquote>
<p>当我们的列表中有很多元素时，我们会想到找到最高或最低的元素，Python 让我们变得更加容易。</p>
<p>在本文中，我们将讨论如何从列表中找到 Python 中的第二大数字。</p>
<ol>
<li class="lvl-4">
<p>排序列表，然后打印倒数第二个数字。</p>
</li>
<li class="lvl-4">
<p>移除最大元素。</p>
</li>
<li class="lvl-4">
<p>寻找最大元素。</p>
</li>
<li class="lvl-4">
<p>遍历列表。</p>
</li>
</ol>
<p>让我们看看第一种方法-</p>
<h2 id="排序列表，然后打印倒数第二个数字">排序列表，然后打印倒数第二个数字</h2>
<p>下面的程序说明了我们如何用 Python 实现它</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#program to find the second largest number of list</span></span><br><span class="line"><span class="comment"># declaring the list</span></span><br><span class="line">list_val = [<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">25</span>, <span class="number">10</span>]</span><br><span class="line"><span class="comment"># sorting the list</span></span><br><span class="line">list_val.sort()</span><br><span class="line"><span class="comment">#displaying the second last element of the list</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The second largest element of the list is:&quot;</span>, list_val[-<span class="number">2</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The second largest element of the <span class="built_in">list</span> <span class="keyword">is</span>: <span class="number">30</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>是时候解释一下了-</p>
<ol>
<li class="lvl-4">
<p>我们已经声明了要从中取出倒数第二个元素的列表。</p>
</li>
<li class="lvl-4">
<p>在此之后，我们使用了排序方法，以便列表中的所有元素都按升序排列。</p>
</li>
<li class="lvl-4">
<p>现在我们使用负索引，因为第二大数字将出现在倒数第二的位置。</p>
</li>
</ol>
<p>第二种方法是通过移除最大元素来获得列表的第二大元素。</p>
<p>让我们看看我们能怎么做。</p>
<h2 id="移除最大元素">移除最大元素</h2>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#program to find the second largest number of list</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># declaring the list</span></span><br><span class="line">list_val = [<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">25</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># new_list is a set of list1</span></span><br><span class="line">res_list = <span class="built_in">set</span>(list_val)</span><br><span class="line"></span><br><span class="line"><span class="comment">#removing the maximum element</span></span><br><span class="line">res_list.remove(<span class="built_in">max</span>(res_list))</span><br><span class="line"></span><br><span class="line"><span class="comment">#printing the second largest element </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(res_list))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">30</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>解释-</strong></p>
<p>让我们了解我们在上面的程序中做了什么-</p>
<ol>
<li class="lvl-4">
<p>我们已经声明了要从中取出倒数第二个元素的列表。</p>
</li>
<li class="lvl-4">
<p>在此之后，我们使用 set 方法获取列表中所有唯一的元素。</p>
</li>
<li class="lvl-4">
<p>现在我们使用 max()从列表中获取最大值，然后删除它。</p>
</li>
<li class="lvl-4">
<p>之后，我们打印结果列表的最大值，这将给出第二大的数字。</p>
</li>
</ol>
<p>在第三种方法中，我们将使用 <code>for</code>循环并从列表中找到第二大数字。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># declaring empty list</span></span><br><span class="line">list_val = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># user provides the number of elements to be added in the list</span></span><br><span class="line">num_list = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter number of elements in list: &quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, num_list + <span class="number">1</span>):</span><br><span class="line">	element = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the elements: &quot;</span>))</span><br><span class="line">	list_val.append(element)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sort the list</span></span><br><span class="line">list_val.sort()</span><br><span class="line"></span><br><span class="line"><span class="comment"># print second largest element</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Second largest element is:&quot;</span>, list_val[-<span class="number">2</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter number of elements <span class="keyword">in</span> <span class="built_in">list</span>: <span class="number">5</span></span><br><span class="line"></span><br><span class="line">Enter the elements: <span class="number">10</span></span><br><span class="line"></span><br><span class="line">Enter the elements: <span class="number">20</span></span><br><span class="line"></span><br><span class="line">Enter the elements: <span class="number">30</span></span><br><span class="line"></span><br><span class="line">Enter the elements: <span class="number">40</span></span><br><span class="line"></span><br><span class="line">Enter the elements: <span class="number">50</span></span><br><span class="line">The second largest element <span class="keyword">is</span>: <span class="number">40</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>解释-</strong></p>
<p>让我们看看我们在这里做了什么-</p>
<ol>
<li class="lvl-4">
<p>我们已经声明了一个空列表，我们将在其中插入元素。</p>
</li>
<li class="lvl-4">
<p>之后，我们要求用户提供我们想要添加到列表中的元素数量。</p>
</li>
<li class="lvl-4">
<p>在此之后，我们使用排序方法，以便列表中的所有元素都按升序排列。</p>
</li>
<li class="lvl-4">
<p>现在我们使用负索引，因为第二大数字将出现在倒数第二的位置。</p>
</li>
</ol>
<h2 id="遍历列表">遍历列表</h2>
<p>在最后一个程序中，我们将遍历列表找出最大的数字，然后利用条件语句从列表中找到第二大的数字。</p>
<p>下面的程序说明了同样的情况-</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc_largest</span>(<span class="params">arr</span>):</span><br><span class="line">	second_largest = arr[<span class="number">0</span>]</span><br><span class="line">	largest_val = arr[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">		<span class="keyword">if</span> arr[i] &gt; largest_val:</span><br><span class="line">			largest_val = arr[i]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">		<span class="keyword">if</span> arr[i] &gt; second_largest <span class="keyword">and</span> arr[i] != largest_val:</span><br><span class="line">			second_largest = arr[i]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> second_largest</span><br><span class="line"><span class="built_in">print</span>(calc_largest([<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">25</span>, <span class="number">10</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">30</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>解释-</strong></p>
<p>让我们了解我们在上面的程序中做了什么-</p>
<ol>
<li class="lvl-4">
<p>第一步是创建一个函数，通过遍历来检查列表中最大的数字。</p>
</li>
<li class="lvl-4">
<p>在下一个 <code>for</code>循环中，我们再次遍历列表以找到最高的数字，但这次不包括前一个，因为这里我们的目标是找到第二大函数。</p>
</li>
<li class="lvl-4">
<p>最后，我们在函数中传递我们的列表。</p>
</li>
</ol>
<p>因此，在本文中，我们有机会跳出框框思考，并发现一些新的方法来开发在 Python 中寻找第二大数字的逻辑。</p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 元组</title>
    <url>/posts/3bfa306a.html</url>
    <content><![CDATA[<h1>Python 元组</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-tuples">https://www.javatpoint.com/python-tuples</a></p>
</blockquote>
<p>Python Tuple 用于存储不可变 Python 对象的序列。元组类似于列表，因为存储在列表中的项目的值可以改变，而元组是不可变的，并且存储在元组中的项目的值不能改变。</p>
<h2 id="创建元组">创建元组</h2>
<p>元组可以写成逗号分隔(，)值的集合，用小括号()括起来。圆括号是可选的，但使用它是一种好的做法。元组可以定义如下。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">T1 = (<span class="number">101</span>, <span class="string">&quot;Peter&quot;</span>, <span class="number">22</span>)  </span><br><span class="line">T2 = (<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>)   </span><br><span class="line">T3 = <span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(T1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(T2))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(T3))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="注意-不用括号创建的元组也称为元组打包。">注意:不用括号创建的元组也称为元组打包。</h4>
<p>可以如下创建一个空元组。</p>
<p>T4 = ()</p>
<p>用单个元素创建元组略有不同。我们需要在元素后面放一个逗号来声明元组。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="string">&quot;JavaTpoint&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(tup1))</span><br><span class="line"><span class="comment">#Creating a tuple with single element </span></span><br><span class="line">tup2 = (<span class="string">&quot;JavaTpoint&quot;</span>,)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(tup2))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>元组的索引方式与列表相同。元组中的项可以通过使用它们特定的索引值来访问。</p>
<p>考虑以下元组示例:</p>
<h3 id="示例-1-2">示例- 1</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tuple1 = (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>)  </span><br><span class="line"><span class="built_in">print</span>(tuple1)  </span><br><span class="line">count = <span class="number">0</span>  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tuple1:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;tuple1[%d] = %d&quot;</span>%(count, i)) </span><br><span class="line">    count = count+<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>)</span><br><span class="line">tuple1[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">tuple1[<span class="number">1</span>] = <span class="number">20</span></span><br><span class="line">tuple1[<span class="number">2</span>] = <span class="number">30</span></span><br><span class="line">tuple1[<span class="number">3</span>] = <span class="number">40</span></span><br><span class="line">tuple1[<span class="number">4</span>] = <span class="number">50</span></span><br><span class="line">tuple1[<span class="number">5</span>] = <span class="number">60</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="示例-2-2">示例- 2</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tuple1 = <span class="built_in">tuple</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the tuple elements ...&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(tuple1)  </span><br><span class="line">count = <span class="number">0</span>  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tuple1:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;tuple1[%d] = %s&quot;</span>%(count, i)) </span><br><span class="line">    count = count+<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the <span class="built_in">tuple</span> elements ..<span class="number">.123456</span></span><br><span class="line">(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">tuple1[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">tuple1[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">tuple1[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">tuple1[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line">tuple1[<span class="number">4</span>] = <span class="number">5</span></span><br><span class="line">tuple1[<span class="number">5</span>] = <span class="number">6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>元组的索引方式与列表相同。元组中的项可以通过使用它们特定的索引值来访问。</p>
<p>我们将在教程的这一部分看到 tuple 的所有这些方面。</p>
<h2 id="元组索引和切片">元组索引和切片</h2>
<p>元组中的索引和切片类似于列表。元组中的索引从 0 开始，到长度(元组)- 1。</p>
<p>元组中的项可以通过使用 index []运算符来访问。Python 还允许我们使用冒号运算符来访问元组中的多个项目。</p>
<p>请参考下图，详细了解索引和切片。</p>
<p><img src="/img/ba543fe02b5f3d6b398ff50d3b4a7b01.png" alt="Python Tuple"></p>
<p>考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tup = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line"><span class="built_in">print</span>(tup[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(tup[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(tup[<span class="number">2</span>])</span><br><span class="line"><span class="comment"># It will give the IndexError</span></span><br><span class="line"><span class="built_in">print</span>(tup[<span class="number">8</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="built_in">tuple</span> index out of <span class="built_in">range</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，元组有 7 个元素，表示 0 到 6。我们试图访问元组外部的一个元素，该元素引发了<strong>索引错误</strong>。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tuple</span> = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line"><span class="comment">#element 1 to end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>[<span class="number">1</span>:])</span><br><span class="line"><span class="comment">#element 0 to 3 element </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>[:<span class="number">4</span>])</span><br><span class="line"><span class="comment">#element 1 to 4 element</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>[<span class="number">1</span>:<span class="number">5</span>]) </span><br><span class="line"><span class="comment"># element 0 to 6 and take step of 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>[<span class="number">0</span>:<span class="number">6</span>:<span class="number">2</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="负索引">负索引</h2>
<p>元组元素也可以通过使用负索引来访问。索引-1 表示最右边的元素，索引-2 表示倒数第二个元素，依此类推。</p>
<p>使用负索引从左到右遍历元素。考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tuple1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)  </span><br><span class="line"><span class="built_in">print</span>(tuple1[-<span class="number">1</span>])  </span><br><span class="line"><span class="built_in">print</span>(tuple1[-<span class="number">4</span>])  </span><br><span class="line"><span class="built_in">print</span>(tuple1[-<span class="number">3</span>:-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(tuple1[:-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(tuple1[-<span class="number">2</span>:])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="删除元组">删除元组</h2>
<p>与列表不同，元组项不能通过使用 <strong>del</strong> 关键字删除，因为元组是不可变的。要删除整个元组，我们可以在元组名称中使用 <strong>del</strong> 关键字。</p>
<p>考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tuple1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)  </span><br><span class="line"><span class="built_in">print</span>(tuple1)  </span><br><span class="line"><span class="keyword">del</span> tuple1[<span class="number">0</span>]  </span><br><span class="line"><span class="built_in">print</span>(tuple1)  </span><br><span class="line"><span class="keyword">del</span> tuple1  </span><br><span class="line"><span class="built_in">print</span>(tuple1)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;tuple.py&quot;</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span>(tuple1)</span><br><span class="line">NameError: name <span class="string">&#x27;tuple1&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="基本元组操作">基本元组操作</h2>
<p>像连接(+)、重复(*)、成员资格(in)这样的运算符的工作方式与它们处理列表的方式相同。有关更多详细信息，请参考下表。</p>
<p>假设声明了 Tuple t = (1，2，3，4，5)和 Tuple t1 = (6，7，8，9)。</p>
<p>| 操作员 | 描述 | 例子 |<br>
| 重复 | 重复运算符使元组元素能够重复多次。 |</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">T1*<span class="number">2</span> = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>|<br>
| 串联 | 它将运算符两侧提到的元组连接起来。 |</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">T1+T2 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br></pre></td></tr></table></figure>
<p>|<br>
| 成员资格 | 如果元组中存在特定项，则返回 true，否则返回 false |</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> (<span class="number">2</span> <span class="keyword">in</span> T1) prints <span class="literal">True</span>.</span><br></pre></td></tr></table></figure>
<p>|<br>
| 循环 | <code>for</code>循环用于迭代元组元素。 |</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> T1: </span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>|<br>
| 长度 | 它用于获取元组的长度。 |</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>(T1) = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>|</p>
<h2 id="Python-元组内置函数">Python 元组内置函数</h2>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>one</td>
<td>cmp(元组 1、元组 2)</td>
<td>它比较两个元组，如果 tuple1 大于 tuple2，则返回 true，否则返回 false。</td>
</tr>
<tr>
<td>Two</td>
<td>len(元组)</td>
<td>它计算元组的长度。</td>
</tr>
<tr>
<td>three</td>
<td>max(元组)</td>
<td>它返回元组的最大元素</td>
</tr>
<tr>
<td>four</td>
<td>min(元组)</td>
<td>它返回元组的最小元素。</td>
</tr>
<tr>
<td>five</td>
<td>tuple(序列)</td>
<td>它将指定的序列转换为元组。</td>
</tr>
</tbody>
</table>
<h2 id="在哪里使用元组？">在哪里使用元组？</h2>
<p>在以下场景中使用元组代替列表。</p>
<p>1.使用 tuple 代替 list 让我们清楚地知道 tuple 数据是不变的，不能改变。</p>
<p>2.Tuple 可以模拟没有键的字典。考虑下面的嵌套结构，它可以用作字典。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[(<span class="number">101</span>, <span class="string">&quot;John&quot;</span>, <span class="number">22</span>), (<span class="number">102</span>, <span class="string">&quot;Mike&quot;</span>, <span class="number">28</span>),  (<span class="number">103</span>, <span class="string">&quot;Dustin&quot;</span>, <span class="number">30</span>)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="列表与元组">列表与元组</h2>
<p>| 序号 | 列表 | 元组 |<br>
| one | 列表的字面值语法由[]显示。 | 元组的字面语法由()表示。 |<br>
| Two | 列表是可变的。 | 元组是不可变的。 |<br>
| three | 列表的长度是可变的。 | 元组具有固定长度。 |<br>
| four | 该列表提供了比元组更多的功能。 | 元组提供的功能比列表少。|<br>
| five | 该列表用于我们需要存储没有约束的简单集合的场景，其中项目的值可以更改。 | 元组用于我们需要存储只读集合的情况，即项目的值不能更改。它可以作为字典里面的钥匙。|<br>
| six | 列表的内存效率不如元组。 | 元组因其不变性而更具内存效率。 |</p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 内置函数</title>
    <url>/posts/8158a18d.html</url>
    <content><![CDATA[<h1>Python 内置函数</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-built-in-functions">https://www.javatpoint.com/python-built-in-functions</a></p>
</blockquote>
<p>Python 内置函数被定义为其功能在 Python 中预定义的函数。python 解释器有几个一直存在的功能。这些功能被称为内置功能。Python 中有几个内置函数，如下所示:</p>
<h2 id="Python-abs-函数">Python abs()函数</h2>
<p>python <strong>abs()</strong> 函数用于返回一个数字的绝对值。它只需要一个参数，一个要返回绝对值的数字。参数可以是整数和浮点数。如果参数是一个复数，那么，abs()返回它的大小。</p>
<p><strong>Python abs()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  integer number	</span></span><br><span class="line">integer = -<span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Absolute value of -40 is:&#x27;</span>, <span class="built_in">abs</span>(integer))</span><br><span class="line"></span><br><span class="line"><span class="comment">#  floating number</span></span><br><span class="line">floating = -<span class="number">20.83</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Absolute value of -40.83 is:&#x27;</span>, <span class="built_in">abs</span>(floating))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Absolute value of -<span class="number">20</span> <span class="keyword">is</span>: <span class="number">20</span></span><br><span class="line">Absolute value of -<span class="number">20.83</span> <span class="keyword">is</span>: <span class="number">20.83</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-全-函数">Python 全()函数</h2>
<p>python <strong>all()</strong> 函数接受一个可迭代对象(如列表、字典等)。).如果传递的 iterable 中的所有项都为真，则返回 true。否则，它返回 False。如果可迭代对象为空，all()函数将返回 True。</p>
<p><strong>Python all()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># all values true</span></span><br><span class="line">k = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">all</span>(k))</span><br><span class="line"></span><br><span class="line"><span class="comment"># all values false</span></span><br><span class="line">k = [<span class="number">0</span>, <span class="literal">False</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">all</span>(k))</span><br><span class="line"></span><br><span class="line"><span class="comment"># one false value</span></span><br><span class="line">k = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">all</span>(k))</span><br><span class="line"></span><br><span class="line"><span class="comment"># one true value</span></span><br><span class="line">k = [<span class="number">0</span>, <span class="literal">False</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">all</span>(k))</span><br><span class="line"></span><br><span class="line"><span class="comment"># empty iterable</span></span><br><span class="line">k = []</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">all</span>(k))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-bin-函数">Python bin()函数</h2>
<p>python <strong>bin()</strong> 函数用于返回指定整数的二进制表示。结果总是以前缀 0b 开头。</p>
<p><strong>Python bin()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">x =  <span class="number">10</span></span><br><span class="line">y =  <span class="built_in">bin</span>(x)</span><br><span class="line"><span class="built_in">print</span> (y)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">0b1010</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-bool（）">Python bool（）</h2>
<p>python <strong>bool()</strong> 使用标准的真值测试过程将一个值转换为布尔值(真或假)。</p>
<p><strong>Python bool()示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">test1 = []</span><br><span class="line"><span class="built_in">print</span>(test1,<span class="string">&#x27;is&#x27;</span>,<span class="built_in">bool</span>(test1))</span><br><span class="line">test1 = [<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(test1,<span class="string">&#x27;is&#x27;</span>,<span class="built_in">bool</span>(test1))</span><br><span class="line">test1 = <span class="number">0.0</span></span><br><span class="line"><span class="built_in">print</span>(test1,<span class="string">&#x27;is&#x27;</span>,<span class="built_in">bool</span>(test1))</span><br><span class="line">test1 = <span class="literal">None</span></span><br><span class="line"><span class="built_in">print</span>(test1,<span class="string">&#x27;is&#x27;</span>,<span class="built_in">bool</span>(test1))</span><br><span class="line">test1 = <span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span>(test1,<span class="string">&#x27;is&#x27;</span>,<span class="built_in">bool</span>(test1))</span><br><span class="line">test1 = <span class="string">&#x27;Easy string&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(test1,<span class="string">&#x27;is&#x27;</span>,<span class="built_in">bool</span>(test1))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[] <span class="keyword">is</span> <span class="literal">False</span></span><br><span class="line">[<span class="number">0</span>] <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line"><span class="number">0.0</span> <span class="keyword">is</span> <span class="literal">False</span></span><br><span class="line"><span class="literal">None</span> <span class="keyword">is</span> <span class="literal">False</span></span><br><span class="line"><span class="literal">True</span> <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line">Easy string <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-字节">Python 字节()</h2>
<p>python 中的 python <strong>字节()<strong>用于返回一个</strong>字节</strong>对象。它是 bytearray()函数的不可变版本。</p>
<p>它可以创建指定大小的空字节对象。</p>
<p><strong>Python 字节()示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">string = <span class="string">&quot;Hello World.&quot;</span></span><br><span class="line">array = <span class="built_in">bytes</span>(string, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">b <span class="string">&#x27; Hello World.&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-可调用-函数">Python 可调用()函数</h2>
<p>python 中的一个 python **可调用()**函数是可以调用的。如果传递的对象看起来是可调用的，这个内置函数检查并返回 true，否则返回 false。</p>
<p><strong>Python 可调用()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">x = <span class="number">8</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">callable</span>(x))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-编译-函数">Python 编译()函数</h2>
<p>python <strong>compile()</strong> 函数以源代码为输入，返回一个代码对象，稍后可以由 exec()函数执行。</p>
<p><strong>Python 编译()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># compile string source to code</span></span><br><span class="line">code_str = <span class="string">&#x27;x=5\ny=10\nprint(&quot;sum =&quot;,x+y)&#x27;</span></span><br><span class="line">code = <span class="built_in">compile</span>(code_str, <span class="string">&#x27;sum.py&#x27;</span>, <span class="string">&#x27;exec&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(code))</span><br><span class="line"><span class="built_in">exec</span>(code)</span><br><span class="line"><span class="built_in">exec</span>(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;code&#x27;</span>&gt;</span><br><span class="line"><span class="built_in">sum</span> = <span class="number">15</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-exec-函数">Python exec()函数</h2>
<p>python <strong>exec()</strong> 函数用于动态执行 python 程序，该程序可以是字符串或目标代码，并且它接受大块代码，这与只接受单个表达式的 eval()函数不同。</p>
<p><strong>Python exec()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">x = <span class="number">8</span></span><br><span class="line"><span class="built_in">exec</span>(<span class="string">&#x27;print(x==8)&#x27;</span>)</span><br><span class="line"><span class="built_in">exec</span>(<span class="string">&#x27;print(x+4)&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-求和-函数">Python 求和()函数</h2>
<p>顾名思义，python <strong>sum()</strong> 函数用于获取一个可迭代的，即列表的数字之和。</p>
<p><strong>Python sum()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">s = <span class="built_in">sum</span>([<span class="number">1</span>, <span class="number">2</span>,<span class="number">4</span> ])</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line">s = <span class="built_in">sum</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>], <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-任意-函数">Python 任意()函数</h2>
<p>如果 iterable 中的任何项目为真，python <strong>any()</strong> 函数将返回真。否则，它返回 False。</p>
<p><strong>Python 任意()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>]                            </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">any</span>(l))                                 </span><br><span class="line"></span><br><span class="line">l = [<span class="number">0</span>, <span class="literal">False</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">any</span>(l))</span><br><span class="line"></span><br><span class="line">l = [<span class="number">0</span>, <span class="literal">False</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">any</span>(l))</span><br><span class="line"></span><br><span class="line">l = []</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">any</span>(l))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-ascii-函数">Python ascii()函数</h2>
<p>python <strong>ascii()</strong> 函数返回一个包含对象的可打印表示的字符串，并使用\x，\u 或\U 转义来转义字符串中的非 ascii 字符。</p>
<p><strong>Python ascii()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">normalText = <span class="string">&#x27;Python is interesting&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ascii</span>(normalText))</span><br><span class="line"></span><br><span class="line">otherText = <span class="string">&#x27;Pythn is interesting&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ascii</span>(otherText))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Pyth\xf6n is interesting&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;Python is interesting&#x27;</span></span><br><span class="line"><span class="string">&#x27;Pyth\xf6n is interesting&#x27;</span></span><br><span class="line">Pythn <span class="keyword">is</span> interesting</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-bytearray（）">Python bytearray（）</h2>
<p>python <strong>bytearray()</strong> 返回一个 bytearray 对象，可以将对象转换成 bytearray 对象，或者创建一个指定大小的空 bytearray 对象。</p>
<p><strong>Python bytearray()示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">string = <span class="string">&quot;Python is a programming language.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># string with encoding &#x27;utf-8&#x27;</span></span><br><span class="line">arr = <span class="built_in">bytearray</span>(string, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bytearray</span>(<span class="string">b&#x27;Python is a programming language.&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-eval-函数">Python eval()函数</h2>
<p>python <strong>eval()</strong> 函数解析传递给它的表达式，并在程序中运行 python 表达式(代码)。</p>
<p><strong>Python eval()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">x = <span class="number">8</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&#x27;x + 1&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-float">Python float()</h2>
<p>python <strong>float()</strong> 函数从数字或字符串中返回一个浮点数。</p>
<p><strong>Python float()示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># for integers</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">float</span>(<span class="number">9</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># for floats</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">float</span>(<span class="number">8.19</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># for string floats</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">float</span>(<span class="string">&quot;-24.27&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># for string floats with whitespaces</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">float</span>(<span class="string">&quot;     -17.19\n&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># string float error</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">float</span>(<span class="string">&quot;xyz&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">9.0</span></span><br><span class="line"><span class="number">8.19</span></span><br><span class="line">-<span class="number">24.27</span></span><br><span class="line">-<span class="number">17.19</span></span><br><span class="line">ValueError: could <span class="keyword">not</span> convert string to <span class="built_in">float</span>: <span class="string">&#x27;xyz&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-格式-函数">Python 格式()函数</h2>
<p>python <strong>format()</strong> 函数返回给定值的格式化表示。</p>
<p><strong>Python 格式()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># d, f and b are a type</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># integer</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">format</span>(<span class="number">123</span>, <span class="string">&quot;d&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># float arguments</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">format</span>(<span class="number">123.4567898</span>, <span class="string">&quot;f&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># binary format</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">format</span>(<span class="number">12</span>, <span class="string">&quot;b&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">123.456790</span></span><br><span class="line"><span class="number">1100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-frozenset">Python frozenset()</h2>
<p>python <strong>frozenset()</strong> 函数返回一个不可变的 frozenset 对象，该对象用给定 iterable 中的元素初始化。</p>
<p><strong>Python frozenset()示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tuple of letters</span></span><br><span class="line">letters = (<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;s&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fSet = <span class="built_in">frozenset</span>(letters)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Frozen set is:&#x27;</span>, fSet)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Empty frozen set is:&#x27;</span>, <span class="built_in">frozenset</span>())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Frozen <span class="built_in">set</span> <span class="keyword">is</span>: <span class="built_in">frozenset</span>(&#123;<span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;t&#x27;</span>&#125;)</span><br><span class="line">Empty frozen <span class="built_in">set</span> <span class="keyword">is</span>: <span class="built_in">frozenset</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-getattr-函数">Python getattr()函数</h2>
<p>python <strong>getattr()</strong> 函数返回对象的命名属性的值。如果找不到，它将返回默认值。</p>
<p><strong>Python getattr()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Details</span>:</span><br><span class="line">    age = <span class="number">22</span></span><br><span class="line">    name = <span class="string">&quot;Phill&quot;</span></span><br><span class="line"></span><br><span class="line">details = Details()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The age is:&#x27;</span>, <span class="built_in">getattr</span>(details, <span class="string">&quot;age&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The age is:&#x27;</span>, details.age)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The age <span class="keyword">is</span>: <span class="number">22</span></span><br><span class="line">The age <span class="keyword">is</span>: <span class="number">22</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-全局-函数">Python 全局()函数</h2>
<p>python <strong>globals()</strong> 函数返回当前全局符号表的字典。</p>
<p>一个<strong>符号表</strong>被定义为一个数据结构，它包含了关于程序的所有必要信息。它包括变量名、方法、类等。</p>
<p><strong>Python 全局()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">age = <span class="number">22</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">globals</span>()[<span class="string">&#x27;age&#x27;</span>] = <span class="number">22</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The age is:&#x27;</span>, age)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The age <span class="keyword">is</span>: <span class="number">22</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-有一个-函数">Python 有一个()函数</h2>
<p>python <strong>any()</strong> 函数如果 iterable 中的任何项目为真，则返回真，否则返回假。</p>
<p><strong>Python 有一个()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>]                            </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">any</span>(l))                                 </span><br><span class="line"></span><br><span class="line">l = [<span class="number">0</span>, <span class="literal">False</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">any</span>(l))</span><br><span class="line"></span><br><span class="line">l = [<span class="number">0</span>, <span class="literal">False</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">any</span>(l))</span><br><span class="line"></span><br><span class="line">l = []</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">any</span>(l))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-iter-函数">Python iter()函数</h2>
<p>python <strong>iter()</strong> 函数用于返回迭代器对象。它创建一个可以一次迭代一个元素的对象。</p>
<p><strong>Python iter()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># list of numbers</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">listIter = <span class="built_in">iter</span>(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># prints &#x27;1&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(listIter))</span><br><span class="line"></span><br><span class="line"><span class="comment"># prints &#x27;2&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(listIter))</span><br><span class="line"></span><br><span class="line"><span class="comment"># prints &#x27;3&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(listIter))</span><br><span class="line"></span><br><span class="line"><span class="comment"># prints &#x27;4&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(listIter))</span><br><span class="line"></span><br><span class="line"><span class="comment"># prints &#x27;5&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(listIter))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-len-函数">Python len()函数</h2>
<p>python <strong>len()</strong> 函数用于返回对象的长度(项数)。</p>
<p><strong>Python len()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">strA = <span class="string">&#x27;Python&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(strA))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Python-列表">Python 列表()</h2>
<p>python <strong>list()</strong> 用 python 创建一个列表。</p>
<p><strong>Python 列表()示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># empty list</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment"># string</span></span><br><span class="line">String = <span class="string">&#x27;abcde&#x27;</span>     </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(String))</span><br><span class="line"></span><br><span class="line"><span class="comment"># tuple</span></span><br><span class="line"><span class="type">Tuple</span> = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="type">Tuple</span>))</span><br><span class="line"><span class="comment"># list</span></span><br><span class="line"><span class="type">List</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="type">List</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[]</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-局部变量-函数">Python 局部变量()函数</h2>
<p>python <strong>locals()</strong> 方法更新并返回当前本地符号表的字典。</p>
<p>一个<strong>符号表</strong>被定义为一个数据结构，它包含了关于程序的所有必要信息。它包括变量名、方法、类等。</p>
<p><strong>Python 局部变量()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">localsAbsent</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">locals</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">localsPresent</span>():</span><br><span class="line">    present = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">locals</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;localsNotPresent:&#x27;</span>, localsAbsent())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;localsPresent:&#x27;</span>, localsPresent())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">localsAbsent: &#123;&#125;</span><br><span class="line">localsPresent: &#123;<span class="string">&#x27;present&#x27;</span>: <span class="literal">True</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-映射-函数">Python 映射()函数</h2>
<p>python <strong>map()</strong> 函数用于将给定的函数应用于 iterable(列表、元组等)的每个项目后，返回结果列表。).</p>
<p><strong>Python 图()功能示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calculateAddition</span>(<span class="params">n</span>):</span><br><span class="line">  <span class="keyword">return</span> n+n</span><br><span class="line"></span><br><span class="line">numbers = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">result = <span class="built_in">map</span>(calculateAddition, numbers)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># converting map object to set</span></span><br><span class="line">numbersAddition = <span class="built_in">set</span>(result)</span><br><span class="line"><span class="built_in">print</span>(numbersAddition)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">map</span> <span class="built_in">object</span> at <span class="number">0x7fb04a6bec18</span>&gt;</span><br><span class="line">&#123;<span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-内存视图-函数">Python 内存视图()函数</h2>
<p>python <strong>memoryview()</strong> 函数返回给定参数的 memoryview 对象。</p>
<p><strong>Python memoryview()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#A random bytearray</span></span><br><span class="line">randomByteArray = <span class="built_in">bytearray</span>(<span class="string">&#x27;ABC&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">mv = <span class="built_in">memoryview</span>(randomByteArray)</span><br><span class="line"></span><br><span class="line"><span class="comment"># access the memory view&#x27;s zeroth index</span></span><br><span class="line"><span class="built_in">print</span>(mv[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># It create byte from memory view</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bytes</span>(mv[<span class="number">0</span>:<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># It create list from memory view</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(mv[<span class="number">0</span>:<span class="number">3</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">65</span></span><br><span class="line"><span class="string">b&#x27;AB&#x27;</span></span><br><span class="line">[<span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-对象">Python 对象()</h2>
<p>python **对象()**返回一个空对象。它是所有类的基础，保存所有类默认的内置属性和方法。</p>
<p><strong>Python 对象()示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">python = <span class="built_in">object</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(python))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(python))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;object&#x27;</span>&gt;</span><br><span class="line">[<span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-开放-函数">Python 开放()函数</h2>
<p>python <strong>open()</strong> 函数打开文件并返回相应的文件对象。</p>
<p><strong>Python open()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># opens python.text file of the current directory</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;python.txt&quot;</span>)</span><br><span class="line"><span class="comment"># specifying full path</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;C:/Python33/README.txt&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Since the mode <span class="keyword">is</span> omitted, the file <span class="keyword">is</span> opened <span class="keyword">in</span> <span class="string">&#x27;r&#x27;</span> mode; opens <span class="keyword">for</span> reading.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-chr-函数">Python chr()函数</h2>
<p>Python <strong>chr()</strong> 函数用于获取一个字符串，该字符串表示一个指向 Unicode 代码整数的字符。例如，chr(97)返回字符串“a”。此函数接受整数参数，如果超出指定范围，将引发错误。参数的标准范围是从 0 到 1，114，111。</p>
<p><strong>Python chr()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">result = <span class="built_in">chr</span>(<span class="number">102</span>) <span class="comment"># It returns string representation of a char</span></span><br><span class="line">result2 = <span class="built_in">chr</span>(<span class="number">112</span>)</span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(result2)</span><br><span class="line"><span class="comment"># Verify, is it string type?</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;is it string type:&quot;</span>, <span class="built_in">type</span>(result) <span class="keyword">is</span> <span class="built_in">str</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ValueError: <span class="built_in">chr</span>() arg <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x110000</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-复合体">Python 复合体()</h2>
<p>Python <strong>complex()</strong> 函数用于将数字或字符串转换为复数。此方法接受两个可选参数并返回一个复数。第一个参数称为实部，第二个称为虚部。</p>
<p><strong>Python 复杂()示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python complex() function example</span></span><br><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">a = <span class="built_in">complex</span>(<span class="number">1</span>) <span class="comment"># Passing single parameter</span></span><br><span class="line">b = <span class="built_in">complex</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="comment"># Passing both parameters</span></span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="number">1.5</span>+<span class="number">0j</span>)</span><br><span class="line">(<span class="number">1.5</span>+<span class="number">2.2j</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-delattr-函数">Python delattr()函数</h2>
<p>Python <strong>delattr()</strong> 函数用于从类中删除一个属性。它需要两个参数，第一个是类的对象，第二个是我们想要删除的属性。删除属性后，它在类中不再可用，如果尝试使用类对象调用它，将引发错误。</p>
<p><strong>Python delattr()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="built_in">id</span> = <span class="number">101</span></span><br><span class="line">    name = <span class="string">&quot;Pranshu&quot;</span></span><br><span class="line">    email = <span class="string">&quot;pranshu@abc.com&quot;</span></span><br><span class="line"><span class="comment"># Declaring function</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getinfo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.<span class="built_in">id</span>, self.name, self.email)</span><br><span class="line">s = Student()</span><br><span class="line">s.getinfo()</span><br><span class="line"><span class="built_in">delattr</span>(Student,<span class="string">&#x27;course&#x27;</span>) <span class="comment"># Removing attribute which is not available</span></span><br><span class="line">s.getinfo() <span class="comment"># error: throws an error</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">101</span> Pranshu [email protected]</span><br><span class="line">AttributeError: course</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-目录-函数">Python 目录()函数</h2>
<p>Python <strong>dir()</strong> 函数返回当前局部范围内的名称列表。如果调用方法的对象有一个名为 <strong>dir</strong>()的方法，将调用该方法，并且必须返回属性列表。它只接受一个对象类型参数。</p>
<p><strong>Python dir()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">att = <span class="built_in">dir</span>()</span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(att)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;__annotations__&#x27;</span>, <span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;__cached__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__file__&#x27;</span>, <span class="string">&#x27;__loader__&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;__spec__&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-divmod-函数">Python divmod()函数</h2>
<p>Python <strong>divmod()</strong> 函数用来求两个数的余数和商。这个函数接受两个数字参数并返回一个元组。两个参数都是必需的，并且都是数字</p>
<p><strong>Python divmod()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python divmod() function example</span></span><br><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">result = <span class="built_in">divmod</span>(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="number">5</span>, <span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-枚举-函数">Python 枚举()函数</h2>
<p>Python <strong>enumerate()</strong> 函数返回一个枚举对象。它需要两个参数，第一个是元素序列，第二个是序列的起始索引。我们可以通过循环或 next()方法按顺序获取元素。</p>
<p><strong>Python 枚举()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">result = <span class="built_in">enumerate</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(result))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">enumerate</span> <span class="built_in">object</span> at <span class="number">0x7ff641093d80</span>&gt;</span><br><span class="line">[(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-字典">Python 字典()</h2>
<p>Python <strong>dict()</strong> 函数是一个创建字典的构造器。Python 字典提供了三种不同的构造器来创建字典:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>如果没有传递参数，它将创建一个空字典。</p>
</li>
<li class="lvl-4">
<p>如果给定了位置参数，将使用相同的键值对创建字典。否则，传递一个可迭代对象。</p>
</li>
<li class="lvl-4">
<p>如果给定了关键字参数，关键字参数及其值将被添加到根据位置参数创建的字典中。</p>
</li>
</ul>
<p><strong>Python dict()示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">result = <span class="built_in">dict</span>() <span class="comment"># returns an empty dictionary</span></span><br><span class="line">result2 = <span class="built_in">dict</span>(a=<span class="number">1</span>,b=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(result2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;&#125;</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-过滤器-函数">Python 过滤器()函数</h2>
<p>Python <strong>filter()</strong> 函数用于获取过滤后的元素。这个函数有两个参数，第一个是函数，第二个是可迭代的。过滤器函数返回可迭代对象的那些元素的序列，对于这些元素，函数返回<strong>真值</strong>。</p>
<p>第一个参数可以是 <strong>none</strong> ，如果函数不可用并且只返回 <strong>true</strong> 的元素。</p>
<p><strong>Python 过滤器()功能示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python filter() function example</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">filterdata</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> x&gt;<span class="number">5</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">result = <span class="built_in">filter</span>(filterdata,(<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>))</span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(result))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="number">6</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-哈希-函数">Python 哈希()函数</h2>
<p>Python <strong>hash()</strong> 函数用于获取一个对象的哈希值。Python 使用哈希算法计算哈希值。哈希值是整数，用于在字典查找过程中比较字典键。我们只能哈希下面给出的类型:</p>
<p><strong>Hassable 类型:</strong>* bool * int * long * float * string * Unicode * tuple * code 对象。</p>
<p><strong>Python hash()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">result = <span class="built_in">hash</span>(<span class="number">21</span>) <span class="comment"># integer value</span></span><br><span class="line">result2 = <span class="built_in">hash</span>(<span class="number">22.2</span>) <span class="comment"># decimal value</span></span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(result2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">461168601842737174</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-帮助-函数">Python 帮助()函数</h2>
<p>Python <strong>help()</strong> 函数用于获取调用过程中传递的对象相关的帮助。它接受一个可选参数并返回帮助信息。如果没有给出参数，它会显示 Python 帮助控制台。它在内部调用 python 的帮助函数。</p>
<p><strong>Python 帮助()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">info = <span class="built_in">help</span>() <span class="comment"># No argument</span></span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(info)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Welcome to Python <span class="number">3.5</span><span class="string">&#x27;s help utility!</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-最小-函数">Python 最小()函数</h2>
<p>Python <strong>min()</strong> 函数用于从集合中获取最小的元素。这个函数接受两个参数，第一个是元素的集合，第二个是 key，并返回集合中最小的元素。</p>
<p><strong>Python min()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">small = <span class="built_in">min</span>(<span class="number">2225</span>,<span class="number">325</span>,<span class="number">2025</span>) <span class="comment"># returns smallest element</span></span><br><span class="line">small2 = <span class="built_in">min</span>(<span class="number">1000.25</span>,<span class="number">2025.35</span>,<span class="number">5625.36</span>,<span class="number">10052.50</span>)</span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(small)</span><br><span class="line"><span class="built_in">print</span>(small2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">325</span></span><br><span class="line"><span class="number">1000.25</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-集-函数">Python 集()函数</h2>
<p>在 python 中，集合是一个内置类，这个函数是这个类的构造器。它用于使用调用期间传递的元素创建新的集合。它将一个可迭代对象作为参数，并返回一个新的 set 对象。</p>
<p><strong>Python 集()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">result = <span class="built_in">set</span>() <span class="comment"># empty set</span></span><br><span class="line">result2 = <span class="built_in">set</span>(<span class="string">&#x27;12&#x27;</span>)</span><br><span class="line">result3 = <span class="built_in">set</span>(<span class="string">&#x27;javatpoint&#x27;</span>)</span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(result2)</span><br><span class="line"><span class="built_in">print</span>(result3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>()</span><br><span class="line">&#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-十六进制-函数">Python 十六进制()函数</h2>
<p>Python <strong>hex()</strong> 函数用于生成一个整数参数的 hex 值。它接受一个整数参数，并返回一个转换为十六进制字符串的整数。在这种情况下，我们希望得到一个浮点的十六进制值，然后使用 float.hex()函数。</p>
<p><strong>Python hex()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">result = <span class="built_in">hex</span>(<span class="number">1</span>) </span><br><span class="line"><span class="comment"># integer value</span></span><br><span class="line">result2 = <span class="built_in">hex</span>(<span class="number">342</span>) </span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(result2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">0x1</span></span><br><span class="line"><span class="number">0x156</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-id-函数">Python id()函数</h2>
<p>Python <strong>id()</strong> 函数返回一个对象的标识。这是一个整数，保证是唯一的。该函数将一个参数作为一个对象，并返回一个代表身份的唯一整数。具有非重叠生存期的两个对象可能具有相同的 id()值。</p>
<p><strong>Python id()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">val = <span class="built_in">id</span>(<span class="string">&quot;Javatpoint&quot;</span>) <span class="comment"># string object</span></span><br><span class="line">val2 = <span class="built_in">id</span>(<span class="number">1200</span>) <span class="comment"># integer object</span></span><br><span class="line">val3 = <span class="built_in">id</span>([<span class="number">25</span>,<span class="number">336</span>,<span class="number">95</span>,<span class="number">236</span>,<span class="number">92</span>,<span class="number">3225</span>]) <span class="comment"># List object</span></span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(val)</span><br><span class="line"><span class="built_in">print</span>(val2)</span><br><span class="line"><span class="built_in">print</span>(val3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">139963782059696</span></span><br><span class="line"><span class="number">139963805666864</span></span><br><span class="line"><span class="number">139963781994504</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-setattr-函数">Python setattr()函数</h2>
<p>Python <strong>setattr()</strong> 函数用于为对象的属性设置一个值。它接受三个参数，即一个对象、一个字符串和一个任意值，并且不返回任何值。当我们想给一个对象添加一个新的属性并给它设置一个值时，这是很有帮助的。</p>
<p><strong>Python setattr()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="built_in">id</span> = <span class="number">0</span></span><br><span class="line">    name = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">id</span>, name</span>):</span><br><span class="line">        self.<span class="built_in">id</span> = <span class="built_in">id</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">student = Student(<span class="number">102</span>,<span class="string">&quot;Sohan&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(student.<span class="built_in">id</span>)</span><br><span class="line"><span class="built_in">print</span>(student.name)</span><br><span class="line"><span class="comment">#print(student.email) product error</span></span><br><span class="line"><span class="built_in">setattr</span>(student, <span class="string">&#x27;email&#x27;</span>,<span class="string">&#x27;sohan@abc.com&#x27;</span>) <span class="comment"># adding new attribute</span></span><br><span class="line"><span class="built_in">print</span>(student.email)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">102</span></span><br><span class="line">Sohan</span><br><span class="line">[email protected]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-切片-函数">Python 切片()函数</h2>
<p>Python <strong>slice()</strong> 函数用于从元素集合中获取元素的切片。Python 提供了两个重载切片函数。第一个函数接受单个参数，而第二个函数接受三个参数并返回一个 slice 对象。这个切片对象可以用来获取集合的一个子部分。</p>
<p><strong>Python 切片()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">result = <span class="built_in">slice</span>(<span class="number">5</span>) <span class="comment"># returns slice object</span></span><br><span class="line">result2 = <span class="built_in">slice</span>(<span class="number">0</span>,<span class="number">5</span>,<span class="number">3</span>) <span class="comment"># returns slice object</span></span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(result2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">slice</span>(<span class="literal">None</span>, <span class="number">5</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="built_in">slice</span>(<span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-排序-函数">Python 排序()函数</h2>
<p>Python <strong>sorted()</strong> 函数用于排序元素。默认情况下，它按升序排序元素，但也可以按降序进行排序。它接受四个参数，并按排序顺序返回一个集合。就字典而言，它只排序键，而不排序值。</p>
<p><strong>Python 排序()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;javatpoint&quot;</span> <span class="comment"># declaring string</span></span><br><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">sorted1 = <span class="built_in">sorted</span>(<span class="built_in">str</span>) <span class="comment"># sorting string</span></span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(sorted1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;v&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-下一个-函数">Python 下一个()函数</h2>
<p>Python <strong>next()</strong> 函数用于从集合中获取下一项。它接受两个参数，即迭代器和默认值，并返回一个元素。</p>
<p>这个方法调用迭代器，如果没有项目，就会抛出一个错误。为了避免错误，我们可以设置一个默认值。</p>
<p><strong>Python next()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">number = <span class="built_in">iter</span>([<span class="number">256</span>, <span class="number">32</span>, <span class="number">82</span>]) <span class="comment"># Creating iterator</span></span><br><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">item = <span class="built_in">next</span>(number) </span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(item)</span><br><span class="line"><span class="comment"># second item</span></span><br><span class="line">item = <span class="built_in">next</span>(number)</span><br><span class="line"><span class="built_in">print</span>(item)</span><br><span class="line"><span class="comment"># third item</span></span><br><span class="line">item = <span class="built_in">next</span>(number)</span><br><span class="line"><span class="built_in">print</span>(item)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">256</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">82</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-输入-函数">Python 输入()函数</h2>
<p>Python <strong>input()</strong> 函数用于获取用户的输入。它提示用户输入并读取一行。读取数据后，它将其转换为字符串并返回。如果读取电渗流，它会抛出一个错误 <strong>EOFError</strong> 。</p>
<p><strong>Python 输入()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">val = <span class="built_in">input</span>(<span class="string">&quot;Enter a value: &quot;</span>)</span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;You entered:&quot;</span>,val)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter a value: <span class="number">45</span></span><br><span class="line">You entered: <span class="number">45</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-int-函数">Python int()函数</h2>
<p>Python <strong>int()</strong> 函数用于获取整数值。它返回一个转换成整数的表达式。如果参数是浮点型的，转换会截断数字。如果参数在整数范围之外，则它会将数字转换为长类型。</p>
<p>如果数字不是数字或者给定了基数，则该数字必须是字符串。</p>
<p><strong>Python int()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">val = <span class="built_in">int</span>(<span class="number">10</span>) <span class="comment"># integer value</span></span><br><span class="line">val2 = <span class="built_in">int</span>(<span class="number">10.52</span>) <span class="comment"># float value</span></span><br><span class="line">val3 = <span class="built_in">int</span>(<span class="string">&#x27;10&#x27;</span>) <span class="comment"># string value</span></span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;integer values :&quot;</span>,val, val2, val3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">integer values : <span class="number">10</span> <span class="number">10</span> <span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-是一个实例-函数">Python 是一个实例()函数</h2>
<p>Python <strong>isinstance()</strong> 函数用于检查给定的对象是否是该类的实例。如果对象属于该类，它将返回 true。否则返回假。如果类是子类，它也会返回 true。</p>
<p><strong>isinstance()</strong> 函数接受两个参数，即对象和 classinfo，然后返回 True 或 False。</p>
<p><strong>Python isinstance()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="built_in">id</span> = <span class="number">101</span></span><br><span class="line">    name = <span class="string">&quot;John&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">id</span>, name</span>):</span><br><span class="line">        self.<span class="built_in">id</span>=<span class="built_in">id</span></span><br><span class="line">        self.name=name</span><br><span class="line"></span><br><span class="line">student = Student(<span class="number">1010</span>,<span class="string">&quot;John&quot;</span>)</span><br><span class="line">lst = [<span class="number">12</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">767</span>]</span><br><span class="line"><span class="comment"># Calling function </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(student, Student)) <span class="comment"># isinstance of Student class</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(lst, Student))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-oct-函数">Python oct()函数</h2>
<p>Python <strong>oct()</strong> 函数用于获取一个整数的八进制值。此方法接受一个参数，并返回一个转换为八进制字符串的整数。如果参数类型不是整数，它会抛出一个错误<strong>类型错误</strong>。</p>
<p><strong>Python oct()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">val = <span class="built_in">oct</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Octal value of 10:&quot;</span>,val)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Octal value of <span class="number">10</span>: <span class="number">0o12</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-顺序-函数">Python 顺序()函数</h2>
<p>python**order()**函数返回一个整数，代表给定 Unicode 字符的 Unicode 代码点。</p>
<p><strong>Python order()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Code point of an integer</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&#x27;8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Code point of an alphabet </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&#x27;R&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Code point of a character</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&#x27;&amp;&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">56</span></span><br><span class="line"><span class="number">82</span></span><br><span class="line"><span class="number">38</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-幂-函数">Python 幂()函数</h2>
<p>python <strong>pow()</strong> 函数用于计算一个数的幂。它返回 x 的 y 次方，如果给定第三个自变量(z)，它返回 x 的 y 模 z 次方，即(x，y) % z。</p>
<p><strong>Python pow()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># positive x, positive y (x**y)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">pow</span>(<span class="number">4</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># negative x, positive y</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">pow</span>(-<span class="number">4</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># positive x, negative y (x**-y)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">pow</span>(<span class="number">4</span>, -<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># negative x, negative y</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">pow</span>(-<span class="number">4</span>, -<span class="number">2</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">0.0625</span></span><br><span class="line"><span class="number">0.0625</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-打印-函数">Python 打印()函数</h2>
<p>python <strong>print()</strong> 函数将给定对象打印到屏幕或其他标准输出设备上。</p>
<p><strong>Python 打印()功能示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Python is programming language.&quot;</span>)</span><br><span class="line"></span><br><span class="line">x = <span class="number">7</span></span><br><span class="line"><span class="comment"># Two objects passed</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x =&quot;</span>, x)</span><br><span class="line"></span><br><span class="line">y = x</span><br><span class="line"><span class="comment"># Three objects passed</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x =&#x27;</span>, x, <span class="string">&#x27;= y&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Python <span class="keyword">is</span> programming language.</span><br><span class="line">x = <span class="number">7</span></span><br><span class="line">x = <span class="number">7</span> = y</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-范围-函数">Python 范围()函数</h2>
<p>python <strong>range()</strong> 函数返回一个不可变的数字序列，默认情况下从 0 开始，递增 1(默认情况下)，以指定的数字结束。</p>
<p><strong>Python 范围()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># empty range</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># using the range(stop)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">4</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># using the range(start, stop)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">7</span> )))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-反向-函数">Python 反向()函数</h2>
<p>python <strong>reversed()</strong> 函数返回给定序列的反向迭代器。</p>
<p><strong>Python 反向()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># for string</span></span><br><span class="line">String = <span class="string">&#x27;Java&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">reversed</span>(String)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># for tuple</span></span><br><span class="line"><span class="type">Tuple</span> = (<span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">reversed</span>(<span class="type">Tuple</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># for range</span></span><br><span class="line">Range = <span class="built_in">range</span>(<span class="number">8</span>, <span class="number">12</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">reversed</span>(Range)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># for list</span></span><br><span class="line"><span class="type">List</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">reversed</span>(<span class="type">List</span>)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;J&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;J&#x27;</span>]</span><br><span class="line">[<span class="number">11</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-圆-函数">Python 圆()函数</h2>
<p>python <strong>round()</strong> 函数对一个数字的数字进行舍入，并返回浮点数。</p>
<p><strong>Python 圆()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  for integers</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#  for floating point</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(<span class="number">10.8</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#  even choice</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(<span class="number">6.6</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-issubclass-函数">Python issubclass()函数</h2>
<p>如果对象参数(第一个参数)是第二个类(第二个参数)的子类，python <strong>issubclass()</strong> 函数返回 true。</p>
<p><strong>Python issubclass()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">rectangleType</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Rectangle is a &#x27;</span>, rectangleType)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span>(<span class="title class_ inherited__">Rectangle</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    Rectangle.__init__(<span class="string">&#x27;square&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(Square, Rectangle))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(Square, <span class="built_in">list</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(Square, (<span class="built_in">list</span>, Rectangle)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(Rectangle, (<span class="built_in">list</span>, Rectangle)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-字符串">Python 字符串</h2>
<p>python <strong>str()</strong> 将指定的值转换为字符串。</p>
<p><strong>Python str()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;4&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Python-元组-函数">Python 元组()函数</h2>
<p>python <strong>tuple()</strong> 函数用于创建 tuple 对象。</p>
<p><strong>Python 元组()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">t1 = <span class="built_in">tuple</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;t1=&#x27;</span>, t1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># creating a tuple from a list</span></span><br><span class="line">t2 = <span class="built_in">tuple</span>([<span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;t2=&#x27;</span>, t2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># creating a tuple from a string</span></span><br><span class="line">t1 = <span class="built_in">tuple</span>(<span class="string">&#x27;Java&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;t1=&#x27;</span>,t1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># creating a tuple from a dictionary</span></span><br><span class="line">t1 = <span class="built_in">tuple</span>(&#123;<span class="number">4</span>: <span class="string">&#x27;four&#x27;</span>, <span class="number">5</span>: <span class="string">&#x27;five&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;t1=&#x27;</span>,t1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">t1= ()</span><br><span class="line">t2= (<span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>)</span><br><span class="line">t1= (<span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">t1= (<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-类型">Python 类型()</h2>
<p>python **类型()**返回指定对象的类型，如果单个参数被传递给内置函数的类型()。如果传递了三个参数，那么它将返回一个新的类型对象。</p>
<p><strong>Python 类型()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> = [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="type">List</span>))</span><br><span class="line"></span><br><span class="line"><span class="type">Dict</span> = &#123;<span class="number">4</span>: <span class="string">&#x27;four&#x27;</span>, <span class="number">5</span>: <span class="string">&#x27;five&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="type">Dict</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span>:</span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">InstanceOfPython = Python()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(InstanceOfPython))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Python&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-vars-函数">Python vars()函数</h2>
<p>python <strong>vars()</strong> 函数返回给定对象的 <strong>dict</strong> 属性。</p>
<p><strong>Python vars()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x = <span class="number">7</span>, y = <span class="number">9</span></span>):</span><br><span class="line">    self.x = x</span><br><span class="line">    self.y = y</span><br><span class="line"></span><br><span class="line">InstanceOfPython = Python()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">vars</span>(InstanceOfPython))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;y&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;x&#x27;</span>: <span class="number">7</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-zip-函数">Python zip()函数</h2>
<p>python <strong>zip()</strong> 函数返回一个 zip 对象，该对象映射多个容器的相似索引。它接受 iterables(可以为零或更多)，使其成为迭代器，根据传递的 iterables 聚合元素，并返回元组的迭代器。</p>
<p><strong>Python zip()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">numList = [<span class="number">4</span>,<span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">strList = [<span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;five&#x27;</span>, <span class="string">&#x27;six&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># No iterables are passed</span></span><br><span class="line">result = <span class="built_in">zip</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Converting itertor to list</span></span><br><span class="line">resultList = <span class="built_in">list</span>(result)</span><br><span class="line"><span class="built_in">print</span>(resultList)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Two iterables are passed</span></span><br><span class="line">result = <span class="built_in">zip</span>(numList, strList)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Converting itertor to set</span></span><br><span class="line">resultSet = <span class="built_in">set</span>(result)</span><br><span class="line"><span class="built_in">print</span>(resultSet)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[]</span><br><span class="line">&#123;(<span class="number">5</span>, <span class="string">&#x27;five&#x27;</span>), (<span class="number">4</span>, <span class="string">&#x27;four&#x27;</span>), (<span class="number">6</span>, <span class="string">&#x27;six&#x27;</span>)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 函数</title>
    <url>/posts/7abf7b36.html</url>
    <content><![CDATA[<h1>Python 函数</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-functions">https://www.javatpoint.com/python-functions</a></p>
</blockquote>
<p>函数是应用最重要的方面。一个函数可以被定义为可重用代码的组织块，它可以在任何需要的时候被调用。</p>
<p>Python 允许我们将一个大型程序划分为称为函数的基本构建块。该函数包含由{}括起来的一组编程语句。一个函数可以被多次调用，为 Python 程序提供可重用性和模块化。</p>
<p>这个函数帮助程序员把程序分成更小的部分。它非常有效地组织了代码，避免了代码的重复。随着程序的增长，函数使程序更有条理。</p>
<p>Python 为我们提供了各种内置功能，如 <strong>range()</strong> 或 <strong>print()</strong> 。虽然，用户可以创建它的函数，这些函数可以称为用户定义函数。</p>
<p>主要有两种功能。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>用户自定义功能</strong> -用户自定义功能是由<strong>用户</strong>为执行特定任务而定义的功能。</p>
</li>
<li class="lvl-4">
<p><strong>内置函数</strong> -内置函数是那些在 Python 中<strong>预定义</strong>的函数。</p>
</li>
</ul>
<p>在本教程中，我们将讨论用户定义函数。</p>
<h2 id="Python-中函数的优势">Python 中函数的优势</h2>
<p>Python 函数有以下优点。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>使用函数，我们可以避免在程序中一次又一次地重写相同的逻辑/代码。</p>
</li>
<li class="lvl-4">
<p>我们可以在一个程序中多次调用 Python 函数，也可以在程序的任何地方调用。</p>
</li>
<li class="lvl-4">
<p>当一个大型 Python 程序被分成多个函数时，我们可以很容易地跟踪它。</p>
</li>
<li class="lvl-4">
<p>可重用性是 Python 函数的主要成就。</p>
</li>
<li class="lvl-4">
<p>然而，在 Python 程序中，函数调用总是开销很大。</p>
</li>
</ul>
<h3 id="创建函数">创建函数</h3>
<p>Python 提供了 <strong>def</strong> 关键字来定义函数。下面给出了定义函数的语法。</p>
<p><strong>语法:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>(<span class="params">parameters</span>):</span><br><span class="line">      function_block</span><br><span class="line"><span class="keyword">return</span> expression</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>让我们理解函数定义的语法。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>def</strong> 关键字和函数名一起用于定义函数。</p>
</li>
<li class="lvl-4">
<p>标识符规则必须遵循函数名。</p>
</li>
<li class="lvl-4">
<p>函数接受参数(参数)，它们可以是可选的。</p>
</li>
<li class="lvl-4">
<p>功能块以冒号(:)开头，块语句必须在同一缩进处。</p>
</li>
<li class="lvl-4">
<p><strong>return</strong> 语句用于返回值。一个功能只能有一个<strong>返回</strong></p>
</li>
</ul>
<h3 id="函数调用">函数调用</h3>
<p>在 Python 中，创建函数后，我们可以从另一个函数调用它。函数必须在函数调用之前定义；否则，Python 解释器会给出一个错误。要调用该函数，请使用后跟括号的函数名。</p>
<p>考虑下面一个简单示例的例子，该示例打印消息“Hello World”。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#function definition</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)  </span><br><span class="line"><span class="comment"># function calling</span></span><br><span class="line">hello_world()    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">hello world</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="退货声明">退货声明</h2>
<p>return 语句用在函数的末尾，并返回函数的结果。它终止函数的执行，并将结果传送到调用函数的地方。return 语句不能在函数外使用。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> [expression_list]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它可以包含表达式，该表达式将被求值并将值返回给调用者函数。如果 return 语句没有表达式或者本身不存在于函数中，那么它返回 <strong>None</strong> 对象。</p>
<p>考虑以下示例:</p>
<h3 id="例-1-9">例 1</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Defining function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>():</span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    b = <span class="number">20</span></span><br><span class="line">    c = a+b</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"><span class="comment"># calling sum() function in print statement</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The sum is:&quot;</span>,<span class="built_in">sum</span>())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The <span class="built_in">sum</span> <span class="keyword">is</span>: <span class="number">30</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们定义了名为 **sum，**的函数，它有一个语句 **c = a+b，**计算给定值，结果由 return 语句返回给调用者函数。</p>
<h3 id="示例-2-创建没有return语句的函数">示例 2 创建没有<code>return</code>语句的函数</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Defining function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>():</span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    b = <span class="number">20</span></span><br><span class="line">    c = a+b</span><br><span class="line"><span class="comment"># calling sum() function in print statement</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们定义了相同的没有 return 语句的函数，因为我们可以看到 <strong>sum()</strong> 函数向调用者函数返回了 <strong>None</strong> 对象。</p>
<h2 id="函数中的参数">函数中的参数</h2>
<p>参数是可以传递给函数的信息类型。参数在括号中指定。我们可以传递任意数量的参数，但是它们必须用逗号隔开。</p>
<p>考虑以下示例，其中包含一个接受字符串作为参数的函数。</p>
<h3 id="例-1-10">例 1</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#defining the function  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span> (name):  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hi &quot;</span>,name) </span><br><span class="line"><span class="comment">#calling the function   </span></span><br><span class="line">func(<span class="string">&quot;Devansh&quot;</span>)   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Hi Devansh</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例-2-8">例 2</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Python function to calculate the sum of two variables   </span></span><br><span class="line"><span class="comment">#defining the function  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span> (a,b):  </span><br><span class="line">    <span class="keyword">return</span> a+b;  </span><br><span class="line"></span><br><span class="line"><span class="comment">#taking values from the user  </span></span><br><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter a: &quot;</span>))  </span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter b: &quot;</span>))  </span><br><span class="line"></span><br><span class="line"><span class="comment">#printing the sum of a and b  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sum = &quot;</span>,<span class="built_in">sum</span>(a,b))  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter a: <span class="number">10</span></span><br><span class="line">Enter b: <span class="number">20</span></span><br><span class="line">Sum =  <span class="number">30</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Python-中的引用调用">Python 中的引用调用</h2>
<p>在 Python 中，引用调用意味着将实际值作为参数传递给函数。所有函数都是通过引用调用的，也就是说，对函数内部的引用所做的所有更改都会恢复到引用所引用的原始值。</p>
<h3 id="示例-1-传递不可变对象-列表">示例 1 传递不可变对象(列表)</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#defining the function  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_list</span>(<span class="params">list1</span>):  </span><br><span class="line">    list1.append(<span class="number">20</span>) </span><br><span class="line">    list1.append(<span class="number">30</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;list inside function = &quot;</span>,list1)  </span><br><span class="line"></span><br><span class="line"><span class="comment">#defining the list  </span></span><br><span class="line">list1 = [<span class="number">10</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>]  </span><br><span class="line"></span><br><span class="line"><span class="comment">#calling the function   </span></span><br><span class="line">change_list(list1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;list outside function = &quot;</span>,list1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> inside function =  [<span class="number">10</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="built_in">list</span> outside function =  [<span class="number">10</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="示例-2-传递可变对象-字符串">示例 2 传递可变对象(字符串)</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#defining the function  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_string</span> (<span class="built_in">str</span>):  </span><br><span class="line">    <span class="built_in">str</span> = <span class="built_in">str</span> + <span class="string">&quot; Hows you &quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;printing the string inside function :&quot;</span>,<span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line">string1 = <span class="string">&quot;Hi I am there&quot;</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">#calling the function  </span></span><br><span class="line">change_string(string1)  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;printing the string outside function :&quot;</span>,string1)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">printing the string inside function : Hi I am there Hows you </span><br><span class="line">printing the string outside function : Hi I am there</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="参数类型">参数类型</h2>
<p>可能有几种类型的参数可以在函数调用时传递。</p>
<ol>
<li class="lvl-4">
<p>必需的参数</p>
</li>
<li class="lvl-4">
<p>关键字参数</p>
</li>
<li class="lvl-4">
<p>默认参数</p>
</li>
<li class="lvl-4">
<p>可变长度参数</p>
</li>
</ol>
<h3 id="必需的参数">必需的参数</h3>
<p>到目前为止，我们已经了解了 Python 中的函数调用。但是，我们可以在函数调用时提供参数。就所需参数而言，这些是在函数调用时需要传递的参数，它们在函数调用和函数定义中的位置完全匹配。如果函数调用中没有提供任何一个参数，或者参数的位置发生了变化，Python 解释器将显示错误。</p>
<p>考虑下面的例子。</p>
<p><strong>例 1</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">name</span>):  </span><br><span class="line">    message = <span class="string">&quot;Hi &quot;</span>+name</span><br><span class="line">    <span class="keyword">return</span> message</span><br><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;Enter the name:&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(func(name))  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the name: John</span><br><span class="line">Hi John</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例 2</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#the function simple_interest accepts three arguments and returns the simple interest accordingly  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">simple_interest</span>(<span class="params">p,t,r</span>):  </span><br><span class="line">    <span class="keyword">return</span> (p*t*r)/<span class="number">100</span>  </span><br><span class="line">p = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the principle amount? &quot;</span>))  </span><br><span class="line">r = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the rate of interest? &quot;</span>))  </span><br><span class="line">t = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the time in years? &quot;</span>))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Simple Interest: &quot;</span>,simple_interest(p,r,t))  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the principle amount: <span class="number">5000</span></span><br><span class="line">Enter the rate of interest: <span class="number">5</span></span><br><span class="line">Enter the time <span class="keyword">in</span> years: <span class="number">3</span></span><br><span class="line">Simple Interest:  <span class="number">750.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例 3</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#the function calculate returns the sum of two arguments a and b  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">a,b</span>):  </span><br><span class="line">    <span class="keyword">return</span> a+b  </span><br><span class="line">calculate(<span class="number">10</span>) <span class="comment"># this causes an error as we are missing a required arguments b.  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">TypeError: calculate() missing <span class="number">1</span> required positional argument: <span class="string">&#x27;b&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="默认参数">默认参数</h2>
<p>Python 允许我们在函数定义中初始化参数。如果在函数调用时没有提供任何参数的值，那么即使在函数调用时没有指定参数，也可以用定义中给出的值初始化该参数。</p>
<p><strong>例 1</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printme</span>(<span class="params">name,age=<span class="number">22</span></span>):  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My name is&quot;</span>,name,<span class="string">&quot;and age is&quot;</span>,age)  </span><br><span class="line">printme(name = <span class="string">&quot;john&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">My name <span class="keyword">is</span> John <span class="keyword">and</span> age <span class="keyword">is</span> <span class="number">22</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例 2</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printme</span>(<span class="params">name,age=<span class="number">22</span></span>):  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My name is&quot;</span>,name,<span class="string">&quot;and age is&quot;</span>,age)  </span><br><span class="line">printme(name = <span class="string">&quot;john&quot;</span>) <span class="comment">#the variable age is not passed into the function however the default value of age is considered in the function  </span></span><br><span class="line">printme(age = <span class="number">10</span>,name=<span class="string">&quot;David&quot;</span>) <span class="comment">#the value of age is overwritten here, 10 will be printed as age </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">My name <span class="keyword">is</span> john <span class="keyword">and</span> age <span class="keyword">is</span> <span class="number">22</span></span><br><span class="line">My name <span class="keyword">is</span> David <span class="keyword">and</span> age <span class="keyword">is</span> <span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="可变长度参数-参数">可变长度参数(*参数)</h3>
<p>在大型项目中，有时我们可能不知道要提前传递的参数数量。在这种情况下，Python 为我们提供了提供逗号分隔值的灵活性，这些值在函数调用时在内部被视为元组。通过使用可变长度参数，我们可以传递任意数量的参数。</p>
<p>然而，在函数定义中，我们使用 <em><strong>args</strong> (star)将变长参数定义为</em> &lt;变量名&gt;。</p>
<p>考虑下面的例子。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printme</span>(<span class="params">*names</span>):  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;type of passed argument is &quot;</span>,<span class="built_in">type</span>(names))  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;printing the passed arguments...&quot;</span>)  </span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:  </span><br><span class="line">        <span class="built_in">print</span>(name)  </span><br><span class="line">printme(<span class="string">&quot;john&quot;</span>,<span class="string">&quot;David&quot;</span>,<span class="string">&quot;smith&quot;</span>,<span class="string">&quot;nick&quot;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> of passed argument <span class="keyword">is</span>  &lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line">printing the passed arguments...</span><br><span class="line">john</span><br><span class="line">David</span><br><span class="line">smith</span><br><span class="line">nick</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们传递了*** name<strong>作为变长参数。我们调用了函数，并传递了在内部被视为元组的值。元组是与列表相同的可迭代序列。为了打印给定值，我们迭代了用于循环的</strong><em>参数名</em>*。</p>
<h3 id="关键字参数-kwargs">关键字参数(**kwargs)</h3>
<p>Python 允许我们使用关键字参数调用函数。这种函数调用将使我们能够以随机顺序传递参数。</p>
<p>参数的名称被视为关键字，并在函数调用和定义中匹配。如果找到相同的匹配，则在函数定义中复制参数的值。</p>
<p>考虑下面的例子。</p>
<p><strong>例 1</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#function func is called with the name and message as the keyword arguments  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">name,message</span>):  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;printing the message with&quot;</span>,name,<span class="string">&quot;and &quot;</span>,message)  </span><br><span class="line"></span><br><span class="line">    <span class="comment">#name and message is copied with the values John and hello respectively  </span></span><br><span class="line">    func(name = <span class="string">&quot;John&quot;</span>,message=<span class="string">&quot;hello&quot;</span>) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">printing the message <span class="keyword">with</span> John <span class="keyword">and</span>  hello</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例 2 在调用</strong>时提供不同顺序的值</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#The function simple_interest(p, t, r) is called with the keyword arguments the order of arguments doesn&#x27;t matter in this case  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">simple_interest</span>(<span class="params">p,t,r</span>):  </span><br><span class="line">    <span class="keyword">return</span> (p*t*r)/<span class="number">100</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Simple Interest: &quot;</span>,simple_interest(t=<span class="number">10</span>,r=<span class="number">10</span>,p=<span class="number">1900</span>))   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Simple Interest:  <span class="number">1900.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果我们在函数调用时提供不同的参数名称，将会抛出一个错误。</p>
<p>考虑下面的例子。</p>
<p><strong>例 3</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#The function simple_interest(p, t, r) is called with the keyword arguments.   </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">simple_interest</span>(<span class="params">p,t,r</span>):  </span><br><span class="line">    <span class="keyword">return</span> (p*t*r)/<span class="number">100</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># doesn&#x27;t find the exact match of the name of the arguments (keywords)    </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Simple Interest: &quot;</span>,simple_interest(time=<span class="number">10</span>,rate=<span class="number">10</span>,principle=<span class="number">1900</span>)) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">TypeError: simple_interest() got an unexpected keyword argument <span class="string">&#x27;time&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Python 允许我们在函数调用时提供所需参数和关键字参数的混合。但是，必需的参数不能在关键字参数之后给出，即一旦在函数调用中遇到关键字参数，以下参数也必须是关键字参数。</p>
<p>考虑下面的例子。</p>
<p><strong>例 4</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">name1,message,name2</span>):  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;printing the message with&quot;</span>,name1,<span class="string">&quot;,&quot;</span>,message,<span class="string">&quot;,and&quot;</span>,name2)  </span><br><span class="line"><span class="comment">#the first argument is not the keyword argument  </span></span><br><span class="line">func(<span class="string">&quot;John&quot;</span>,message=<span class="string">&quot;hello&quot;</span>,name2=<span class="string">&quot;David&quot;</span>) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">printing the message <span class="keyword">with</span> John , hello ,<span class="keyword">and</span> David</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面的示例将导致一个错误，因为在函数调用中传递了关键字和必需参数的不正确组合。</p>
<p><strong>例 5</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">name1,message,name2</span>): </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;printing the message with&quot;</span>,name1,<span class="string">&quot;,&quot;</span>,message,<span class="string">&quot;,and&quot;</span>,name2)  </span><br><span class="line">func(<span class="string">&quot;John&quot;</span>,message=<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;David&quot;</span>)      </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">SyntaxError: positional argument follows keyword argument</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Python 提供了传递多个关键字参数的工具，这些参数可以表示为 **<strong>kwargs</strong> 。它与 *<strong>args</strong> 相似，但它以字典格式存储参数。</p>
<p>当我们事先不知道参数的数量时，这种类型的参数是有用的。</p>
<p>考虑以下示例:</p>
<p><strong>示例 6:使用关键字参数</strong>的多个参数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">food</span>(<span class="params">**kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line">food(a=<span class="string">&quot;Apple&quot;</span>)</span><br><span class="line">food(fruits=<span class="string">&quot;Orange&quot;</span>, Vagitables=<span class="string">&quot;Carrot&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;Apple&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;fruits&#x27;</span>: <span class="string">&#x27;Orange&#x27;</span>, <span class="string">&#x27;Vagitables&#x27;</span>: <span class="string">&#x27;Carrot&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="变量的范围">变量的范围</h2>
<p>变量的范围取决于变量被声明的位置。程序的一部分中声明的变量可能无法被其他部分访问。</p>
<p>在 python 中，变量是用两种类型的作用域定义的。</p>
<ol>
<li class="lvl-4">
<p>全局变量</p>
</li>
<li class="lvl-4">
<p>局部变量</p>
</li>
</ol>
<p>任何函数外部定义的变量都具有全局作用域，而函数内部定义的变量具有局部作用域。</p>
<p>考虑下面的例子。</p>
<h3 id="示例-1-局部变量">示例 1 局部变量</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_message</span>():  </span><br><span class="line">    message = <span class="string">&quot;hello !! I am going to print a message.&quot;</span> <span class="comment"># the variable message is local to the function itself  </span></span><br><span class="line">    <span class="built_in">print</span>(message)  </span><br><span class="line">print_message()  </span><br><span class="line"><span class="built_in">print</span>(message) <span class="comment"># this will cause an error since a local variable cannot be accessible here.    </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">hello !! I am going to <span class="built_in">print</span> a message.</span><br><span class="line">  File <span class="string">&quot;/root/PycharmProjects/PythonTest/Test1.py&quot;</span>, line <span class="number">5</span>, <span class="keyword">in</span> </span><br><span class="line">    <span class="built_in">print</span>(message)</span><br><span class="line">NameError: name <span class="string">&#x27;message&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="示例-2-全局变量">示例 2 全局变量</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">*args</span>):  </span><br><span class="line">    <span class="built_in">sum</span>=<span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:  </span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span> +arg  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The sum is&quot;</span>,<span class="built_in">sum</span>)  </span><br><span class="line"><span class="built_in">sum</span>=<span class="number">0</span>  </span><br><span class="line">calculate(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>) <span class="comment">#60 will be printed as the sum  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Value of sum outside the function:&quot;</span>,<span class="built_in">sum</span>) <span class="comment"># 0 will be printed  Output:</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The <span class="built_in">sum</span> <span class="keyword">is</span> <span class="number">60</span></span><br><span class="line">Value of <span class="built_in">sum</span> outside the function: <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 列表</title>
    <url>/posts/95b8e516.html</url>
    <content><![CDATA[<h1>Python 列表</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-lists">https://www.javatpoint.com/python-lists</a></p>
</blockquote>
<p>Python 中的列表用于存储各种类型数据的序列。Python 列表是可变类型的，这意味着我们可以在它创建后修改它的元素。然而，Python 由六种能够存储序列的数据类型组成，但最常见和最可靠的类型是列表。</p>
<p>列表可以定义为不同类型的值或项的集合。列表中的项目用逗号(，)分隔，并用方括号[]括起来。</p>
<p>列表可以定义如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">L1 = [<span class="string">&quot;John&quot;</span>, <span class="number">102</span>, <span class="string">&quot;USA&quot;</span>]  </span><br><span class="line">L2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果我们尝试使用 type()函数打印 L1、L2 和 L3 的类型，那么它将显示为一个列表。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(L1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(L2))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="列表的特征">列表的特征</h3>
<p>该列表具有以下特征:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>名单是有序的。</p>
</li>
<li class="lvl-4">
<p>列表的元素可以通过索引来访问。</p>
</li>
<li class="lvl-4">
<p>列表是可变类型的。</p>
</li>
<li class="lvl-4">
<p>列表是可变类型。</p>
</li>
<li class="lvl-4">
<p>列表可以存储各种元素的数量。</p>
</li>
</ul>
<p>让我们检查第一个陈述，列表是有序的。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;Peter&quot;</span>,<span class="number">4.50</span>,<span class="string">&quot;Ricky&quot;</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="string">&quot;Peter&quot;</span>,<span class="number">4.50</span>,<span class="string">&quot;Ricky&quot;</span>,<span class="number">6</span>]</span><br><span class="line">a ==b</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>两个列表都由相同的元素组成，但是第二个列表改变了第五个元素的索引位置，这违反了列表的顺序。当比较两个列表时，它返回 false。</p>
<p>列表在生存期内保持元素的顺序。这就是为什么它是有序的对象集合。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>,<span class="string">&quot;Peter&quot;</span>, <span class="number">4.50</span>,<span class="string">&quot;Ricky&quot;</span>,<span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>,<span class="string">&quot;Peter&quot;</span>, <span class="number">4.50</span>,<span class="string">&quot;Ricky&quot;</span>,<span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">a == b</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>让我们详细看一下列表示例。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">emp = [<span class="string">&quot;John&quot;</span>, <span class="number">102</span>, <span class="string">&quot;USA&quot;</span>]   </span><br><span class="line">Dep1 = [<span class="string">&quot;CS&quot;</span>,<span class="number">10</span>]</span><br><span class="line">Dep2 = [<span class="string">&quot;IT&quot;</span>,<span class="number">11</span>]  </span><br><span class="line">HOD_CS = [<span class="number">10</span>,<span class="string">&quot;Mr. Holding&quot;</span>]  </span><br><span class="line">HOD_IT = [<span class="number">11</span>, <span class="string">&quot;Mr. Bewon&quot;</span>]  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;printing employee data...&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Name : %s, ID: %d, Country: %s&quot;</span>%(emp[<span class="number">0</span>],emp[<span class="number">1</span>],emp[<span class="number">2</span>]))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;printing departments...&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Department 1:\nName: %s, ID: %d\nDepartment 2:\nName: %s, ID: %s&quot;</span>%(Dep1[<span class="number">0</span>],Dep2[<span class="number">1</span>],Dep2[<span class="number">0</span>],Dep2[<span class="number">1</span>]))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;HOD Details ....&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;CS HOD Name: %s, Id: %d&quot;</span>%(HOD_CS[<span class="number">1</span>],HOD_CS[<span class="number">0</span>]))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;IT HOD Name: %s, Id: %d&quot;</span>%(HOD_IT[<span class="number">1</span>],HOD_IT[<span class="number">0</span>]))  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(emp),<span class="built_in">type</span>(Dep1),<span class="built_in">type</span>(Dep2),<span class="built_in">type</span>(HOD_CS),<span class="built_in">type</span>(HOD_IT))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">printing employee data...</span><br><span class="line">Name : John, ID: <span class="number">102</span>, Country: USA</span><br><span class="line">printing departments...</span><br><span class="line">Department <span class="number">1</span>:</span><br><span class="line">Name: CS, ID: <span class="number">11</span></span><br><span class="line">Department <span class="number">2</span>:</span><br><span class="line">Name: IT, ID: <span class="number">11</span></span><br><span class="line">HOD Details ....</span><br><span class="line">CS HOD Name: Mr. Holding, Id: <span class="number">10</span></span><br><span class="line">IT HOD Name: Mr. Bewon, Id: <span class="number">11</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们创建了包含员工和部门详细信息的列表，并打印了相应的详细信息。观察上面的代码，更好地理解列表的概念。</p>
<h2 id="列表索引和拆分">列表索引和拆分</h2>
<p>索引的处理方式与字符串的处理方式相同。可以使用 slice 运算符[]访问列表的元素。</p>
<p>索引从 0 开始，长度为- 1。列表的第一个元素存储在第 0 个索引处，列表的第二个元素存储在第 1 个索引处，依此类推。</p>
<p><img src="img/cd09874c013575f9a7505a36176f8460.png" alt="Python Lists"></p>
<p>我们可以使用以下语法获取列表的子列表。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">list_varible(start:stop:step)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>开始</strong>表示列表的开始索引位置。</p>
</li>
<li class="lvl-4">
<p><strong>停止</strong>表示列表的最后一个索引位置。</p>
</li>
<li class="lvl-4">
<p><strong>步骤</strong>用于跳过<strong>开始:停止</strong>内的第<code>n</code>个元素</p>
</li>
</ul>
<p>考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">3</span>])</span><br><span class="line"><span class="comment"># Slicing the elements</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">0</span>:<span class="number">6</span>])</span><br><span class="line"><span class="comment"># By default the index value is 0 so its starts from the 0th element and go for index -1.</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[:])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">2</span>:<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">1</span>:<span class="number">6</span>:<span class="number">2</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>与其他语言不同，Python 还提供了使用负索引的灵活性。负指数从右边算起。列表的最后一个元素(最右边)的索引为-1；其相邻的左边元素出现在索引-2 处，以此类推，直到遇到最左边的元素。</p>
<p><img src="img/b520fb44b97d8c45105d6a95a5ea699a.png" alt="Python Lists"></p>
<p>让我们看看下面的例子，我们将使用负索引来访问列表的元素。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[-<span class="number">3</span>:])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[:-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[-<span class="number">3</span>:-<span class="number">1</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如上所述，我们可以通过使用负索引来获取元素。在上面的代码中，第一个 print 语句返回列表中最右边的元素。第二个 print 语句返回子列表，依此类推。</p>
<h2 id="更新列表值">更新列表值</h2>
<p>列表是 Python 中最通用的数据结构，因为它们是可变的，并且它们的值可以通过使用切片和赋值操作符来更新。</p>
<p>Python 还提供了 append()和 insert()方法，可用于向列表中添加值。</p>
<p>考虑以下示例来更新列表中的值。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]   </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)   </span><br><span class="line"><span class="comment"># It will assign value to the value to the second index </span></span><br><span class="line"><span class="built_in">list</span>[<span class="number">2</span>] = <span class="number">10</span> </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)  </span><br><span class="line"><span class="comment"># Adding multiple-element </span></span><br><span class="line"><span class="built_in">list</span>[<span class="number">1</span>:<span class="number">3</span>] = [<span class="number">89</span>, <span class="number">78</span>]   </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>) </span><br><span class="line"><span class="comment"># It will add value at the end of the list</span></span><br><span class="line"><span class="built_in">list</span>[-<span class="number">1</span>] = <span class="number">25</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">89</span>, <span class="number">78</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">89</span>, <span class="number">78</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">25</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以使用 <strong>del</strong> 关键字删除列表元素。如果我们不知道要从列表中删除哪个元素，Python 还为我们提供了 <strong>remove()</strong> 方法。</p>
<p>考虑以下示例来删除列表元素。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]   </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)   </span><br><span class="line"><span class="comment"># It will assign value to the value to second index </span></span><br><span class="line"><span class="built_in">list</span>[<span class="number">2</span>] = <span class="number">10</span> </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)  </span><br><span class="line"><span class="comment"># Adding multiple element </span></span><br><span class="line"><span class="built_in">list</span>[<span class="number">1</span>:<span class="number">3</span>] = [<span class="number">89</span>, <span class="number">78</span>]   </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>) </span><br><span class="line"><span class="comment"># It will add value at the end of the list</span></span><br><span class="line"><span class="built_in">list</span>[-<span class="number">1</span>] = <span class="number">25</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">89</span>, <span class="number">78</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">89</span>, <span class="number">78</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">25</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Python-列表操作">Python 列表操作</h2>
<p>串联(+)和重复(*)运算符的工作方式与它们处理字符串的方式相同。</p>
<p>让我们看看列表如何响应各种操作符。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Consider a Lists l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="keyword">and</span> l2 = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>] to perform operation.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>| 操作员 | 描述 | 例子 |<br>
| 重复 | 重复操作符使列表元素能够重复多次。 |</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">L1*<span class="number">2</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>|<br>
| 串联 | 它将运算符两边提到的列表连接起来。 |</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">l1+l2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>
<p>|<br>
| 成员资格 | 如果特定列表中存在特定项目，则返回 true，否则返回 false。 |</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">2</span> <span class="keyword">in</span> l1) prints <span class="literal">True</span>.</span><br></pre></td></tr></table></figure>
<p>|<br>
| 循环 | <code>for</code>循环用于迭代列表元素。 |</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> l1: </span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>|<br>
| 长度 | 它用于获取列表的长度 |</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>(l1) = <span class="number">4</span> </span><br></pre></td></tr></table></figure>
<p>|</p>
<h2 id="迭代列表">迭代列表</h2>
<p>可以通过使用 for - in 循环来迭代列表。包含四个字符串的简单列表，可以如下迭代。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [<span class="string">&quot;John&quot;</span>, <span class="string">&quot;David&quot;</span>, <span class="string">&quot;James&quot;</span>, <span class="string">&quot;Jonathan&quot;</span>]  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>: </span><br><span class="line">    <span class="comment"># The i variable will iterate over the elements of the List and contains each element in each iteration.   </span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">John</span><br><span class="line">David</span><br><span class="line">James</span><br><span class="line">Jonathan</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="向列表中添加元素">向列表中添加元素</h2>
<p>Python 提供了 append()函数，用于将元素添加到列表中。但是，append()函数只能在列表的末尾添加值。</p>
<p>考虑下面的例子，我们从用户那里获取列表的元素，并在控制台上打印该列表。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#Declaring the empty list</span></span><br><span class="line">l =[]</span><br><span class="line"><span class="comment">#Number of elements will be entered by the user  </span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the number of elements in the list:&quot;</span>))</span><br><span class="line"><span class="comment"># for loop to take the input</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n):   </span><br><span class="line">    <span class="comment"># The input is taken from the user and added to the list as the item</span></span><br><span class="line">    l.append(<span class="built_in">input</span>(<span class="string">&quot;Enter the item:&quot;</span>))   </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;printing the list items..&quot;</span>) </span><br><span class="line"><span class="comment"># traversal loop to print the list items  </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> l: </span><br><span class="line">    <span class="built_in">print</span>(i, end = <span class="string">&quot;  &quot;</span>)   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the number of elements <span class="keyword">in</span> the <span class="built_in">list</span>:<span class="number">5</span></span><br><span class="line">Enter the item:<span class="number">25</span></span><br><span class="line">Enter the item:<span class="number">46</span></span><br><span class="line">Enter the item:<span class="number">12</span></span><br><span class="line">Enter the item:<span class="number">75</span></span><br><span class="line">Enter the item:<span class="number">42</span></span><br><span class="line">printing the <span class="built_in">list</span> items</span><br><span class="line"><span class="number">25</span>  <span class="number">46</span>  <span class="number">12</span>  <span class="number">75</span>  <span class="number">42</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="从列表中删除元素">从列表中删除元素</h2>
<p>Python 提供了 <strong>remove()</strong> 函数，用于从列表中移除元素。考虑下面的例子来理解这个概念。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]   </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;printing original list: &quot;</span>);  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:  </span><br><span class="line">    <span class="built_in">print</span>(i,end=<span class="string">&quot; &quot;</span>)  </span><br><span class="line"><span class="built_in">list</span>.remove(<span class="number">2</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nprinting the list after the removal of first element...&quot;</span>)  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:  </span><br><span class="line">    <span class="built_in">print</span>(i,end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">printing original <span class="built_in">list</span>: </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br><span class="line">printing the <span class="built_in">list</span> after the removal of first element...</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Python-列表内置函数">Python 列表内置函数</h2>
<p>Python 提供了以下内置函数，可以与列表一起使用。</p>
<p>| 塞内加尔 | 功能 | 描述 | 例子 |<br>
| one | 《议定书》/《公约》缔约方会议(清单 1、清单 2) | 它比较了两个列表的元素。 | Python 3 和以上版本中不使用此方法。 |<br>
| Two | len(列表) | 它用于计算列表的长度。 |</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">L1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(L1))</span><br><span class="line">    <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>|<br>
| three | 最大值(列表) | 它返回列表的最大元素。 |</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">L1 = [<span class="number">12</span>,<span class="number">34</span>,<span class="number">26</span>,<span class="number">48</span>,<span class="number">72</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(L1))</span><br><span class="line"><span class="number">72</span></span><br></pre></td></tr></table></figure>
<p>|<br>
| four | 最小值(列表) | 它返回列表的最小元素。 |</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">L1 = [<span class="number">12</span>,<span class="number">34</span>,<span class="number">26</span>,<span class="number">48</span>,<span class="number">72</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(L1))</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>|<br>
| five | 列表(序列) | 它将任何序列转换为列表。 |</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;Johnson&quot;</span></span><br><span class="line">s = <span class="built_in">list</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(s))</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="title class_">list</span>&gt;</span><br></pre></td></tr></table></figure>
<p>|</p>
<p>让我们来看看几个列表示例。</p>
<p><strong>示例:1-</strong> 编写程序删除列表的重复元素。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">55</span>,<span class="number">98</span>,<span class="number">65</span>,<span class="number">65</span>,<span class="number">13</span>,<span class="number">29</span>]</span><br><span class="line"><span class="comment"># Declare an empty list that will store unique values</span></span><br><span class="line">list2 = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list1:</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> list2:</span><br><span class="line">        list2.append(i)</span><br><span class="line"><span class="built_in">print</span>(list2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">55</span>, <span class="number">98</span>, <span class="number">65</span>, <span class="number">13</span>, <span class="number">29</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例:2-</strong> 写一个程序，求列表中元素的和。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">list1 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">24</span>]</span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list1:</span><br><span class="line">    <span class="built_in">sum</span> = <span class="built_in">sum</span>+i    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The sum is:&quot;</span>,<span class="built_in">sum</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The <span class="built_in">sum</span> <span class="keyword">is</span>: <span class="number">67</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例:3-</strong> 编写程序，找出至少包含一个公共元素的列表。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">list2 = [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">10</span>]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> list1:</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> list2:</span><br><span class="line">        <span class="keyword">if</span> x == y:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;The common element is:&quot;</span>,x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The common element <span class="keyword">is</span>: <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 列表推导</title>
    <url>/posts/a5129ea8.html</url>
    <content><![CDATA[<h1>Python 列表推导</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-list-comprehension">https://www.javatpoint.com/python-list-comprehension</a></p>
</blockquote>
<p>列表推导被定义为一种优雅的定义方式，在 Python 中创建一个列表，由括号组成，括号中包含一个表达式，后跟子句的**。它在计算和编码空间和时间方面都是有效的。**</p>
<h3 id="签名">签名</h3>
<p>清单理解从**‘[’****‘]’**开始。</p>
<p>如果有条件，列表<strong>中</strong>项<strong>的【表达式</strong></p>
<p>**### 例子</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">letters = []</span><br><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">&#x27;Python&#x27;</span>:</span><br><span class="line">    letters.append(letter)</span><br><span class="line"><span class="built_in">print</span>(letters)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;n&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例子-2">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">letters = [ letter <span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">&#x27;Python&#x27;</span> ]</span><br><span class="line"><span class="built_in">print</span>( letters)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;n&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例子-3">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">x = &#123;<span class="string">&#x27;chrome&#x27;</span>: <span class="string">&#x27;browser&#x27;</span>, <span class="string">&#x27;Windows&#x27;</span>: <span class="string">&#x27;OS&#x27;</span>, <span class="string">&#x27;C&#x27;</span>: <span class="string">&#x27;language&#x27;</span>&#125;</span><br><span class="line">x[<span class="string">&#x27;mouse&#x27;</span>] = <span class="string">&#x27;hardware&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(x[<span class="string">&#x27;Windows&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<pre><code class="language-py">OS

```**</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 列表与元组</title>
    <url>/posts/97185454.html</url>
    <content><![CDATA[<h1>Python 列表与元组</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-list-vs-tuple">https://www.javatpoint.com/python-list-vs-tuple</a></p>
</blockquote>
<p>在本教程中，我们将学习列表和元组之间的重要区别，以及它们在 Python 中如何发挥重要作用。</p>
<p>列表和元组用于顺序存储一个或多个 Python 对象或数据类型。两者都可以存储任何数据，如整数、浮点、字符串和字典。列表和元组在大多数因素上是相似的，但是在这里我们将描述它们之间的主要区别。</p>
<p>让我们讨论以下几点的主要区别。</p>
<h2 id="代表性差异">代表性差异</h2>
<p>列表和元组的表示略有不同。列表通常用方括号[]括起来，元素是逗号分隔的元素。元组用括号()括起来，元素用逗号分隔。括号是可选的，这些类型的元组被称为元组打包。</p>
<p>考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">list1 = [<span class="string">&#x27;JavaTpoint&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">54.30</span>, &#123;<span class="string">&#x27;Name: &#x27;</span><span class="string">&#x27;Peter&#x27;</span>&#125;]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">list</span>))</span><br><span class="line">tuple1 = (<span class="string">&#x27;JavaTpoint&#x27;</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">31.9</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(tuple1))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的程序中，我们定义了一个 <strong>list1</strong> 变量，它保存了从索引 0 到 4 的不同数据类型的列表。我们定义了另一个变量 <strong>tuple1，</strong>，它包含不同数据类型的元组。它由()括起来。</p>
<h2 id="可变列表和不可变元组">可变列表和不可变元组</h2>
<p>这是列表和元组之间最重要的区别，而列表是可变的，元组是不可变的。列表是可变的，这意味着 Python 对象在创建后可以修改，而元组在创建后不能修改。考虑给定的示例。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a = [<span class="string">&quot;Peter&quot;</span>,<span class="string">&quot;Joseph&quot;</span>,<span class="string">&quot;Mathew&quot;</span>,<span class="string">&quot;Ricky&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;Peter&#x27;</span>, <span class="string">&#x27;Joseph&#x27;</span>, <span class="string">&#x27;Mathew&#x27;</span>, <span class="string">&#x27;Ricky&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在我们将第 0 <sup>个</sup>索引元素“Peter”更改为“Samson”。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a[<span class="number">0</span>] = <span class="string">&quot;Samson&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;Samson&#x27;</span>, <span class="string">&#x27;Joseph&#x27;</span>, <span class="string">&#x27;Mathew&#x27;</span>, <span class="string">&#x27;Ricky&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在我们创建一个元组并做同样的事情。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a = (<span class="number">10</span>,<span class="number">20</span>,<span class="string">&quot;JavaTpoint&quot;</span>,<span class="number">30</span>,<span class="number">40</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="number">10</span>, <span class="number">20</span>, <span class="string">&#x27;JavaTpoint&#x27;</span>, <span class="number">30</span>, <span class="number">40</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">50</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">5</span>-52b2981fae12&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; <span class="number">1</span> a[<span class="number">0</span>] = <span class="number">50</span></span><br><span class="line"></span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于不变性，我们在更改元组的 1 <sup>st</sup> 元素时出错。它不支持项目分配。</p>
<h2 id="排除故障">排除故障</h2>
<p>由于元组的不变性，在大型项目中很容易调试。如果我们有一个小项目或较少数量的数据，那么列表就发挥了有效的作用。让我们考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a = [<span class="number">6</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line"><span class="comment"># Copying address of a in b</span></span><br><span class="line">b = a</span><br><span class="line">a[<span class="number">3</span>] = <span class="string">&quot;JavaToint&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="string">&#x27;JavaToint&#x27;</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们做了<strong>b = a</strong>；这里我们没有将列表对象从 b 复制到 a。<strong>b</strong>指的是列表 <strong>a</strong> 的地址。这意味着如果我们在 b 中进行更改，那么它将反映与列表 **a、**中相同的内容，这使得调试变得容易。但是对于 Python 对象可能有多个引用的重要项目来说，这很难。</p>
<p>跟踪列表中的那些变化会非常复杂，但是不可变的对象元组在创建后不能改变。</p>
<p>所以元组很容易调试。</p>
<h2 id="功能支持">功能支持</h2>
<p>元组支持的操作比列表少。内置的 **dir(对象)**用于获取列表和元组支持的所有函数。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>列出功能</strong></p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">dir</span>(<span class="built_in">list</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;__add__&#x27;</span>,<span class="string">&#x27;__class__&#x27;</span>,<span class="string">&#x27;__contains__&#x27;</span>,<span class="string">&#x27;__delattr__&#x27;</span>,<span class="string">&#x27;__delitem__&#x27;</span>,<span class="string">&#x27;__dir_,</span></span><br><span class="line"><span class="string"> &#x27;</span>__doc__<span class="string">&#x27;,&#x27;</span>__eq__<span class="string">&#x27;,&#x27;</span>__format__<span class="string">&#x27;, &#x27;</span>__get__<span class="string">&#x27;,&#x27;</span>__getattribute__<span class="string">&#x27;,&#x27;</span>__getitem_<span class="string">&#x27; &#x27;</span>__gt__<span class="string">&#x27;,&#x27;</span>__hash__<span class="string">&#x27;,&#x27;</span>__iadd__<span class="string">&#x27;,&#x27;</span>__imul__<span class="string">&#x27;,&#x27;</span>__init__<span class="string">&#x27;,&#x27;</span>__init_subclass__<span class="string">&#x27;&#x27;</span>__iter__<span class="string">&#x27;,&#x27;</span>__le__<span class="string">&#x27;,&#x27;</span>__len__<span class="string">&#x27;,&#x27;</span>__lt__<span class="string">&#x27;,&#x27;</span>__mul__<span class="string">&#x27;, &#x27;</span>__ne__<span class="string">&#x27;,&#x27;</span>__new__<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>__reduce__<span class="string">&#x27;, &#x27;</span>__reduce_ex__<span class="string">&#x27;,&#x27;</span>__repr__<span class="string">&#x27;,&#x27;</span>__reversed__<span class="string">&#x27;,&#x27;</span>__rmul__<span class="string">&#x27;,&#x27;</span>__setattr__<span class="string">&#x27;,&#x27;</span>__setitem__<span class="string">&#x27;,&#x27;</span>__sizeof__<span class="string">&#x27;,&#x27;</span>__str__<span class="string">&#x27;,&#x27;</span>__subclasshook__<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>append<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>clea<span class="string">r&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>copy<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>count<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>extend<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>index<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>insert<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>pop<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>remove<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>reverse<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>sort<span class="string">&#x27;]</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>元组函数</strong></p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">dir</span>(<span class="built_in">tuple</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;__add__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__class__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__contains__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__delattr__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__dir__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__doc__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__eq__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__format__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__ge__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__getattribute__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__getitem__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__getnewargs__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__gt__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__hash__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__init__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__init_subclass__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__iter__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__le__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__len__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__lt__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__mul__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__ne__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__new__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__reduce__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__reduce_ex__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__repr__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__rmul__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__setattr__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__sizeof__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__str__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__subclasshook__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;count&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;index&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="内存高效">内存高效</h2>
<p>元组比列表更节省内存，因为元组的内置操作更少。列表适用于较少的元素，而元组对于大量数据来说比列表快一点。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">Tuple</span> = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">5485</span>,<span class="number">87525</span>,<span class="number">955</span>,<span class="number">3343</span>,<span class="number">53234</span>,<span class="number">6423</span>,<span class="number">623456</span>,<span class="number">234535</span>)</span><br><span class="line"><span class="type">List</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">78</span>,<span class="number">34</span>,<span class="number">43</span>,<span class="number">32</span>,<span class="number">43</span>,<span class="number">55</span>,<span class="number">54</span>,<span class="number">212</span>,<span class="number">642</span>,<span class="number">533</span>,<span class="number">43434</span>,<span class="number">54532</span> ]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Tuple size =&#x27;</span>, <span class="type">Tuple</span>.__sizeof__())       <span class="comment"># Tuple size = 52</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;List size =&#x27;</span>, <span class="type">List</span>.__sizeof__())  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="type">Tuple</span> size = <span class="number">168</span></span><br><span class="line"><span class="type">List</span> size = <span class="number">216</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="结论-2">结论</h2>
<ul class="lvl-0">
<li class="lvl-4">
<p>在某些情况下，列表可能比元组更有用。但是元组是 Python 的重要数据结构。元组通常用于不可更改的数据，或者我们可以说数据将在元组中被**“写保护”**。元组向 Python 解释器发送数据将来不应改变的指示。</p>
</li>
<li class="lvl-4">
<p>我们可以像使用字典一样使用元组，而不用使用键来存储数据。例如-</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">list1 = [(<span class="number">101</span>, <span class="string">&quot;Mike&quot;</span>, <span class="number">24</span>),(<span class="number">102</span>, <span class="string">&#x27;Hussey&#x27;</span>, <span class="number">26</span>),(<span class="number">103</span>, <span class="string">&#x27;David&#x27;</span>, <span class="number">27</span>),(<span class="number">104</span>,  <span class="string">&#x27;Warner&#x27;</span>, <span class="number">29</span>)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p>元组可以用于字典关键字，因为这些关键字是可哈希和不可变的，而列表不能在字典中使用关键字。</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">dict</span> = &#123;(<span class="string">&quot;Mike&quot;</span>,<span class="number">22</span>):<span class="number">24000</span>&#125;    <span class="comment">#valid dictionary</span></span><br><span class="line"><span class="built_in">dict</span> = &#123;[<span class="string">&quot;Peter&quot;</span>,<span class="number">26</span>]:<span class="number">25000</span>&#125;   <span class="comment">#Invalid dictionary</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 历史和版本</title>
    <url>/posts/255b14f4.html</url>
    <content><![CDATA[<h1>Python 历史和版本</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-history">https://www.javatpoint.com/python-history</a></p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-4">
<p>Python 在 20 世纪 80 年代末奠定了基础。</p>
</li>
<li class="lvl-4">
<p>Python 的实现始于 1989 年 12 月荷兰 CWI 的吉多·范·罗松。</p>
</li>
<li class="lvl-4">
<p>1991 年 2 月， <strong>Guido Van Rossum</strong> 发布了代码(标记为版本 0.9.0)来替换源代码。</p>
</li>
<li class="lvl-4">
<p>1994 年，Python 1.0 发布了新特性，如 lambda、map、filter 和 reduce。</p>
</li>
<li class="lvl-4">
<p>Python 2.0 增加了新功能，如列表推导、垃圾收集系统。</p>
</li>
<li class="lvl-4">
<p>2008 年 12 月 3 日，Python 3.0(也叫“Py3K”)发布。它旨在纠正语言的根本缺陷。</p>
</li>
<li class="lvl-4">
<p><em>ABC 编程语言</em>据说是 Python 语言的前身，它能够处理异常并与阿米巴操作系统接口。</p>
</li>
<li class="lvl-4">
<p>以下编程语言会影响 Python:</p>
<ul class="lvl-2">
<li class="lvl-8">ABC 语言。</li>
<li class="lvl-8">Modula-3</li>
</ul>
</li>
</ul>
<h2 id="为什么叫-Python？">为什么叫 Python？</h2>
<p>选择名称 <a href="https://www.javatpoint.com/python-tutorial">Python</a> 背后有一个事实。<strong>吉多·范·罗苏姆</strong>正在阅读英国广播公司(BBC)热门喜剧系列《T4》的剧本《巨蟒飞行马戏团》。那是 20 世纪 70 年代后期的节目。</p>
<p>范·罗瑟姆想选择一个独特的、有点神秘的名字。所以他决定为他们新创建的编程语言选择以**“蒙蒂·Python 的飞行马戏团”**命名 Python。</p>
<p>这部喜剧系列很有创意，也很随意。它无所不谈。因此，它是缓慢和不可预测的，这使得它非常有趣。</p>
<p>Python 也是多才多艺，广泛应用于各个技术领域，如<a href="https://www.javatpoint.com/machine-learning">机器学习</a>、<a href="https://www.javatpoint.com/artificial-intelligence-tutorial">人工智能</a>、Web 开发、<a href="javatpoint.com/mobile-application-testing">移动应用</a>、桌面应用、科学计算等。</p>
<h2 id="Python-版本列表">Python 版本列表</h2>
<p>Python 编程语言正在定期更新，增加了新的功能和支持。Python 版本中有很多更新，从 1994 年开始到当前版本。</p>
<p>下面列出了 Python 版本及其发布日期。</p>
<table>
<thead>
<tr>
<th>Python 版本</th>
<th>发布日期</th>
</tr>
</thead>
<tbody>
<tr>
<td>Python 1.0</td>
<td>1994 年 1 月</td>
</tr>
<tr>
<td>Python 1.5</td>
<td>一九九七年十二月三十一日</td>
</tr>
<tr>
<td>Python 1.6</td>
<td>2000 年 9 月 5 日</td>
</tr>
<tr>
<td>Python 2.0</td>
<td>二○○○年十月十六日</td>
</tr>
<tr>
<td>Python 2.1</td>
<td>二零零一年四月十七日</td>
</tr>
<tr>
<td>Python 2.2</td>
<td>二零零一年十二月二十一日</td>
</tr>
<tr>
<td>Python 2.3</td>
<td>2003 年 7 月 29 日</td>
</tr>
<tr>
<td>Python 2.4</td>
<td>二○○四年十一月三十日</td>
</tr>
<tr>
<td>Python 2.5</td>
<td>2006 年 9 月 19 日</td>
</tr>
<tr>
<td>Python 2.6</td>
<td>08 年 10 月 1 日</td>
</tr>
<tr>
<td>Python 2.7</td>
<td>2010 年 7 月 3 日</td>
</tr>
<tr>
<td>Python 3.0</td>
<td>2008 年 12 月 3 日</td>
</tr>
<tr>
<td>Python 3.1</td>
<td>2009 年 6 月 27 日</td>
</tr>
<tr>
<td>Python 3.2</td>
<td>2011 年 2 月 20 日</td>
</tr>
<tr>
<td>Python 3.3</td>
<td>2012 年 9 月 29 日</td>
</tr>
<tr>
<td>Python 3.4</td>
<td>2014 年 3 月 16 日</td>
</tr>
<tr>
<td>Python 3.5</td>
<td>2015 年 9 月 13 日</td>
</tr>
<tr>
<td>Python 3.6</td>
<td>2016 年 12 月 23 日</td>
</tr>
<tr>
<td>Python 3.7</td>
<td>2018 年 6 月 27 日</td>
</tr>
<tr>
<td>Python 3.8</td>
<td>2019 年 10 月 14 日</td>
</tr>
</tbody>
</table>
<h2 id="学习-Python-时要牢记的技巧">学习 Python 时要牢记的技巧</h2>
<p>初学者最常问的问题- **“学习 Python 最好的方法是什么”？**这是最初的相关问题，因为学习任何编程语言的第一步都是知道如何学习。</p>
<p>正确的学习方式有助于我们快速学习，成为一名优秀的 Python 开发人员。</p>
<p>在本节中，我们将讨论学习 Python 时应该记住的各种技巧。</p>
<h3 id="1-明确我们为什么要学习">1.明确我们为什么要学习</h3>
<p>在学习 Python 之前，目标应该是明确的。Python 是一门简单的语言，也是一门庞大的语言。它包括许多库、模块、内置函数和数据结构。如果目标不明确，那么学习 Python 将会是一段枯燥而单调的旅程。如果没有明确的目标，你可能无法完成。</p>
<p>所以，首先弄清楚学习背后的动机，可以是任何事情，比如了解一些新的东西，使用 Python 开发项目，切换到 Python 等。下面是 Python 被广泛使用的一般领域。随便挑一个。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>数据分析和处理</p>
</li>
<li class="lvl-4">
<p>人工智能</p>
</li>
<li class="lvl-4">
<p>比赛</p>
</li>
<li class="lvl-4">
<p>硬件/传感器/机器人</p>
</li>
<li class="lvl-4">
<p>桌面应用</p>
</li>
</ul>
<p>根据自己的兴趣选择任意一两个领域，开始学习 Python 的旅程。</p>
<h3 id="2-学习基本语法">2.学习基本语法</h3>
<p>学习 Python 编程语言的语法是最基本的一步。在深入学习语法之前，我们必须先学习基本的语法。正如我们在前面的教程中所讨论的，Python 很容易学习，并且语法简单。它不使用分号和括号。它的句法就像英语一样。</p>
<p>所以学习它的语法只需要最少的时间。一旦我们正确理解了它的语法，进一步的学习将会更容易更快地开始项目。</p>
<h4 id="注意-学习-Python-3，而不是-Python-2-7，因为行业不再使用它。我们的-Python-教程基于其最新版本-Python-3。">注意-学习 Python 3，而不是 Python 2.7，因为行业不再使用它。我们的 Python 教程基于其最新版本 Python 3。</h4>
<h3 id="3-自己写代码">3.自己写代码</h3>
<p>编写代码是学习 Python 最有效、最健壮的方法。首先，试着在纸上写代码并在脑海中运行(模拟运行)，然后进入系统。在纸上写代码将有助于我们快速熟悉存储在深层记忆中的语法和概念。编写代码时，尽量使用正确的函数和合适的变量名称。</p>
<p>Python 编程有许多编辑器，可以自动突出语法相关的问题。所以我们不需要太在意这些错误。</p>
<h3 id="4-继续练习">4.继续练习</h3>
<p>下一个重要的步骤是练习。它需要通过代码实现 Python 概念。我们应该与我们的日常编码实践保持一致。</p>
<p>一致性是生活中任何方面成功的关键，不仅仅是在编程方面。每天写代码将有助于发展肌肉记忆。</p>
<p>我们可以做相关概念的习题或者解决至少 2 到 3 个 Python 的问题。这看起来很难，但肌肉记忆在编程中起着很大的作用。它将带领我们超越那些认为只有 Python 的阅读概念就足够了的人。</p>
<h3 id="5-根据需要做笔记">5.根据需要做笔记</h3>
<p>自己创建笔记是学习 Python 概念和语法的绝佳方法。它将建立稳定性和专注度，帮助你成为一名 Python 开发人员。用相关信息做简短的笔记，并包括相关主题的适当例子。</p>
<p>保持自己的笔记也有助于快速学习。发表在《心理科学》上的一项研究显示-</p>
<blockquote>
<p>在研究中做手写笔记的学生被迫变得更有选择性——因为你不能像打字一样快。</p>
</blockquote>
<h3 id="6-与他人讨论概念">6.与他人讨论概念</h3>
<p>编码似乎是一种孤立的活动，但我们可以通过与他人互动来提高自己的技能。我们应该向正在学习 Python 的专家或朋友讨论我们的疑惑。这个习惯将有助于获得额外的信息、提示和技巧，以及编码问题的解决方案。Python 最大的优势之一是它有一个很棒的社区。因此，我们也可以向热情的 Python 爱好者学习。</p>
<h3 id="7-做小项目">7.做小项目</h3>
<p>了解 Python 的基本概念后，初学者应该尝试在小项目上工作。这将有助于更深入地理解 Python，并在其中变得更有分量。理论知识不足以掌握 Python 语言。这些项目可以是任何东西，只要它们教会你一些东西。你可以从小项目开始，如计算器应用、tic-toc-toe 游戏、闹钟应用、待办事项列表、学生或客户管理系统等。</p>
<p>一旦你对一个小项目得心应手，你就可以轻松地转向你感兴趣的领域(机器学习、网络开发等)。).</p>
<h3 id="8-教导他人">8.教导他人</h3>
<p>有一句名言**“如果你想学点什么，那你应该教其他人”**。在学习 Python 的情况下也是如此。通过创建博客、录制视频或在当地培训中心上课，将您的信息分享给其他学生。它将帮助我们增强对 Python 的理解，并探索您知识中看不见的漏洞。如果您不想做所有这些，请加入在线论坛，并在 Python 相关问题上发布您的答案。</p>
<h3 id="9-探索库和框架">9.探索库和框架</h3>
<p>Python 由大量的库和各种框架组成。在熟悉了 Python 的基本概念之后，下一步是探索 Python 库。库对于处理领域特定的项目是必不可少的。在下一节中，我们将简要介绍主要的库。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong><a href="https://www.javatpoint.com/tensorflow">TensorFlow</a> -</strong> 它是一个人工智能库，允许我们创建大规模的基于 AI 的项目。</p>
</li>
<li class="lvl-4">
<p><strong><a href="https://www.javatpoint.com/django-tutorial">Django</a> -</strong> 它是一个开源框架，允许我们开发 web 应用。它简单、灵活且易于管理。</p>
</li>
<li class="lvl-4">
<p><strong><a href="https://www.javatpoint.com/flask-tutorial">Flask</a> -</strong> 也是一个开源的 web 框架。它用于开发轻量级 web 应用。</p>
</li>
<li class="lvl-4">
<p><strong><a href="https://www.javatpoint.com/python-pandas">Pandas</a> -</strong> 这是一个用来进行科学计算的 Python 库。</p>
</li>
<li class="lvl-4">
<p><strong><a href="https://www.javatpoint.com/keras">Keras</a> -</strong> 它是一个开源库，用来围绕神经网络工作。</p>
</li>
</ul>
<p>Python 中有很多库。以上，我们已经提到了其中的几个。</p>
<h3 id="10-为开源做贡献">10.为开源做贡献</h3>
<p>众所周知，Python 是一种开源语言，这意味着它对每个人都是免费的。我们还可以向 Python 在线社区投稿，以增强我们的知识。为开源项目做贡献是探索自己知识的最好方式。我们还会收到对我们提交的工作的反馈、意见或建议。反馈将支持 Python 编程的最佳实践，并帮助我们成为一名优秀的 Python 开发人员。</p>
<h2 id="Python-的用法">Python 的用法</h2>
<p>Python 是一种通用、开源的高级编程语言，也提供了许多库和框架。Python 因其简单、易于语法和用户友好的环境而广受欢迎。Python 的用法如下。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>桌面应用</p>
</li>
<li class="lvl-4">
<p>网络应用</p>
</li>
<li class="lvl-4">
<p><a href="https://www.javatpoint.com/data-science">数据科学</a></p>
</li>
<li class="lvl-4">
<p><a href="https://www.javatpoint.com/artificial-intelligence-tutorial">人工智能</a></p>
</li>
<li class="lvl-4">
<p><a href="https://www.javatpoint.com/machine-learning">机器学习</a></p>
</li>
<li class="lvl-4">
<p>科学计算</p>
</li>
<li class="lvl-4">
<p><a href="https://www.javatpoint.com/robotics-tutorial">机器人</a></p>
</li>
<li class="lvl-4">
<p><a href="https://www.javatpoint.com/iot-internet-of-things">物联网(IoT)</a></p>
</li>
<li class="lvl-4">
<p>赌博</p>
</li>
<li class="lvl-4">
<p>移动应用</p>
</li>
<li class="lvl-4">
<p>数据分析和预处理</p>
</li>
</ul>
<p>在下一个主题中，我们将讨论 <a href="https://www.javatpoint.com/python-applications">Python 应用</a>，在这里我们已经详细定义了 Python 的用法。</p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 变量</title>
    <url>/posts/18ed7528.html</url>
    <content><![CDATA[<h1>Python 变量</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-variables">https://www.javatpoint.com/python-variables</a></p>
</blockquote>
<p>变量是用于引用内存位置的名称。Python 变量也称为标识符，用于保存值。</p>
<p>在 Python 中，我们不需要指定变量的类型，因为 Python 是一种推断语言，并且足够聪明，可以获得变量类型。</p>
<p>变量名可以是一组字母和数字，但它们必须以字母或下划线开头。</p>
<p>建议变量名使用小写字母。rahul 和 Rahul 都是两个不同的变量。</p>
<h2 id="标识符命名">标识符命名</h2>
<p>变量是标识符的例子。标识符用于标识程序中使用的字面值。命名标识符的规则如下。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>变量的第一个字符必须是字母或下划线（<code>_</code>）。</p>
</li>
<li class="lvl-4">
<p>除第一个字符外，所有字符都可以是小写字母(a-z)、大写字母(A-Z)、下划线或数字(0-9)。</p>
</li>
<li class="lvl-4">
<p>标识符名称不能包含任何空格或特殊字符(！, @, #, %, ^, &amp;, *).</p>
</li>
<li class="lvl-4">
<p>标识符名称不得与语言中定义的任何关键字相似。</p>
</li>
<li class="lvl-4">
<p>标识符名称区分大小写；比如我的名字，和我的名字不一样。</p>
</li>
<li class="lvl-4">
<p>有效标识符的例子:a123，_n，n_9 等。</p>
</li>
<li class="lvl-4">
<p>无效标识符的示例:1a、n%4、n 9 等。</p>
</li>
</ul>
<h2 id="声明变量并赋值">声明变量并赋值</h2>
<p>Python 不要求我们在应用中使用变量之前声明变量。它允许我们在需要的时候创建一个变量。</p>
<p>我们不需要在 Python 中显式声明变量。当我们给变量赋值时，该变量会自动声明。</p>
<p>等号(=)运算符用于给变量赋值。</p>
<h2 id="对象引用">对象引用</h2>
<p>当我们声明一个变量时，有必要了解 Python 解释器是如何工作的。处理变量的过程与许多其他编程语言有些不同。</p>
<p>Python 是高度面向对象的编程语言；这就是为什么每个数据项都属于特定类型的类。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;John&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">John</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Python 对象创建一个整数对象，并将其显示在控制台上。在上面的 print 语句中，我们创建了一个字符串对象。让我们使用 Python 内置的 <strong>type()</strong> 函数来检查它的类型。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>(<span class="string">&quot;John&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在 Python 中，变量是一个符号名称，是对对象的引用或指针。变量用来用这个名字来表示对象。</p>
<p>让我们理解下面的例子</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = <span class="number">50</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="img/b2d2c994c879691b8703f74bb137b1a3.png" alt="Python Variables"></p>
<p>在上图中，变量 <strong>a</strong> 指的是一个整数对象。</p>
<p>假设我们将整数值 50 赋给一个新变量 b。</p>
<p>a = 50</p>
<p>b = a</p>
<p><img src="img/bb04824d45f1fd8453e1b3933054fb99.png" alt="Python Variables"></p>
<p>变量 b 引用了 a 指向的同一个对象，因为 Python 不会创建另一个对象。</p>
<p>让我们将新值赋给 b。现在两个变量将引用不同的对象。</p>
<p>a = 50</p>
<p>b =100</p>
<p><img src="img/019075008623bcf1a77c3545a3c8146c.png" alt="Python Variables"></p>
<p>如果我们将同一个变量赋给两个不同的值，Python 可以有效地管理内存。</p>
<h2 id="对象标识">对象标识</h2>
<p>在 Python 中，每个创建的对象在 Python 中都是唯一标识的。Python 保证没有两个对象具有相同的标识符。内置 <strong>id()</strong> 功能，用于识别对象标识符。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = <span class="number">50</span></span><br><span class="line">b = a</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b))</span><br><span class="line"><span class="comment"># Reassigned variable a</span></span><br><span class="line">a = <span class="number">500</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">140734982691168</span></span><br><span class="line"><span class="number">140734982691168</span></span><br><span class="line"><span class="number">2822056960944</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们指定 <strong>b = a，a</strong> 和 <strong>b</strong> 都指向同一个对象。当我们通过 <strong>id()</strong> 函数检查时，它返回了相同的数字。我们将 <strong>a</strong> 重新分配给 500；然后它引用新的对象标识符。</p>
<h2 id="变量名">变量名</h2>
<p>我们已经讨论了如何声明有效变量。变量名可以是任意长度，可以有大写、小写(A 到 Z、A 到 Z)、数字(0-9)和下划线字符（<code>_</code>）。考虑以下有效变量名称的示例。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;Devansh&quot;</span></span><br><span class="line">age = <span class="number">20</span></span><br><span class="line">marks = <span class="number">80.50</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(name)</span><br><span class="line"><span class="built_in">print</span>(age)</span><br><span class="line"><span class="built_in">print</span>(marks)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Devansh</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">80.5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>请考虑以下有效变量名称。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;A&quot;</span></span><br><span class="line">Name = <span class="string">&quot;B&quot;</span></span><br><span class="line">naMe = <span class="string">&quot;C&quot;</span></span><br><span class="line">NAME = <span class="string">&quot;D&quot;</span></span><br><span class="line">n_a_m_e = <span class="string">&quot;E&quot;</span></span><br><span class="line">_name = <span class="string">&quot;F&quot;</span></span><br><span class="line">name_ = <span class="string">&quot;G&quot;</span></span><br><span class="line">_name_ = <span class="string">&quot;H&quot;</span></span><br><span class="line">na56me = <span class="string">&quot;I&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(name,Name,naMe,NAME,n_a_m_e, NAME, n_a_m_e, _name, name_,_name, na56me)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">A B C D E D E F G F I</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们已经声明了一些有效的变量名，比如 name，<em>name</em>，等等。但不建议这样做，因为当我们试图阅读代码时，可能会造成混乱。变量名应该是描述性的，以使代码更易读。</p>
<p>多词关键字可以通过以下方法创建。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Camel Case -</strong> 在 Camel Case 中，中间的每个单词或缩写都以大写字母开头。没有空白的介入。例如- nameOfStudent、valueOfVaraible 等。</p>
</li>
<li class="lvl-4">
<p><strong>Pascal Case -</strong> 与 Camel Case 相同，但这里第一个字也是大写。例如- NameOfStudent 等。</p>
</li>
<li class="lvl-4">
<p><strong>蛇格-</strong> 在蛇格中，单词用下划线隔开。例如-学生姓名等。</p>
</li>
</ul>
<h2 id="多重赋值">多重赋值</h2>
<p>Python 允许我们在一条语句中为多个变量赋值，这也称为多次赋值。</p>
<p>我们可以通过两种方式应用多个赋值，要么将单个值赋给多个变量，要么将多个值赋给多个变量。考虑下面的例子。</p>
<p><strong>1。给多个变量赋值</strong></p>
<p><strong>Eg:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">x=y=z=<span class="number">50</span>  </span><br><span class="line"><span class="built_in">print</span>(x)  </span><br><span class="line"><span class="built_in">print</span>(y)  </span><br><span class="line"><span class="built_in">print</span>(z)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">50</span>  </span><br><span class="line"><span class="number">50</span>  </span><br><span class="line"><span class="number">50</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>2。给多个变量分配多个值:</strong></p>
<p><strong>Eg:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a,b,c=<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>  </span><br><span class="line"><span class="built_in">print</span> a  </span><br><span class="line"><span class="built_in">print</span> b  </span><br><span class="line"><span class="built_in">print</span> c  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>  </span><br><span class="line"><span class="number">10</span>  </span><br><span class="line"><span class="number">15</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这些值将按照变量出现的顺序进行分配。</p>
<h2 id="Python-变量类型">Python 变量类型</h2>
<p>Python 中有两种类型的变量——局部变量和全局变量。让我们了解以下变量。</p>
<h3 id="局部变量">局部变量</h3>
<p>局部变量是在函数内部声明并在函数内部有作用域的变量。让我们理解下面的例子。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Declaring a function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line">    <span class="comment"># Defining local variables. They has scope only within a function</span></span><br><span class="line">    a = <span class="number">20</span></span><br><span class="line">    b = <span class="number">30</span></span><br><span class="line">    c = a + b</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The sum is:&quot;</span>, c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calling a function</span></span><br><span class="line">add()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The <span class="built_in">sum</span> <span class="keyword">is</span>: <span class="number">50</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的代码中，我们声明了一个名为 <strong>add()</strong> 的函数，并在函数中分配了一些变量。这些变量将被称为<strong>局部变量</strong>，其范围仅在函数内部。如果我们试图在函数外使用它们，我们会得到以下错误。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add()</span><br><span class="line"><span class="comment"># Accessing local variable outside the function </span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The <span class="built_in">sum</span> <span class="keyword">is</span>: <span class="number">50</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">NameError: name <span class="string">&#x27;a&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们试图在它们的范围之外使用局部变量；它抛出了<strong>命名错误。</strong></p>
<h3 id="全局变量">全局变量</h3>
<p>全局变量可以在整个程序中使用，其范围在整个程序中。我们可以在函数内部或外部使用全局变量。</p>
<p>默认情况下，在函数外部声明的变量是全局变量。Python 提供了<strong>全局</strong>关键字来使用函数内部的全局变量。如果我们不使用<strong>全局</strong>关键字，函数会将其视为局部变量。让我们理解下面的例子。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Declare a variable and initialize it</span></span><br><span class="line">x = <span class="number">101</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Global variable in function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mainFunction</span>():</span><br><span class="line">    <span class="comment"># printing a global variable</span></span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    <span class="comment"># modifying a global variable</span></span><br><span class="line">    x = <span class="string">&#x27;Welcome To Javatpoint&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line">mainFunction()</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">101</span></span><br><span class="line">Welcome To Javatpoint</span><br><span class="line">Welcome To Javatpoint</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的代码中，我们声明了一个全局变量 <strong>x</strong> ，并为其赋值。接下来，我们定义了一个函数，并使用函数内部的<strong>全局</strong>关键字访问了声明的变量。现在我们可以修改它的值。然后，我们给变量 x 分配了一个新的字符串值。</p>
<p>现在，我们调用该函数并继续打印 <strong>x</strong> 。它打印为新分配的 x 值。</p>
<h2 id="删除变量">删除变量</h2>
<p>我们可以使用 <strong>del</strong> 关键字删除变量。语法如下。</p>
<p><strong>语法-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> &lt;variable_name&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在下面的例子中，我们创建了一个变量 x，并为其赋值。我们删除了变量 x，打印出来，得到错误**“变量 x 没有定义”**。变量 x 今后将不再使用。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Assigning a value to x</span></span><br><span class="line">x = <span class="number">6</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment"># deleting a variable. </span></span><br><span class="line"><span class="keyword">del</span> x</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;C:/Users/DEVANSH SHARMA/PycharmProjects/Hello/multiprocessing.py&quot;</span>, line <span class="number">389</span>, <span class="keyword">in</span> <span class="built_in">print</span>(x)</span><br><span class="line">NameError: name <span class="string">&#x27;x&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined </span><br></pre></td></tr></table></figure>
<h2 id="Python-中整数的最大可能值">Python 中整数的最大可能值</h2>
<p>与其他编程语言不同，Python 没有长整型或浮点型数据类型。它将所有整数值视为 <strong>int</strong> 数据类型。这里，问题出现了。Python 中变量能容纳的最大可能值是多少？考虑下面的例子。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># A Python program to display that we can store</span></span><br><span class="line"><span class="comment"># large numbers in Python</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">10000000000000000000000000000000000000000000</span></span><br><span class="line">a = a + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"><span class="built_in">print</span> (a)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line"><span class="number">10000000000000000000000000000000000000000001</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>正如我们在上面的例子中看到的，我们给变量 <strong>x</strong> 分配了一个大的整数值，并检查了它的类型。它打印了<strong>类&lt; int &gt;</strong> 不长 int。因此，没有位数的限制，我们可以扩展到我们的记忆极限。</p>
<p>Python 没有任何特殊的数据类型来存储更大的数字。</p>
<h3 id="用-Python-打印单个和多个变量">用 Python 打印单个和多个变量</h3>
<p>我们可以在一个 print 语句中打印多个变量。以下是单个和多个打印值的示例。</p>
<p><strong>示例- 1(打印单变量)</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># printing single value </span></span><br><span class="line">a = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>((a))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例- 2(打印多个变量)</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line">b = <span class="number">6</span></span><br><span class="line"><span class="comment"># printing multiple variables</span></span><br><span class="line"><span class="built_in">print</span>(a,b)</span><br><span class="line"><span class="comment"># separate the variables by the comma</span></span><br><span class="line">Print(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="基本原理">基本原理:</h2>
<p>本节包含 Python 的基础知识，例如:</p>
<p><strong>i)代币及其类型。</strong></p>
<p><strong>ii)评论</strong></p>
<p><strong>a)代币:</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>标记可以定义为标点符号、保留词和语句中的每个词。</p>
</li>
<li class="lvl-4">
<p>令牌是给定程序中最小的单元。</p>
</li>
</ul>
<p>Python 中有以下标记:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>关键词。</p>
</li>
<li class="lvl-4">
<p>标识符。</p>
</li>
<li class="lvl-4">
<p>字面值。</p>
</li>
<li class="lvl-4">
<p>操作员。</p>
</li>
</ul>
<p>我们将在接下来的教程中详细讨论上述令牌。</p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 命令行参数</title>
    <url>/posts/4e90abbc.html</url>
    <content><![CDATA[<h1>Python 命令行参数</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-command-line-arguments">https://www.javatpoint.com/python-command-line-arguments</a></p>
</blockquote>
<p>Python 支持可以在命令行上运行的程序，并带有命令行参数。它是执行脚本时需要传递给脚本的输入参数。</p>
<p>它意味着与脚本的命令行界面进行交互。</p>
<p>它提供了一个 <strong>getopt</strong> 模块，可以在其中解析命令行参数和选项。</p>
<h2 id="什么是论点传递？">什么是论点传递？</h2>
<p>命令 <strong>ls</strong> 通常用于获取特定目录中文件和文件夹的摘要。</p>
<h2 id="为什么要使用-argparse？">为什么要使用 argparse？</h2>
<p>它意味着程序的作者和用户之间的通信，这不需要进入代码并对脚本进行更改。它为用户提供了输入命令行参数的能力。</p>
<h2 id="访问命令行参数">访问命令行参数</h2>
<p>Python <code>sys</code>模块通过 sys.argv 提供对命令行参数的访问。</p>
<h2 id="Python-sys模块">Python <code>sys</code>模块</h2>
<p>这是早期 Python 发行版附带的一个基本模块。这与 C 库使用 argc/argv 访问参数的方法类似。<code>sys</code>模块在一个名为 sys.argv 的简单列表结构中实现命令行参数。</p>
<p>每个列表元素代表一个参数。第一个- sys.argv[0] -是 Python 脚本的名称。其他列表元素是 sys.argv[1]到 sys.argv[n]-是命令行参数 2 到 n。作为参数之间的分隔符，使用了空格。相应地，必须引用包含空格的参数值。</p>
<p>它将命令行参数存储到一个列表中；我们可以使用 <strong>sys.argv</strong> 访问它。这是非常有用的，也是以字符串形式读取命令行参数的简单方法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(sys.argv))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The command line arguments are:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sys.argv:</span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="python-getopt模块">python <code>getopt</code>模块</h2>
<p>Python <code>getopt</code>模块通过参数验证扩展了输入字符串的分离。基于 getopt C 函数，它允许短选项和长选项，包括赋值。</p>
<p>它与解析命令行参数的 C getopt()函数非常相似。</p>
<p>它在解析命令行参数时非常有用，我们希望用户输入一些选项。</p>
<p><strong>代码</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> getopt</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">argv = sys.argv[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    opts, args = getopt.getopt(argv, <span class="string">&#x27;hm:d&#x27;</span>, [<span class="string">&#x27;help&#x27;</span>, <span class="string">&#x27;my_file=&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(opts)</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line"><span class="keyword">except</span> getopt.GetoptError:</span><br><span class="line">    <span class="comment"># Print a message or do something useful</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Something went wrong!&#x27;</span>)</span><br><span class="line">    sys.exit(<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="python-argparse-module-python-剖析模组">python argparse module-python 剖析模组</h2>
<p>它提供了一个带有标准化输出的命令行界面，而前两个解决方案将大部分工作留给了您。argparse 允许使用 UNIX 或 GNU 风格的名称检查来验证固定参数和可选参数。这是解析命令行参数的首选方式。它提供了许多选项，如位置参数、参数的默认值、帮助消息、指定参数的数据类型等。</p>
<p>它使得编写用户友好的命令行界面变得容易。当用户给程序提供无效参数时，它会自动生成帮助和使用信息并发出错误。</p>
<p><strong>getopt.getopt 方法</strong></p>
<p>此方法用于解析命令行选项和参数列表。</p>
<p><strong>语法:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">getopt.getopt(args, options, [long_options])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>args</strong> -是需要解析的参数列表。</p>
<p><strong>选项</strong> -脚本想要识别的一串选项字母，其中的选项需要一个参数，参数后面应该跟一个冒号(😃。</p>
<p><strong>long_options(可选)</strong> -必须是包含长选项名称的字符串，应该支持。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>该方法返回一个由两个元素组成的值，即(<strong>选项列表，值</strong>)对，选项列表被剥离后留下的程序参数列表。</p>
</li>
<li class="lvl-4">
<p>每个选项和值对作为选项的第一个元素返回，短选项以连字符为前缀(例如，'-x ‘)，长选项以两个连字符为前缀(例如，’- long-option ')。</p>
</li>
</ul>
<p><strong>异常。getptertror〔t1〕</strong></p>
<p>当在参数列表中发现无法识别的选项时，或者当任何需要参数的选项都没有给出参数时，就会出现这种异常。</p>
<p>异常的参数是指示错误原因的字符串。属性<strong>消息</strong>和<strong>选择</strong>给出错误信息和相关选项。</p>
<p><strong>代码</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> sys, getopt</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line">   inputfile = <span class="string">&#x27;&#x27;</span></span><br><span class="line">   outputfile = <span class="string">&#x27;&#x27;</span></span><br><span class="line">   <span class="keyword">try</span>:</span><br><span class="line">      opts, args = getopt.getopt(argv,<span class="string">&quot;hi:o:&quot;</span>,[<span class="string">&quot;ifile=&quot;</span>,<span class="string">&quot;ofile=&quot;</span>])</span><br><span class="line">   <span class="keyword">except</span> getopt.GetoptError:</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&#x27;test.py -i &lt;inputfile&gt; -o &lt;outputfile&gt;&#x27;</span></span><br><span class="line">      sys.exit(<span class="number">2</span>)</span><br><span class="line">   <span class="keyword">for</span> opt, arg <span class="keyword">in</span> opts:</span><br><span class="line">      <span class="keyword">if</span> opt == <span class="string">&#x27;-h&#x27;</span>:</span><br><span class="line">         <span class="built_in">print</span> <span class="string">&#x27;test.py -i &lt;inputfile&gt; -o &lt;outputfile&gt;&#x27;</span></span><br><span class="line">         sys.exit()</span><br><span class="line">      <span class="keyword">elif</span> opt <span class="keyword">in</span> (<span class="string">&quot;-i&quot;</span>, <span class="string">&quot;--ifile&quot;</span>):</span><br><span class="line">         inputfile = arg</span><br><span class="line">      <span class="keyword">elif</span> opt <span class="keyword">in</span> (<span class="string">&quot;-o&quot;</span>, <span class="string">&quot;--ofile&quot;</span>):</span><br><span class="line">         outputfile = arg</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&#x27;Input file is &quot;&#x27;</span>, inputfile</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&#x27;Output file is &quot;&#x27;</span>, outputfile</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">   main(sys.argv[<span class="number">1</span>:])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">$ test.py -h</span><br><span class="line">usage: test.py -i &lt;inputfile&gt; -o &lt;outputfile&gt;</span><br><span class="line"></span><br><span class="line">$ test.py -i BMP -o</span><br><span class="line">usage: test.py -i &lt;inputfile&gt; -o &lt;outputfile&gt;</span><br><span class="line"></span><br><span class="line">$ test.py -i inputfile</span><br><span class="line">Input file <span class="keyword">is</span> <span class="string">&quot; inputfile</span></span><br><span class="line"><span class="string">Output file is &quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="python-中如何使用命令行参数？">python 中如何使用命令行参数？</h2>
<p><pwe can="" use="" modules="" to="" get="" arguments.="" p="">| 组件 | 使用 | Python 版本 |<br>
| [计]系统复制命令（system 的简写） | sys.argv 中的所有参数(基本) | 全部 |<br>
| 抱怨吗 | 构建命令行界面 | &gt;= 2.3 |<br>
| docopt | 已创建命令行界面 | &gt;= 2.5 |<br>
| 火 | 自动生成命令行界面(CLi) | 全部 |<br>
| 选择吗 | 反对 | &lt; 2.7 |</p>
<p>docopt</p>
<p>Docopt 用于创建命令行界面。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> docopt <span class="keyword">import</span> docopt</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">arguments = docopt(__doc__, version=<span class="string">&#x27;Example 1&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(arguments) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>开火</strong></p>
<p>Python Fire 自动生成命令行界面；你只需要一行代码。与其他模块不同，它可以立即工作。</p>
<p>您不需要定义任何参数；默认情况下，所有方法都是链接的。</p>
<p>要安装它，请键入:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install fire</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>定义或使用类别:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> fire</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">       <span class="keyword">def</span> <span class="title function_">openfile</span>(<span class="params">self, filename</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Open file &#x27;&quot;</span> + filename + <span class="string">&quot;&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    fire.Fire(Python) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>您有与类方法匹配的选项:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">python example.py hello</span><br><span class="line">python example.py openfile filename.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<ul class="lvl-2">
<li class="lvl-4">*</pwe></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 多进程</title>
    <url>/posts/4300f84b.html</url>
    <content><![CDATA[<h1>Python 多进程</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-multiprocessing">https://www.javatpoint.com/python-multiprocessing</a></p>
</blockquote>
<p>在本文中，我们将学习如何使用 Python 实现多进程。我们还讨论了它的高级概念。</p>
<h3 id="什么是多进程？">什么是多进程？</h3>
<p>多进程是系统并行运行一个或多个进程的能力。简单来说，多进程使用单个计算机系统内的两个或更多 <a href="https://www.javatpoint.com/cpu-full-form">CPU</a> 。该方法还能够在多个进程之间分配任务。</p>
<p>处理单元共享主存储器和外围设备来同时处理程序。多进程应用分成更小的部分，独立运行。操作系统将每个进程分配给处理器。</p>
<p><a href="https://www.javatpoint.com/python-tutorial">Python</a> 提供了支持交换进程的称为多进程的内置包。在使用多进程之前，我们必须了解进程对象。</p>
<h3 id="为什么是多进程？">为什么是多进程？</h3>
<p>多进程对于在计算机系统中执行多种任务是必不可少的。假设一台计算机没有多进程器或单处理器。我们同时为该系统分配不同的进程。</p>
<p>然后，它将不得不中断前一个任务，并转移到另一个任务，以保持所有进程的运行。这就像厨师独自在厨房工作一样简单。他要做几个任务来烹饪食物，比如切、清洗、烹饪、揉面、烘焙等。</p>
<p>因此，多进程对于同时执行几个任务而不中断是必不可少的。它还使得跟踪所有任务变得容易。这就是为什么多进程的概念会出现。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>多进程可以表示为一台具有多个中央处理器的计算机。</p>
</li>
<li class="lvl-4">
<p>多核处理器是指具有两个或更多独立单元的单个计算组件。</p>
</li>
</ul>
<p>在多进程中， <a href="https://www.javatpoint.com/central-processing-unit">CPU</a> 可以一次分配多个任务，每个任务都有自己的处理器。</p>
<h2 id="Python-中的多进程">Python 中的多进程</h2>
<p>Python 提供了<code>multiprocessing</code>模块来在单个系统中执行多个任务。它提供了一个用户友好和直观的 API 来处理多进程。</p>
<p>让我们理解多进程的简单例子。</p>
<p>示例-</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">disp</span>():</span><br><span class="line">      <span class="built_in">print</span> (<span class="string">&#x27;Hello !! Welcome to Python Tutorial&#x27;</span>)</span><br><span class="line">      <span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">      p = Process(target=disp)</span><br><span class="line">      p.start()</span><br><span class="line">      p.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;Hello !! Welcome to Python Tutorial&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的代码中，我们已经导入了 Process 类，然后在 <strong>disp()</strong> 函数中创建了 Process 对象。然后我们使用 <strong>start()</strong> 方法开始流程，并使用 <strong>join()</strong> 方法完成流程。我们也可以使用<strong>参数</strong>关键字在声明的函数中传递参数。</p>
<p>让我们理解下面这个带参数的多进程的例子。</p>
<p><strong>示例- 2</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Python multiprocessing example</span></span><br><span class="line"><span class="comment"># importing the multiprocessing module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cube</span>(<span class="params">n</span>):</span><br><span class="line">   <span class="comment"># This function will print the cube of the given number</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;The Cube is: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(n * n * n))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="comment"># This function will print the square of the given number</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;The Square is: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(n * n))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">   <span class="comment"># creating two processes</span></span><br><span class="line">   process1 = multiprocessing.Process(target= square, args=(<span class="number">5</span>, ))</span><br><span class="line">   process2 = multiprocessing.Process(target= cube, args=(<span class="number">5</span>, ))</span><br><span class="line"></span><br><span class="line">   <span class="comment"># Here we start the process 1</span></span><br><span class="line">   process1.start()</span><br><span class="line">   <span class="comment"># Here we start process 2</span></span><br><span class="line">   process2.start()</span><br><span class="line"></span><br><span class="line">   <span class="comment"># The join() method is used to wait for process 1 to complete</span></span><br><span class="line">   process1.join()</span><br><span class="line">   <span class="comment"># It is used to wait for process 1 to complete</span></span><br><span class="line">   process2.join()</span><br><span class="line"></span><br><span class="line">   <span class="comment"># Print if both processes are completed</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Both processes are finished&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The Cube <span class="keyword">is</span>: <span class="number">125</span></span><br><span class="line">The Square <span class="keyword">is</span>: <span class="number">25</span></span><br><span class="line">Both processes are finished</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>解释-</strong></p>
<p>在上面的例子中，我们创建了两个函数-**cube()**函数计算给定数字的立方， <strong>square()</strong> 函数计算给定数字的平方。</p>
<p>接下来，我们定义了 process 类的 Process 对象，它有两个参数。第一个参数是代表要执行的函数的<strong>目标</strong>，第二个参数是代表要在函数中传递的参数的<strong>参数。</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">process1 = multiprocessing.Process(target= square, args=(<span class="number">5</span>, ))</span><br><span class="line">process2 = multiprocessing.Process(target= cube, args=(<span class="number">5</span>, ))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们使用了 <strong>start()</strong> 方法来启动流程。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">process1.start()</span><br><span class="line">process2.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>正如我们在输出中看到的，它等待完成<strong>过程一</strong>，然后是<strong>过程二</strong>。最后一条语句在两个进程完成后执行。</p>
<h2 id="Python-多进程类">Python 多进程类</h2>
<p>Python <code>multiprocessing</code>模块提供了许多常用于构建并行程序的类。我们将讨论它的主要类——进程、队列和锁。我们已经在前面的例子中讨论了 Process 类。现在我们将讨论队列和锁类。</p>
<p>让我们看一个简单的例子，获取系统中当前的 CPU 数量。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The number of CPU currently working in system : &quot;</span>, multiprocessing.cpu_count())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;The number of CPU currently woking in system : &#x27;</span>, <span class="number">32</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上 CPU 数量可能因您的电脑而异。对我们来说，核心数量是 32。</p>
<h2 id="使用队列类的-Python-多进程">使用队列类的 Python 多进程</h2>
<p>我们知道队列是数据结构的重要部分。Python 多进程与基于“先进先出”概念的数据结构队列完全相同。队列通常存储 Python 对象，并在进程间共享数据方面发挥重要作用。</p>
<p>队列作为参数在进程的目标函数中传递，以允许进程使用数据。队列提供 <strong>put()</strong> 函数插入数据， <strong>get()</strong> 函数从队列中获取数据。让我们理解下面的例子。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Importing Queue Class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line">fruits = [<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Orange&#x27;</span>, <span class="string">&#x27;Guava&#x27;</span>, <span class="string">&#x27;Papaya&#x27;</span>, <span class="string">&#x27;Banana&#x27;</span>]</span><br><span class="line">count = <span class="number">1</span></span><br><span class="line"><span class="comment"># creating a queue object</span></span><br><span class="line">queue = Queue()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;pushing items to the queue:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> fr <span class="keyword">in</span> fruits:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;item no: &#x27;</span>, count, <span class="string">&#x27; &#x27;</span>, fr)</span><br><span class="line">    queue.put(fr)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\npopping items from the queue:&#x27;</span>)</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> queue.empty():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;item no: &#x27;</span>, count, <span class="string">&#x27; &#x27;</span>, queue.get())</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">pushing items to the queue:</span><br><span class="line">(<span class="string">&#x27;item no: &#x27;</span>, <span class="number">1</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;Apple&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;item no: &#x27;</span>, <span class="number">2</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;Orange&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;item no: &#x27;</span>, <span class="number">3</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;Guava&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;item no: &#x27;</span>, <span class="number">4</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;Papaya&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;item no: &#x27;</span>, <span class="number">5</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;Banana&#x27;</span>)</span><br><span class="line"></span><br><span class="line">popping items <span class="keyword">from</span> the queue:</span><br><span class="line">(<span class="string">&#x27;item no: &#x27;</span>, <span class="number">0</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;Apple&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;item no: &#x27;</span>, <span class="number">1</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;Orange&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;item no: &#x27;</span>, <span class="number">2</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;Guava&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;item no: &#x27;</span>, <span class="number">3</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;Papaya&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;item no: &#x27;</span>, <span class="number">4</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;Banana&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>解释-</strong></p>
<p>在上面的代码中，我们已经导入了<strong>队列</strong>类，并初始化了名为水果的列表。接下来，我们将<strong>计数</strong>指定为 1。count 变量将计算元素的总数。然后，我们通过调用 <strong>Queue()</strong> 方法来创建队列对象。该对象将用于执行队列中的操作。在 <code>for</code>循环中，我们使用 <strong>put()</strong> 函数将元素一个接一个地插入到队列中，并随着循环的每次迭代将计数增加 1。</p>
<h2 id="Python-多进程锁类">Python 多进程锁类</h2>
<p>多进程 Lock 类用于获取进程的锁，这样我们就可以保持另一个进程执行类似的代码，直到锁被释放。锁类主要执行两个任务。第一种是使用 <strong>acquire()</strong> 功能获取锁，第二种是使用 <strong>release()</strong> 功能释放锁。</p>
<h2 id="Python-多进程示例">Python 多进程示例</h2>
<p>假设我们有多个任务。因此，我们创建了两个队列:第一个队列将维护任务，另一个队列将存储完整的任务日志。下一步是实例化进程来完成任务。如前所述，Queue 类已经同步，所以我们不需要使用 lock 类获取锁。</p>
<p>在下面的例子中，我们将把所有的多进程类合并在一起。让我们看看下面的例子。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Lock, Process, Queue, current_process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> queue </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">jobTodo</span>(<span class="params">tasks_to_perform, complete_tasks</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># The try block to catch task from the queue.</span></span><br><span class="line">            <span class="comment"># The get_nowait() function is used to</span></span><br><span class="line">            <span class="comment"># raise queue.Empty exception if the queue is empty.</span></span><br><span class="line"></span><br><span class="line">            task = tasks_to_perform.get_nowait()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> queue.Empty:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">                <span class="comment"># if no exception has been raised, the else block will execute</span></span><br><span class="line">                <span class="comment"># add the task completion</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(task)</span><br><span class="line">            complete_tasks.put(task + <span class="string">&#x27; is done by &#x27;</span> + current_process().name)</span><br><span class="line">            time.sleep(<span class="number">.5</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    total_task = <span class="number">8</span></span><br><span class="line">    total_number_of_processes = <span class="number">3</span></span><br><span class="line">    tasks_to_perform = Queue()</span><br><span class="line">    complete_tasks = Queue()</span><br><span class="line">    number_of_processes = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(total_task):</span><br><span class="line">        tasks_to_perform.put(<span class="string">&quot;Task no &quot;</span> + <span class="built_in">str</span>(i))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># defining number of processes</span></span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(total_number_of_processes):</span><br><span class="line">        p = Process(target=jobTodo, args=(tasks_to_perform, complete_tasks))</span><br><span class="line">        number_of_processes.append(p)</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># completing process</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> number_of_processes:</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print the output</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> complete_tasks.empty():</span><br><span class="line">        <span class="built_in">print</span>(complete_tasks.get())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Task no <span class="number">2</span></span><br><span class="line">Task no <span class="number">5</span></span><br><span class="line">Task no <span class="number">0</span></span><br><span class="line">Task no <span class="number">3</span></span><br><span class="line">Task no <span class="number">6</span></span><br><span class="line">Task no <span class="number">1</span></span><br><span class="line">Task no <span class="number">4</span></span><br><span class="line">Task no <span class="number">7</span></span><br><span class="line">Task no <span class="number">0</span> <span class="keyword">is</span> done by Process-<span class="number">1</span></span><br><span class="line">Task no <span class="number">1</span> <span class="keyword">is</span> done by Process-<span class="number">3</span></span><br><span class="line">Task no <span class="number">2</span> <span class="keyword">is</span> done by Process-<span class="number">2</span></span><br><span class="line">Task no <span class="number">3</span> <span class="keyword">is</span> done by Process-<span class="number">1</span></span><br><span class="line">Task no <span class="number">4</span> <span class="keyword">is</span> done by Process-<span class="number">3</span></span><br><span class="line">Task no <span class="number">5</span> <span class="keyword">is</span> done by Process-<span class="number">2</span></span><br><span class="line">Task no <span class="number">6</span> <span class="keyword">is</span> done by Process-<span class="number">1</span></span><br><span class="line">Task no <span class="number">7</span> <span class="keyword">is</span> done by Process-<span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Python-多进程池">Python 多进程池</h2>
<p>Python 多进程池对于跨多个输入值并行执行一个函数至关重要。它还用于将输入数据分布在进程间**(数据并行)**。考虑以下多进程池的示例。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">w = ([<span class="string">&quot;V&quot;</span>, <span class="number">5</span>], [<span class="string">&quot;X&quot;</span>, <span class="number">2</span>], [<span class="string">&quot;Y&quot;</span>, <span class="number">1</span>], [<span class="string">&quot;Z&quot;</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work_log</span>(<span class="params">data_for_work</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; Process name is %s waiting time is %s seconds&quot;</span> % (data_for_work[<span class="number">0</span>], data_for_work[<span class="number">1</span>]))</span><br><span class="line">    time.sleep(<span class="built_in">int</span>(data_for_work[<span class="number">1</span>]))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; Process %s Executed.&quot;</span> % data_for_work[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handler</span>():</span><br><span class="line">    p = Pool(<span class="number">2</span>)</span><br><span class="line">    p.<span class="built_in">map</span>(work_log, w)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    handler()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Process name <span class="keyword">is</span> V waiting time <span class="keyword">is</span> <span class="number">5</span> seconds</span><br><span class="line">Process V Executed.</span><br><span class="line">Process name <span class="keyword">is</span> X waiting time <span class="keyword">is</span> <span class="number">2</span> seconds</span><br><span class="line">Process X Executed.</span><br><span class="line">Process name <span class="keyword">is</span> Y waiting time <span class="keyword">is</span> <span class="number">1</span> seconds</span><br><span class="line">Process Y Executed.</span><br><span class="line">Process name <span class="keyword">is</span> Z waiting time <span class="keyword">is</span> <span class="number">3</span> seconds</span><br><span class="line">Process Z Executed.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>让我们了解多进程池的另一个例子。</p>
<p><strong>示例- 2</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> Pool(<span class="number">5</span>) <span class="keyword">as</span> p:</span><br><span class="line">        <span class="built_in">print</span>(p.<span class="built_in">map</span>(fun, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">27</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="代理对象">代理对象</h2>
<p>代理对象被称为驻留在不同进程中的共享对象。这个对象也被称为代理。多个代理对象可能有相似的引用。代理对象由各种方法组成，这些方法用于调用其引用对象的相应方法。下面是代理对象的例子。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager</span><br><span class="line">manager = Manager()</span><br><span class="line">l = manager.<span class="built_in">list</span>([i*i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)])</span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">repr</span>(l))</span><br><span class="line"><span class="built_in">print</span>(l[<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(l[<span class="number">2</span>:<span class="number">5</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line">&lt;ListProxy <span class="built_in">object</span>, typeid <span class="string">&#x27;list&#x27;</span> at <span class="number">0x7f063621ea10</span>&gt;</span><br><span class="line"><span class="number">16</span></span><br><span class="line">[<span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代理对象是可选择的，因此我们可以在进程之间传递它们。这些对象也用于同步的控制级别。</p>
<h2 id="多进程的常用功能">多进程的常用功能</h2>
<p>到目前为止，我们已经讨论了使用 Python 进行多进程的基本概念。多进程本身是一个广泛的主题，对于在单个系统中执行各种任务至关重要。我们正在定义一些常用于实现多进程的基本功能。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pipe()</td>
<td>pipe()函数返回一对连接对象。</td>
</tr>
<tr>
<td>pipe()</td>
<td>run()方法用于表示流程活动。</td>
</tr>
<tr>
<td>start()</td>
<td>start()方法用于启动进程。</td>
</tr>
<tr>
<td>join([timeout])</td>
<td>join()方法用于阻塞进程，直到调用 join()方法的进程终止。超时是可选参数。</td>
</tr>
<tr>
<td>is_alive()</td>
<td>如果进程是活动的，它将返回。</td>
</tr>
<tr>
<td>terminate()</td>
<td>顾名思义，它用于终止进程。永远记住 Linux 中使用 <strong>terminate()</strong> 方法，对于 Windows，我们使用 <strong>TerminateProcess()</strong> 方法。</td>
</tr>
<tr>
<td>kill()</td>
<td>这种方法类似于<strong>终止()</strong>，但使用的是 Unix 上的 SIGKILL 信号。</td>
</tr>
<tr>
<td>close()</td>
<td>该方法用于关闭<strong>进程</strong>对象，并释放与之相关的所有资源。</td>
</tr>
<tr>
<td>qsize()</td>
<td>它返回队列的大致大小。</td>
</tr>
<tr>
<td>empty()</td>
<td>如果队列为空，则返回<strong>真</strong>。</td>
</tr>
<tr>
<td>full()</td>
<td>如果队列已满，则返回<strong>真</strong>。</td>
</tr>
<tr>
<td>get_await()</td>
<td>这个方法相当于<strong>得到(False)</strong> 。</td>
</tr>
<tr>
<td>get()</td>
<td>此方法用于从队列中获取元素。它从队列中移除并返回一个元素。</td>
</tr>
<tr>
<td>put()</td>
<td>此方法用于将元素插入队列。</td>
</tr>
<tr>
<td>cpu_count()</td>
<td>它返回系统中工作的中央处理器的数量。</td>
</tr>
<tr>
<td>current_process()</td>
<td>它返回对应于当前进程的 Process 对象。</td>
</tr>
<tr>
<td>parent_process()</td>
<td>它返回对应于当前进程的父进程对象。</td>
</tr>
<tr>
<td>task_done()</td>
<td>此功能用于指示排队的任务已完成。</td>
</tr>
<tr>
<td>join_thread()</td>
<td>此方法用于连接后台线程</td>
</tr>
</tbody>
</table>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 字典</title>
    <url>/posts/781e27f3.html</url>
    <content><![CDATA[<h1>Python 字典</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-dictionary">https://www.javatpoint.com/python-dictionary</a></p>
</blockquote>
<p>Python 字典用于以键值对格式存储数据。字典是 Python 中的数据类型，它可以模拟现实生活中的数据排列，其中某个特定的键存在某个特定的值。它是可变的数据结构。字典被定义为元素键和值。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>键必须是单个元素</p>
</li>
<li class="lvl-4">
<p>值可以是任何类型，如列表、元组、整数等。</p>
</li>
</ul>
<p>换句话说，我们可以说字典是键值对的集合，其中的值可以是任何 Python 对象。相反，键是不可变的 Python 对象，即数字、字符串或元组。</p>
<h2 id="创建字典">创建字典</h2>
<p>字典可以通过使用用花括号{}括起来的多个键值对来创建，每个键都用冒号(:)与其值分开。下面给出了定义字典的语法。</p>
<p><strong>语法:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="type">Dict</span> = &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">22</span>&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的字典 <strong>Dict</strong> 中，键<strong>名称</strong>和<strong>年龄</strong>是不可变对象的字符串。</p>
<p>让我们看一个创建字典并打印其内容的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Employee = &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">29</span>, <span class="string">&quot;salary&quot;</span>:<span class="number">25000</span>,<span class="string">&quot;Company&quot;</span>:<span class="string">&quot;GOOGLE&quot;</span>&#125;  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Employee))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;printing Employee data .... &quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(Employee)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line">Printing Employee data .... </span><br><span class="line">&#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">29</span>, <span class="string">&#x27;salary&#x27;</span>: <span class="number">25000</span>, <span class="string">&#x27;Company&#x27;</span>: <span class="string">&#x27;GOOGLE&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Python 提供了内置函数 <strong>dict()</strong> 方法，也是用来创建字典的。空花括号{}用于创建空字典。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creating an empty Dictionary </span></span><br><span class="line"><span class="type">Dict</span> = &#123;&#125; </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Empty Dictionary: &quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="type">Dict</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Creating a Dictionary </span></span><br><span class="line"><span class="comment"># with dict() method </span></span><br><span class="line"><span class="type">Dict</span> = <span class="built_in">dict</span>(&#123;<span class="number">1</span>: <span class="string">&#x27;Java&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;T&#x27;</span>, <span class="number">3</span>:<span class="string">&#x27;Point&#x27;</span>&#125;) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nCreate Dictionary by using  dict(): &quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="type">Dict</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Creating a Dictionary </span></span><br><span class="line"><span class="comment"># with each item as a Pair </span></span><br><span class="line"><span class="type">Dict</span> = <span class="built_in">dict</span>([(<span class="number">1</span>, <span class="string">&#x27;Devansh&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;Sharma&#x27;</span>)]) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nDictionary with each item as a pair: &quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="type">Dict</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Empty Dictionary: </span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">Create Dictionary by using <span class="built_in">dict</span>(): </span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;Java&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;T&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;Point&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">Dictionary <span class="keyword">with</span> each item <span class="keyword">as</span> a pair: </span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;Devansh&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Sharma&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="访问字典值">访问字典值</h2>
<p>我们已经讨论了如何使用索引在列表和元组中访问数据。</p>
<p>但是，可以通过使用键来访问字典中的值，因为键在字典中是唯一的。</p>
<p>字典值可以通过以下方式访问。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Employee = &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">29</span>, <span class="string">&quot;salary&quot;</span>:<span class="number">25000</span>,<span class="string">&quot;Company&quot;</span>:<span class="string">&quot;GOOGLE&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Employee))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;printing Employee data .... &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Name : %s&quot;</span> %Employee[<span class="string">&quot;Name&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Age : %d&quot;</span> %Employee[<span class="string">&quot;Age&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Salary : %d&quot;</span> %Employee[<span class="string">&quot;salary&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Company : %s&quot;</span> %Employee[<span class="string">&quot;Company&quot;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line">printing Employee data .... </span><br><span class="line">Name : John</span><br><span class="line">Age : <span class="number">29</span></span><br><span class="line">Salary : <span class="number">25000</span></span><br><span class="line">Company : GOOGLE</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Python 为我们提供了一种使用 get()方法访问字典值的替代方法。它会给出与索引相同的结果。</p>
<h2 id="添加字典值">添加字典值</h2>
<p>字典是一种可变的数据类型，它的值可以通过使用特定的键来更新。该值可随键 <strong>Dict【键】=值</strong>一起更新。update()方法也用于更新现有值。</p>
<p>注意:如果键值已经存在于字典中，该值将被更新。否则，在字典中添加新的键。</p>
<p>让我们看一个更新字典值的例子。</p>
<p><strong>示例- 1:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creating an empty Dictionary </span></span><br><span class="line"><span class="type">Dict</span> = &#123;&#125; </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Empty Dictionary: &quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="type">Dict</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Adding elements to dictionary one at a time </span></span><br><span class="line"><span class="type">Dict</span>[<span class="number">0</span>] = <span class="string">&#x27;Peter&#x27;</span></span><br><span class="line"><span class="type">Dict</span>[<span class="number">2</span>] = <span class="string">&#x27;Joseph&#x27;</span></span><br><span class="line"><span class="type">Dict</span>[<span class="number">3</span>] = <span class="string">&#x27;Ricky&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nDictionary after adding 3 elements: &quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="type">Dict</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Adding set of values  </span></span><br><span class="line"><span class="comment"># with a single Key </span></span><br><span class="line"><span class="comment"># The Emp_ages doesn&#x27;t exist to dictionary</span></span><br><span class="line"><span class="type">Dict</span>[<span class="string">&#x27;Emp_ages&#x27;</span>] = <span class="number">20</span>, <span class="number">33</span>, <span class="number">24</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nDictionary after adding 3 elements: &quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="type">Dict</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Updating existing Key&#x27;s Value </span></span><br><span class="line"><span class="type">Dict</span>[<span class="number">3</span>] = <span class="string">&#x27;JavaTpoint&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nUpdated key value: &quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="type">Dict</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Empty Dictionary: </span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">Dictionary after adding <span class="number">3</span> elements: </span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">&#x27;Peter&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Joseph&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;Ricky&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">Dictionary after adding <span class="number">3</span> elements: </span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">&#x27;Peter&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Joseph&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;Ricky&#x27;</span>, <span class="string">&#x27;Emp_ages&#x27;</span>: (<span class="number">20</span>, <span class="number">33</span>, <span class="number">24</span>)&#125;</span><br><span class="line"></span><br><span class="line">Updated key value: </span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">&#x27;Peter&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Joseph&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;JavaTpoint&#x27;</span>, <span class="string">&#x27;Emp_ages&#x27;</span>: (<span class="number">20</span>, <span class="number">33</span>, <span class="number">24</span>)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例- 2:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Employee = &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">29</span>, <span class="string">&quot;salary&quot;</span>:<span class="number">25000</span>,<span class="string">&quot;Company&quot;</span>:<span class="string">&quot;GOOGLE&quot;</span>&#125;  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Employee))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;printing Employee data .... &quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(Employee)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Enter the details of the new employee....&quot;</span>);  </span><br><span class="line">Employee[<span class="string">&quot;Name&quot;</span>] = <span class="built_in">input</span>(<span class="string">&quot;Name: &quot;</span>);  </span><br><span class="line">Employee[<span class="string">&quot;Age&quot;</span>] = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Age: &quot;</span>));  </span><br><span class="line">Employee[<span class="string">&quot;salary&quot;</span>] = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Salary: &quot;</span>));  </span><br><span class="line">Employee[<span class="string">&quot;Company&quot;</span>] = <span class="built_in">input</span>(<span class="string">&quot;Company:&quot;</span>);  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;printing the new data&quot;</span>);  </span><br><span class="line"><span class="built_in">print</span>(Employee)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Empty Dictionary: </span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">Dictionary after adding <span class="number">3</span> elements: </span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">&#x27;Peter&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Joseph&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;Ricky&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">Dictionary after adding <span class="number">3</span> elements: </span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">&#x27;Peter&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Joseph&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;Ricky&#x27;</span>, <span class="string">&#x27;Emp_ages&#x27;</span>: (<span class="number">20</span>, <span class="number">33</span>, <span class="number">24</span>)&#125;</span><br><span class="line"></span><br><span class="line">Updated key value: </span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">&#x27;Peter&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Joseph&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;JavaTpoint&#x27;</span>, <span class="string">&#x27;Emp_ages&#x27;</span>: (<span class="number">20</span>, <span class="number">33</span>, <span class="number">24</span>)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="使用-del-关键字删除元素">使用 del 关键字删除元素</h2>
<p>使用下面给出的 <strong>del</strong> 关键字可以删除字典中的项目。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Employee = &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">29</span>, <span class="string">&quot;salary&quot;</span>:<span class="number">25000</span>,<span class="string">&quot;Company&quot;</span>:<span class="string">&quot;GOOGLE&quot;</span>&#125;  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Employee))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;printing Employee data .... &quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(Employee)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Deleting some of the employee data&quot;</span>)   </span><br><span class="line"><span class="keyword">del</span> Employee[<span class="string">&quot;Name&quot;</span>]  </span><br><span class="line"><span class="keyword">del</span> Employee[<span class="string">&quot;Company&quot;</span>]  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;printing the modified information &quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(Employee)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Deleting the dictionary: Employee&quot;</span>);  </span><br><span class="line"><span class="keyword">del</span> Employee  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Lets try to print it again &quot;</span>);  </span><br><span class="line"><span class="built_in">print</span>(Employee)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line">printing Employee data .... </span><br><span class="line">&#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">29</span>, <span class="string">&#x27;salary&#x27;</span>: <span class="number">25000</span>, <span class="string">&#x27;Company&#x27;</span>: <span class="string">&#x27;GOOGLE&#x27;</span>&#125;</span><br><span class="line">Deleting some of the employee data</span><br><span class="line">printing the modified information </span><br><span class="line">&#123;<span class="string">&#x27;Age&#x27;</span>: <span class="number">29</span>, <span class="string">&#x27;salary&#x27;</span>: <span class="number">25000</span>&#125;</span><br><span class="line">Deleting the dictionary: Employee</span><br><span class="line">Lets <span class="keyword">try</span> to <span class="built_in">print</span> it again </span><br><span class="line">NameError: name <span class="string">&#x27;Employee&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面代码中的最后一个 print 语句，它引发了一个错误，因为我们试图打印已经删除的 Employee 字典。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>使用 pop()方法</strong></p>
</li>
</ul>
<p><strong>pop()</strong> 方法接受键作为参数，并移除相关联的值。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creating a Dictionary </span></span><br><span class="line"><span class="type">Dict</span> = &#123;<span class="number">1</span>: <span class="string">&#x27;JavaTpoint&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Peter&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;Thomas&#x27;</span>&#125; </span><br><span class="line"><span class="comment"># Deleting a key  </span></span><br><span class="line"><span class="comment"># using pop() method </span></span><br><span class="line">pop_ele = <span class="type">Dict</span>.pop(<span class="number">3</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="type">Dict</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;JavaTpoint&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Peter&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Python 还提供了一个内置的方法 popitem()和 clear()方法，用于从字典中移除元素。popitem()从字典中移除任意元素，而 clear()方法移除整个字典中的所有元素。</p>
<h2 id="迭代字典">迭代字典</h2>
<p>字典可以使用 <code>for</code>循环进行迭代，如下所示。</p>
<h3 id="例-1-11">例 1</h3>
<p><strong># <code>for</code>循环打印字典的所有键</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Employee = &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">29</span>, <span class="string">&quot;salary&quot;</span>:<span class="number">25000</span>,<span class="string">&quot;Company&quot;</span>:<span class="string">&quot;GOOGLE&quot;</span>&#125;  </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> Employee:  </span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Name</span><br><span class="line">Age</span><br><span class="line">salary</span><br><span class="line">Company</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例-2-9">例 2</h3>
<p><strong>#<code>for</code>循环打印字典的所有值</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Employee = &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">29</span>, <span class="string">&quot;salary&quot;</span>:<span class="number">25000</span>,<span class="string">&quot;Company&quot;</span>:<span class="string">&quot;GOOGLE&quot;</span>&#125;  </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> Employee:  </span><br><span class="line">    <span class="built_in">print</span>(Employee[x])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">John</span><br><span class="line"><span class="number">29</span></span><br><span class="line"><span class="number">25000</span></span><br><span class="line">GOOGLE</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="示例-3">示例- 3</h3>
<p><strong>#<code>for</code>循环使用 values()方法打印字典的值。</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Employee = &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">29</span>, <span class="string">&quot;salary&quot;</span>:<span class="number">25000</span>,<span class="string">&quot;Company&quot;</span>:<span class="string">&quot;GOOGLE&quot;</span>&#125;  </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> Employee.values():  </span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">John</span><br><span class="line"><span class="number">29</span></span><br><span class="line"><span class="number">25000</span></span><br><span class="line">GOOGLE</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例-4">例 4</h3>
<p><strong>#<code>for</code>循环使用 items()方法打印字典的项目。</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Employee = &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">29</span>, <span class="string">&quot;salary&quot;</span>:<span class="number">25000</span>,<span class="string">&quot;Company&quot;</span>:<span class="string">&quot;GOOGLE&quot;</span>&#125;  </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> Employee.items():  </span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;John&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;Age&#x27;</span>, <span class="number">29</span>)</span><br><span class="line">(<span class="string">&#x27;salary&#x27;</span>, <span class="number">25000</span>)</span><br><span class="line">(<span class="string">&#x27;Company&#x27;</span>, <span class="string">&#x27;GOOGLE&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="字典键的属性">字典键的属性</h2>
<p>1.在字典中，我们不能为同一个键存储多个值。如果我们为一个键传递多个值，那么最后分配的值被认为是该键的值。</p>
<p>考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Employee=&#123;<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;John&quot;</span>,<span class="string">&quot;Age&quot;</span>:<span class="number">29</span>,<span class="string">&quot;Salary&quot;</span>:<span class="number">25000</span>,<span class="string">&quot;Company&quot;</span>:<span class="string">&quot;GOOGLE&quot;</span>,<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;John&quot;</span>&#125;  </span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> Employee.items():  </span><br><span class="line">    <span class="built_in">print</span>(x,y)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Name John</span><br><span class="line">Age <span class="number">29</span></span><br><span class="line">Salary <span class="number">25000</span></span><br><span class="line">Company GOOGLE</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.在 python 中，键不能是任何可变对象。我们可以使用数字、字符串或元组作为关键字，但是我们不能使用任何像列表这样的可变对象作为字典中的关键字。</p>
<p>考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Employee = &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">29</span>, <span class="string">&quot;salary&quot;</span>:<span class="number">25000</span>,<span class="string">&quot;Company&quot;</span>:<span class="string">&quot;GOOGLE&quot;</span>,[<span class="number">100</span>,<span class="number">201</span>,<span class="number">301</span>]:<span class="string">&quot;Department ID&quot;</span>&#125;  </span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> Employee.items():  </span><br><span class="line">    <span class="built_in">print</span>(x,y)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;dictionary.py&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> </span><br><span class="line">    Employee = &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">29</span>, <span class="string">&quot;salary&quot;</span>:<span class="number">25000</span>,<span class="string">&quot;Company&quot;</span>:<span class="string">&quot;GOOGLE&quot;</span>,[<span class="number">100</span>,<span class="number">201</span>,<span class="number">301</span>]:<span class="string">&quot;Department ID&quot;</span>&#125;</span><br><span class="line">TypeError: unhashable <span class="built_in">type</span>: <span class="string">&#x27;list&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="内置字典功能">内置字典功能</h2>
<p>下面给出了内置的 python 字典方法以及描述。</p>
<p>| 塞内加尔 | 功能 | 描述 |<br>
| 1 | len(dict) | 它被用来计算字典的长度。 |<br>
| 2 | any(dict) | 与处理列表和元组的方式一样，如果一个字典键确实具有计算结果为 True 的布尔表达式，则 any() 方法确实会返回 True。 |<br>
| 3 | all(dict) | 与any()方法不同的是，all()只有在字典的每个键都包含一个True布尔值时才返回True。 |<br>
| 4 | sorted(dict) | 与列表和元组一样，sorted() 方法返回字典键的有序序列。升序排序对原始Python字典没有影响。 |</p>
<h2 id="内置字典方法">内置字典方法</h2>
<p>下面给出了内置的 python 字典方法以及描述。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>one</td>
<td>dict.clear()</td>
<td>它用于删除字典中的所有条目。</td>
</tr>
<tr>
<td>Two</td>
<td>dict.copy()</td>
<td>它返回字典的一个简单副本。</td>
</tr>
<tr>
<td>three</td>
<td>dict.from key(iterable，value= None，/)</td>
<td>根据值等于值的可迭代表创建新字典。</td>
</tr>
<tr>
<td>four</td>
<td>dict.get(key，default=“none”)</td>
<td>它用于获取为传递的键指定的值。</td>
</tr>
<tr>
<td>five</td>
<td>dict.has_key(key)</td>
<td>如果字典包含指定的键，则返回 true。</td>
</tr>
<tr>
<td>six</td>
<td>dict.items()</td>
<td>它以元组的形式返回所有键值对。</td>
</tr>
<tr>
<td>seven</td>
<td>dict.key()</td>
<td>它返回字典的所有键。</td>
</tr>
<tr>
<td>eight</td>
<td>dict.setdefault(key，default =“None”)</td>
<td>如果没有在字典中指定关键字，它用于将关键字设置为默认值</td>
</tr>
<tr>
<td>nine</td>
<td>dict.update(dict2)</td>
<td>它通过向字典中添加 dict2 的键值对来更新字典。</td>
</tr>
<tr>
<td>Ten</td>
<td>values()</td>
<td>它返回字典的所有值。</td>
</tr>
<tr>
<td>Eleven</td>
<td>len()</td>
<td></td>
</tr>
<tr>
<td>Twelve</td>
<td>popitem()</td>
<td></td>
</tr>
<tr>
<td>Thirteen</td>
<td>pop()</td>
<td></td>
</tr>
<tr>
<td>Fourteen</td>
<td>count()</td>
<td></td>
</tr>
<tr>
<td>Fifteen</td>
<td>index()</td>
<td></td>
</tr>
</tbody>
</table>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 字符串</title>
    <url>/posts/fe4ed95b.html</url>
    <content><![CDATA[<h1>Python 字符串</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-strings">https://www.javatpoint.com/python-strings</a></p>
</blockquote>
<p>到目前为止，我们已经讨论了 Python 中作为标准数据类型的数字。在本节教程中，我们将讨论 Python 中最流行的数据类型，即字符串。</p>
<p>Python 字符串是由单引号、双引号或三引号括起来的字符的集合。计算机不理解字符；在内部，它将被操纵的字符存储为 0 和 1 的组合。</p>
<p>每个字符都用 ASCII 或 Unicode 字符编码。所以我们可以说 Python 字符串也叫做 Unicode 字符的集合。</p>
<p>在 Python 中，字符串可以通过在引号中包含字符或字符序列来创建。Python 允许我们使用单引号、双引号或三引号来创建字符串。</p>
<p>考虑下面 Python 中的例子来创建一个字符串。</p>
<h3 id="语法">语法:</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;Hi Python !&quot;</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，如果我们使用 Python 脚本检查变量<strong>字符串</strong>的类型</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">str</span>)), then it will <span class="built_in">print</span> a string (<span class="built_in">str</span>).  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在 Python 中，字符串被视为字符序列，这意味着 Python 不支持字符数据类型；相反，写为“p”的单个字符被视为长度为 1 的字符串。</p>
<h2 id="用-Python-创建字符串">用 Python 创建字符串</h2>
<p>我们可以通过用单引号或双引号将字符括起来来创建字符串。Python 还提供了三重引号来表示字符串，但它通常用于多行字符串或<strong>文档字符串</strong>。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#Using single quotes</span></span><br><span class="line">str1 = <span class="string">&#x27;Hello Python&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(str1)</span><br><span class="line"><span class="comment">#Using double quotes</span></span><br><span class="line">str2 = <span class="string">&quot;Hello Python&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Using triple quotes</span></span><br><span class="line">str3 = <span class="string">&#x27;&#x27;&#x27;Triple quotes are generally used for </span></span><br><span class="line"><span class="string">    represent the multiline or</span></span><br><span class="line"><span class="string">    docstring&#x27;&#x27;&#x27;</span> </span><br><span class="line"><span class="built_in">print</span>(str3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Hello Python</span><br><span class="line">Hello Python</span><br><span class="line">Triple quotes are generally used <span class="keyword">for</span> </span><br><span class="line">    represent the multiline <span class="keyword">or</span></span><br><span class="line">    docstring</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="字符串索引和拆分">字符串索引和拆分</h2>
<p>像其他语言一样，Python 字符串的索引从 0 开始。例如，字符串“HELLO”的索引如下图所示。</p>
<p><img src="img/e7cc0c71bb40b0c8f29f30e3107ed2cc.png" alt="Python String"></p>
<p>考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;HELLO&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">4</span>])</span><br><span class="line"><span class="comment"># It returns the IndexError because 6th index doesn&#x27;t exist</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">6</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">H</span><br><span class="line">E</span><br><span class="line">L</span><br><span class="line">L</span><br><span class="line">O</span><br><span class="line">IndexError: string index out of <span class="built_in">range</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如 Python 所示，切片运算符[]用于访问字符串的各个字符。但是，我们可以使用 Python 中的:(冒号)运算符从给定的字符串中访问子字符串。考虑下面的例子。</p>
<p><img src="img/843b99a3c370382db5fab064dd71f623.png" alt="Python String"></p>
<p>在这里，我们必须注意到切片运算符中给出的上限总是排他的，即如果给定了 str = 'HELLO '，那么 str[1:3]将始终包括 str[1] = 'E '，str[2] = 'L '等。</p>
<p>考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Given String</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;JAVATPOINT&quot;</span></span><br><span class="line"><span class="comment"># Start Oth index to end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>:])</span><br><span class="line"><span class="comment"># Starts 1th index to 4th index</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">1</span>:<span class="number">5</span>])</span><br><span class="line"><span class="comment"># Starts 2nd index to 3rd index</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:<span class="number">4</span>])</span><br><span class="line"><span class="comment"># Starts 0th to 2nd index</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[:<span class="number">3</span>])</span><br><span class="line"><span class="comment">#Starts 4th to 6th index</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">4</span>:<span class="number">7</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">JAVATPOINT</span><br><span class="line">AVAT</span><br><span class="line">VA</span><br><span class="line">JAV</span><br><span class="line">TPO</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以在字符串中进行负切片；它从最右边的字符开始，表示为-1。第二个最右边的索引表示-2，依此类推。请看下图。</p>
<p><img src="img/215eeac38272afdae7bb1ffb34ee8579.png" alt="Python String"></p>
<p>考虑以下示例</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;JAVATPOINT&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[-<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[-<span class="number">2</span>:])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[-<span class="number">4</span>:-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[-<span class="number">7</span>:-<span class="number">2</span>])</span><br><span class="line"><span class="comment"># Reversing the given string</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[::-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[-<span class="number">12</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">T</span><br><span class="line">I</span><br><span class="line">NT</span><br><span class="line">OIN</span><br><span class="line">ATPOI</span><br><span class="line">TNIOPTAVAJ</span><br><span class="line">IndexError: string index out of <span class="built_in">range</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="重新分配字符串">重新分配字符串</h2>
<p>更新字符串的内容就像将其分配给新字符串一样简单。字符串对象不支持项赋值，即字符串只能用新字符串替换，因为它的内容不能被部分替换。字符串在 Python 中是不可变的。</p>
<p>考虑下面的例子。</p>
<h3 id="例-1-12">例 1</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;HELLO&quot;</span>  </span><br><span class="line"><span class="built_in">str</span>[<span class="number">0</span>] = <span class="string">&quot;h&quot;</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;12.py&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">str</span>[<span class="number">0</span>] = <span class="string">&quot;h&quot;</span>;</span><br><span class="line">TypeError: <span class="string">&#x27;str&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然而，在示例 1 中，字符串 <strong>str</strong> 可以被完全分配给新的内容，如以下示例中所指定的。</p>
<h3 id="例-2-10">例 2</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;HELLO&quot;</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)  </span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;hello&quot;</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">HELLO</span><br><span class="line">hello  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="删除字符串">删除字符串</h2>
<p>我们知道字符串是不可变的。我们不能删除字符串中的字符。但是我们可以使用 <strong>del</strong> 关键字删除整个字符串。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;JAVATPOINT&quot;</span></span><br><span class="line"><span class="keyword">del</span> <span class="built_in">str</span>[<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">TypeError: <span class="string">&#x27;str&#x27;</span> <span class="built_in">object</span> doesn<span class="string">&#x27;t support item deletion</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>现在我们删除整个字符串。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">str1 = <span class="string">&quot;JAVATPOINT&quot;</span></span><br><span class="line"><span class="keyword">del</span> str1</span><br><span class="line"><span class="built_in">print</span>(str1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">NameError: name <span class="string">&#x27;str1&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="字符串运算符">字符串运算符</h2>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>它被称为连接运算符，用于连接运算符两侧的字符串。</td>
</tr>
<tr>
<td>*</td>
<td>它被称为重复算子。它将同一字符串的多个副本连接起来。</td>
</tr>
<tr>
<td>[]</td>
<td>它被称为切片算子。它用于访问特定字符串的子字符串。</td>
</tr>
<tr>
<td>[:]</td>
<td>它被称为范围切片运算符。它用于访问指定范围内的字符。</td>
</tr>
<tr>
<td>in</td>
<td>它被称为成员运算符。如果指定的字符串中存在特定的子字符串，则返回。</td>
</tr>
<tr>
<td>not in</td>
<td>它也是一个成员操作符，其作用与 in 完全相反。如果指定的字符串中不存在特定的子字符串，则返回 true。</td>
</tr>
<tr>
<td>r/R</td>
<td>它用于指定原始字符串。原始字符串用于我们需要打印转义字符(如“C://python”)的实际含义的情况。要将任何字符串定义为原始字符串，字符 R 或 R 后面是字符串。</td>
</tr>
<tr>
<td>%</td>
<td>它用于执行字符串格式化。它利用 C 编程中使用的格式说明符，如%d 或%f，在 python 中映射它们的值。我们将讨论如何在 python 中进行格式化。</td>
</tr>
</tbody>
</table>
<h3 id="例子-4">例子</h3>
<p>考虑下面的例子来理解 Python 操作符的真正用途。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;Hello&quot;</span>   </span><br><span class="line">str1 = <span class="string">&quot; world&quot;</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>*<span class="number">3</span>) <span class="comment"># prints HelloHelloHello  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>+str1)<span class="comment"># prints Hello world   </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">4</span>]) <span class="comment"># prints o              </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:<span class="number">4</span>]); <span class="comment"># prints ll                  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;w&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>) <span class="comment"># prints false as w is not present in str  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;wo&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> str1) <span class="comment"># prints false as wo is present in str1\.   </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">r&#x27;C://python37&#x27;</span>) <span class="comment"># prints C://python37 as it is written  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The string str : %s&quot;</span>%(<span class="built_in">str</span>)) <span class="comment"># prints The string str : Hello   </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">HelloHelloHello</span><br><span class="line">Hello world</span><br><span class="line">o</span><br><span class="line">ll</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line">C://python37</span><br><span class="line">The string <span class="built_in">str</span> : Hello</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Python-字符串格式">Python 字符串格式</h2>
<h3 id="换码顺序">换码顺序</h3>
<p>让我们假设我们需要把文本写成——他们说，“你好，发生什么事了？”-给定的语句可以用单引号或双引号写出，但它会引发<strong>语法错误</strong>，因为它同时包含单引号和双引号。</p>
<h2 id="例子-5">例子</h2>
<p>考虑下面的例子来理解 Python 操作符的真正用途。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;They said, &quot;</span>Hello what<span class="string">&#x27;s going on?&quot;&quot;</span></span><br><span class="line"><span class="string">print(str)</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">SyntaxError: invalid syntax</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以使用三重引号来解决这个问题，但是 Python 提供了转义序列。</p>
<p>反斜杠(/)符号表示转义序列。反斜杠后面可以跟一个特殊的字符，它有不同的解释。字符串中的单引号必须转义。我们可以应用与双引号中相同的内容。</p>
<h3 id="示例">示例-</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># using triple quotes</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;&#x27;They said, &quot;What&#x27;s there?&quot;&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># escaping single quotes</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;They said, &quot;What\&#x27;s going on?&quot;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># escaping double quotes</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;They said, \&quot;What&#x27;s going on?\&quot;&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">They said, <span class="string">&quot;What&#x27;s there?&quot;</span></span><br><span class="line">They said, <span class="string">&quot;What&#x27;s going on?&quot;</span></span><br><span class="line">They said, <span class="string">&quot;What&#x27;s going on?&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>转义序列列表如下所示:</p>
<p><img src="/img/2023-07-1815.20.32.png" alt="转义序列"></p>
<p>以下是转义序列的简单示例。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;C:\\Users\\DEVANSH SHARMA\\Python32\\Lib&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;This is the \n multiline quotes&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;This is \x48\x45\x58 representation&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">C:\Users\DEVANSH SHARMA\Python32\Lib</span><br><span class="line">This <span class="keyword">is</span> the </span><br><span class="line"> multiline quotes</span><br><span class="line">This <span class="keyword">is</span> HEX representation</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以使用原始字符串忽略给定字符串的转义序列。我们可以通过在字符串前面写 <strong>r</strong> 或 <strong>R</strong> 来实现。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">r&quot;C:\\Users\\DEVANSH SHARMA\\Python32&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">C:\\Users\\DEVANSH SHARMA\\Python32</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="format-方法">format()方法</h2>
<p><strong>format()</strong> 方法是格式化字符串时最灵活、最有用的方法。大括号{}用作字符串中的占位符，并被**格式()**方法参数替换。让我们看一下给出的一个例子:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Using Curly braces</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; and &#123;&#125; both are the best friend&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;Devansh&quot;</span>,<span class="string">&quot;Abhishek&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#Positional Argument</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;1&#125; and &#123;0&#125; best players &quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;Virat&quot;</span>,<span class="string">&quot;Rohit&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#Keyword Argument</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;a&#125;,&#123;b&#125;,&#123;c&#125;&quot;</span>.<span class="built_in">format</span>(a = <span class="string">&quot;James&quot;</span>, b = <span class="string">&quot;Peter&quot;</span>, c = <span class="string">&quot;Ricky&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Devansh <span class="keyword">and</span> Abhishek both are the best friend</span><br><span class="line">Rohit <span class="keyword">and</span> Virat best players </span><br><span class="line">James,Peter,Ricky </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="使用-运算符的-Python-字符串格式">使用%运算符的 Python 字符串格式</h2>
<p>Python 允许我们使用 C 的 printf 语句中使用的格式说明符。Python 中的格式说明符的处理方式与 c 语言中的相同。但是，Python 提供了一个额外的运算符%，用作格式说明符及其值之间的接口。换句话说，我们可以说它将格式说明符绑定到值。</p>
<p>考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Integer = <span class="number">10</span>;  </span><br><span class="line">Float = <span class="number">1.290</span>  </span><br><span class="line">String = <span class="string">&quot;Devansh&quot;</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hi I am Integer ... My value is %d\nHi I am float ... My value is %f\nHi I am string ... My value is %s&quot;</span>%(Integer,Float,String))  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Hi I am Integer ... My value <span class="keyword">is</span> <span class="number">10</span></span><br><span class="line">Hi I am <span class="built_in">float</span> ... My value <span class="keyword">is</span> <span class="number">1.290000</span></span><br><span class="line">Hi I am string ... My value <span class="keyword">is</span> Devansh</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-字符串函数">Python 字符串函数</h2>
<p>Python 提供了各种用于字符串处理的内置函数。许多字符串乐趣</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>capitalize()</td>
<td>它将字符串的第一个字符大写。python3 中不推荐使用此函数</td>
</tr>
<tr>
<td>casefold()</td>
<td>它返回适合无大小写比较的 s 版本。</td>
</tr>
<tr>
<td>center(width ,fillchar)</td>
<td>它返回一个空格填充的字符串，原始字符串以相等数量的左右空格为中心。</td>
</tr>
<tr>
<td>count(string,begin,end)</td>
<td>它计算字符串中开始和结束索引之间的子字符串出现的次数。</td>
</tr>
<tr>
<td>decode(encoding = ‘UTF8’, errors = ‘strict’)</td>
<td>使用注册用于编码的编解码器解码字符串。</td>
</tr>
<tr>
<td>encode()</td>
<td>使用为编码注册的编解码器对 S 进行编码。默认编码为“utf-8”。</td>
</tr>
<tr>
<td>endswith(suffix ,begin=0,end=len(string))</td>
<td>如果字符串在开始和结束之间以给定后缀结束，它将返回一个布尔值。</td>
</tr>
<tr>
<td>expandtabs(tabsize = 8)</td>
<td>它将字符串中的制表符定义为多个空格。默认空间值为 8。</td>
</tr>
<tr>
<td>find(substring ,beginIndex, endIndex)</td>
<td>它返回在开始索引和结束索引之间找到子字符串的字符串的索引值。</td>
</tr>
<tr>
<td>format(value)</td>
<td>它使用传递的值返回 S 的格式化版本。</td>
</tr>
<tr>
<td>index(subsring, beginIndex, endIndex)</td>
<td>如果找不到字符串，它将引发异常。它的工作原理与 find()方法相同。</td>
</tr>
<tr>
<td>isalnum()</td>
<td>如果字符串中的字符是字母数字，即字母或数字，并且至少有 1 个字符，则返回 true。否则，它返回 false。</td>
</tr>
<tr>
<td>isalpha()</td>
<td>如果所有字符都是字母并且至少有一个字符，则返回真，否则返回假。</td>
</tr>
<tr>
<td>isdiction()</td>
<td>如果字符串的所有字符都是小数，则返回 true。</td>
</tr>
<tr>
<td>isdigital()</td>
<td>如果所有字符都是数字并且至少有一个字符，则返回真，否则返回假。</td>
</tr>
<tr>
<td>isidentifier()</td>
<td>如果字符串是有效的标识符，则返回 true。</td>
</tr>
<tr>
<td>islower())</td>
<td>如果字符串的字符是小写，则返回 true，否则返回 false。</td>
</tr>
<tr>
<td>isnumeric()</td>
<td>如果字符串只包含数字字符，则返回 true。</td>
</tr>
<tr>
<td>isprintable()</td>
<td>如果 s 的所有字符都是可打印的或 s 为空，则返回 true，否则返回 false。</td>
</tr>
<tr>
<td>isupper()</td>
<td>如果字符串的字符为大写，则返回 false，否则返回 False。</td>
</tr>
<tr>
<td>isspace()</td>
<td>如果字符串的字符是空格，则返回 true，否则返回 false。</td>
</tr>
<tr>
<td>istitle()</td>
<td>如果字符串标题正确，则返回 true，否则返回 false。标题字符串的第一个字符是大写的，而其他字符是小写的。</td>
</tr>
<tr>
<td>isupper()</td>
<td>如果字符串的所有字符(如果存在)都为真，则返回真，否则返回假。</td>
</tr>
<tr>
<td>join(seq)</td>
<td>它合并给定序列的字符串表示。</td>
</tr>
<tr>
<td>len(string)</td>
<td>它返回字符串的长度。</td>
</tr>
<tr>
<td>ljust(width[,fillchar])</td>
<td>它返回空格填充的字符串，原始字符串左对齐给定的宽度。</td>
</tr>
<tr>
<td>lower()</td>
<td>它将字符串的所有字符转换为小写。</td>
</tr>
<tr>
<td>lstrip()</td>
<td>它删除字符串的所有前导空格，也可用于删除前导中的特定字符。</td>
</tr>
<tr>
<td>partition()</td>
<td>它在 S 中搜索分隔符 sep，并返回它之前的部分、分隔符本身和它之后的部分。如果找不到分隔符，返回 S 和两个空字符串。</td>
</tr>
<tr>
<td>maketrans()</td>
<td>它返回一个用于翻译函数的翻译表。</td>
</tr>
<tr>
<td>replace(old,new[,count])</td>
<td>它用新的字符序列替换旧的字符序列。如果给定了 max，则 max 字符将被替换。</td>
</tr>
<tr>
<td>rfind(str，beg=0，end=len(str))</td>
<td>它类似于 find，但它以向后的方向遍历字符串。</td>
</tr>
<tr>
<td>rindex(str，beg=0，end=len(str))</td>
<td>它与索引相同，但它以向后的方向遍历字符串。</td>
</tr>
<tr>
<td>rjust(width,[,fillchar])</td>
<td>返回一个空格填充的字符串，其原始字符串右对齐指定的字符数。</td>
</tr>
<tr>
<td>rstrip()</td>
<td>它删除字符串的所有尾部空白，也可以用来删除尾部的特定字符。</td>
</tr>
<tr>
<td>rsplit(sep = none，maxsplit = -1)</td>
<td>它与 split()相同，但它从向后的方向处理字符串。它返回字符串中的单词列表。如果未指定分隔符，则字符串会根据空格进行拆分。</td>
</tr>
<tr>
<td>split(str,num=string.count(str))</td>
<td>根据分隔符字符串拆分字符串。如果未提供分隔符，字符串将根据空格进行拆分。它返回与分隔符连接的子字符串列表。</td>
</tr>
<tr>
<td>splitlines(num=string.count(‘\n’))</td>
<td>它返回删除换行符后每行的字符串列表。</td>
</tr>
<tr>
<td>startswith(str，beg=0，end=len(str))</td>
<td>如果字符串从开始和结束之间的给定字符串开始，它将返回一个布尔值。</td>
</tr>
<tr>
<td>strip([chars])</td>
<td>它用于对字符串执行 lstrip()和 rstrip()。</td>
</tr>
<tr>
<td>swapcase()</td>
<td>它反转字符串中所有字符的大小写。</td>
</tr>
<tr>
<td>title()</td>
<td>它用于将字符串转换为标题大小写，即字符串<strong>meereut</strong>将转换为 meereut。</td>
</tr>
<tr>
<td>translate(table,deletechars = ‘’)</td>
<td>它根据函数中传递的转换表来转换字符串。</td>
</tr>
<tr>
<td>upper()</td>
<td>它将字符串的所有字符转换为大写。</td>
</tr>
<tr>
<td>zfill(width)</td>
<td>返回用零填充的原始字符串，总宽度为个字符；zfill()用于数字，保留任何给定的符号(小于零)。</td>
</tr>
<tr>
<td>rpartition()</td>
<td></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 字面量</title>
    <url>/posts/df094b34.html</url>
    <content><![CDATA[<h1>Python 字面量</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-literals">https://www.javatpoint.com/python-literals</a></p>
</blockquote>
<p>Python 字面量可以定义为变量或常量中给出的数据。</p>
<p>Python 支持以下字面量:</p>
<h3 id="1-字符串字面量">1.字符串字面量:</h3>
<p>字符串可以用引号括起来。我们可以使用单引号和双引号来创建字符串。</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Aman&quot;</span> , <span class="string">&#x27;12345&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>字符串类型:</strong></p>
<p>Python 支持两种类型的字符串:</p>
<p><strong>a)单线字符串</strong> -在单线内终止的字符串称为单线字符串。</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">text1=<span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>b)多行字符串-</strong> 多行书写的文本称为多行字符串。</p>
<p>有两种方法可以创建多行字符串:</p>
<p><strong>1)每行末尾加黑色斜线。</strong></p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">text1=<span class="string">&#x27;hello\  </span></span><br><span class="line"><span class="string">user&#x27;</span>  </span><br><span class="line"><span class="built_in">print</span>(text1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;hellouser&#x27;</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>2)使用三重引号:-</strong></p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">str2=<span class="string">&#x27;&#x27;&#x27;welcome </span></span><br><span class="line"><span class="string">to </span></span><br><span class="line"><span class="string">SSSIT&#x27;&#x27;&#x27;</span>  </span><br><span class="line"><span class="built_in">print</span> str2 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">welcome  </span><br><span class="line">to  </span><br><span class="line">SSSIT  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="二-数值字面量">二.数值字面量:</h3>
<p>数值是不可变的。数字字面量可以属于以下四种不同的数字类型。</p>
<p>| Int(有符号整数) | 长(长整数) | 浮点 | 复杂 |<br>
| 没有小数部分的数字(可以是正数也可以是负数) | 大小不限的整数，后跟小写或大写字母 L 例如:87032845L | 既有整数部分又有小数部分的实数，例如:-26.2 | 形式为 a+bj，其中 a 构成复数的实部，b 构成复数的虚部。例:3.14j |</p>
<p><strong>示例-数值字面量</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">x = <span class="number">0b10100</span> <span class="comment">#Binary Literals</span></span><br><span class="line">y = <span class="number">100</span> <span class="comment">#Decimal Literal </span></span><br><span class="line">z = <span class="number">0o215</span> <span class="comment">#Octal Literal</span></span><br><span class="line">u = <span class="number">0x12d</span> <span class="comment">#Hexadecimal Literal</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Float Literal</span></span><br><span class="line">float_1 = <span class="number">100.5</span> </span><br><span class="line">float_2 = <span class="number">1.5e2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Complex Literal </span></span><br><span class="line">a = <span class="number">5</span>+<span class="number">3.14j</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x, y, z, u)</span><br><span class="line"><span class="built_in">print</span>(float_1, float_2)</span><br><span class="line"><span class="built_in">print</span>(a, a.imag, a.real)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span> <span class="number">100</span> <span class="number">141</span> <span class="number">301</span></span><br><span class="line"><span class="number">100.5</span> <span class="number">150.0</span></span><br><span class="line">(<span class="number">5</span>+<span class="number">3.14j</span>) <span class="number">3.14</span> <span class="number">5.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="三-布尔字面量">三.布尔字面量:</h3>
<p>布尔字面量可以有两个值中的任何一个:真或假。</p>
<p><strong>示例-布尔字面量</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">x = (<span class="number">1</span> == <span class="literal">True</span>)</span><br><span class="line">y = (<span class="number">2</span> == <span class="literal">False</span>)</span><br><span class="line">z = (<span class="number">3</span> == <span class="literal">True</span>)</span><br><span class="line">a = <span class="literal">True</span> + <span class="number">10</span></span><br><span class="line">b = <span class="literal">False</span> + <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x is&quot;</span>, x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y is&quot;</span>, y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;z is&quot;</span>, z)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a:&quot;</span>, a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b:&quot;</span>, b)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">x <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line">y <span class="keyword">is</span> <span class="literal">False</span></span><br><span class="line">z <span class="keyword">is</span> <span class="literal">False</span></span><br><span class="line">a: <span class="number">11</span></span><br><span class="line">b: <span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="四-特殊字面量。">四.特殊字面量。</h3>
<p>Python 包含一个特殊的字面量，即<strong>无。</strong></p>
<p>无用于指定未创建的字段。它也用于 Python 中列表的结尾。</p>
<p><strong>示例-特殊字面量</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">val1=<span class="number">10</span>  </span><br><span class="line">val2=<span class="literal">None</span>  </span><br><span class="line"><span class="built_in">print</span>(val1)   </span><br><span class="line"><span class="built_in">print</span>(val2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="动词-（verb-的缩写）字面量集合。">动词 （verb 的缩写）字面量集合。</h3>
<p>Python 提供了四种类型的字面量集合，如列表字面量、元组字面量、字典字面量和集合字面量。</p>
<p><strong>列表:</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>列表包含不同数据类型的项目。列表是可变的，即可修改的。</p>
</li>
<li class="lvl-4">
<p>列表中存储的值由逗号(，)分隔，并包含在方括号([])中。我们可以在列表中存储不同类型的数据。</p>
</li>
</ul>
<p><strong>示例-列表字面量</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>=[<span class="string">&#x27;John&#x27;</span>,<span class="number">678</span>,<span class="number">20.4</span>,<span class="string">&#x27;Peter&#x27;</span>]  </span><br><span class="line">list1=[<span class="number">456</span>,<span class="string">&#x27;Andrew&#x27;</span>]  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span> + list1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;John&#x27;</span>, <span class="number">678</span>, <span class="number">20.4</span>, <span class="string">&#x27;Peter&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;John&#x27;</span>, <span class="number">678</span>, <span class="number">20.4</span>, <span class="string">&#x27;Peter&#x27;</span>, <span class="number">456</span>, <span class="string">&#x27;Andrew&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>字典:</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>Python 字典将数据存储在键值对中。</p>
</li>
<li class="lvl-4">
<p>它由花括号{}括起来，每对用逗号(，)隔开。</p>
</li>
</ul>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Pater&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>:<span class="number">18</span>,<span class="string">&#x27;Roll_nu&#x27;</span>:<span class="number">101</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Pater&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;Roll_nu&#x27;</span>: <span class="number">101</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>元组:</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>Python 元组是不同数据类型集合。它是不可变的，这意味着它在创建后不能被修改。</p>
</li>
<li class="lvl-4">
<p>它用括号()括起来，每个元素用逗号(，)分隔。</p>
</li>
</ul>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tup = (<span class="number">10</span>,<span class="number">20</span>,<span class="string">&quot;Dev&quot;</span>,[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(tup)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="number">10</span>, <span class="number">20</span>, <span class="string">&#x27;Dev&#x27;</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>设定:</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>Python 集合是无序数据集的集合。</p>
</li>
<li class="lvl-4">
<p>它用{}括起来，每个元素用逗号(，)隔开。</p>
</li>
</ul>
<p><strong>示例:-设置字面量量</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> = &#123;<span class="string">&#x27;apple&#x27;</span>,<span class="string">&#x27;grapes&#x27;</span>,<span class="string">&#x27;guava&#x27;</span>,<span class="string">&#x27;papaya&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;guava&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;papaya&#x27;</span>, <span class="string">&#x27;grapes&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 异常</title>
    <url>/posts/28b176d2.html</url>
    <content><![CDATA[<h1>Python 异常</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-exception-handling">https://www.javatpoint.com/python-exception-handling</a></p>
</blockquote>
<p>异常可以定义为程序中导致程序流程中断的异常。</p>
<p>每当出现异常时，程序就会停止执行，因此不会执行下一个代码。因此，一个异常是无法处理 Python 脚本的运行时错误。异常是表示错误的 Python 对象</p>
<p>Python 提供了一种处理异常的方法，这样代码就可以在没有任何中断的情况下执行。如果我们不处理异常，解释器就不会执行异常后存在的所有代码。</p>
<p>Python 有许多<strong>内置异常</strong>，使我们的程序能够不间断运行并给出输出。这些异常如下:</p>
<h2 id="常见异常">常见异常</h2>
<p>Python 提供了内置异常的数量，但这里我们描述的是常见的标准异常。下面列出了标准 Python 程序可能引发的常见异常。</p>
<ol>
<li class="lvl-4">
<p>**零除错误:**当一个数被零除时发生。</p>
</li>
<li class="lvl-4">
<p>**名称错误:**找不到名称时出现。它可能是局部的，也可能是全局的。</p>
</li>
<li class="lvl-4">
<p>**缩进错误:**如果给出了不正确的缩进。</p>
</li>
<li class="lvl-4">
<p><strong>IOError:</strong> 输入输出操作失败时出现。</p>
</li>
<li class="lvl-4">
<p><strong>EOFError:</strong> 当到达文件末尾，但仍在执行操作时，就会出现这种情况。</p>
</li>
</ol>
<hr>
<h2 id="不处理异常的问题">不处理异常的问题</h2>
<p>正如我们已经讨论过的，异常是中止程序执行的异常。</p>
<p>假设我们有两个变量 <strong>a</strong> 和 <strong>b</strong> ，它们接受用户的输入并执行这些值的除法。如果用户输入零作为分母呢？它将中断程序执行，并通过一个<strong>零分</strong>异常。让我们看看下面的例子。</p>
<h3 id="例子-6">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter a:&quot;</span>))  </span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter b:&quot;</span>))  </span><br><span class="line">c = a/b</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a/b = %d&quot;</span> %c)  </span><br><span class="line"></span><br><span class="line"><span class="comment">#other code:  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hi I am other part of the program&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter a:<span class="number">10</span></span><br><span class="line">Enter b:<span class="number">0</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;exception-test.py&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    c = a/b;</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的程序在语法上是正确的，但是它由于异常输入而出错。这种编程可能不适合或不推荐项目，因为这些项目需要不间断的执行。这就是为什么异常处理在处理这些意外异常时起着重要作用。我们可以用以下方式处理这些异常。</p>
<h2 id="python-中的异常处理">python 中的异常处理</h2>
<h3 id="尝试-期望语句">尝试-期望语句</h3>
<p>如果 Python 程序包含可能引发异常的可疑代码，我们必须将该代码放在 <strong>try</strong> 块中。 <strong>try</strong> 块后面必须跟有<strong>除了</strong>语句，该语句包含一个代码块，如果 try 块中有异常，将执行该代码块。</p>
<p><img src="/img/91cbc9604d5533a4c10d8f532597cad7.png" alt="Python Exception handling"></p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    <span class="comment">#block of code   </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Exception1:  </span><br><span class="line">    <span class="comment">#block of code  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Exception2:  </span><br><span class="line">    <span class="comment">#block of code  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#other code  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>考虑下面的例子。</p>
<p><strong>例 1</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter a:&quot;</span>))  </span><br><span class="line">    b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter b:&quot;</span>))  </span><br><span class="line">    c = a/b</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Can&#x27;t divide with zero&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter a:<span class="number">10</span></span><br><span class="line">Enter b:<span class="number">0</span></span><br><span class="line">Can<span class="string">&#x27;t divide with zero</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>我们还可以将 else 语句与 try-except 语句一起使用，在 try 语句中，如果 try 块中没有发生异常，我们可以放置将在场景中执行的代码。</p>
<p>下面给出了将 else 语句与 try-except 语句一起使用的语法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    <span class="comment">#block of code   </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Exception1:  </span><br><span class="line">    <span class="comment">#block of code   </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    <span class="comment">#this code executes if no except block is executed  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/e59c291f3d732153e8fb4ad437231bb9.png" alt="Python Exception handling"></p>
<p>考虑以下程序。</p>
<p><strong>例 2</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter a:&quot;</span>))  </span><br><span class="line">    b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter b:&quot;</span>))  </span><br><span class="line">    c = a/b</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a/b = %d&quot;</span>%c)  </span><br><span class="line"><span class="comment"># Using Exception with except statement. If we print(Exception) it will return exception class</span></span><br><span class="line"><span class="keyword">except</span> Exception:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;can&#x27;t divide by zero&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(Exception)</span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hi I am else block&quot;</span>)   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter a:<span class="number">10</span></span><br><span class="line">Enter b:<span class="number">0</span></span><br><span class="line">can<span class="string">&#x27;t divide by zero</span></span><br><span class="line"><span class="string">&lt;class &#x27;</span>Exception<span class="string">&#x27;&gt;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<h2 id="无异常的异常语句">无异常的异常语句</h2>
<p>Python 提供了不在异常语句中指定异常名称的灵活性。</p>
<p>考虑下面的例子。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter a:&quot;</span>))  </span><br><span class="line">    b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter b:&quot;</span>))  </span><br><span class="line">    c = a/b;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a/b = %d&quot;</span>%c)  </span><br><span class="line"><span class="keyword">except</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;can&#x27;t divide by zero&quot;</span>)  </span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hi I am else block&quot;</span>)   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="与异常变量一起使用的-except-语句">与异常变量一起使用的 except 语句</h3>
<p>除了语句，我们可以将异常变量与<strong>一起使用。使用</strong>作为<strong>关键字。该对象将返回异常的原因。考虑以下示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter a:&quot;</span>))  </span><br><span class="line">    b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter b:&quot;</span>))  </span><br><span class="line">    c = a/b</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a/b = %d&quot;</span>%c)  </span><br><span class="line">    <span class="comment"># Using exception object with the except statement</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;can&#x27;t divide by zero&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hi I am else block&quot;</span>)   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter a:<span class="number">10</span></span><br><span class="line">Enter b:<span class="number">0</span></span><br><span class="line">can<span class="string">&#x27;t divide by zero</span></span><br><span class="line"><span class="string">division by zero</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<h2 id="需要记住的要点">需要记住的要点</h2>
<ol>
<li class="lvl-4">
<p>Python 方便我们不用 except 语句指定异常。</p>
</li>
<li class="lvl-4">
<p>我们可以在 except 语句中声明多个异常，因为 try 块可能包含引发不同类型异常的语句。</p>
</li>
<li class="lvl-4">
<p>我们还可以在 try-except 语句中指定一个 else 块，如果 try 块中没有引发异常，就会执行该语句。</p>
</li>
<li class="lvl-4">
<p>不抛出异常的语句应该放在 else 块中。</p>
</li>
</ol>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    <span class="comment">#this will throw an exception if the file doesn&#x27;t exist.   </span></span><br><span class="line">    fileptr = <span class="built_in">open</span>(<span class="string">&quot;file.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)  </span><br><span class="line"><span class="keyword">except</span> IOError:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;File not found&quot;</span>)  </span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The file opened successfully&quot;</span>)  </span><br><span class="line">    fileptr.close()  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">File <span class="keyword">not</span> found</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="声明多个异常">声明多个异常</h2>
<p>Python 允许我们用 except 子句声明多个异常。在 try 块引发多个异常的情况下，声明多个异常非常有用。语法如下。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    <span class="comment">#block of code   </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> (&lt;Exception <span class="number">1</span>&gt;,&lt;Exception <span class="number">2</span>&gt;,&lt;Exception <span class="number">3</span>&gt;,...&lt;Exception n&gt;)  </span><br><span class="line">    <span class="comment">#block of code   </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    <span class="comment">#block of code  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:    </span><br><span class="line">    a=<span class="number">10</span>/<span class="number">0</span>;    </span><br><span class="line"><span class="keyword">except</span>(ArithmeticError, IOError):    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Arithmetic Exception&quot;</span>)    </span><br><span class="line"><span class="keyword">else</span>:    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Successfully Done&quot;</span>)     </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Arithmetic Exception</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="尝试…最后封锁">尝试…最后封锁</h2>
<p>Python 提供了可选的 <strong>finally</strong> 语句，与 <strong>try</strong> 语句一起使用。无论发生什么异常，它都会被执行，并用于释放外部资源。finally 块为执行提供了保证。</p>
<p>我们可以将 finally 块与 try 块一起使用，在 try 块中我们可以调整必要的代码，这些代码必须在 try 语句引发异常之前执行。</p>
<p>下面给出了使用 finally 块的语法。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    <span class="comment"># block of code   </span></span><br><span class="line">    <span class="comment"># this may throw an exception  </span></span><br><span class="line"><span class="keyword">finally</span>:  </span><br><span class="line">    <span class="comment"># block of code  </span></span><br><span class="line">    <span class="comment"># this will always be executed   </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/9876a92311a75281788d0410bb5ab466.png" alt="Python Exception handling"></p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    fileptr = <span class="built_in">open</span>(<span class="string">&quot;file2.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)    </span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">        fileptr.write(<span class="string">&quot;Hi I am good&quot;</span>)  </span><br><span class="line">    <span class="keyword">finally</span>:  </span><br><span class="line">        fileptr.close()  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;file closed&quot;</span>)  </span><br><span class="line"><span class="keyword">except</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error&quot;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">file closed</span><br><span class="line">Error</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="引发异常">引发异常</h2>
<p>使用 Python 中的 <strong>raise</strong> 子句可以强制引发异常。在我们需要引发异常来停止程序执行的场景中，这非常有用。</p>
<p>例如，有一个程序需要 2GB 内存来执行，如果程序试图占用 2GB 内存，那么我们可以引发一个异常来停止程序的执行。</p>
<p>下面给出了使用 raise 语句的语法。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">raise</span> Exception_class,&lt;value&gt;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>记分</strong></p>
<ol>
<li class="lvl-4">
<p>若要引发异常，请使用 raise 语句。异常类名紧随其后。</p>
</li>
<li class="lvl-4">
<p>可以为异常提供一个可以在括号中给出的值。</p>
</li>
<li class="lvl-4">
<p>使用关键字访问值“<strong>”作为</strong>。” <strong>e</strong> 用作存储异常值的参考变量。</p>
</li>
<li class="lvl-4">
<p>我们可以将该值传递给异常，以指定异常类型。</p>
</li>
</ol>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    age = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the age:&quot;</span>))  </span><br><span class="line">    <span class="keyword">if</span>(age&lt;<span class="number">18</span>):  </span><br><span class="line">        <span class="keyword">raise</span> ValueError </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;the age is valid&quot;</span>)  </span><br><span class="line"><span class="keyword">except</span> ValueError:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The age is not valid&quot;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the age:<span class="number">17</span></span><br><span class="line">The age <span class="keyword">is</span> <span class="keyword">not</span> valid</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例 2 通过消息</strong>引发异常</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">     num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter a positive integer: &quot;</span>))</span><br><span class="line">     <span class="keyword">if</span>(num &lt;= <span class="number">0</span>):</span><br><span class="line"><span class="comment"># we can pass the message in the raise statement</span></span><br><span class="line">         <span class="keyword">raise</span> ValueError(<span class="string">&quot;That is  a negative number!&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">     <span class="built_in">print</span>(e)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter a positive integer: -<span class="number">5</span></span><br><span class="line">That <span class="keyword">is</span> a negative number!</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例 3</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter a:&quot;</span>))  </span><br><span class="line">    b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter b:&quot;</span>))  </span><br><span class="line">    <span class="keyword">if</span> b <span class="keyword">is</span> <span class="number">0</span>:  </span><br><span class="line">        <span class="keyword">raise</span> ArithmeticError</span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;a/b = &quot;</span>,a/b)  </span><br><span class="line"><span class="keyword">except</span> ArithmeticError:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The value of b can&#x27;t be 0&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter a:<span class="number">10</span></span><br><span class="line">Enter b:<span class="number">0</span></span><br><span class="line">The value of b can<span class="string">&#x27;t be 0</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<h2 id="自定义异常">自定义异常</h2>
<p>Python 允许我们创建可以从程序中引发并使用 except 子句捕获的异常。但是，我们建议您在访问 Python 对象和类后阅读这一部分。</p>
<p>考虑下面的例子。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorInCode</span>(<span class="title class_ inherited__">Exception</span>):    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):    </span><br><span class="line">        self.data = data    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):    </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">repr</span>(self.data)    </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:    </span><br><span class="line">    <span class="keyword">raise</span> ErrorInCode(<span class="number">2000</span>)    </span><br><span class="line"><span class="keyword">except</span> ErrorInCode <span class="keyword">as</span> ae:    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Received error:&quot;</span>, ae.data)    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Received error: <span class="number">2000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 循环</title>
    <url>/posts/3ebc62bf.html</url>
    <content><![CDATA[<h1>Python 循环</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-loops">https://www.javatpoint.com/python-loops</a></p>
</blockquote>
<p>默认情况下，用任何编程语言编写的程序流都是连续的。有时我们可能需要改变程序的流程。特定代码的执行可能需要重复几次。</p>
<p>为此，编程语言提供了各种类型的循环，这些循环能够多次重复某些特定的代码。考虑下图来理解循环语句的工作原理。</p>
<p><img src="img/90feeebbf07e6277b451324829840d35.png" alt="Python Loops"></p>
<h2 id="为什么我们在-python-中使用循环？">为什么我们在 python 中使用循环？</h2>
<p>循环将复杂的问题简化为简单的问题。它使我们能够改变程序的流程，这样我们就可以在有限的时间内重复相同的代码，而不是一次又一次地编写相同的代码。例如，如果我们需要打印前 10 个自然数，那么我们可以在最多运行 10 次迭代的循环中打印，而不是使用 print 语句 10 次。</p>
<h2 id="循环的优点">循环的优点</h2>
<p>Python 中的循环有以下优点。</p>
<ol>
<li class="lvl-4">
<p>它提供代码的可重用性。</p>
</li>
<li class="lvl-4">
<p>使用循环，我们不需要一次又一次地编写相同的代码。</p>
</li>
<li class="lvl-4">
<p>使用循环，我们可以遍历数据结构的元素(数组或链表)。</p>
</li>
</ol>
<p>Python 中有以下循环语句。</p>
<p>| 循环语句 | 描述 |<br>
| <code>for</code>循环 | <code>for</code>循环用于我们需要执行部分代码直到满足给定条件的情况。<code>for</code>循环也称为经过测试的循环。如果迭代次数事先已知，最好使用 <code>for</code>循环。 |<br>
| <code>While</code>循环 | <code>While</code>循环将用于我们事先不知道迭代次数的场景。语句块在 <code>While</code>循环中执行，直到满足 <code>While</code>循环中指定的条件。它也被称为预测试循环。 |<br>
| 边做边循环 | do-<code>While</code>循环一直持续到给定条件满足为止。它也被称为后测试循环。当需要至少执行一次循环时使用(主要是菜单驱动程序)。 |</p>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 数据类型</title>
    <url>/posts/cbc5e2b2.html</url>
    <content><![CDATA[<h1>Python 数据类型</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-data-types">https://www.javatpoint.com/python-data-types</a></p>
</blockquote>
<p>变量可以保存值，每个值都有一个数据类型。Python 是一种动态类型语言；因此，我们在声明变量时不需要定义它的类型。解释器隐式地将值与其类型绑定。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>变量 <strong>a</strong> 保存整数值 5，我们没有定义它的类型。Python 解释器会自动将变量 <strong>a</strong> 解释为整数类型。</p>
<p>Python 使我们能够检查程序中使用的变量的类型。Python 为我们提供了 <strong>type()</strong> 函数，返回传递的变量的类型。</p>
<p>考虑以下示例来定义不同数据类型的值并检查其类型。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a=<span class="number">10</span></span><br><span class="line">b=<span class="string">&quot;Hi Python&quot;</span></span><br><span class="line">c = <span class="number">10.5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(c))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;float&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="标准数据类型">标准数据类型</h2>
<p>一个变量可以保存不同类型的值。例如，一个人的名字必须存储为字符串，而他的 id 必须存储为整数。</p>
<p>Python 提供了各种标准数据类型，定义了每种类型的存储方法。下面给出了 Python 中定义的数据类型。</p>
<ol>
<li class="lvl-4">
<p><a href="#numbers">数字</a></p>
</li>
<li class="lvl-4">
<p><a href="#SequenceType">序列类型</a></p>
</li>
<li class="lvl-4">
<p><a href="#Boolean">布尔</a></p>
</li>
<li class="lvl-4">
<p><a href="#Set">设置</a></p>
</li>
<li class="lvl-4">
<p><a href="#dictionary">字典</a></p>
</li>
</ol>
<p><img src="img/a00048e994264539ed0e8efced9e71c8.png" alt="Python Data Types"></p>
<p>在教程的这一部分，我们将简要介绍上述数据类型。我们将在本教程的后面详细讨论每一个。</p>
<h3 id="民数记">民数记</h3>
<p>Number 存储数值。整数、浮点和复数值属于 Python Numbers 数据类型。Python 提供了 <strong>type()</strong> 函数来知道变量的数据类型。类似地， <strong>isinstance()</strong> 函数用于检查某个对象是否属于某个特定的类。</p>
<p>当一个数字被分配给一个变量时，Python 会创建数字对象。比如；</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The type of a&quot;</span>, <span class="built_in">type</span>(a))</span><br><span class="line"></span><br><span class="line">b = <span class="number">40.5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The type of b&quot;</span>, <span class="built_in">type</span>(b))</span><br><span class="line"></span><br><span class="line">c = <span class="number">1</span>+<span class="number">3j</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The type of c&quot;</span>, <span class="built_in">type</span>(c))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; c is a complex number&quot;</span>, <span class="built_in">isinstance</span>(<span class="number">1</span>+<span class="number">3j</span>,<span class="built_in">complex</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The <span class="built_in">type</span> of a &lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line">The <span class="built_in">type</span> of b &lt;<span class="keyword">class</span> <span class="string">&#x27;float&#x27;</span>&gt;</span><br><span class="line">The <span class="built_in">type</span> of c &lt;<span class="keyword">class</span> <span class="string">&#x27;complex&#x27;</span>&gt;</span><br><span class="line">c <span class="keyword">is</span> <span class="built_in">complex</span> number: <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Python 支持三种类型的数字数据。</p>
<ol>
<li class="lvl-4">
<p><strong>Int -</strong> 整数值可以是任意长度，如整数 10、2、29、-20、-150 等。Python 对整数的长度没有限制。其价值属于<strong>国际</strong></p>
</li>
<li class="lvl-4">
<p><strong>Float -</strong> Float 用于存储 1.9、9.902、15.2 等浮点数。它精确到小数点后 15 位。</p>
</li>
<li class="lvl-4">
<p><strong>复数-</strong> 复数包含有序对，即 x + iy，其中 x 和 y 分别表示实部和虚部。2.14j、2.0 + 2.3j 等复数。</p>
</li>
</ol>
<h3 id="序列类型">序列类型</h3>
<h3 id="线">线</h3>
<p>字符串可以定义为引号中表示的字符序列。在 Python 中，我们可以使用单引号、双引号或三引号来定义字符串。</p>
<p>Python 中的字符串处理是一项简单的任务，因为 Python 提供了内置函数和运算符来执行字符串中的操作。</p>
<p>在字符串处理的情况下，运算符+用于连接两个字符串，因为操作*“hello”+“python”<em>返回</em>“hello python”*。</p>
<p>运算符<em>被称为重复运算符，因为操作“Python”</em> 2 返回“Python Python”。</p>
<p>以下示例说明了 Python 中的字符串。</p>
<p><strong>示例- 1</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;string using double quotes&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line">s = <span class="string">&#x27;&#x27;&#x27;A multiline</span></span><br><span class="line"><span class="string">string&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">string using double quotes</span><br><span class="line">A multiline</span><br><span class="line">string</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>考虑下面的字符串处理示例。</p>
<p><strong>示例- 2</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&#x27;hello javatpoint&#x27;</span> <span class="comment">#string str1  </span></span><br><span class="line">str2 = <span class="string">&#x27; how are you&#x27;</span> <span class="comment">#string str2  </span></span><br><span class="line"><span class="built_in">print</span> (str1[<span class="number">0</span>:<span class="number">2</span>]) <span class="comment">#printing first two character using slice operator  </span></span><br><span class="line"><span class="built_in">print</span> (str1[<span class="number">4</span>]) <span class="comment">#printing 4th character of the string  </span></span><br><span class="line"><span class="built_in">print</span> (str1*<span class="number">2</span>) <span class="comment">#printing the string twice  </span></span><br><span class="line"><span class="built_in">print</span> (str1 + str2) <span class="comment">#printing the concatenation of str1 and str2  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">he</span><br><span class="line">o</span><br><span class="line">hello javatpointhello javatpoint</span><br><span class="line">hello javatpoint how are you</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="目录">目录</h3>
<p>Python 列表类似于 c 语言中的数组。但是，列表可以包含不同类型的数据。列表中存储的项目用逗号(，)分隔，并括在方括号[]内。</p>
<p>我们可以使用 slice [:]运算符来访问列表的数据。串联运算符(+)和重复运算符(*)处理列表的方式与处理字符串的方式相同。</p>
<p>考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">list1  = [<span class="number">1</span>, <span class="string">&quot;hi&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="number">2</span>]  </span><br><span class="line"><span class="comment">#Checking type of given list</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(list1))</span><br><span class="line"></span><br><span class="line"><span class="comment">#Printing the list1</span></span><br><span class="line"><span class="built_in">print</span> (list1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># List slicing</span></span><br><span class="line"><span class="built_in">print</span> (list1[<span class="number">3</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># List slicing</span></span><br><span class="line"><span class="built_in">print</span> (list1[<span class="number">0</span>:<span class="number">2</span>]) </span><br><span class="line"></span><br><span class="line"><span class="comment"># List Concatenation using + operator</span></span><br><span class="line"><span class="built_in">print</span> (list1 + list1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># List repetation using * operator</span></span><br><span class="line"><span class="built_in">print</span> (list1 * <span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="string">&#x27;hi&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="string">&#x27;hi&#x27;</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="string">&#x27;hi&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="string">&#x27;hi&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="string">&#x27;hi&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="string">&#x27;hi&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="string">&#x27;hi&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="number">2</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="元组">元组</h3>
<p>元组在许多方面类似于列表。像列表一样，元组也包含不同数据类型项的集合。元组的项用逗号(，)分隔，并包含在括号()中。</p>
<p>元组是只读的数据结构，因为我们不能修改元组的项目的大小和值。</p>
<p>让我们看一个简单的元组例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tup  = (<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="number">2</span>)  </span><br><span class="line"><span class="comment"># Checking type of tup</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">type</span>(tup))  </span><br><span class="line"></span><br><span class="line"><span class="comment">#Printing the tuple</span></span><br><span class="line"><span class="built_in">print</span> (tup)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Tuple slicing</span></span><br><span class="line"><span class="built_in">print</span> (tup[<span class="number">1</span>:])  </span><br><span class="line"><span class="built_in">print</span> (tup[<span class="number">0</span>:<span class="number">1</span>])  </span><br><span class="line"></span><br><span class="line"><span class="comment"># Tuple concatenation using + operator</span></span><br><span class="line"><span class="built_in">print</span> (tup + tup)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># Tuple repatation using * operator</span></span><br><span class="line"><span class="built_in">print</span> (tup * <span class="number">3</span>)   </span><br><span class="line"></span><br><span class="line"><span class="comment"># Adding value to tup. It will throw an error.</span></span><br><span class="line">t[<span class="number">2</span>] = <span class="string">&quot;hi&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line">(<span class="string">&#x27;hi&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="string">&#x27;Python&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="string">&#x27;hi&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;hi&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;hi&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="string">&#x27;hi&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;hi&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;hi&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;main.py&quot;</span>, line <span class="number">14</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    t[<span class="number">2</span>] = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="字典">字典</h3>
<p>字典是项的键值对的无序集合。它就像一个关联数组或哈希表，其中每个键存储一个特定的值。键可以保存任何原始数据类型，而值是任意的 Python 对象。</p>
<p>字典中的项目用逗号(，)分隔，并包含在大括号{}中。</p>
<p>考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="number">1</span>:<span class="string">&#x27;Jimmy&#x27;</span>, <span class="number">2</span>:<span class="string">&#x27;Alex&#x27;</span>, <span class="number">3</span>:<span class="string">&#x27;john&#x27;</span>, <span class="number">4</span>:<span class="string">&#x27;mike&#x27;</span>&#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment"># Printing dictionary</span></span><br><span class="line"><span class="built_in">print</span> (d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Accesing value using keys</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1st name is &quot;</span>+d[<span class="number">1</span>]) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;2nd name is &quot;</span>+ d[<span class="number">4</span>])  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (d.keys())  </span><br><span class="line"><span class="built_in">print</span> (d.values())  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">1st name <span class="keyword">is</span> Jimmy</span><br><span class="line">2nd name <span class="keyword">is</span> mike</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;Jimmy&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Alex&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;john&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;mike&#x27;</span>&#125;</span><br><span class="line">dict_keys([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">dict_values([<span class="string">&#x27;Jimmy&#x27;</span>, <span class="string">&#x27;Alex&#x27;</span>, <span class="string">&#x27;john&#x27;</span>, <span class="string">&#x27;mike&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="布尔代数学体系的">布尔代数学体系的</h3>
<p>布尔类型提供两个内置值，真和假。这些值用于确定给定语句的真假。它由类 bool 表示。True 可以用任何非零值或“T”表示，而 false 可以用 0 或“F”表示。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python program to check the boolean type</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">True</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">False</span>))</span><br><span class="line"><span class="built_in">print</span>(false)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;bool&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;bool&#x27;</span>&gt;</span><br><span class="line">NameError: name <span class="string">&#x27;false&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="一组">一组</h3>
<p>Python 集是数据类型的无序集合。它是可迭代的、可变的(可以在创建后修改)，并且具有独特的元素。在 set 中，元素的顺序是未定义的；它可以返回元素的改变的序列。通过使用内置函数 **set()，**创建集合，或者在花括号中传递一系列元素，并用逗号分隔。它可以包含各种类型的值。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creating Empty set</span></span><br><span class="line">set1 = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">set2 = &#123;<span class="string">&#x27;James&#x27;</span>, <span class="number">2</span>, <span class="number">3</span>,<span class="string">&#x27;Python&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#Printing Set value</span></span><br><span class="line"><span class="built_in">print</span>(set2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Adding element to the set</span></span><br><span class="line"></span><br><span class="line">set2.add(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(set2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Removing element from the set</span></span><br><span class="line">set2.remove(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(set2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">3</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;James&#x27;</span>, <span class="number">2</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;James&#x27;</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">10</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;James&#x27;</span>, <span class="number">3</span>, <span class="number">10</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 文件处理</title>
    <url>/posts/4f5b6974.html</url>
    <content><![CDATA[<h1>Python 文件处理</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-files-io">https://www.javatpoint.com/python-files-io</a></p>
</blockquote>
<p>到目前为止，我们从控制台获取输入，并将其写回控制台，以便与用户进行交互。</p>
<p>有时候，仅仅在控制台上显示数据是不够的。要显示的数据可能非常大，并且只能在控制台上显示有限数量的数据，因为内存是易失性的，不可能一次又一次地恢复以编程方式生成的数据。</p>
<p>当数据需要永久存储到文件中时，文件处理起着重要的作用。文件是磁盘上存储相关信息的命名位置。我们可以在程序终止后访问存储的信息(非易失性的)。</p>
<p>在其他编程语言中，文件处理实现略长或复杂，但在 Python 中，它更简单、更短。</p>
<p>在 Python 中，文件在两种模式下被视为文本或二进制文件。文件可以是文本或二进制格式，文件的每一行都以特殊字符结尾。</p>
<p>因此，文件操作可以按以下顺序进行。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>打开文件</p>
</li>
<li class="lvl-4">
<p>读取或写入-执行操作</p>
</li>
<li class="lvl-4">
<p>关闭文件</p>
</li>
</ul>
<h2 id="打开文件">打开文件</h2>
<p>Python 提供了一个 <strong>open()</strong> 函数，接受两个参数，文件名和访问文件的访问模式。该函数返回一个文件对象，该对象可用于执行各种操作，如读取、写入等。</p>
<p><strong>语法:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">file <span class="built_in">object</span> = <span class="built_in">open</span>(&lt;file-name&gt;, &lt;access-mode&gt;, &lt;buffering&gt;)   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以使用各种模式(如读取、写入或追加)来访问这些文件。以下是有关打开文件的访问模式的详细信息。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>存取方式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>one</td>
<td>r</td>
<td>它以只读模式打开文件。文件指针存在于开头。如果没有通过访问模式，默认情况下，文件在此模式下是打开的。</td>
</tr>
<tr>
<td>Two</td>
<td>rb</td>
<td>它以二进制格式将文件打开为只读。文件指针存在于文件的开头。</td>
</tr>
<tr>
<td>three</td>
<td>r+</td>
<td>它打开文件进行读写。文件指针存在于文件的开头。</td>
</tr>
<tr>
<td>four</td>
<td>rb+</td>
<td>它以二进制格式打开文件进行读写。文件指针存在于文件的开头。</td>
</tr>
<tr>
<td>five</td>
<td>w</td>
<td>它打开文件只写。如果文件以前存在，它会覆盖该文件；如果不存在同名文件，它会创建一个新文件。文件指针存在于文件的开头。</td>
</tr>
<tr>
<td>six</td>
<td>wb</td>
<td>它打开文件，只以二进制格式写入。如果文件以前存在，它会覆盖该文件；如果没有文件，它会创建一个新文件。文件指针存在于文件的开头。</td>
</tr>
<tr>
<td>seven</td>
<td>w+</td>
<td>它打开文件进行读写。它与 r+的不同之处在于，如果存在先前的文件，它会覆盖先前的文件，而 r+不会覆盖先前写入的文件。如果没有文件，它会创建一个新文件。文件指针存在于文件的开头。</td>
</tr>
<tr>
<td>eight</td>
<td>wb+</td>
<td>它以二进制格式打开文件进行读写。文件指针存在于文件的开头。</td>
</tr>
<tr>
<td>nine</td>
<td>a</td>
<td>它以追加模式打开文件。文件指针存在于先前写入的文件(如果存在)的末尾。如果不存在同名文件，它会创建一个新文件。</td>
</tr>
<tr>
<td>Ten</td>
<td>ab</td>
<td>它以二进制格式在追加模式下打开文件。指针存在于先前写入的文件的末尾。如果不存在同名文件，它会创建一个二进制格式的新文件。</td>
</tr>
<tr>
<td>Eleven</td>
<td>a+</td>
<td>它打开一个文件来附加和读取两者。如果文件存在，文件指针将保留在文件的末尾。如果不存在同名文件，它会创建一个新文件。</td>
</tr>
<tr>
<td>Twelve</td>
<td>ab+</td>
<td>它打开一个文件，以二进制格式追加和读取两者。文件指针保持在文件的末尾。</td>
</tr>
</tbody>
</table>
<p>让我们看一个简单的例子，以读取模式打开一个名为“file.txt”(存储在同一个目录中)的文件，并在控制台上打印其内容。</p>
<h2 id="例子-7">例子</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#opens the file file.txt in read mode  </span></span><br><span class="line">fileptr = <span class="built_in">open</span>(<span class="string">&quot;file.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> fileptr:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;file is opened successfully&quot;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;_io.TextIOWrapper&#x27;</span>&gt;</span><br><span class="line">file <span class="keyword">is</span> opened successfully</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们传递了<strong>文件名</strong>作为第一个参数，并以读取模式打开了文件，正如我们提到的 <strong>r</strong> 作为第二个参数。<strong>文件程序</strong>保存文件对象，如果文件打开成功，它将执行打印语句</p>
<h2 id="close-方法">close()方法</h2>
<p>一旦文件上的所有操作完成，我们必须使用 <strong>close()</strong> 方法通过 Python 脚本关闭它。一旦在文件对象上调用 <strong>close()</strong> 方法，任何未写的信息都会被销毁。</p>
<p>我们可以使用当前在 Python 中打开的文件系统在外部对文件执行任何操作；因此，最好在所有操作完成后关闭文件。</p>
<p>下面给出了使用 <strong>close()</strong> 方法的语法。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">fileobject.close() </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># opens the file file.txt in read mode  </span></span><br><span class="line">fileptr = <span class="built_in">open</span>(<span class="string">&quot;file.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> fileptr:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;file is opened successfully&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">#closes the opened file  </span></span><br><span class="line">fileptr.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>关闭文件后，我们无法在文件中执行任何操作。该文件需要正确关闭。如果在文件中执行某些操作时出现任何异常，程序将终止，而不会关闭文件。</p>
<p>我们应该用下面的方法来克服这类问题。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">   fileptr = <span class="built_in">open</span>(<span class="string">&quot;file.txt&quot;</span>)</span><br><span class="line">   <span class="comment"># perform file operations</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">   fileptr.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="with-语句">with 语句</h2>
<p>python 2.5 中引入了带有语句的**。with 语句在操作文件的情况下很有用。它用于一对语句之间要执行一段代码的场景。**</p>
<p>下面给出了使用和语句打开文件的语法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(&lt;file name&gt;, &lt;access mode&gt;) <span class="keyword">as</span> &lt;file-pointer&gt;:  </span><br><span class="line">    <span class="comment">#statement suite   </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用 with 语句的优点是，无论嵌套块如何退出，它都能保证关闭文件。</p>
<p>在文件的情况下总是建议使用<strong>和</strong>语句，因为如果中断、返回或异常发生在嵌套的代码块中，那么它会自动关闭文件，我们不需要编写 <strong>close()</strong> 函数。它不会让文件损坏。</p>
<p>考虑下面的例子。</p>
<h3 id="例子-8">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;file.txt&quot;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">    content = f.read();  </span><br><span class="line">    <span class="built_in">print</span>(content)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="正在写入文件">正在写入文件</h2>
<p>要向文件中写入一些文本，我们需要使用 open 方法以下列访问模式之一打开文件。</p>
<p><strong>w:</strong> 如果有文件存在，会覆盖文件。文件指针在文件的开头。</p>
<p><strong>a:</strong> 将追加已有文件。文件指针在文件的末尾。如果没有文件，它会创建一个新文件。</p>
<p>考虑下面的例子。</p>
<h3 id="例子-9">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># open the file.txt in append mode. Create a new file if no such file exists.</span></span><br><span class="line">fileptr = <span class="built_in">open</span>(<span class="string">&quot;file2.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># appending the content to the file</span></span><br><span class="line">fileptr.write(<span class="string">&#x27;&#x27;&#x27;Python is the modern day language. It makes things so simple.</span></span><br><span class="line"><span class="string">It is the fastest-growing programing language&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># closing the opened the file</span></span><br><span class="line">fileptr.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<p>File2.txt</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Python <span class="keyword">is</span> the modern-day language. It makes things so simple. It <span class="keyword">is</span> the fastest growing programming language.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>文件快照 2.txt</strong></p>
<p><img src="/img/8746120179208b4814be588cc221fcbd.png" alt="Python File Handling"></p>
<p>我们已经在 <strong>w</strong> 模式下打开了文件。<strong>文件 1.txt</strong> 文件不存在，它创建了一个新文件，我们已经使用 <strong>write()</strong> 函数在文件中写入了内容。</p>
<h3 id="例-2-11">例 2</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#open the file.txt in write mode.  </span></span><br><span class="line">fileptr = <span class="built_in">open</span>(<span class="string">&quot;file2.txt&quot;</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#overwriting the content of the file  </span></span><br><span class="line">fileptr.write(<span class="string">&quot; Python has an easy syntax and user-friendly interaction.&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">#closing the opened file   </span></span><br><span class="line">fileptr.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Python <span class="keyword">is</span> the modern day language. It makes things so simple.</span><br><span class="line">It <span class="keyword">is</span> the fastest growing programing language Python has an easy syntax <span class="keyword">and</span> user-friendly interaction.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>文件快照 2.txt</strong></p>
<p><img src="/img/9d825d5bd62cb15a83550d49521770b8.png" alt="Python File Handling"></p>
<p>我们可以看到文件的内容被修改了。我们已经在<strong>模式下打开了该文件，并在现有的</strong>文件 2.txt** 中添加了内容。**</p>
<p>**要使用 Python 脚本读取文件，Python 提供了 <strong>read()</strong> 方法。 <strong>read()</strong> 方法从文件中读取一个字符串。它可以读取文本和二进制格式的数据。</p>
<p><strong>read()</strong> 方法的语法如下。</p>
<p><strong>语法:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">fileobj.read(&lt;count&gt;)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，计数是从文件的开头开始要从文件中读取的字节数。如果没有指定计数，那么它可以读取文件的内容直到结束。</p>
<p>考虑下面的例子。</p>
<h3 id="例子-10">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#open the file.txt in read mode. causes error if no such file exists.  </span></span><br><span class="line">fileptr = <span class="built_in">open</span>(<span class="string">&quot;file2.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line"><span class="comment">#stores all the data of the file into the variable content  </span></span><br><span class="line">content = fileptr.read(<span class="number">10</span>) </span><br><span class="line"><span class="comment"># prints the type of the data stored in the file  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(content))    </span><br><span class="line"><span class="comment">#prints the content of the file  </span></span><br><span class="line"><span class="built_in">print</span>(content)     </span><br><span class="line"><span class="comment">#closes the opened file  </span></span><br><span class="line">fileptr.close()  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line">Python <span class="keyword">is</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们已经使用 <strong>read()</strong> 函数读取了<strong>文件 2.txt</strong> 的内容。我们将计数值传递为十，这意味着它将从文件中读取前十个字符。</p>
<p>如果我们使用下面一行，那么它将打印文件的所有内容。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">content = fileptr.read()</span><br><span class="line"><span class="built_in">print</span>(content) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Python <span class="keyword">is</span> the modern-day language. It makes things so simple.</span><br><span class="line">It <span class="keyword">is</span> the fastest-growing programing language Python has easy an syntax <span class="keyword">and</span> user-friendly interaction.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="循环读取文件">循环读取文件</h3>
<p>我们可以使用 <code>for</code>循环来读取文件。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#open the file.txt in read mode. causes an error if no such file exists.  </span></span><br><span class="line">fileptr = <span class="built_in">open</span>(<span class="string">&quot;file2.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);   </span><br><span class="line"><span class="comment">#running a for loop   </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> fileptr:  </span><br><span class="line">    <span class="built_in">print</span>(i) <span class="comment"># i contains each line of the file   </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Python <span class="keyword">is</span> the modern day language.</span><br><span class="line"></span><br><span class="line">It makes things so simple.</span><br><span class="line"></span><br><span class="line">Python has easy syntax <span class="keyword">and</span> user-friendly interaction.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="读取文件的行">读取文件的行</h2>
<p>Python 通过使用函数 <strong>readline()</strong> 方法来方便逐行读取文件。 <strong>readline()</strong> 方法从头开始读取文件的行，也就是说，如果我们使用 readline()方法两次，那么我们就可以得到文件的前两行。</p>
<p>考虑下面的例子，它包含一个函数 <strong>readline()</strong> ，该函数读取我们的文件**“file 2 . txt”**的第一行，该文件包含三行。考虑下面的例子。</p>
<h3 id="示例-1-使用-readline-函数读取行">示例 1:使用 readline()函数读取行</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#open the file.txt in read mode. causes error if no such file exists.  </span></span><br><span class="line">fileptr = <span class="built_in">open</span>(<span class="string">&quot;file2.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);   </span><br><span class="line"><span class="comment">#stores all the data of the file into the variable content  </span></span><br><span class="line">content = fileptr.readline()   </span><br><span class="line">content1 = fileptr.readline()</span><br><span class="line"><span class="comment">#prints the content of the file  </span></span><br><span class="line"><span class="built_in">print</span>(content)   </span><br><span class="line"><span class="built_in">print</span>(content1)</span><br><span class="line"><span class="comment">#closes the opened file  </span></span><br><span class="line">fileptr.close()  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Python <span class="keyword">is</span> the modern day language.</span><br><span class="line"></span><br><span class="line">It makes things so simple.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们两次调用了 <strong>readline()</strong> 函数，这就是它从文件中读取两行的原因。</p>
<p>Python 还提供了用于读取行的<strong>读取行()<strong>方法。它返回行的列表，直到到达</strong>文件(EOF)</strong> 的末尾。</p>
<h3 id="示例-2-使用-readlines-函数读取行">示例 2:使用 <code>readlines()</code>函数读取行</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#open the file.txt in read mode. causes error if no such file exists.  </span></span><br><span class="line">fileptr = <span class="built_in">open</span>(<span class="string">&quot;file2.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);   </span><br><span class="line"></span><br><span class="line"><span class="comment">#stores all the data of the file into the variable content  </span></span><br><span class="line">content = fileptr.readlines()   </span><br><span class="line"></span><br><span class="line"><span class="comment">#prints the content of the file  </span></span><br><span class="line"><span class="built_in">print</span>(content)   </span><br><span class="line"></span><br><span class="line"><span class="comment">#closes the opened file  </span></span><br><span class="line">fileptr.close()  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;Python is the modern day language.\n&#x27;</span>, <span class="string">&#x27;It makes things so simple.\n&#x27;</span>, <span class="string">&#x27;Python has easy syntax and user-friendly interaction.&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="创建新文件">创建新文件</h2>
<p>在函数 open()的情况下，可以使用以下访问模式之一创建新文件。</p>
<p><strong>x:</strong> 它用指定的名称创建一个新文件。如果存在同名文件，则会导致错误。</p>
<p><strong>a:</strong> 如果不存在指定名称的文件，则创建该文件。如果具有指定名称的文件已经存在，它会将内容追加到文件中。</p>
<p><strong>w:</strong> 如果不存在指定名称的文件，它会创建一个新文件。它会覆盖现有文件。</p>
<p>考虑下面的例子。</p>
<h3 id="例-1-13">例 1</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#open the file.txt in read mode. causes error if no such file exists.  </span></span><br><span class="line">fileptr = <span class="built_in">open</span>(<span class="string">&quot;file2.txt&quot;</span>,<span class="string">&quot;x&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(fileptr)  </span><br><span class="line"><span class="keyword">if</span> fileptr:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;File created successfully&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;_io.TextIOWrapper name=<span class="string">&#x27;file2.txt&#x27;</span> mode=<span class="string">&#x27;x&#x27;</span> encoding=<span class="string">&#x27;cp1252&#x27;</span>&gt;</span><br><span class="line">File created successfully </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="文件指针位置">文件指针位置</h2>
<p>Python 提供了 tell()方法，用于打印文件指针当前所在的字节数。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># open the file file2.txt in read mode  </span></span><br><span class="line">fileptr = <span class="built_in">open</span>(<span class="string">&quot;file2.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">#initially the filepointer is at 0   </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The filepointer is at byte :&quot;</span>,fileptr.tell())  </span><br><span class="line"></span><br><span class="line"><span class="comment">#reading the content of the file  </span></span><br><span class="line">content = fileptr.read();  </span><br><span class="line"></span><br><span class="line"><span class="comment">#after the read operation file pointer modifies. tell() returns the location of the fileptr.   </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;After reading, the filepointer is at:&quot;</span>,fileptr.tell())  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The filepointer <span class="keyword">is</span> at byte : <span class="number">0</span></span><br><span class="line">After reading, the filepointer <span class="keyword">is</span> at: <span class="number">117</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="修改文件指针位置">修改文件指针位置</h2>
<p>在现实应用中，有时我们需要从外部更改文件指针位置，因为我们可能需要在不同的位置读取或写入内容。</p>
<p>为此，Python 为我们提供了 <code>seek()</code>方法，使我们能够在外部修改文件指针的位置。</p>
<p>下面给出了使用 <code>seek()</code>方法的语法。</p>
<p><strong>语法:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;file-ptr&gt;.seek(offset[, <span class="keyword">from</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>seek()</code>方法接受两个参数:</p>
<p>**偏移量:**指文件指针在文件内的新位置。</p>
<p><strong>from:</strong> 表示字节移动的参考位置。如果设置为 0，文件的开头将用作参考位置。如果设置为 1，文件指针的当前位置将用作参考位置。如果设置为 2，文件指针的末端将用作参考位置。</p>
<p>考虑下面的例子。</p>
<h3 id="例子-11">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># open the file file2.txt in read mode  </span></span><br><span class="line">fileptr = <span class="built_in">open</span>(<span class="string">&quot;file2.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">#initially the filepointer is at 0   </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The filepointer is at byte :&quot;</span>,fileptr.tell())  </span><br><span class="line"></span><br><span class="line"><span class="comment">#changing the file pointer location to 10\.  </span></span><br><span class="line">fileptr.seek(<span class="number">10</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">#tell() returns the location of the fileptr.   </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;After reading, the filepointer is at:&quot;</span>,fileptr.tell())  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The filepointer <span class="keyword">is</span> at byte : <span class="number">0</span></span><br><span class="line">After reading, the filepointer <span class="keyword">is</span> at: <span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Python-os模块">Python <code>os</code>模块</h2>
<h3 id="重命名文件">重命名文件</h3>
<p>Python <strong>os</strong> 模块支持与操作系统的交互。os 模块提供文件处理操作中涉及的功能，如重命名、删除等。它为我们提供了 rename()方法，将指定的文件重命名为新名称。下面给出了使用**重命名()**方法的语法。</p>
<p><strong>语法:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">rename(current-name, new-name)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第一个参数是当前文件名，第二个参数是修改后的名称。我们可以绕过这两个参数来更改文件名。</p>
<p><strong>例 1:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os  </span><br><span class="line"></span><br><span class="line"><span class="comment">#rename file2.txt to file3.txt  </span></span><br><span class="line">os.rename(<span class="string">&quot;file2.txt&quot;</span>,<span class="string">&quot;file3.txt&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<p>以上代码将当前<strong>文件 2.txt</strong> 重命名为<strong>文件 3.txt</strong></p>
<h3 id="正在删除文件">正在删除文件</h3>
<p>os 模块提供 <strong>remove()</strong> 方法，用于删除指定的文件。下面给出了使用 <strong>remove()</strong> 方法的语法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">remove(file-name) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例 1</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os;  </span><br><span class="line"><span class="comment">#deleting the file named file3.txt   </span></span><br><span class="line">os.remove(<span class="string">&quot;file3.txt&quot;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="创建新目录">创建新目录</h2>
<p><strong>mkdir()</strong> 方法用于创建当前工作目录中的目录。下面给出了创建新目录的语法。</p>
<p><strong>语法:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">mkdir(directory name)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例 1</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os  </span><br><span class="line"></span><br><span class="line"><span class="comment">#creating a new directory with the name new  </span></span><br><span class="line">os.mkdir(<span class="string">&quot;new&quot;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="getcwd-方法">getcwd()方法</h2>
<p>此方法返回当前工作目录。</p>
<p>下面给出了使用 getcwd()方法的语法。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">os.getcwd()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.getcwd()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;C:\\Users\\DEVANSH SHARMA&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="更改当前工作目录">更改当前工作目录</h2>
<p>chdir()方法用于将当前工作目录更改为指定目录。</p>
<p>下面给出了使用 chdir()方法的语法。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">chdir(<span class="string">&quot;new-directory&quot;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例子-12">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="comment"># Changing current directory with the new directiory</span></span><br><span class="line">os.chdir(<span class="string">&quot;C:\\Users\\DEVANSH SHARMA\\Documents&quot;</span>)</span><br><span class="line"><span class="comment">#It will display the current working directory</span></span><br><span class="line">os.getcwd()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;C:\\Users\\DEVANSH SHARMA\\Documents&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="正在删除目录">正在删除目录</h2>
<p>rmdir()方法用于删除指定的目录。</p>
<p>下面给出了使用 rmdir()方法的语法。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">os.rmdir(directory name)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例 1</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment">#removing the new directory   </span></span><br><span class="line">os.rmdir(<span class="string">&quot;directory_name&quot;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它将删除指定的目录。</p>
<h2 id="将-Python-输出写入文件">将 Python 输出写入文件</h2>
<p>在 Python 中，需要将 Python 脚本的输出写入文件。</p>
<p>模块<strong>子流程</strong>的 <strong>check_call()</strong> 方法用于执行 Python 脚本，并将该脚本的输出写入文件。</p>
<p>以下示例包含两个 python 脚本。脚本文件 <a href="http://1.py">1.py</a> 执行脚本文件. py，并将其输出写入文本文件 <strong>output.txt.</strong></p>
<p><strong>例</strong></p>
<p><strong><a href="http://file.py">file.py</a></strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">temperatures=[<span class="number">10</span>,-<span class="number">20</span>,-<span class="number">289</span>,<span class="number">100</span>]  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">c_to_f</span>(<span class="params">c</span>):  </span><br><span class="line">    <span class="keyword">if</span> c&lt; -<span class="number">273.15</span>:  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;That temperature doesn&#x27;t make sense!&quot;</span>  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        f=c*<span class="number">9</span>/<span class="number">5</span>+<span class="number">32</span>  </span><br><span class="line">        <span class="keyword">return</span> f  </span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> temperatures:  </span><br><span class="line">    <span class="built_in">print</span>(c_to_f(t))  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong><a href="http://file.py">file.py</a></strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess  </span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">    subprocess.check_call([<span class="string">&quot;python&quot;</span>, <span class="string">&quot;file.py&quot;</span>], stdout=f)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="文件相关方法">文件相关方法</h2>
<p>文件对象提供以下方法来操作各种操作系统上的文件。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>one</td>
<td>file.close()</td>
<td>它关闭打开的文件。文件一旦关闭，就不能再读写了。</td>
</tr>
<tr>
<td>Two</td>
<td>File.flush()</td>
<td>它会刷新内部缓冲区。</td>
</tr>
<tr>
<td>three</td>
<td>File.fileno（）</td>
<td>它返回底层实现用来向操作系统请求输入/输出的文件描述符。</td>
</tr>
<tr>
<td>four</td>
<td>File.isatty()</td>
<td>如果文件连接到 TTY 设备，则返回 true，否则返回 false。</td>
</tr>
<tr>
<td>five</td>
<td>File.next()</td>
<td>它返回文件的下一行。</td>
</tr>
<tr>
<td>six</td>
<td>file.read([size])</td>
<td>它读取指定大小的文件。</td>
</tr>
<tr>
<td>seven</td>
<td>file.readline([size])</td>
<td>它从文件中读取一行，并将文件指针放在新行的开头。</td>
</tr>
<tr>
<td>eight</td>
<td>file.readline([sizehint])</td>
<td>它返回一个包含文件所有行的列表。它使用 readline()函数读取文件，直到发生 EOF。</td>
</tr>
<tr>
<td>nine</td>
<td>File.seek(offset[，from)</td>
<td>它将文件指针的位置修改为具有指定引用的指定偏移量。</td>
</tr>
<tr>
<td>Ten</td>
<td>File.tell()</td>
<td>它返回文件指针在文件中的当前位置。</td>
</tr>
<tr>
<td>Eleven</td>
<td>file.truncate([size])</td>
<td>它会将文件截断到可选的指定大小。</td>
</tr>
<tr>
<td>Twelve</td>
<td>File.write(str)</td>
<td>它将指定的字符串写入文件</td>
</tr>
<tr>
<td>Thirteen</td>
<td>File.writelines(seq)</td>
<td>它将一系列字符串写入文件。</td>
</tr>
</tbody>
</table>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 数组</title>
    <url>/posts/3f108209.html</url>
    <content><![CDATA[<h1>Python 数组</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-arrays">https://www.javatpoint.com/python-arrays</a></p>
</blockquote>
<p>数组被定义为存储在连续内存位置的项的集合。它是一个可以容纳固定数量物品的容器，这些物品应该是同一类型的。数组在大多数编程语言中很流行，比如 C/C++、JavaScript 等。</p>
<p>数组是一种将多个相同类型的项存储在一起的思想，通过简单地在基值上添加一个偏移量，可以更容易地计算每个元素的位置。数组的组合可以通过减少代码的整体大小来节省大量时间。它用于在单个变量中存储多个值。如果您有一个存储在相应变量中的项目列表，如下所示:</p>
<p>car1 = “Lamborghini”</p>
<p>car2 = “bugatti”</p>
<p>car3 = &quot;Koenigsegg &quot;</p>
<p>如果你想在汽车中循环并找到一个特定的，你可以使用数组。</p>
<p>数组可以用 Python 通过一个名为<strong>数组</strong>的模块来处理。当我们只需要操作特定的数据值时，这是非常有用的。以下是理解数组概念的术语:</p>
<p><strong>Element</strong> -存储在数组中的每个项目称为一个元素。</p>
<p><strong>Index</strong> -数组中元素的位置有一个数字索引，用来标识元素的位置。</p>
<h2 id="数组表示">数组表示</h2>
<p>数组可以用不同的方式和不同的语言来声明。应该考虑的要点如下:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>索引从 0 开始。</p>
</li>
<li class="lvl-4">
<p>我们可以通过索引访问每个元素。</p>
</li>
<li class="lvl-4">
<p>数组的长度定义了存储元素的容量。</p>
</li>
</ul>
<h2 id="数组操作">数组操作</h2>
<p>阵列支持的一些基本操作如下:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>遍历</strong> -它会逐个打印所有元素。</p>
</li>
<li class="lvl-4">
<p><strong>插入</strong> -它在给定的索引处添加一个元素。</p>
</li>
<li class="lvl-4">
<p><strong>删除</strong> -删除给定索引处的元素。</p>
</li>
<li class="lvl-4">
<p><strong>搜索</strong> -它使用给定的索引或按值搜索元素。</p>
</li>
<li class="lvl-4">
<p><strong>更新</strong> -它更新给定索引处的元素。</p>
</li>
</ul>
<p>通过将数组模块导入 python 程序，可以在 Python 中创建数组。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> *</span><br><span class="line">arrayName = array(typecode, [initializers]) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>访问数组元素</strong></p>
<p>我们可以使用数组元素各自的索引来访问这些元素。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> array <span class="keyword">as</span> arr</span><br><span class="line">a = arr.array(<span class="string">&#x27;i&#x27;</span>, [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;First element:&quot;</span>, a[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Second element:&quot;</span>, a[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Second last element:&quot;</span>, a[-<span class="number">1</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">First element: <span class="number">2</span></span><br><span class="line">Second element: <span class="number">4</span></span><br><span class="line">Second last element: <span class="number">8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>**说明:**在上面的例子中，我们导入了一个数组，定义了一个名为“a”的变量，该变量保存数组的元素，并通过数组的索引访问元素来打印元素。</p>
<h2 id="如何更改或添加元素">如何更改或添加元素</h2>
<p>数组是可变的，它们的元素可以像列表一样以类似的方式改变。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> array <span class="keyword">as</span> arr</span><br><span class="line">numbers = arr.array(<span class="string">&#x27;i&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># changing first element</span></span><br><span class="line">numbers[<span class="number">0</span>] = <span class="number">0</span>   </span><br><span class="line"><span class="built_in">print</span>(numbers)    <span class="comment"># Output: array(&#x27;i&#x27;, [0, 2, 3, 5, 7, 10])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># changing 3rd to 5th element</span></span><br><span class="line">numbers[<span class="number">2</span>:<span class="number">5</span>] = arr.array(<span class="string">&#x27;i&#x27;</span>, [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>])  </span><br><span class="line"><span class="built_in">print</span>(numbers)    <span class="comment"># Output: array(&#x27;i&#x27;, [0, 2, 4, 6, 8, 10])</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">array(<span class="string">&#x27;i&#x27;</span>, [<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">10</span>])</span><br><span class="line">array(<span class="string">&#x27;i&#x27;</span> ,[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>**说明:**在上面的例子中，我们导入了一个数组，并定义了一个名为“numbers”的变量来保存数组的值。如果我们想更改或添加数组中的元素，我们可以通过定义要更改或添加元素的数组的特定索引来实现。</p>
<h2 id="为什么要在-Python-中使用数组？">为什么要在 Python 中使用数组？</h2>
<p>数组的组合节省了大量时间。数组可以减少代码的整体大小。</p>
<h2 id="如何从数组中删除元素？">如何从数组中删除元素？</h2>
<p>可以使用 Python 的 <strong>del</strong> 语句从数组中删除元素。如果我们想从数组中删除任何值，我们可以通过使用特定元素的索引来实现。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> array <span class="keyword">as</span> arr</span><br><span class="line">number = arr.array(<span class="string">&#x27;i&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="keyword">del</span> number[<span class="number">2</span>]                           <span class="comment"># removing third element</span></span><br><span class="line"><span class="built_in">print</span>(number)                           <span class="comment"># Output: array(&#x27;i&#x27;, [1, 2, 3, 4])</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">array(<span class="string">&#x27;i&#x27;</span>, [<span class="number">10</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">60</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>**说明:**在上面的例子中，我们导入了一个数组，并定义了一个名为“number”的变量来存储数组的值。这里，通过使用 <code>del</code>语句，我们移除了给定数组的第三个元素[3]。</p>
<h2 id="求数组的长度">求数组的长度</h2>
<p>数组的长度定义为数组中存在的元素数量。它返回一个整数值，该整数值等于该数组中存在的元素总数。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">len</span>(array_name)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="数组连接">数组连接</h2>
<p>我们可以使用+符号轻松连接任意两个数组。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a=arr.array(<span class="string">&#x27;d&#x27;</span>,[<span class="number">1.1</span> , <span class="number">2.1</span> ,<span class="number">3.1</span>,<span class="number">2.6</span>,<span class="number">7.8</span>])</span><br><span class="line">b=arr.array(<span class="string">&#x27;d&#x27;</span>,[<span class="number">3.7</span>,<span class="number">8.6</span>])</span><br><span class="line">c=arr.array(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">c=a+b</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Array c = &quot;</span>,c)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Array c= array(<span class="string">&#x27;d&#x27;</span>, [<span class="number">1.1</span>, <span class="number">2.1</span>, <span class="number">3.1</span>, <span class="number">2.6</span>, <span class="number">7.8</span>, <span class="number">3.7</span>, <span class="number">8.6</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>解释</strong></p>
<p>在上面的例子中，我们定义了名为“a，b，c”的变量来保存数组的值。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> array <span class="keyword">as</span> arr</span><br><span class="line">x = arr.array(<span class="string">&#x27;i&#x27;</span>, [<span class="number">4</span>, <span class="number">7</span>, <span class="number">19</span>, <span class="number">22</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;First element:&quot;</span>, x[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Second element:&quot;</span>, x[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Second last element:&quot;</span>, x[-<span class="number">1</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">First element: <span class="number">4</span></span><br><span class="line">Second element: <span class="number">7</span></span><br><span class="line">Second last element: <span class="number">22</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>**说明:**在上面的例子中，首先，我们导入了一个数组，并定义了一个名为“x”的变量，该变量保存了一个数组的值，然后，我们使用数组的索引打印了元素。</p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 日期和时间</title>
    <url>/posts/f7e311b4.html</url>
    <content><![CDATA[<h1>Python 日期和时间</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-date">https://www.javatpoint.com/python-date</a></p>
</blockquote>
<p>Python 为<strong>日期时间</strong>模块提供了真实的日期和时间。在现实应用中，我们需要处理日期和时间。Python 使我们能够安排我们的 Python 脚本在特定的时间运行。</p>
<p>在 Python 中，日期不是数据类型，但是我们可以通过导入以<strong>日期时间、时间和日历</strong>命名的模块来处理日期对象。</p>
<p>在教程的这一部分，我们将讨论如何在 Python 中使用日期和时间对象。</p>
<p><strong>日期时间</strong>类别分为六个主要类别。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>date</strong> -它由年、月和日作为属性组成。</p>
</li>
<li class="lvl-4">
<p><strong>time</strong> -这是一个完美的时间，假设每天都有精确的 24<em>60</em>60 秒。它有小时、分钟、秒、微秒和 <strong>tzinfo</strong> 属性。</p>
</li>
<li class="lvl-4">
<p><strong>datetime</strong> -它是日期和时间的分组，以及年、月、日、小时、分钟、秒、微秒和 tzinfo 属性。</p>
</li>
<li class="lvl-4">
<p><strong>timedelta-</strong> 它表示两个日期、时间或日期时间实例到微秒分辨率之间的差异。</p>
</li>
<li class="lvl-4">
<p><strong>tzinfo</strong> -提供时区信息对象。</p>
</li>
<li class="lvl-4">
<p><strong>datetime-</strong> 包含在新版 Python 中。它是实现 <strong>tzinfo</strong> 抽象基类的类。</p>
</li>
</ul>
<h2 id="滴答声">滴答声</h2>
<p>在 Python 中，时间瞬间是从 1970 年 1 月 1 日上午 12 点开始计算的。模块时间的函数 <strong>time()</strong> 返回自 1970 年 1 月 1 日上午 12 点以来花费的滴答总数。刻度可以看作是测量时间的最小单位。</p>
<p>考虑以下示例</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time;</span><br><span class="line"><span class="comment">#prints the number of ticks spent since 12 AM, 1st January 1970</span></span><br><span class="line"><span class="built_in">print</span>(time.time())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1585928913.6519969</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="如何获取当前时间？">如何获取当前时间？</h2>
<p>时间模块的 localtime()函数用于获取当前的时间元组。考虑下面的例子。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time;  </span><br><span class="line"></span><br><span class="line"><span class="comment">#returns a time tuple   </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(time.localtime(time.time()))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">time.struct_time(tm_year=<span class="number">2020</span>, tm_mon=<span class="number">4</span>, tm_mday=<span class="number">3</span>, tm_hour=<span class="number">21</span>, tm_min=<span class="number">21</span>, tm_sec=<span class="number">40</span>, tm_wday=<span class="number">4</span>, tm_yday=<span class="number">94</span>, tm_isdst=<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="时间元组">时间元组</h2>
<p>时间被视为 9 个数字的元组。让我们看看时间元组的成员。</p>
<p><img src="/img/WX20230718-161550@2x.png" alt="Python时间元组"></p>
<h2 id="获取格式化时间">获取格式化时间</h2>
<p>可以使用时间模块的 <strong>asctime()</strong> 功能格式化时间。它返回正在传递的时间元组的格式化时间。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time  </span><br><span class="line">  <span class="comment">#returns the formatted time    </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(time.asctime(time.localtime(time.time())))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Tue Dec <span class="number">18</span> <span class="number">15</span>:<span class="number">31</span>:<span class="number">39</span> <span class="number">2018</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Python-睡眠时间">Python 睡眠时间</h2>
<p>时间模块的 <strong>sleep()</strong> 方法用于在给定的时间内停止脚本的执行。输出将延迟作为浮点提供的秒数。</p>
<p>考虑下面的例子。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="comment">#Each element will be printed after 1 second</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="日期时间模块">日期时间模块</h2>
<p><strong>日期时间</strong>模块使我们能够创建自定义日期对象，对日期执行各种操作，如比较等。</p>
<p>要使用日期作为日期对象，我们必须将<strong>datetime</strong>模块导入 python 源代码。</p>
<p>考虑以下示例来获取当前时间的<strong>日期时间</strong>对象表示。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="comment">#returns the current datetime object   </span></span><br><span class="line"><span class="built_in">print</span>(datetime.datetime.now())  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span>-04-04 <span class="number">13</span>:<span class="number">18</span>:<span class="number">35.252578</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="创建日期对象">创建日期对象</h2>
<p>我们可以在日期时间构造器中绕过需要创建日期对象的日期来创建日期对象。</p>
<p>考虑下面的例子。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime  </span><br><span class="line"><span class="comment">#returns the datetime object for the specified date  </span></span><br><span class="line"><span class="built_in">print</span>(datetime.datetime(<span class="number">2020</span>,04,04))  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span>-04-04 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们还可以指定创建 datetime 对象的时间和日期。考虑下面的例子。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment">#returns the datetime object for the specified time    </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(datetime.datetime(<span class="number">2020</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">26</span>,<span class="number">40</span>))  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span>-04-04 01:<span class="number">26</span>:<span class="number">40</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们以顺序的方式传入了 <strong>datetime()</strong> 函数年、月、日、小时、分钟和毫秒属性。</p>
<h2 id="两个日期的比较">两个日期的比较</h2>
<p>我们可以使用比较运算符如&gt;、&gt; =、</p>
<p>考虑下面的例子。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime <span class="keyword">as</span> dt  </span><br><span class="line"><span class="comment">#Compares the time. If the time is in between 8AM and 4PM, then it prints working hours otherwise it prints fun hours  </span></span><br><span class="line"><span class="keyword">if</span> dt(dt.now().year,dt.now().month,dt.now().day,<span class="number">8</span>)&lt;dt.now()&lt;dt(dt.now().year,dt.now().month,dt.now().day,<span class="number">16</span>):  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Working hours....&quot;</span>)  </span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;fun hours&quot;</span>) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">fun hours</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="日历模块">日历模块</h2>
<p>Python 提供了一个日历对象，其中包含各种使用日历的方法。</p>
<p>考虑以下示例来打印 2018 年最后一个月的日历。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> calendar;  </span><br><span class="line">cal = calendar.month(<span class="number">2020</span>,<span class="number">3</span>)  </span><br><span class="line"><span class="comment">#printing the calendar of December 2018  </span></span><br><span class="line"><span class="built_in">print</span>(cal)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">March <span class="number">2020</span></span><br><span class="line">Mo Tu We Th Fr Sa Su</span><br><span class="line">                   <span class="number">1</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></span><br><span class="line"> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span></span><br><span class="line"><span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span> <span class="number">21</span> <span class="number">22</span></span><br><span class="line"><span class="number">23</span> <span class="number">24</span> <span class="number">25</span> <span class="number">26</span> <span class="number">27</span> <span class="number">28</span> <span class="number">29</span></span><br><span class="line"><span class="number">30</span> <span class="number">31</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="打印全年日历">打印全年日历</h2>
<p>日历模块的 prcal()方法用于打印全年的日历。要打印日历的年份必须传递到此方法中。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> calendar  </span><br><span class="line"><span class="comment">#printing the calendar of the year 2019  </span></span><br><span class="line">s = calendar.prcal(<span class="number">2020</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<p><img src="/img/dad88516687d0ffd2db69d6126f4b657.png" alt="Python Date and time"></p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 栈和队列</title>
    <url>/posts/fcfa0d23.html</url>
    <content><![CDATA[<h1>Python 栈和队列</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-stack-and-queue">https://www.javatpoint.com/python-stack-and-queue</a></p>
</blockquote>
<p>数据结构组织计算机中的存储，以便我们可以轻松地访问和更改数据。栈和队列是计算机科学中最早定义的数据结构。一个简单的 Python 列表也可以充当队列和栈。队列遵循先进先出规则，用于编程排序。栈和队列通常用数组或链表来实现。</p>
<h2 id="堆">堆</h2>
<p>栈是遵循后进先出原则的数据结构。要实现栈，我们需要两个简单的操作:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>push -</strong> 它在栈顶增加一个元素。</p>
</li>
<li class="lvl-4">
<p><strong>pop -</strong> 它从栈顶部移除一个元素。</p>
</li>
</ul>
<p><img src="/img/c9a5e014de2c318eb07a1be9a5e1aad1.png" alt="Python Stack and Queue"><br>
<img src="/img/9999d88be401c76225c1afa90d8a539b.png" alt="Python Stack and Queue"></p>
<p><strong>操作:</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>添加-</strong> 增加栈中的项目，增加栈大小。加法发生在栈的顶部。</p>
</li>
<li class="lvl-4">
<p><strong>删除-</strong> 它由两个条件组成，第一，如果栈中没有元素，那么栈中会发生下溢，第二，如果栈包含一些元素，那么最顶层的元素会被移除。它减小了栈大小。</p>
</li>
<li class="lvl-4">
<p><strong>遍历-</strong> 它涉及访问栈的每个元素。</p>
</li>
</ul>
<p><strong>特征:</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>栈的插入顺序被保留。</p>
</li>
<li class="lvl-4">
<p>对解析操作很有用。</p>
</li>
<li class="lvl-4">
<p>允许双重。</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Code to demonstrate Implementation of </span></span><br><span class="line"><span class="comment"># stack using list </span></span><br><span class="line">x = [<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;Android&quot;</span>] </span><br><span class="line">x.push(<span class="string">&quot;Java&quot;</span>) </span><br><span class="line">x.push(<span class="string">&quot;C++&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(x) </span><br><span class="line"><span class="built_in">print</span>(x.pop()) </span><br><span class="line"><span class="built_in">print</span>(x) </span><br><span class="line"><span class="built_in">print</span>(x.pop()) </span><br><span class="line"><span class="built_in">print</span>(x) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;Android&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;C++&#x27;</span>]</span><br><span class="line">C++</span><br><span class="line">[<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;Android&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>]</span><br><span class="line">Java</span><br><span class="line">[<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;Android&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="长队">长队</h2>
<p>队列遵循先进先出原则。它是从两端打开的，因此我们可以很容易地在后面添加元素，也可以从前面移除元素。</p>
<p>为了实现队列，我们需要两个简单的操作:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>入队-</strong> 它在队列末尾添加一个元素。</p>
</li>
<li class="lvl-4">
<p><strong>出列-</strong> 它从队列的开头移除元素。</p>
</li>
</ul>
<p><img src="/img/abeb66cf570ae556cbf354b900476da3.png" alt="Python Stack and Queue"><br>
<img src="/img/c61e6e42c53b0a070c8cb7478428f4d2.png" alt="Python Stack and Queue"></p>
<p><strong>队列上的操作</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>加法-</strong> 它将队列中的元素相加，并发生在后端，即队列的后面。</p>
</li>
<li class="lvl-4">
<p><strong>删除-</strong> 它由两个条件组成——如果队列中没有元素，则队列中出现下溢，或者如果栈包含一些元素，则位于前面的元素被删除。</p>
</li>
<li class="lvl-4">
<p><strong>遍历-</strong> 它包括访问队列的每个元素。</p>
</li>
</ul>
<p><strong>特征</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>队列的插入顺序被保留。</p>
</li>
<li class="lvl-4">
<p>允许双重。</p>
</li>
<li class="lvl-4">
<p>对解析 CPU 任务操作很有用。</p>
</li>
</ul>
<h4 id="注意-队列的实现有点不一样。队列遵循“先进先出”。时间在这里起着重要的作用。栈很快，因为我们从列表的末尾插入和弹出元素，而在队列中，插入和弹出是从列表的开头开始的，所以它变得很慢。这种时间差的原因是由于列表的属性，列表在结束操作时很快，但在开始操作时很慢，因为所有其他元素都必须一个接一个地移动。">注意:队列的实现有点不一样。队列遵循“先进先出”。时间在这里起着重要的作用。栈很快，因为我们从列表的末尾插入和弹出元素，而在队列中，插入和弹出是从列表的开头开始的，所以它变得很慢。这种时间差的原因是由于列表的属性，列表在结束操作时很快，但在开始操作时很慢，因为所有其他元素都必须一个接一个地移动。</h4>
<h3 id="密码">密码</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> queue </span><br><span class="line"><span class="comment"># Queue is created as an object &#x27;L&#x27;</span></span><br><span class="line">L = queue.Queue(maxsize=<span class="number">10</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Data is inserted in &#x27;L&#x27; at the end using put() </span></span><br><span class="line">L.put(<span class="number">9</span>) </span><br><span class="line">L.put(<span class="number">6</span>) </span><br><span class="line">L.put(<span class="number">7</span>) </span><br><span class="line">L.put(<span class="number">4</span>) </span><br><span class="line"><span class="comment"># get() takes data from </span></span><br><span class="line"><span class="comment"># from the head  </span></span><br><span class="line"><span class="comment"># of the Queue </span></span><br><span class="line"><span class="built_in">print</span>(L.get()) </span><br><span class="line"><span class="built_in">print</span>(L.get()) </span><br><span class="line"><span class="built_in">print</span>(L.get()) </span><br><span class="line"><span class="built_in">print</span>(L.get()) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 模块</title>
    <url>/posts/cae0d850.html</url>
    <content><![CDATA[<h1>Python 模块</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-modules">https://www.javatpoint.com/python-modules</a></p>
</blockquote>
<p>python 模块可以定义为 python 程序文件，其中包含 python 代码，包括 python 函数、类或变量。换句话说，我们可以说我们的 python 代码文件以扩展名(。py)被视为模块。我们可能在 python 模块中有一个可运行的代码。</p>
<p>Python 中的模块为我们提供了以逻辑方式组织代码的灵活性。</p>
<p>要将一个模块的功能用于另一个模块，我们必须导入特定的模块。</p>
<h2 id="例子-13">例子</h2>
<p>在这个例子中，我们将创建一个名为 <a href="http://file.py">file.py</a> 的模块，它包含一个函数 func，该函数 func 包含在控制台上打印一些消息的代码。</p>
<p>让我们创建名为 <strong><a href="http://file.py">file.py</a>.</strong> 的模块</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#displayMsg prints a message to the name being passed. </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">displayMsg</span>(<span class="params">name</span>)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;Hi &quot;</span>+name);  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，我们需要将这个模块包含到我们的主模块中，以调用在名为 file 的模块中定义的 displayMsg()方法。</p>
<h2 id="在-python-代码中加载模块">在 python 代码中加载模块</h2>
<p>我们需要在 python 代码中加载该模块来使用它的功能。Python 提供了两种类型的语句，定义如下。</p>
<ol>
<li class="lvl-4">
<p>进口声明</p>
</li>
<li class="lvl-4">
<p>自导入语句</p>
</li>
</ol>
<h2 id="进口声明">进口声明</h2>
<p>import 语句用于将一个模块的所有功能导入到另一个模块中。在这里，我们必须注意到，我们可以通过将任何 python 源文件作为模块导入另一个 python 源文件来使用该文件的功能。</p>
<p>我们可以用一个 import 语句导入多个模块，但是一个模块被加载一次，无论加载多少次，它都已经被导入到我们的文件中。</p>
<p>下面给出了使用 import 语句的语法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> module1,module2,........ module n</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因此，如果我们需要调用 <a href="http://file.py">file.py</a> 中定义的函数 displayMsg()，我们必须将该文件作为一个模块导入到我们的模块中，如下例所示。</p>
<h2 id="示例-2">示例:</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> file;</span><br><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;Enter the name?&quot;</span>)</span><br><span class="line">file.displayMsg(name)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the name?John</span><br><span class="line">Hi John</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="自导入语句">自导入语句</h2>
<p>python 提供了仅导入模块特定属性的灵活性，而不是将整个模块导入命名空间。这可以通过使用 from？导入语句。下面给出了使用 from-import 语句的语法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> &lt; module-name&gt; <span class="keyword">import</span> &lt;name <span class="number">1</span>&gt;, &lt;name <span class="number">2</span>&gt;..,&lt;name n&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>考虑以下名为计算的模块，它包含求和、乘法和除法三个函数。</p>
<p><strong>计算. py:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#place the code in the calculation.py </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">summation</span>(<span class="params">a,b</span>):</span><br><span class="line">	<span class="keyword">return</span> a+b</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multiplication</span>(<span class="params">a,b</span>):</span><br><span class="line">	<span class="keyword">return</span> a*b;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">a,b</span>):</span><br><span class="line">	<span class="keyword">return</span> a/b;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong><a href="http://Main.py">Main.py</a>:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> calculation <span class="keyword">import</span> summation  </span><br><span class="line"><span class="comment">#it will import only the summation() from calculation.py</span></span><br><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the first number&quot;</span>))</span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the second number&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sum = &quot;</span>,summation(a,b)) <span class="comment">#we do not need to specify the module name while accessing summation()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the first number10</span><br><span class="line">Enter the second number20</span><br><span class="line">Sum =  <span class="number">30</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>来自…如果我们事先知道要从模块中导入的属性，那么使用 import 语句总是更好。它不会让我们的代码变得更重。我们还可以使用*从模块中导入所有属性。</p>
<p>请考虑以下语法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> &lt;module&gt; <span class="keyword">import</span> * </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="重命名模块">重命名模块</h2>
<p>Python 为我们提供了导入具有特定名称的模块的灵活性，这样我们就可以在 python 源文件中使用这个名称来使用那个模块。</p>
<p>重命名模块的语法如下。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;module-name&gt; <span class="keyword">as</span> &lt;specific-name&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="例子-14">例子</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#the module calculation of previous example is imported in this example as cal. </span></span><br><span class="line"><span class="keyword">import</span> calculation <span class="keyword">as</span> cal;</span><br><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter a?&quot;</span>));</span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter b?&quot;</span>));</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sum = &quot;</span>,cal.summation(a,b))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter a?<span class="number">10</span></span><br><span class="line">Enter b?<span class="number">20</span></span><br><span class="line">Sum =  <span class="number">30</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="使用-dir-函数">使用 dir()函数</h2>
<p>dir()函数返回在传递的模块中定义的名称的排序列表。该列表包含该模块中定义的所有子模块、变量和函数。</p>
<p>考虑下面的例子。</p>
<h2 id="例子-15">例子</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="type">List</span> = <span class="built_in">dir</span>(json)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="type">List</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;JSONDecoder&#x27;</span>, <span class="string">&#x27;JSONEncoder&#x27;</span>, <span class="string">&#x27;__all__&#x27;</span>, <span class="string">&#x27;__author__&#x27;</span>, <span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;__cached__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;__file__&#x27;</span>, <span class="string">&#x27;__loader__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;__path__&#x27;</span>, <span class="string">&#x27;__spec__&#x27;</span>, <span class="string">&#x27;__version__&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;_default_decoder&#x27;</span>, <span class="string">&#x27;_default_encoder&#x27;</span>, <span class="string">&#x27;decoder&#x27;</span>, <span class="string">&#x27;dump&#x27;</span>, <span class="string">&#x27;dumps&#x27;</span>, <span class="string">&#x27;encoder&#x27;</span>, <span class="string">&#x27;load&#x27;</span>, <span class="string">&#x27;loads&#x27;</span>, <span class="string">&#x27;scanner&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="重载-函数">重载()函数</h2>
<p>正如我们已经说过的，一个模块被加载一次，不管它被导入 python 源文件的次数是多少。但是，如果您想重新加载已经导入的模块来重新执行顶层代码，python 为我们提供了 reload()函数。下面给出了使用 reload()函数的语法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">reload(&lt;module-name&gt;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>例如，要重新加载前面示例中定义的模块计算，我们必须使用下面一行代码。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">reload(calculation)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="变量的范围-2">变量的范围</h2>
<p>在 Python 中，变量与两种类型的范围相关联。模块中定义的所有变量都包含全局范围，除非或直到它在函数中定义。</p>
<p>函数内部定义的所有变量都包含一个局部范围，该范围仅限于该函数本身。我们不能全局访问局部变量。</p>
<p>如果两个变量在两个不同的作用域(即局部和全局)中用相同的名称定义，那么优先级将始终给予局部变量。</p>
<p>考虑下面的例子。</p>
<h2 id="例子-16">例子</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;john&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_name</span>(<span class="params">name</span>):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;Hi&quot;</span>,name) <span class="comment">#prints the name that is local to this function only.</span></span><br><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;Enter the name?&quot;</span>)</span><br><span class="line">print_name(name)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Hi David </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-包">Python 包</h2>
<p>python 中的包通过提供分层目录结构来方便开发人员使用应用开发环境，其中包包含子包、模块和子模块。这些包用于有效地对应用级代码进行分类。</p>
<p>让我们在您的主目录中创建一个名为 Employees 的包。请考虑以下步骤。</p>
<p>1.在路径/ <strong>主页</strong>上创建一个名为 Employees 的目录。</p>
<p>2.在路径/ <strong>home</strong> / <strong>Employees</strong> 上创建一个名为 <a href="http://ITEmployees.py">ITEmployees.py</a> 的 python 源文件。</p>
<p><strong>项目员工. py</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getITNames</span>():</span><br><span class="line">	<span class="type">List</span> = [<span class="string">&quot;John&quot;</span>, <span class="string">&quot;David&quot;</span>, <span class="string">&quot;Nick&quot;</span>, 	<span class="string">&quot;Martin&quot;</span>]</span><br><span class="line">	<span class="keyword">return</span> <span class="type">List</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3.同样，再创建一个名为 <a href="http://BPOEmployees.py">BPOEmployees.py</a> 的 python 文件，并创建一个函数 getBPONames()。</p>
<p>4.现在，我们在第一步中创建的雇员目录包含两个 python 模块。为了使这个目录成为一个包，我们需要在这里包含一个文件，即 <strong>init</strong>。py，包含此目录中定义的模块的导入语句。</p>
<p><strong><strong>init</strong>。py</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ITEmployees <span class="keyword">import</span> getITNames</span><br><span class="line"><span class="keyword">from</span> BPOEmployees <span class="keyword">import</span> getBPONames</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>5.现在目录 <strong>Employees</strong> 变成了包含两个 python 模块的包。这里我们必须注意到，我们必须创建 <strong>init</strong>。py 在一个目录中，将这个目录转换成一个包。</p>
<p>6.要使用雇员包中定义的模块，我们必须在 python 源文件中导入这些模块。让我们在主目录(/home)中创建一个简单的 python 源文件，它使用这个包中定义的模块。</p>
<p><strong>测试 py</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Employees</span><br><span class="line"><span class="built_in">print</span>(Employees.getNames())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;David&#x27;</span>, <span class="string">&#x27;Nick&#x27;</span>, <span class="string">&#x27;Martin&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以在包裹里有子包裹。我们可以根据应用需求将包嵌套到任何级别。</p>
<p>下图显示了应用库管理系统的目录结构，该系统包含三个子包，即管理员、图书管理员和学生。子包包含 python 模块。</p>
<p><img src="/img/b43763de4410bff6f379ff9fb51b6f11.png" alt="Python packages"></p>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 正则表达式</title>
    <url>/posts/76b9023d.html</url>
    <content><![CDATA[<h1>Python 正则表达式</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-regex">https://www.javatpoint.com/python-regex</a></p>
</blockquote>
<p>正则表达式可以定义为用于在字符串中搜索模式的字符序列。模块 re 提供了在 python 程序中使用正则表达式的支持。如果使用正则表达式时出现错误，re 模块将引发异常。</p>
<p>必须导入 <strong>re</strong> 模块才能使用 python 中的 regex 功能。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> re </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="正则函数">正则函数</h2>
<p>python 中使用了以下正则表达式函数。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>compile - 它用于将正则模式转换为正则表达式的对象，该对象可以通过多种方式用于匹配字符串中的模式。</p>
</li>
<li class="lvl-2">
<p>search - 它用于查找给定字符串中正则表达式模式的第一次出现。</p>
</li>
<li class="lvl-2">
<p>match - 它开始匹配字符串开头的模式。</p>
</li>
<li class="lvl-2">
<p>fullmatch - 它用于将整个字符串与正则表达式模式匹配。</p>
</li>
<li class="lvl-2">
<p>split - 它用于根据正则表达式模式拆分模式。</p>
</li>
<li class="lvl-2">
<p>findall - 它用于查找字符串中的所有非重叠模式。它返回匹配模式的列表。</p>
</li>
<li class="lvl-2">
<p>finditer - 返回生成匹配对象的迭代器。</p>
</li>
<li class="lvl-2">
<p>sub - 在用替换替换模式的第一次出现后，它会返回一个字符串。</p>
</li>
<li class="lvl-2">
<p>subn - 它的工作原理与“子”相同。它返回一个元组（new_string，num_of_substitution）。</p>
</li>
<li class="lvl-2">
<p>escape - 它用于转义模式中的特殊字符。</p>
</li>
<li class="lvl-2">
<p>purge - 它用于清除正则表达式缓存。</p>
</li>
</ul>
<h2 id="形成正则表达式">形成正则表达式</h2>
<p>正则表达式可以通过混合使用元字符、特殊序列和集合来形成。</p>
<h3 id="元字符">元字符</h3>
<p>元字符是具有指定含义的字符。</p>
<p>| 元字符 | 描述 | 例子 |<br>
| [] | 它表示字符集。 | “[a-z]” |<br>
| \ | 它代表了特殊的序列。 | &quot; \r &quot; |<br>
| . | 它表示任何角色都出现在某个特定的地方。 | “是的.” |<br>
| ^ | 它表示字符串开头的模式。 | “^Java” |<br>
| $ | 它表示字符串末尾的模式。 | “点$” |<br>
| * | 它表示字符串中出现零个或多个模式。 | “你好*” |<br>
| + | 它表示字符串中模式的一次或多次出现。 | “你好+” |<br>
| {} | 字符串中模式出现的指定次数。 | java{2} |<br>
| ? | 它代表这个或那个角色的存在。 | &quot; java|point &quot; |<br>
| () | 捕获并分组 |  |</p>
<h3 id="特殊序列">特殊序列</h3>
<p>特殊序列是包含\后跟一个字符的序列。</p>
<table>
<thead>
<tr>
<th>字母</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\A</td>
<td>如果指定的字符出现在字符串的开头，它将返回匹配项。</td>
</tr>
<tr>
<td>\b</td>
<td>如果指定的字符出现在字符串的开头或结尾，它将返回匹配项。</td>
</tr>
<tr>
<td>\B</td>
<td>如果指定的字符出现在字符串的开头而不是结尾，它将返回一个匹配项。</td>
</tr>
<tr>
<td>\d</td>
<td>如果字符串包含数字[0-9]，则返回匹配项。</td>
</tr>
<tr>
<td>\D</td>
<td>如果字符串不包含数字[0-9]，则返回匹配项。</td>
</tr>
<tr>
<td>\s</td>
<td>如果字符串包含任何空白字符，它将返回匹配项。</td>
</tr>
<tr>
<td>\S</td>
<td>如果字符串不包含任何空格字符，它将返回匹配项。</td>
</tr>
<tr>
<td>\w</td>
<td>如果字符串包含任何单词字符，它将返回匹配项。</td>
</tr>
<tr>
<td>\W</td>
<td>如果字符串不包含任何单词，它将返回一个匹配项。</td>
</tr>
<tr>
<td>\Z</td>
<td>如果指定字符位于字符串末尾，则返回匹配项。</td>
</tr>
</tbody>
</table>
<h3 id="设置">设置</h3>
<p>集合是放在一对方括号内的一组字符。它代表着特殊的意义。</p>
<p>| 塞内加尔 | 一组 | 描述 |<br>
| one | [arn] | 如果字符串包含集合中的任何指定字符，则返回匹配项。 |<br>
| Two | [a-n] | 如果字符串包含 a 到 n 之间的任何字符，则返回匹配项。 |<br>
| three | [^arn] | 如果字符串包含除 a、r 和 n 以外的字符，则返回匹配项。 |<br>
| four | [0123] | 如果字符串包含任何指定的数字，则返回匹配项。 |<br>
| five | [0-9] | 如果字符串包含 0 到 9 之间的任何数字，则返回匹配项。 |<br>
| six | [0-5][0-9] | 如果字符串包含 00 到 59 之间的任何数字，则返回匹配项。 |<br>
| Ten | [一个接一个] | 如果字符串包含任何字母(小写或大写)，则返回匹配项。 |</p>
<h3 id="findall-函数">findall()函数</h3>
<p>此方法返回一个列表，其中包含字符串中模式的所有匹配项的列表。它按照找到的顺序返回模式。如果没有匹配项，则返回一个空列表。</p>
<p>考虑下面的例子。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;How are you. How is everything&quot;</span></span><br><span class="line"></span><br><span class="line">matches = re.findall(<span class="string">&quot;How&quot;</span>, <span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(matches)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(matches)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;How&#x27;</span>, <span class="string">&#x27;How&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="匹配对象">匹配对象</h2>
<p>match 对象包含关于搜索和输出的信息。如果没有找到匹配项，则返回无对象。</p>
<h3 id="例子-17">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;How are you. How is everything&quot;</span></span><br><span class="line"></span><br><span class="line">matches = re.search(<span class="string">&quot;How&quot;</span>, <span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(matches))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(matches) <span class="comment">#matches is the search object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;_sre.SRE_Match&#x27;</span>&gt;</span><br><span class="line">&lt;_sre.SRE_Match <span class="built_in">object</span>; span=(<span class="number">0</span>, <span class="number">3</span>), match=<span class="string">&#x27;How&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="匹配对象方法">匹配对象方法</h3>
<p>有以下与匹配对象相关联的方法。</p>
<ol>
<li class="lvl-4">
<p><strong>span():</strong> 它返回包含匹配的开始和结束位置的元组。</p>
</li>
<li class="lvl-4">
<p><strong>string():</strong> 返回传递给函数的字符串。</p>
</li>
<li class="lvl-4">
<p><strong>group():</strong> 返回字符串中找到匹配的部分。</p>
</li>
</ol>
<h3 id="例子-18">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;How are you. How is everything&quot;</span></span><br><span class="line"></span><br><span class="line">matches = re.search(<span class="string">&quot;How&quot;</span>, <span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(matches.span())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(matches.group())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(matches.string)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">How</span><br><span class="line">How are you. How <span class="keyword">is</span> everything</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 注释</title>
    <url>/posts/7ae95e2f.html</url>
    <content><![CDATA[<h1>Python 注释</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-comments">https://www.javatpoint.com/python-comments</a></p>
</blockquote>
<p>Python 注释对于程序员来说是一个必不可少的工具。注释通常用于解释代码。如果代码有适当的解释，我们很容易理解。一个好的程序员必须使用注释，因为将来任何人都想修改代码以及实现新的模块；然后，它可以很容易地完成。</p>
<p>在其他编程语言(如 C++)中，它为单行注释和/<em>提供了//选项…</em>/表示多行注释，但 Python 提供单行 Python 注释。为了在代码中应用注释，我们在语句或代码的开头使用哈希(#)。</p>
<p>让我们理解下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This is the print statement</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello Python&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，我们使用哈希(#)对 print 语句进行了注释。不会影响我们的打印声明。</p>
<h2 id="Python-多行-Comment">Python 多行 Comment</h2>
<p>我们必须在每一行代码的开头使用哈希(#)来应用多行 Python 注释。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># First line of the comment </span></span><br><span class="line"><span class="comment"># Second line of the comment</span></span><br><span class="line"><span class="comment"># Third line of the comment</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Variable a holds value 5</span></span><br><span class="line"><span class="comment"># Variable b holds value 10</span></span><br><span class="line"><span class="comment"># Variable c holds sum of a and b</span></span><br><span class="line"><span class="comment"># Print the result</span></span><br><span class="line">a = <span class="number">5</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">c = a+b</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The sum is:&quot;</span>, c)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The <span class="built_in">sum</span> <span class="keyword">is</span>: <span class="number">15</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的代码非常易读，即使是绝对的初学者也能理解每一行代码中发生的事情。这就是在代码中使用注释的好处。</p>
<p>对于多行注释，我们也可以使用三重引号(’ ’ ’ ')。三重引号也用于字符串格式。考虑下面的例子。</p>
<h2 id="文档字符串-Python-注释">文档字符串 Python 注释</h2>
<p>docstring 注释主要用于模块、函数、类或方法。它是一个 Python 文档字符串。我们将在后续教程中解释该类/方法。</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">intro</span>():</span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  This function prints Hello Joseph</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Hi Joseph&quot;</span>)            </span><br><span class="line">intro()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Hello Joseph</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以通过使用 <strong>doc</strong> 属性来检查函数的文档字符串。</p>
<p>Generally, four whitespaces are used as the indentation. The amount of indentation depends on user, but it must be consistent throughout that block.</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">intro</span>():</span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  This function prints Hello Joseph</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Hello Joseph&quot;</span>)            </span><br><span class="line">intro.__doc__</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Output:</span><br><span class="line"><span class="string">&#x27;\n  This function prints Hello Joseph\n  &#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="注意-docstring-必须是函数中的第一件事；否则，Python-解释器无法获取-docstring。">注意:docstring 必须是函数中的第一件事；否则，Python 解释器无法获取 docstring。</h4>
<h2 id="Python-缩进">Python 缩进</h2>
<p>Python 使用缩进来定义代码块。其他编程语言如 C、C++和 Java 使用花括号{}，而 Python 使用缩进。空白在 Python 中用作缩进。</p>
<p>缩进在代码的开头使用，并以非预期的一行结束。同一行缩进定义了代码块(函数体、循环等)。)</p>
<p>通常，四个空格用作缩进。缩进量取决于用户，但必须在整个块中保持一致。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">3</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了表示一个代码块，我们用相同的空格缩进代码块的每一行。</p>
<p>考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">dn = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the number:&quot;</span>))</span><br><span class="line"><span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Even Number&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Odd Number&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Task Complete&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the number: <span class="number">10</span></span><br><span class="line">Even Number</span><br><span class="line">Task Complete</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的代码， <strong>if</strong> 和 <strong>else</strong> 是两个独立的代码块。两个代码块都缩进四个空格。print(“任务完成”)语句没有缩进四个空格，并且超出了 <strong>if-else</strong> 块。</p>
<p>如果缩进使用不当，将导致<strong>缩进错误</strong>。</p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 特性</title>
    <url>/posts/b34390d8.html</url>
    <content><![CDATA[<h1>Python 特性</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-features">https://www.javatpoint.com/python-features</a></p>
</blockquote>
<p>Python 提供了许多有用的特性，这些特性使它从其他编程语言中变得流行和有价值。它支持面向对象编程、过程编程方法，并提供动态内存分配。我们在下面列出了一些基本特性。</p>
<h3 id="1-易于学习和使用">1)易于学习和使用</h3>
<p>与其他编程语言相比，Python 很容易学习。它的语法简单明了，与英语非常相似。没有使用分号或大括号，缩进定义了代码块。是初学者推荐的编程语言。</p>
<h3 id="2-表达性语言">2)表达性语言</h3>
<p>Python 可以使用几行代码执行复杂的任务。一个简单的例子，你简单输入<strong>打印的 hello world 程序(“Hello World”)</strong>。它只需要一行代码就可以执行，而 Java 或 C 需要多行代码。</p>
<h3 id="3-解释语言">3)解释语言</h3>
<p>Python 是一种解释语言；它意味着 Python 程序一次执行一行。作为解释语言的优势，它使调试变得容易和可移植。</p>
<h3 id="4-跨平台语言">4)跨平台语言</h3>
<p>Python 可以在 Windows、Linux、UNIX、Macintosh 等不同平台上平等运行。所以，我们可以说 Python 是一种可移植的语言。它使程序员只需编写一次程序，就可以为几个竞争平台开发软件。</p>
<h3 id="5-自由和开源">5)自由和开源</h3>
<p>Python 对每个人都是免费的。在其官方网站<a href="https://www.python.org/">www.python.org</a>上可以免费获得。它在世界各地拥有一个庞大的社区，致力于开发新的 python 模块和函数。任何人都可以为 Python 社区做出贡献。开源的意思是，“任何人都可以下载它的源代码，而不用花一分钱。”</p>
<h3 id="6-面向对象语言">6)面向对象语言</h3>
<p>Python 支持面向对象语言，类和对象的概念应运而生。它支持继承、多态和封装等。面向对象的过程有助于程序员编写可重用的代码，并以更少的代码开发应用。</p>
<h3 id="7-可扩展">7)可扩展</h3>
<p>这意味着其他语言，如 C/C++可以用来编译代码，因此它可以在我们的 Python 代码中进一步使用。它将程序转换成字节码，任何平台都可以使用该字节码。</p>
<h3 id="8-大型标准图书馆">8)大型标准图书馆</h3>
<p>它为各种领域提供了大量的库，如机器学习、web 开发人员以及脚本。有各种机器学习库，如 Tensor flow、Pandas、Numpy、Keras、Pytorch 等。Django、flask、金字塔是 Python web 开发的流行框架。</p>
<h3 id="9-图形用户界面编程支持">9)图形用户界面编程支持</h3>
<p>图形用户界面用于开发桌面应用。PyQT5、Tkinter、Kivy 是用于开发 web 应用的库。</p>
<h3 id="10-集成">10)集成</h3>
<p>它可以很容易地与 C、C++、JAVA 等语言集成。Python 像 C、C++和 Java 一样逐行运行代码。这使得调试代码变得容易。</p>
<h3 id="11-可嵌入">11.可嵌入</h3>
<p>其他编程语言的代码可以在 Python 源代码中使用。我们也可以使用另一种编程语言的 Python 源代码。它可以将其他语言嵌入到我们的代码中。</p>
<h3 id="12-动态存储分配">12.动态存储分配</h3>
<p>在 Python 中，我们不需要指定变量的数据类型。当我们给变量赋值时，它会在运行时自动给变量分配内存。假设我们被赋予整数值 15 到 <strong>x，</strong>，那么我们不需要写 **int x = 15。**只写 x = 15。</p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 生成器</title>
    <url>/posts/23b78c5e.html</url>
    <content><![CDATA[<h1>Python 生成器</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-generators">https://www.javatpoint.com/python-generators</a></p>
</blockquote>
<h2 id="什么是-Python-生成器？">什么是 Python 生成器？</h2>
<p>Python 生成器是返回遍历对象的函数，用于创建迭代器。它一次遍历整个项目。生成器也可以是语法类似于 Python 中列表推导的表达式。</p>
<p>在 Python 中创建迭代有很大的复杂性；我们需要实现 <strong><strong>iter</strong>()</strong> 和 <strong><strong>next</strong>()</strong> 方法来跟踪内部状态。</p>
<p>创建迭代器是一个漫长的过程。这就是为什么生成器在简化这一过程中起着至关重要的作用。如果迭代中没有发现值，则引发<strong>停止迭代</strong>异常。</p>
<h2 id="如何用-Python-创建生成器函数？">如何用 Python 创建生成器函数？</h2>
<p>用 Python 创建一个生成器非常简单。类似于 <strong>def</strong> 关键字定义的正常函数，使用 <strong>yield</strong> 关键字代替 return。或者我们可以说，如果任何函数的主体包含一个 <strong>yield</strong> 语句，那么它就会自动成为一个生成函数。考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">simple</span>():</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>):</span><br><span class="line">         <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"><span class="comment">#Successive Function call using for loop</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> simple():</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="收益率与回报">收益率与回报</h3>
<p><strong>yield</strong> 语句负责控制生成器功能的流程。它通过保存所有状态暂停函数执行，并向调用者让步。稍后，当调用一个连续的函数时，它将恢复执行。我们可以在生成器函数中使用多重 <code>yield</code>语句。</p>
<p>return 语句<strong>返回</strong>一个值，终止整个函数，函数中只能使用一个 return 语句。</p>
<p><strong>使用多收益率报表</strong></p>
<p>我们可以在生成器函数中使用多重 <code>yield</code>语句。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multiple_yield</span>():</span><br><span class="line">    str1 = <span class="string">&quot;First String&quot;</span></span><br><span class="line">    <span class="keyword">yield</span> str1</span><br><span class="line"></span><br><span class="line">    str2 = <span class="string">&quot;Second string&quot;</span></span><br><span class="line">    <span class="keyword">yield</span> str2</span><br><span class="line"></span><br><span class="line">    str3 = <span class="string">&quot;Third String&quot;</span></span><br><span class="line">    <span class="keyword">yield</span> str3</span><br><span class="line">obj = multiple_yield()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(obj))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(obj))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(obj))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">First String</span><br><span class="line">Second string</span><br><span class="line">Third String</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="生成器函数和普通函数的区别">生成器函数和普通函数的区别</h3>
<ul class="lvl-0">
<li class="lvl-4">
<p>普通函数只包含一个 L <strong>返回</strong>语句，而生成器函数可以包含一个或多个<strong>返回</strong>语句。</p>
</li>
<li class="lvl-4">
<p>当调用生成器函数时，正常函数会立即暂停，并将控制权转移给调用方。</p>
</li>
<li class="lvl-4">
<p>局部变量及其状态在连续调用之间被记住。</p>
</li>
<li class="lvl-4">
<p>当函数终止时，会自动引发 StopIteration 异常。</p>
</li>
</ul>
<h3 id="生成器表达式">生成器表达式</h3>
<p>我们可以轻松创建生成器表达式，而无需使用用户定义的函数。它与创建匿名函数的 lambda 函数相同；生成器的表达式创建匿名生成器函数。</p>
<p>生成器表达式的表示类似于 Python 列表推导。唯一不同的是<strong>方括号被圆括号</strong>代替。列表推导计算整个列表，而生成器表达式一次计算一个项目。</p>
<p>考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># List Comprehension</span></span><br><span class="line">z = [x**<span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generator expression</span></span><br><span class="line">a = (x**<span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x01BA3CD8</span>&gt;</span><br><span class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">27</span>, <span class="number">64</span>, <span class="number">125</span>, <span class="number">216</span>, <span class="number">343</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的程序中，列表推导返回了元素立方体的列表，而生成器表达式返回了计算值的引用。我们也可以在生成器对象上调用 <strong>next()</strong> ，而不是对循环应用**。让我们考虑另一个例子:**</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">z = (x**<span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(z))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(z))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(z))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(z))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">64</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="注意-当我们调用-next-时，Python-会对我们作为参数传递的函数调用-next-函数。">注意:-当我们调用 next()时，Python 会对我们作为参数传递的函数调用 <strong>next</strong>()函数。</h4>
<p>在上面的程序中，我们使用了 <strong>next()</strong> 函数，该函数返回列表的下一项。</p>
<p>**示例:**编写一个程序，使用生成器打印给定数字的表格。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">table</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">        <span class="keyword">yield</span> n*i</span><br><span class="line">           i = i+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> table(<span class="number">15</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">45</span></span><br><span class="line"><span class="number">60</span></span><br><span class="line"><span class="number">75</span></span><br><span class="line"><span class="number">90</span></span><br><span class="line"><span class="number">105</span></span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="number">135</span></span><br><span class="line"><span class="number">150</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，生成器函数使用 <code>for</code>循环进行迭代。</p>
<h2 id="生成器的优点">生成器的优点</h2>
<p>生成器有各种各样的优点。下面给出了几个例子:</p>
<h3 id="1-易于实施">1.易于实施</h3>
<p>与迭代器相比，生成器很容易实现。在迭代器中，我们必须实现**_ _ ITER <em>()<strong>和</strong></em> _ next _()**函数。</p>
<h3 id="2-内存高效">2.内存高效</h3>
<p>对于大量序列，生成器具有内存效率。normal 函数返回一个列表序列，在返回结果之前在内存中创建一个完整的序列，但是 generator 函数计算值并暂停它们的执行。它继续连续呼叫。无限序列生成器是内存优化的一个很好的例子。下面我们用 <strong>sys.getsizeof()</strong> 函数来讨论一下。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># List comprehension</span></span><br><span class="line">nums_squared_list = [i * <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>)]</span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;Memory in Bytes:&quot;</span>nums_squared_list))</span><br><span class="line"><span class="comment"># Generator Expression</span></span><br><span class="line">nums_squared_gc = (i ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>))</span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;Memory in Bytes:&quot;</span>, nums_squared_gc))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Memory <span class="keyword">in</span> Bytes: <span class="number">4508</span></span><br><span class="line">Memory <span class="keyword">in</span> Bytes: <span class="number">56</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以从上面的输出中观察到，列表推导使用了 4508 字节的内存，而生成器表达式使用了 56 字节的内存。这意味着生成器对象比列表压缩效率高得多。</p>
<h3 id="3-用发生器进行流水线操作">3.用发生器进行流水线操作</h3>
<p>数据管道提供了在不使用额外计算机内存的情况下处理大型数据集或数据流的工具。</p>
<p>假设我们有一个著名餐厅的日志文件。日志文件中有一列(4 <sup>第</sup>列)记录了每小时售出的汉堡数量，我们想对其求和，找出 4 年内售出的汉堡总数。在这种情况下，生成器可以生成包含一系列操作的管道。下面是它的代码:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;sells.log&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">burger_col = (line[<span class="number">3</span>] <span class="keyword">for</span> line <span class="keyword">in</span> file)  per_hour = (<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> burger_col <span class="keyword">if</span> x != <span class="string">&#x27;N/A&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Total burgers sold = &quot;</span>,<span class="built_in">sum</span>(per_hour))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>4。生成无限序列</strong></p>
<p>生成器可以生产无限多的物品。内存中不能包含无限序列，由于生成器一次只能生成一个项目，请考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">infinite_sequence</span>():</span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> num</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> infinite_sequence():</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line">.........</span><br><span class="line">..........</span><br><span class="line"><span class="number">315</span></span><br><span class="line"><span class="number">316</span></span><br><span class="line"><span class="number">317</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;C:\Users\DEVANSH SHARMA\Desktop\generator.py&quot;</span>, line <span class="number">33</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">KeyboardInterrupt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在本教程中，我们已经了解了 Python 生成器。</p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 简介</title>
    <url>/posts/406f8352.html</url>
    <content><![CDATA[<h1>Python 简介</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-tutorial">https://www.javatpoint.com/python-tutorial</a></p>
</blockquote>
<p><img src="img/c7dda965d389ce88154f60028501ce7e.png" alt="Python"></p>
<p>Python 教程提供了 Python 的基本和高级概念。我们的 Python 教程是为初学者和专业人士设计的。</p>
<p>Python 是一种简单、通用、高级和面向对象的编程语言。</p>
<p>Python 也是一种解释脚本语言。 <em>Guido Van Rossum</em> 被称为 Python 编程的创始人。</p>
<p>我们的 Python 教程包括 Python 编程的所有主题，如安装、控制语句、<a href="python-strings">字符串</a>、<a href="python-lists">列表</a>、<a href="python-tuples">元组</a>、<a href="python-dictionary">字典</a>、<a href="python-modules">模块</a>、<a href="python-exception-handling">异常</a>、日期和时间、文件 I/O、程序等。还提供了 Python 面试问题，帮助您更好地理解 Python 编程。</p>
<h2 id="什么是-Python">什么是 Python</h2>
<p><strong>Python</strong> 是一种通用的、动态的、<a href="classification-of-programming-languages">高级的</a>，并且经过解释的编程语言。它支持面向对象编程方法来开发应用。它简单易学，提供了大量的高级数据结构。</p>
<p>Python 是<em>易于学习</em>但功能强大且用途广泛的脚本语言，这使得它对应用开发很有吸引力。</p>
<p>Python 的语法和带有解释性质的<em>动态类型</em>使其成为脚本和快速应用开发的理想语言。</p>
<p>Python 支持<em>多种编程模式</em>，包括面向对象、命令式和函数式或过程式编程风格。</p>
<p>Python 不打算在特定的领域工作，比如 web 编程。这就是为什么它被称为<em>多用途</em>编程语言的原因，因为它可以与 web、企业、3D CAD 等一起使用。</p>
<p>我们不需要用数据类型来声明变量，因为它是<em>动态类型的</em>，所以我们可以写一个=10 来赋一个整型变量中的整数值。</p>
<p>Python 让开发调试<em>变快</em>是因为 Python 开发中没有包含编译步骤，编辑-测试-调试周期非常快。</p>
<h2 id="Python-2-对-Python-3">Python 2 对 Python 3</h2>
<p>在大多数编程语言中，每当新版本发布时，它都支持该语言现有版本的功能和语法，因此，项目更容易在新版本中切换。但是，就 Python 而言，Python 2 和 Python 3 这两个版本彼此有很大的不同。</p>
<p>下面列出了 Python 2 和 Python 3 之间的差异:</p>
<ol>
<li class="lvl-4">
<p>Python 2 使用<strong>打印</strong>作为语句，并用作打印“某物”在控制台上打印一些字符串。另一方面，Python 3 使用<strong>打印</strong>作为功能，并用作打印(“某物”)在控制台上打印某物。</p>
</li>
<li class="lvl-4">
<p>Python 2 使用函数 raw_input()接受用户的输入。它返回表示用户键入的值的字符串。要将其转换为整数，我们需要使用 Python 中的 int()函数。另一方面，Python 3 使用 input()函数，该函数自动解释用户输入的输入类型。但是，我们可以通过使用基元函数(int()，str()，等)将该值转换为任何类型。).</p>
</li>
<li class="lvl-4">
<p>在 Python 2 中，隐式字符串类型是 ASCII，而在 Python 3 中，隐式字符串类型是 Unicode。</p>
</li>
<li class="lvl-4">
<p>Python 3 不包含 Python 2 的 xrange()函数。xrange()是 range()函数的变体，它返回一个 xrange 对象，其工作方式类似于 Java 迭代器。range()返回一个列表，例如函数 range(0，3)包含 0，1，2。</p>
</li>
<li class="lvl-4">
<p>Python 3 中的异常处理也有一个小变化。它将一个关键字<strong>定义为</strong>，这是必须使用的。我们将在 Python 编程教程的异常处理部分讨论它。</p>
</li>
</ol>
<h2 id="Python-历史">Python 历史</h2>
<p>Python 是由吉多·范·罗苏姆于 1991 年在荷兰 CWI 发明的。Python 编程语言的思想取自于 ABC 编程语言或者我们可以说 ABC 是 Python 语言的前身。</p>
<p>选择 Python 这个名字背后也有一个事实。吉多·范·罗苏姆是当时英国广播公司热门喜剧节目《巨蟒飞行马戏团》的粉丝。所以他决定为他新创建的编程语言选择名称 <strong>Python</strong> 。</p>
<p>Python 在世界各地拥有广泛的社区，并在短时间内发布其版本。</p>
<h2 id="为什么要学-Python？">为什么要学 Python？</h2>
<p>Python 为程序员提供了许多有用的特性。这些特点使它成为最受欢迎和广泛使用的语言。我们在下面列出了 Python 的几个基本特性。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>易于使用和学习</p>
</li>
<li class="lvl-4">
<p>表达性语言</p>
</li>
<li class="lvl-4">
<p>解释语言</p>
</li>
<li class="lvl-4">
<p>面向对象语言</p>
</li>
<li class="lvl-4">
<p>开源语言</p>
</li>
<li class="lvl-4">
<p>可扩张的</p>
</li>
<li class="lvl-4">
<p>学习标准库</p>
</li>
<li class="lvl-4">
<p>图形用户界面编程支持</p>
</li>
<li class="lvl-4">
<p>完整的</p>
</li>
<li class="lvl-4">
<p>可嵌入</p>
</li>
<li class="lvl-4">
<p>动态存储分配</p>
</li>
<li class="lvl-4">
<p>广泛的库和框架</p>
</li>
</ul>
<h2 id="Python-在哪里使用？">Python 在哪里使用？</h2>
<p>Python 是一种通用的、流行的编程语言，它被用于几乎每个技术领域。下面给出了 Python 使用的各个领域。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>数据科学</p>
</li>
<li class="lvl-4">
<p>数据挖掘技术</p>
</li>
<li class="lvl-4">
<p>桌面应用</p>
</li>
<li class="lvl-4">
<p>基于控制台的应用</p>
</li>
<li class="lvl-4">
<p>移动应用</p>
</li>
<li class="lvl-4">
<p>软件开发</p>
</li>
<li class="lvl-4">
<p>人工智能</p>
</li>
<li class="lvl-4">
<p>网络应用</p>
</li>
<li class="lvl-4">
<p>企业应用</p>
</li>
<li class="lvl-4">
<p>三维计算机辅助设计应用</p>
</li>
<li class="lvl-4">
<p>机器学习</p>
</li>
<li class="lvl-4">
<p>计算机视觉或图像处理应用。</p>
</li>
<li class="lvl-4">
<p>语音识别</p>
</li>
</ul>
<h2 id="Python-基本语法">Python 基本语法</h2>
<p>Python 编程语言中没有使用花括号或分号。这是一种类似英语的语言。但是 Python 使用缩进来定义一个代码块。缩进只不过是在需要时在语句前添加空白。<strong>例如-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">       statement <span class="number">1</span></span><br><span class="line">       statement <span class="number">2</span></span><br><span class="line">       …………………</span><br><span class="line">       …………………</span><br><span class="line">         statement N</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，从右到左的语句属于函数。通常，我们可以用四个空格来定义缩进。</p>
<h2 id="Python-第一程序">Python 第一程序</h2>
<p>与其他编程语言不同，Python 提供了使用几行代码来执行代码的工具。<strong>例如</strong> -假设我们要用 Java 打印**《你好世界》**程序；打印它需要三行。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line"> public static void main(String[] args)&#123;</span><br><span class="line">// Prints <span class="string">&quot;Hello, World&quot;</span> to the terminal window.</span><br><span class="line">  System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另一方面，我们可以使用 Python 中的一条语句来实现这一点。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这两个程序将打印相同的结果，但它只需要一条语句，而不使用 Python 中的分号或大括号。</p>
<h2 id="Python-流行框架和库">Python 流行框架和库</h2>
<p>Python 拥有广泛的库和框架，广泛应用于机器学习、人工智能、web 应用等各个领域。我们定义一些流行的 Python 框架和库如下。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Web 开发(服务器端)-</strong> Django Flask，金字塔，CherryPy</p>
</li>
<li class="lvl-4">
<p><strong>基于 GUI 的应用-</strong> Tk、PyGTK、PyQt、PyJs 等。</p>
</li>
<li class="lvl-4">
<p><strong>机器学习-</strong> 张量洛、PyTorch、 <strong>Scikit-learn</strong> 、Matplotlib、Scipy 等。</p>
</li>
<li class="lvl-4">
<p><strong>数学-</strong> Numpy，Pandas 等。</p>
</li>
</ul>
<h2 id="Python-打印-函数-2">Python 打印()函数</h2>
<p><strong>print()</strong> 功能向标准输出设备(屏幕)或文本流文件显示给定对象。</p>
<p>与其他编程语言不同，Python <strong>print()</strong> 函数是最独特、最通用的函数。</p>
<p><strong>print()</strong> 函数的语法如下。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(*objects, sep=<span class="string">&#x27; &#x27;</span>, end=<span class="string">&#x27;\n&#x27;</span>, file=sys.stdout, flush=<span class="literal">False</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>让我们一个一个解释它的参数。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>对象-</strong> 对象只不过是需要打印的语句。*符号表示可以有多个语句。</p>
</li>
<li class="lvl-4">
<p><strong>sep-****sep</strong>参数分隔打印值。默认值为“”。</p>
</li>
<li class="lvl-4">
<p><strong>end -</strong> 语句中最后打印 <strong>end</strong> 。</p>
</li>
<li class="lvl-4">
<p><strong>文件-</strong> 必须是写(字符串)方法的对象。</p>
</li>
<li class="lvl-4">
<p><strong>刷新-</strong> 如果为真，则强制刷新流或文件。默认情况下，它的值为 false。</p>
</li>
</ul>
<p>让我们理解下面的例子。</p>
<h3 id="示例-1-返回值">示例- 1:返回值</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Welcome to javaTpoint.&quot;</span>)</span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="comment"># Two objects are passed in print() function</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a =&quot;</span>, a)</span><br><span class="line"></span><br><span class="line">b = a</span><br><span class="line"><span class="comment"># Three objects are passed in print function</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a =&#x27;</span>, a, <span class="string">&#x27;= b&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Welcome to javaTpoint.</span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">a = <span class="number">10</span> = b</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从上面的输出中我们可以看到，可以在单个 <strong>print()</strong> 语句中打印多个对象。我们只需要用逗号(，)来分隔彼此。</p>
<h3 id="示例-2-使用-sep-和-end-参数">示例- 2:使用 sep 和 end 参数</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a =&quot;</span>, a, sep=<span class="string">&#x27;dddd&#x27;</span>, end=<span class="string">&#x27;\n\n\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a =&quot;</span>, a, sep=<span class="string">&#x27;0&#x27;</span>, end=<span class="string">&#x27;$$$$$&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a =dddd10</span><br><span class="line"></span><br><span class="line">a =<span class="number">0</span>10$$$$$</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在第一个 <strong>print()</strong> 语句中，我们使用了 <strong>sep</strong> 和 <strong>end</strong> 参数。给定对象刚好在<strong>9</strong>值之后打印。打印在给定对象最后的结束参数值。我们可以看到，第二个 <strong>print()</strong> 函数打印了三条黑线后的结果。</p>
<h2 id="向用户输入">向用户输入</h2>
<p>Python 提供了**输入()**功能，用于接受用户的输入。让我们理解下面的例子。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;Enter a name of student:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The student name is: &quot;</span>, name)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter a name of student: Devansh</span><br><span class="line">The student name <span class="keyword">is</span>:   Devansh</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>默认情况下， <strong>input()</strong> 函数接受字符串输入，但是如果我们想接受其他数据类型作为输入呢？</p>
<p>如果我们想把输入当成一个整数，我们需要把 <strong>input()</strong> 函数打造成一个整数。</p>
<p><strong>例如-</strong></p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a  = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter first number: &quot;</span>))</span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter second number: &quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a+b)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter first number: <span class="number">50</span></span><br><span class="line">Enter second number: <span class="number">100</span></span><br><span class="line"><span class="number">150</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以使用**输入()**函数获取任何类型的值。</p>
<h2 id="Python-运算符">Python 运算符</h2>
<p>运算符是对 Python 对象执行各种操作的符号。Python 操作符是处理 Python 数据类型的最基本要素。此外，Python 还提供了标识成员和按位运算符。我们将在下面的教程中通过合适的例子学习所有这些操作符。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Python 运算符</strong></p>
</li>
</ul>
<h2 id="Python-条件语句">Python 条件语句</h2>
<p>条件语句帮助我们为特定的条件执行特定的块。在本教程中，我们将学习如何使用条件表达式来执行不同的语句块。Python 提供了 if 和 else 关键字来设置逻辑条件。elif 关键字也用作条件语句。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>蟒若…else 语句</strong></p>
</li>
</ul>
<h2 id="Python-循环">Python 循环</h2>
<p>有时我们可能需要改变程序的流程。特定代码的执行可能需要重复几次。为此，编程语言提供了各种类型的循环，能够多次重复某些特定的代码。考虑下面的教程来详细理解这些语句。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Python 循环</strong></p>
</li>
<li class="lvl-4">
<p><strong>Python For Loop</strong></p>
</li>
<li class="lvl-4">
<p><strong>Python While Loop</strong></p>
</li>
</ul>
<h2 id="Python-数据结构">Python 数据结构</h2>
<p>数据结构是指可以将一些数据保存在一起的结构，或者我们说它们是用来以有组织的方式存储数据的。Python 提供了内置的数据结构，如<strong>列表、元组、字典和集合</strong>。我们可以使用数据结构执行复杂的任务。</p>
<h3 id="Python-列表-2">Python 列表</h3>
<p>Python 列表保存有序的项目集合。我们可以在列表中存储一系列项目。Python 列表是可变的，这意味着它可以在创建后进行修改。列表项目包含在方括号[]内，用逗号分隔。让我们看看列表的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">L1 = [<span class="string">&quot;John&quot;</span>, <span class="number">102</span>, <span class="string">&quot;USA&quot;</span>]    </span><br><span class="line">L2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果我们尝试使用 <strong>type()</strong> 函数打印 L1、L2 和 L3 的类型，那么它将显示为一个列表。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(L1))  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(L2))  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要了解有关 list 的更多信息，请访问以下教程。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Python 列表</strong></p>
</li>
<li class="lvl-4">
<p><strong>Python 列表函数</strong></p>
</li>
</ul>
<h3 id="Python-元组">Python 元组</h3>
<p>Python Tuple 用于存储不可变 Python 对象的序列。元组类似于列表，因为存储在列表中的项目的值可以改变，而元组是不可变的，并且存储在元组中的项目的值不能改变。</p>
<p>元组可以定义如下</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tup = (<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Mango&quot;</span> , <span class="string">&quot;Orange&quot;</span> , <span class="string">&quot;Banana&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(tup))</span><br><span class="line"><span class="built_in">print</span>(tup)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line">(<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Mango&#x27;</span>, <span class="string">&#x27;Orange&#x27;</span>, <span class="string">&#x27;Banana&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果我们试图向元组中添加新的，它将抛出一个错误。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tup = (<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Mango&quot;</span> , <span class="string">&quot;Orange&quot;</span> , <span class="string">&quot;Banana&quot;</span>)</span><br><span class="line"></span><br><span class="line">tup[<span class="number">2</span>] = <span class="string">&quot;Papaya&quot;</span></span><br><span class="line"><span class="built_in">print</span>(tup)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;C:/Users/DEVANSH SHARMA/PycharmProjects/Hello/gamewithturtle.py&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> tup[<span class="number">2</span>] = <span class="string">&quot;Papaya&quot;</span></span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment </span><br></pre></td></tr></table></figure>
<p>上面的程序抛出了一个错误，因为元组是不可变的类型。要了解更多关于元组的信息，请访问 Python 元组。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Python 元组</strong></p>
</li>
</ul>
<h3 id="Python-字符串-2">Python 字符串</h3>
<p>Python 字符串是一个字符序列。它是由单引号、双引号或三引号括起来的字符的集合。它也可以定义为 Unicode 字符的集合。我们可以如下创建一个字符串。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creating string using double quotes</span></span><br><span class="line">str1 = <span class="string">&quot;Hi Python&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str1)</span><br><span class="line"><span class="comment"># Creating string using single quotes</span></span><br><span class="line">str1 = <span class="string">&#x27;Hi Python&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(str1)</span><br><span class="line"><span class="comment"># Creating string using triple quotes</span></span><br><span class="line">str1 = <span class="string">&#x27;&#x27;&#x27;Hi Python&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(str1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Hi Python</span><br><span class="line">Hi Python</span><br><span class="line">Hi Python</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Python 不支持字符数据类型。写为“p”的单个字符被视为长度为 1 的字符串。</p>
<p>刺痛也是不可改变的。声明后我们不能改变。要了解有关字符串的更多信息，请访问以下教程。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Python 串</strong></p>
</li>
<li class="lvl-4">
<p><strong>Python 串法</strong></p>
</li>
</ul>
<h3 id="字典-2">字典</h3>
<p>Python 字典是一种最高效的数据结构，用于存储大量数据。它以键值对格式存储数据。每个值都与其键相对应地存储。</p>
<p>键必须是唯一的，值可以是任何类型，如整数、列表、元组等。</p>
<p>它是一个可变类型；我们可以在它创建后重新分配。下面是用 Python 创建字典的例子。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">employee = &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">29</span>, <span class="string">&quot;salary&quot;</span>:<span class="number">250000</span>,<span class="string">&quot;Company&quot;</span>:<span class="string">&quot;GOOGLE&quot;</span>&#125;    </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(employee))    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;printing Employee data .... &quot;</span>)    </span><br><span class="line"><span class="built_in">print</span>(employee)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line">Printing Employee data .... </span><br><span class="line">&#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">29</span>, <span class="string">&#x27;salary&#x27;</span>: <span class="number">250000</span>, <span class="string">&#x27;Company&#x27;</span>: <span class="string">&#x27;GOOGLE&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>空花括号{}用于创建空字典。要了解更多信息，请访问字典的完整教程。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Python 字典</strong></p>
</li>
<li class="lvl-4">
<p><strong>Python 字典方法</strong></p>
</li>
</ul>
<h3 id="Python-集">Python 集</h3>
<p>Python 集是无序元素的集合。集合中的每个元素必须是唯一且不可变的。集合是可变的，这意味着我们可以在整个程序中随时修改。让我们了解一下用 Python 创建集合的例子。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creating Set</span></span><br><span class="line">Month = &#123;<span class="string">&quot;January&quot;</span>, <span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>, <span class="string">&quot;July&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(Month)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Month))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;March&#x27;</span>, <span class="string">&#x27;July&#x27;</span>, <span class="string">&#x27;April&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;June&#x27;</span>, <span class="string">&#x27;February&#x27;</span>, <span class="string">&#x27;January&#x27;</span>&#125;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;set&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要获得关于器械包的更多信息，请访问以下资源。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Python 套装</strong></p>
</li>
<li class="lvl-4">
<p><strong>Python 设置方法</strong></p>
</li>
</ul>
<h2 id="Python-函数式编程">Python 函数式编程</h2>
<p>Python 教程的这一部分定义了一些与函数式编程相关的重要工具，比如 <strong>lambda 和递归函数</strong>。这些功能在完成复杂任务时非常有效。我们定义了几个重要的功能，比如<strong>减少、映射、<strong>和</strong>过滤。</strong> Python 提供了包含各种<strong>功能编程工具</strong>的<strong>功能工具</strong>模块。请访问下面的教程，了解更多关于函数式编程的知识。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>Python 函数</p>
</li>
<li class="lvl-4">
<p>Python 映射()函数</p>
</li>
<li class="lvl-4">
<p>Python 过滤器()函数</p>
</li>
<li class="lvl-4">
<p>Python reduce()函数</p>
</li>
<li class="lvl-4">
<p>python functools 模块</p>
</li>
<li class="lvl-4">
<p>Python 函数</p>
</li>
</ul>
<h2 id="Python-文件输入-输出">Python 文件输入/输出</h2>
<p>文件用于在计算机磁盘中存储数据。在本教程中，我们将解释 Python 的内置文件对象。我们可以使用 Python 脚本打开一个文件，并执行各种操作，如写入、读取和追加。打开文件有多种方法。我们用相关的例子来解释。我们还将学习对二进制文件执行读/写操作。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Python 文件输入输出</strong></p>
</li>
</ul>
<h2 id="Python-模块">Python 模块</h2>
<p>Python 模块是包含 Python 代码或函数的程序文件。Python 中有两种类型的模块——用户定义模块和内置模块。用户定义的模块，或者我们可以说我们的 Python 代码是用<strong>保存的。py</strong> 扩展，被视为用户自定义模块。</p>
<p>内置模块是 Python 的预定义模块。为了使用模块的功能，我们需要将它们导入到我们当前的工作程序中。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Python 模块</strong></p>
</li>
</ul>
<h2 id="Python-异常">Python 异常</h2>
<p>异常可以定义为程序中导致程序流程中断的异常。</p>
<p>每当出现异常时，程序就会停止执行，因此不会执行下一个代码。因此，一个异常是无法处理 Python 脚本的运行时错误。异常是表示错误的 Python 对象。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Python 异常</strong></p>
</li>
</ul>
<h2 id="Python-CSV-文件">Python CSV 文件</h2>
<p>A <strong>csv</strong> 代表“逗号分隔值”，它被定义为一种简单的文件格式，使用特定的结构来排列表格数据。它以纯文本形式存储表格数据，如电子表格或数据库，并具有通用的数据交换格式。一个 <strong>csv</strong> 文件打开到 excel 表中，行和列数据定义了标准格式。请访问以下教程，详细了解 CSV 模块。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Python 读取 CSV 文件</strong></p>
</li>
<li class="lvl-4">
<p><strong>Python 编写 CSV 文件</strong></p>
</li>
</ul>
<h2 id="Python-发送邮件">Python 发送邮件</h2>
<p>我们可以使用 Python 脚本发送或阅读邮件。Python 的标准库模块对于处理各种协议很有用，比如 PoP3 和 IMAP。我们将从 Python 脚本中学习如何使用流行的电子邮件服务 SMTP 发送邮件。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Python 发送邮件</strong></p>
</li>
</ul>
<h2 id="Python-魔术方法">Python 魔术方法</h2>
<p>Python 魔法方法被定义为给类增加“魔法”的特殊方法。它以双下划线开始和结束，例如， <strong><em>init</em></strong> 或 <strong><em>str</em>。</strong></p>
<p>内置类定义了许多神奇的方法。 <strong>dir()</strong> 函数可以用来查看一个类继承的魔法方法的数量。它在方法名中有两个前缀和后缀下划线。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Python 魔法</strong></p>
</li>
</ul>
<h2 id="Python-糟糕的概念">Python 糟糕的概念</h2>
<p>Python 中的一切都被视为一个对象，包括整数值、浮点、函数、类和无。除此之外，Python 支持所有面向概念。下面是 Python 的 oops 概念的简要介绍。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>类和对象-</strong> Python 类是对象的蓝图。对象是数据和作用于数据的方法的集合。</p>
</li>
<li class="lvl-4">
<p><strong>继承-</strong> 继承是一种技术，其中一个类继承其他类的属性。</p>
</li>
<li class="lvl-4">
<p><strong>构造器-</strong> Python 提供了一种特殊的方法 <strong><strong>init</strong>()</strong> ，被称为构造器。当对象实例化时，会自动调用此方法。</p>
</li>
<li class="lvl-4">
<p><strong>数据成员-</strong> 保存与类及其对象相关联的数据的变量。</p>
</li>
</ul>
<p>要详细阅读 oops 概念，请访问以下资源。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Python 哎呀概念</strong></p>
</li>
<li class="lvl-4">
<p><strong>Python 对象和类</strong></p>
</li>
<li class="lvl-4">
<p><strong>Python 构造器</strong></p>
</li>
<li class="lvl-4">
<p><strong>Python 继承</strong></p>
</li>
<li class="lvl-4">
<p><strong>Python 多态性</strong></p>
</li>
</ul>
<h2 id="Python-高级主题">Python 高级主题</h2>
<p>Python 包含许多先进而有用的概念，可以帮助程序员解决复杂的任务。这些概念在下面给出。</p>
<h3 id="Python-迭代器">Python 迭代器</h3>
<p>迭代器只是一个可以迭代的对象。它一次返回一个对象。可以使用两种特殊的方法来实现， <strong><strong>iter</strong>()和 <strong>next</strong>()</strong> 。</p>
<p>要了解更多关于迭代器的信息，请访问我们的 <strong>Python 迭代器</strong>教程。</p>
<h3 id="Python-生成器">Python 生成器</h3>
<p>生成器是创建迭代器最简单的方法。要了解更多信息，请访问我们的 <strong>Python 生成器</strong>教程。</p>
<h3 id="Python-装饰器">Python 装饰器</h3>
<p>这些用于修改函数的行为。装饰者提供了包装另一个函数的灵活性，以扩展包装函数的工作，而无需永久修改它。</p>
<p>要了解更多信息，请访问 <strong>Python 装饰器</strong>教程。</p>
<h2 id="Python-数据库连接">Python 数据库连接</h2>
<p>我们可以使用各种数据库和 Python。您可以通过访问下面的资源来学习完整的教程。Python DBI-API 认可标准功能集，这些功能集将包含在各个关系数据库管理系统产品的数据库连接模块中。我们使用 Python DBI API 解释所有重要的数据库连接。</p>
<h3 id="python-语言">python 语言</h3>
<p>环境设置</p>
<p>数据库连接</p>
<p>创建新数据库</p>
<p>创建表格</p>
<p>插入操作</p>
<p>读取操作</p>
<p>更新操作</p>
<p>连接操作</p>
<p>执行交易</p>
<h3 id="Python-MongoDB">Python MongoDB</h3>
<p>Python MongoDB</p>
<h3 id="Python-SQLite">Python SQLite</h3>
<p>Python SQLite</p>
<h2 id="Python-CGI">Python CGI</h2>
<p>Python CGI 代表**“公共网关接口”，**，用于定义如何在网络服务器和自定义 Python 脚本之间交换信息。<strong>通用网关接口</strong>是外部网关程序与服务器接口的标准，如 HTTP 服务器。要了解更多关于 Python CGI 的信息，请访问下面的教程。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Python CGI</strong></p>
</li>
</ul>
<h2 id="先决条件">先决条件</h2>
<p>在学习 Python 之前，您必须具备编程概念的基本知识。</p>
<h2 id="观众">观众</h2>
<p>我们的 Python 教程旨在帮助初学者和专业人士。</p>
<h2 id="问题">问题</h2>
<p>我们保证您在本 Python 教程中不会发现任何问题。但是如果有任何错误，请在联系表格中发布问题。</p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 编写 CSV 文件</title>
    <url>/posts/57719496.html</url>
    <content><![CDATA[<h1>Python 编写 CSV 文件</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-write-csv-file">https://www.javatpoint.com/python-write-csv-file</a></p>
</blockquote>
<h2 id="CSV-文件">CSV 文件</h2>
<p>CSV 代表“逗号分隔值”，它被定义为一种简单的文件格式，使用特定的结构来排列表格数据。它以纯文本存储表格数据，如电子表格或数据库，并具有数据交换的标准格式。CSV 文件在 excel 工作表中打开，行和列数据定义了标准格式。</p>
<h2 id="Python-CSV-模块函数">Python CSV 模块函数</h2>
<p>CSV 模块的工作是处理 CSV 文件，以便从指定的列中读取/写入和获取数据。CSV 函数有不同的类型。</p>
<h2 id="编写-CSV-文件">编写 CSV 文件</h2>
<p>我们还可以使用 csv.writer()模块用 Python 编写任何新的和现有的 CSV 文件。它类似于 csv.reader()模块，也有两种方法，即 <strong>writer</strong> 函数或 <strong>Dict Writer</strong> 类。</p>
<p>它呈现两个功能，即 <strong>writerow()</strong> 和<strong>write row()</strong>。 <strong>writerow()</strong> 函数只写一行，而**writerow()**函数写多行。<br>
<strong>方言</strong></p>
<p>它被定义为允许您创建、存储和重用各种格式参数的构造。它支持几个属性；最常用的是:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Dialect.delimiter:</strong> 该属性用作字段之间的分隔字符。默认值是逗号(，)。</p>
</li>
<li class="lvl-4">
<p><strong>Dialect.quotechar:</strong> 此属性用于引用包含特殊字符的字段。</p>
</li>
<li class="lvl-4">
<p><strong>Dialect.lineterminator:</strong> 用于新建线路，默认值为’ \r\n '。</p>
</li>
</ul>
<p>让我们将以下数据写入 CSV 文件。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">data = [&#123;<span class="string">&#x27;Rank&#x27;</span>: <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;first_name&#x27;</span>: <span class="string">&#x27;Parker&#x27;</span>, <span class="string">&#x27;last_name&#x27;</span>: <span class="string">&#x27;Brian&#x27;</span>&#125;,   </span><br><span class="line">&#123;<span class="string">&#x27;Rank&#x27;</span>: <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;first_name&#x27;</span>: <span class="string">&#x27;Smith&#x27;</span>, <span class="string">&#x27;last_name&#x27;</span>: <span class="string">&#x27;Rodriguez&#x27;</span>&#125;,  </span><br><span class="line">&#123;<span class="string">&#x27;Rank&#x27;</span>: <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;first_name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;last_name&#x27;</span>: <span class="string">&#x27;smith&#x27;</span>&#125;,  </span><br><span class="line">&#123;<span class="string">&#x27;Rank&#x27;</span>: <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;first_name&#x27;</span>: <span class="string">&#x27;Jane&#x27;</span>, <span class="string">&#x27;last_name&#x27;</span>: <span class="string">&#x27;Oscar&#x27;</span>&#125;,   </span><br><span class="line">&#123;<span class="string">&#x27;Rank&#x27;</span>: <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;first_name&#x27;</span>: <span class="string">&#x27;Alex&#x27;</span>, <span class="string">&#x27;last_name&#x27;</span>: <span class="string">&#x27;Tim&#x27;</span>&#125;]  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="示例-3">示例-</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> csv  </span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;Python.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> csvfile:  </span><br><span class="line">    fieldnames = [<span class="string">&#x27;first_name&#x27;</span>, <span class="string">&#x27;last_name&#x27;</span>, <span class="string">&#x27;Rank&#x27;</span>]  </span><br><span class="line">    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)  </span><br><span class="line"></span><br><span class="line">    writer.writeheader()  </span><br><span class="line">    writer.writerow(&#123;<span class="string">&#x27;Rank&#x27;</span>: <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;first_name&#x27;</span>: <span class="string">&#x27;Parker&#x27;</span>, <span class="string">&#x27;last_name&#x27;</span>: <span class="string">&#x27;Brian&#x27;</span>&#125;)  </span><br><span class="line">    writer.writerow(&#123;<span class="string">&#x27;Rank&#x27;</span>: <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;first_name&#x27;</span>: <span class="string">&#x27;Smith&#x27;</span>,  </span><br><span class="line">                     <span class="string">&#x27;last_name&#x27;</span>: <span class="string">&#x27;Rodriguez&#x27;</span>&#125;)  </span><br><span class="line">    writer.writerow(&#123;<span class="string">&#x27;Rank&#x27;</span>: <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;first_name&#x27;</span>: <span class="string">&#x27;Jane&#x27;</span>, <span class="string">&#x27;last_name&#x27;</span>: <span class="string">&#x27;Oscar&#x27;</span>&#125;)  </span><br><span class="line">    writer.writerow(&#123;<span class="string">&#x27;Rank&#x27;</span>: <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;first_name&#x27;</span>: <span class="string">&#x27;Jane&#x27;</span>, <span class="string">&#x27;last_name&#x27;</span>: <span class="string">&#x27;Loive&#x27;</span>&#125;)  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Writing complete&quot;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Writing complete</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它返回名为“Python.csv”的文件，其中包含以下数据:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">first_name,last_name,Rank  </span><br><span class="line">Parker,Brian,B  </span><br><span class="line">Smith,Rodriguez,A  </span><br><span class="line">Jane,Oscar,B  </span><br><span class="line">Jane,Loive,B   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="将-CSV-写入字典">将 CSV 写入字典</h2>
<p>我们也可以使用类 <strong>DictWriter</strong> 将 CSV 文件直接写入字典。</p>
<p>名为 python.csv 的文件包含以下数据:</p>
<p>帕克，会计，11 月</p>
<p>史密斯，信息技术，10 月</p>
<h3 id="示例-4">示例-</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> csv  </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;python.csv&#x27;</span>, mode=<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> csv_file:  </span><br><span class="line">    fieldnames = [<span class="string">&#x27;emp_name&#x27;</span>, <span class="string">&#x27;dept&#x27;</span>, <span class="string">&#x27;birth_month&#x27;</span>]  </span><br><span class="line">    writer = csv.DictWriter(csv_file, fieldnames=fieldnames)  </span><br><span class="line">    writer.writeheader()  </span><br><span class="line">    writer.writerow(&#123;<span class="string">&#x27;emp_name&#x27;</span>: <span class="string">&#x27;Parker&#x27;</span>, <span class="string">&#x27;dept&#x27;</span>: <span class="string">&#x27;Accounting&#x27;</span>, <span class="string">&#x27;birth_month&#x27;</span>: <span class="string">&#x27;November&#x27;</span>&#125;)  </span><br><span class="line">    writer.writerow(&#123;<span class="string">&#x27;emp_name&#x27;</span>: <span class="string">&#x27;Smith&#x27;</span>, <span class="string">&#x27;dept&#x27;</span>: <span class="string">&#x27;IT&#x27;</span>, <span class="string">&#x27;birth_month&#x27;</span>: <span class="string">&#x27;October&#x27;</span>&#125;)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">emp_name,dept,birth_month</span><br><span class="line">Parker,Accounting,November</span><br><span class="line">Smith,IT,October</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="用-Pandas-编写-CSV-文件">用 Pandas 编写 CSV 文件</h2>
<p>Pandas 被定义为建立在 Numpy 库之上的开源库。它为用户提供快速分析、数据清理和数据准备。</p>
<p>就像用 Pandas 读 CSV 文件一样简单。您需要创建 DataFrame，它是一个二维、异构的表格数据结构，由三个主要组件组成——数据、列和行。在这里，我们要读取一个稍微复杂一点的文件，名为 hrdata.csv，其中包含公司员工的数据。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Name,Hire Date,Salary,Leaves Remaining  </span><br><span class="line">John Idle,08/<span class="number">15</span>/<span class="number">14</span>,<span class="number">50000.00</span>,<span class="number">10</span>  </span><br><span class="line">Smith Gilliam,04/07/<span class="number">15</span>,<span class="number">65000.00</span>,<span class="number">8</span>  </span><br><span class="line">Parker Chapman,02/<span class="number">21</span>/<span class="number">14</span>,<span class="number">45000.00</span>,<span class="number">10</span>  </span><br><span class="line">Jones Palin,<span class="number">10</span>/<span class="number">14</span>/<span class="number">13</span>,<span class="number">70000.00</span>,<span class="number">3</span>  </span><br><span class="line">Terry Gilliam,07/<span class="number">22</span>/<span class="number">14</span>,<span class="number">48000.00</span>,<span class="number">7</span>  </span><br><span class="line">Michael Palin,06/<span class="number">28</span>/<span class="number">13</span>,<span class="number">66000.00</span>,<span class="number">8</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="示例-5">示例-</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas  </span><br><span class="line">df = pandas.read_csv(<span class="string">&#x27;hrdata.csv&#x27;</span>,   </span><br><span class="line">            index_col=<span class="string">&#x27;Employee&#x27;</span>,   </span><br><span class="line">            parse_dates=[<span class="string">&#x27;Hired&#x27;</span>],  </span><br><span class="line">            header=<span class="number">0</span>,   </span><br><span class="line">            names=[<span class="string">&#x27;Employee&#x27;</span>, <span class="string">&#x27;Hired&#x27;</span>, <span class="string">&#x27;Salary&#x27;</span>, <span class="string">&#x27;Sick Days&#x27;</span>])  </span><br><span class="line">df.to_csv(<span class="string">&#x27;hrdata_modified.csv&#x27;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Employee, Hired, Salary, Sick Days</span><br><span class="line">John Idle, <span class="number">2014</span>-03-<span class="number">15</span>, <span class="number">50000.0</span>,<span class="number">10</span></span><br><span class="line">Smith Gilliam, <span class="number">2015</span>-06-01, <span class="number">65000.0</span>,<span class="number">8</span></span><br><span class="line">Parker Chapman, <span class="number">2014</span>-05-<span class="number">12</span>, <span class="number">45000.0</span>,<span class="number">10</span></span><br><span class="line">Jones Palin, <span class="number">2013</span>-<span class="number">11</span>-01, <span class="number">70000.0</span>,<span class="number">3</span></span><br><span class="line">Terry Gilliam, <span class="number">2014</span>-08-<span class="number">12</span> , <span class="number">48000.0</span>,<span class="number">7</span></span><br><span class="line">Michael Palin, <span class="number">2013</span>-05-<span class="number">23</span>, <span class="number">66000.0</span>,<span class="number">8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 编写Excel文件</title>
    <url>/posts/40395c62.html</url>
    <content><![CDATA[<h1>Python 编写 Excel 文件</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-write-excel-file">https://www.javatpoint.com/python-write-excel-file</a></p>
</blockquote>
<p>Python write excel 文件用于使用 <strong>xlwt</strong> 模块对电子表格执行多个操作。这是用将数据和格式信息写入文件的理想方式。xls 扩展。</p>
<p>如果您想将数据写入任何文件，并且不想经历自己做所有事情的麻烦，那么您可以使用 <code>for</code>循环来稍微自动化整个过程。</p>
<h2 id="使用-xlsxwriter-模块编写-Excel-文件">使用 xlsxwriter 模块编写 Excel 文件</h2>
<p>我们也可以使用 <strong>xlsxwriter</strong> 模块编写 excel 文件。它被定义为一个 Python 模块，用于以 XLSX 文件格式编写文件。它还可以用于将文本、数字和公式写入多个工作表。此外，它还支持图表、格式、图像、页面设置、自动过滤器、条件格式等功能。</p>
<p>我们需要使用以下命令来安装 xlsxwriter 模块:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install xlsxwriter   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="注意-在整个-XlsxWriter-中，行和列都是零索引的。工作表中的第一个单元格列为，A1-是-0，0-，B1-是-0，1-，A2-是-1，0-，B2-是-1，1-…，等等。">注意-在整个 XlsxWriter 中，行和列都是零索引的。工作表中的第一个单元格列为，A1 是(0，0)，B1 是(0，1)，A2 是(1，0)，B2 是(1，1)…，等等。</h4>
<h2 id="用-openpyxl-模块编写-Excel-文件">用 openpyxl 模块编写 Excel 文件</h2>
<p>它被定义为一个包，如果您想要读写，通常会推荐它。xlsx、xlsm、xltx 和 xltm 文件。可以通过运行<strong>类型(wb)</strong> 进行检查。</p>
<p>load_workbook()函数接受一个参数并返回一个代表文件的 workbook 对象。确保您在电子表格所在的同一目录中。否则，导入时会出现错误。</p>
<p>在 range()函数的帮助下，您可以很容易地使用 <code>for</code>循环来帮助您打印出第 2 列中有值的行的值。如果这些特定的单元格是空的，您将获得无。</p>
<h2 id="用-xlwt-将数据写入-Excel-文件">用 xlwt 将数据写入 Excel 文件</h2>
<p>除了 XlsxWriter 包之外，您还可以使用 xlwt 包来创建包含您的数据的电子表格。它是用于写入数据、格式化信息等的替代包。非常适合用将数据和格式信息写入文件。xls 扩展。它可以对电子表格执行多种操作。</p>
<p>它支持诸如格式、图像、图表、页面设置、自动过滤器、条件格式等功能。</p>
<p>Pandas 有很好的方法从 excel 文件中读取各种数据。我们也可以把结果导入回 Pandas。</p>
<h2 id="用-pyexcel-写文件">用 pyexcel 写文件</h2>
<p>您可以使用 save_as()函数轻松地将数组导出回电子表格，并将目标文件的数组和名称传递给 dest_file_name 参数。</p>
<p>它允许我们指定分隔符并添加 dest_delimiter 参数。您可以传递要用作中间分隔符的符号&quot; &quot;。</p>
<p><strong>代码</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># import xlsxwriter module   </span></span><br><span class="line"><span class="keyword">import</span> xlsxwriter   </span><br><span class="line"></span><br><span class="line">book = xlsxwriter.Book(<span class="string">&#x27;Example2.xlsx&#x27;</span>)   </span><br><span class="line">sheet = book.add_sheet()   </span><br><span class="line"></span><br><span class="line"><span class="comment"># Rows and columns are zero indexed.   </span></span><br><span class="line">row = <span class="number">0</span>  </span><br><span class="line">column = <span class="number">0</span>  </span><br><span class="line"></span><br><span class="line">content = [<span class="string">&quot;Parker&quot;</span>, <span class="string">&quot;Smith&quot;</span>, <span class="string">&quot;John&quot;</span>]   </span><br><span class="line"></span><br><span class="line"><span class="comment"># iterating through the content list   </span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> content :   </span><br><span class="line"></span><br><span class="line">    <span class="comment"># write operation perform   </span></span><br><span class="line">    sheet.write(row, column, item)   </span><br><span class="line"></span><br><span class="line">    <span class="comment"># incrementing the value of row by one with each iterations.   </span></span><br><span class="line">    row += <span class="number">1</span>  </span><br><span class="line"></span><br><span class="line">book.close()   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<p><img src="/img/e6611a713395d80bdc84551db2e656c3.png" alt="Python Write Excel File"></p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 装饰器</title>
    <url>/posts/d89d2c35.html</url>
    <content><![CDATA[<h1>Python 装饰器</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-decorator">https://www.javatpoint.com/python-decorator</a></p>
</blockquote>
<p>装饰器是 Python 最有用和最强大的工具之一。这些用于修改函数的行为。装饰器提供了包装另一个函数的灵活性，以扩展包装函数的工作，而无需永久修改它。</p>
<blockquote>
<p>在 Decorators 中，函数作为参数传递给另一个函数，然后在包装函数中调用。</p>
</blockquote>
<p>它也被称为<strong>元编程</strong>，程序的一部分试图在编译时改变程序的另一部分。</p>
<p>在理解<strong>装饰器</strong>之前，我们需要了解 Python 的一些重要概念。</p>
<h2 id="Python-中有哪些函数？">Python 中有哪些函数？</h2>
<p>Python 有一个最有趣的特性，那就是所有的东西都被当作一个对象，甚至我们在 Python 中定义的类或者任何变量也被假定为一个对象。函数是 Python 中的第一类对象，因为它们可以引用、传递给变量以及从其他函数返回。示例如下:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">msg</span>):</span><br><span class="line">    <span class="built_in">print</span>(msg)</span><br><span class="line">func1(<span class="string">&quot;Hii&quot;</span>)</span><br><span class="line">func2 = func1</span><br><span class="line">func2(<span class="string">&quot;Hii&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Hii</span><br><span class="line">Hii</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的程序中，当我们运行代码时，它为两个函数提供了相同的输出。<strong>功能 2</strong> 指功能<strong>功能 1</strong> 并作为功能。我们需要理解函数的以下概念:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>该函数可以被引用并传递给变量，也可以从其他函数返回。</p>
</li>
<li class="lvl-4">
<p>这些函数可以在另一个函数中声明，并作为参数传递给另一个函数。</p>
</li>
</ul>
<h2 id="内部函数">内部函数</h2>
<p>Python 提供了在另一个函数中定义函数的工具。这些类型的函数称为内部函数。考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;We are in first function&quot;</span>)</span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">&quot;This is first child function&quot;</span>)</span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">&quot; This is second child function&quot;</span>)</span><br><span class="line">     func1()</span><br><span class="line">     func2()</span><br><span class="line">func()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">We are <span class="keyword">in</span> first function</span><br><span class="line">This <span class="keyword">is</span> first child function</span><br><span class="line">This <span class="keyword">is</span> second child function</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的程序中，子函数是如何声明的并不重要。子函数的执行会对输出产生影响。这些子函数与**函数()**局部有界，因此不能单独调用。</p>
<p>接受其他函数作为自变量的函数也称为<strong>高阶函数</strong>。考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x+<span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x-<span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">operator</span>(<span class="params">func, x</span>):</span><br><span class="line">    temp = func(x)</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line"><span class="built_in">print</span>(operator(sub,<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(operator(add,<span class="number">20</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的程序中，我们已经将 <strong>sub()</strong> 函数和 <strong>add()</strong> 函数作为参数传递给了 <strong>operator()</strong> 函数。</p>
<p>一个函数可以返回另一个函数。考虑下面的例子:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hi</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> hi</span><br><span class="line">new = hello()</span><br><span class="line">new()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Hello</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的程序中， <strong>hi()</strong> 函数嵌套在 <strong>hello()</strong> 函数中。每次我们呼叫 <strong>hi()</strong> 它都会返回。</p>
<h3 id="用参数装饰函数">用参数装饰函数</h3>
<p>让我们举一个例子来理解参数化装饰函数:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="built_in">print</span>(x/y)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer_div</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">x,y</span>):</span><br><span class="line">        <span class="keyword">if</span>(x</span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">2.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="语法装饰器">语法装饰器</h3>
<p>在上面的程序中，我们已经修饰了 <strong>out_div()</strong> 有点笨重。Python 不使用上述方法，而是允许<strong>用@符号</strong>轻松使用装饰器。有时它被称为“馅饼”语法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer_div</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">x,y</span>):</span><br><span class="line">        <span class="keyword">if</span>(x</span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">2.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="重用装饰器">重用装饰器</h3>
<p>我们也可以通过调用装饰函数来重用装饰器。让我们把装饰器做成它自己的模块，可以用在许多其他功能中。使用以下代码创建名为 <strong>mod_decorator.py</strong> 的文件:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_twice</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper_do_twice</span>():</span><br><span class="line">        func()</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> wrapper_do_twice</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以在其他文件中导入 mod_decorator.py。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> decorator <span class="keyword">import</span> do_twice</span><br><span class="line"><span class="meta">@do_twice</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello There&quot;</span>)</span><br><span class="line">say_hello()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Hello There</span><br><span class="line">Hello There</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="带参数的-Python-装饰器">带参数的 Python 装饰器</h3>
<p>我们想在函数中传递一些参数。让我们用下面的代码来实现:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> decorator <span class="keyword">import</span> do_twice</span><br><span class="line"><span class="meta">@do_twice</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">name</span>):</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">f&quot;Hello <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">display()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">TypeError: display() missing <span class="number">1</span> required positional argument: <span class="string">&#x27;name&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以看到，函数没有接受这个参数。运行此代码会引发错误。我们可以通过在内包装函数中使用 <em><strong>args</strong> 和 **<strong>kwargs</strong> 来修复这个错误。如下修改</em><em>装饰器:</em>*</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_twice</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper_function</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        func(*args,**kwargs)</span><br><span class="line">        func(*args,**kwargs)</span><br><span class="line">   <span class="keyword">return</span> wrapper_function</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在 <strong>wrapper_function()</strong> 可以接受任意数量的参数，并将它们传递给函数。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> decorator <span class="keyword">import</span> do_twice</span><br><span class="line"><span class="meta">@do_twice</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">name</span>):</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">f&quot;Hello <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">display(<span class="string">&quot;John&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Hello John</span><br><span class="line">Hello John</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="从修饰函数返回值">从修饰函数返回值</h3>
<p>我们可以控制修饰函数的返回类型。示例如下:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> decorator <span class="keyword">import</span> do_twice</span><br><span class="line"><span class="meta">@do_twice</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">return_greeting</span>(<span class="params">name</span>):</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;We are created greeting&quot;</span>)</span><br><span class="line">     <span class="keyword">return</span> <span class="string">f&quot;Hi <span class="subst">&#123;name&#125;</span>&quot;</span></span><br><span class="line">hi_adam = return_greeting(<span class="string">&quot;Adam&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">We are created greeting</span><br><span class="line">We are created greeting</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="高级装饰师">高级装饰师</h2>
<p>让我们通过以下话题来了解一下高级装饰师:</p>
<h3 id="阶级装饰者">阶级装饰者</h3>
<p>Python 提供了两种修饰类的方法。首先，我们可以在一个类里面修饰方法；Python 中有像 <strong>@classmethod、@staticmethod</strong> 、 <strong>@property</strong> 这样的内置装饰器。 <strong>@classmethod</strong> 和 <strong>@staticmethod</strong> 定义了类内不与类的任何其他实例连接的方法。@属性通常用于修改类属性的 getters 和 setters。让我们通过下面的例子来理解它:</p>
<p>示例:1-<strong>@属性装饰器</strong> -通过使用它，我们可以使用类函数作为属性。考虑以下代码:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,grade</span>):</span><br><span class="line">         self.name = name</span><br><span class="line">         self.grade = grade</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">         <span class="keyword">return</span> self.name + <span class="string">&quot; got grade &quot;</span> + self.grade</span><br><span class="line"></span><br><span class="line">stu = Student(<span class="string">&quot;John&quot;</span>,<span class="string">&quot;B&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Name:&quot;</span>, stu.name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Grade:&quot;</span>, stu.grade)</span><br><span class="line"><span class="built_in">print</span>(stu.display)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Name: John</span><br><span class="line">Grade: B</span><br><span class="line">John got grade B</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>示例:2-<strong>@staticmethod decorator</strong>-该@ static method 用于定义类中的一个静态方法。它通过使用类名和类的实例来调用。考虑以下代码:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line"><span class="meta">     @staticmethod</span></span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&quot;Hello Peter&quot;</span>)</span><br><span class="line">per = Person()</span><br><span class="line">per.hello()</span><br><span class="line">Person.hello()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Hello Peter</span><br><span class="line">Hello Peter</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="单例类">单例类</h3>
<p>单例类只有一个实例。Python 中有很多单例，包括 True、None 等。</p>
<h3 id="嵌套装饰者">嵌套装饰者</h3>
<p>我们可以通过将多个装饰器放在一起来使用它们。让我们考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@function1</span></span><br><span class="line"><span class="meta">@function2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>(<span class="params">name</span>):</span><br><span class="line">      <span class="built_in">print</span>(f <span class="string">&quot;&#123;name&#125;&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们通过将嵌套装饰器堆叠在一起来使用它们。</p>
<h3 id="带参数的装饰器">带参数的装饰器</h3>
<p>在装饰器中传递参数总是有用的。根据给定的参数值，装饰器可以执行几次。让我们考虑下面的例子:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Import functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">repeat</span>(<span class="params">num</span>):</span><br><span class="line"></span><br><span class="line"><span class="comment">#Creating and returning a wrapper function</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator_repeat</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">        @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">                value = func(*args,**kwargs)</span><br><span class="line">             <span class="keyword">return</span> value</span><br><span class="line">          <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator_repeat</span><br><span class="line"></span><br><span class="line"><span class="comment">#Here we are passing num as an argument which repeats the print function</span></span><br><span class="line"><span class="meta">@repeat(<span class="params">num=<span class="number">5</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function1</span>(<span class="params">name</span>):</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">JavatPoint</span><br><span class="line">JavatPoint</span><br><span class="line">JavatPoint</span><br><span class="line">JavatPoint</span><br><span class="line">JavatPoint</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上例中， <strong>@repeat</strong> 指的是可以在另一个函数中调用的函数对象。 <strong>@repeat(num = 5)</strong> 将返回一个充当装饰器的函数。</p>
<p>上面的代码看起来可能很复杂，但它是最常用的装饰器模式，我们使用了一个额外的 <strong>def</strong> 来处理装饰器的参数。</p>
<h4 id="注意-带参数的-Decorator-在编程中并不常用，但它提供了灵活性。不管有没有争论，我们都可以使用它。">注意:带参数的 Decorator 在编程中并不常用，但它提供了灵活性。不管有没有争论，我们都可以使用它。</h4>
<h3 id="有状态装饰器">有状态装饰器</h3>
<p>有状态装饰器用于跟踪装饰器状态。让我们考虑这样一个例子，我们正在创建一个装饰器，计算函数被调用的次数。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Import functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_function</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">@functools.wraps(<span class="params">func</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wrapper_count_calls</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">wrapper_count_calls.num_calls += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Call<span class="subst">&#123;wrapper_count_calls.num_calls&#125;</span> of <span class="subst">&#123;func.__name__!r&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">wrapper_count_calls.num_calls = <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> wrapper_count_calls</span><br><span class="line"></span><br><span class="line"><span class="meta">@count_function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Say Hello&quot;</span>)</span><br><span class="line"></span><br><span class="line">say_hello()</span><br><span class="line">say_hello()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Call <span class="number">1</span> of <span class="string">&#x27;say_hello&#x27;</span></span><br><span class="line">Say Hello</span><br><span class="line">Call <span class="number">2</span> of <span class="string">&#x27;say_hello&#x27;</span></span><br><span class="line">Say Hello</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上述程序中，状态表示存储在<strong>中的函数的调用次数。num _ 调用包装函数上的</strong>。当我们调用 <strong>say_hello()</strong> 时，它会显示该函数的调用次数。</p>
<h3 id="装饰类">装饰类</h3>
<p>类是保持状态的最佳方式。在这一节中，我们将学习如何使用类作为装饰器。这里我们将创建一个包含 <strong><strong>init</strong>()</strong> 的类，并将<strong>函数</strong>作为参数。该类需要是可调用的，这样它就可以代替修饰函数。</p>
<p>为了使类可调用，我们实现了特殊的 <strong><strong>call</strong>()</strong> 方法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Count_Calls</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">functools.update_wrapper(self, func)</span><br><span class="line">self.func = func</span><br><span class="line">self.num_calls = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">self.num_calls += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Call<span class="subst">&#123;self.num_calls&#125;</span> of <span class="subst">&#123;self.func.__name__!r&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Count_Calls</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Say Hello&quot;</span>)</span><br><span class="line"></span><br><span class="line">say_hello()</span><br><span class="line">say_hello()</span><br><span class="line">say_hello()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Call <span class="number">1</span> of <span class="string">&#x27;say_hello&#x27;</span></span><br><span class="line">Say Hello</span><br><span class="line">Call <span class="number">2</span> of <span class="string">&#x27;say_hello&#x27;</span></span><br><span class="line">Say Hello</span><br><span class="line">Call <span class="number">3</span> of <span class="string">&#x27;say_hello&#x27;</span></span><br><span class="line">Say Hello</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong><strong>init</strong>()</strong> 方法存储对该函数的引用，并且可以进行任何其他所需的初始化。</p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 网页抓取</title>
    <url>/posts/90ed4a77.html</url>
    <content><![CDATA[<h1>Python 网页抓取</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/web-scraping-using-python">https://www.javatpoint.com/web-scraping-using-python</a></p>
</blockquote>
<h2 id="什么是网页抓取？">什么是网页抓取？</h2>
<p>网页抓取是一种从几个网站中提取大量数据的技术。术语**“抓取”<strong>是指从另一个来源(网页)获取信息并将其保存到本地文件中。例如:假设你正在做一个名为</strong>“手机比较网站”**的项目，你需要手机的价格、收视率和型号名称来比较不同的手机。如果你通过查看各种网站来收集这些细节，将会花费很多时间。在这种情况下，网络废弃扮演了一个重要的角色，通过编写几行代码，你可以得到想要的结果。</p>
<p><img src="/img/8a37123f170e26989b070b36174b9399.png" alt="Web Scraping Using Python"></p>
<p>网络抓取以非结构化格式从网站中提取数据。它有助于收集这些非结构化数据并将其转换为结构化形式。</p>
<p>初创公司更喜欢网络抓取，因为这是一种廉价而有效的获取大量数据的方式，而无需与数据销售公司建立任何合作关系。</p>
<h2 id="网络报废合法吗？">网络报废合法吗？</h2>
<p>这里就出现了<strong>抓取是否合法的问题</strong>。答案是有些网站允许合法使用。网页抓取只是一个工具，你可以用正确的方式或错误的方式使用它。</p>
<p>如果有人试图抓取非公开数据，网络抓取是非法的。并非所有人都能获得非公开数据；如果你试图提取这样的数据，那就违反了法律条款。</p>
<p>有几种工具可以从网站上抓取数据，例如:</p>
<p>Scrapping-bot<br>
Scrapper API<br>
Octoparse<br>
<a href="http://Import.io">Import.io</a><br>
<a href="http://Webhose.io">Webhose.io</a><br>
<a href="http://Dexi.io">Dexi.io</a><br>
Outwit<br>
Diffbot<br>
Content Grabber<br>
Mozenda<br>
Web Scrapper Chrome Extension</p>
<h2 id="为什么要拆网？">为什么要拆网？</h2>
<p><img src="/img/de495825f19a481c0775844e92002403.png" alt="Web Scraping Using Python"></p>
<p>正如我们上面所讨论的，网络爬取被用来从网站中提取数据。但是我们应该知道如何使用原始数据。原始数据可以用于各种领域。让我们来看看网络报废的用法:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>动态价格监控</strong></p>
</li>
</ul>
<p>它被广泛用于从几个在线购物网站收集数据，比较产品价格，并做出有利可图的定价决策。使用网络爬取数据的价格监控使公司能够了解市场状况并促进动态定价。这确保了他们的公司总是高于其他公司。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>市场调研</strong></p>
</li>
</ul>
<p>爬虫完全适合市场趋势分析。它正在获得对特定市场的洞察。大型组织需要大量数据，而网络报废为数据提供了可靠和准确的保证。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>邮件收集</strong></p>
</li>
</ul>
<p>许多公司使用个人电子邮件数据进行电子邮件营销。他们可以针对特定的受众进行营销。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>新闻和内容监控</strong></p>
</li>
</ul>
<p>一个单一的新闻周期可以对你的业务产生显著的影响或真正的威胁。如果你的公司依赖于一个组织的新闻分析，它经常出现在新闻中。因此，网页抓取为监控和解析最关键的故事提供了终极解决方案。新闻文章和社交媒体平台可以直接影响股市。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>社交媒体报废</strong></p>
</li>
</ul>
<p>网络爬取在从**推特、脸书、**和 **Instagram、**等社交媒体网站上提取数据以找到热门话题方面发挥着至关重要的作用。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>研发</strong></p>
</li>
</ul>
<p>从网站上报废<strong>一般信息、统计数据、温度</strong>等大数据集，分析后用于开展调查或研发。</p>
<h2 id="为什么要用-Python-进行网页报废？">为什么要用 Python 进行网页报废？</h2>
<p>还有其他流行的编程语言，但是为什么我们选择 <a href="https://www.javatpoint.com/python-tutorial">Python</a> 而不是其他编程语言来进行网页抓取呢？下面我们将描述 Python 的一些特性，这些特性使得 Python 成为最有用的网络废弃编程语言。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>动态键入</strong></p>
</li>
</ul>
<p>在 Python 中，我们不需要为变量定义数据类型；我们可以在任何需要的地方直接使用这个变量。它节省时间，使任务更快。Python 定义了它的类来识别变量的数据类型。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>庞大的图书馆收藏</strong></p>
</li>
</ul>
<p>Python 附带了广泛的库，如 <strong>NumPy、Matplotlib、Pandas、Scipy 等</strong>。，它为各种用途的工作提供了灵活性。它适用于几乎每个新兴领域，也适用于提取数据和进行操作的网络废弃。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>低代码</strong></p>
</li>
</ul>
<p>爬虫的目的是为了节省时间。但是如果你花更多的时间写代码呢？这就是为什么我们使用 Python，因为它可以用几行代码执行一项任务。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>开源社区</strong></p>
</li>
</ul>
<p>Python 是开源的，这意味着它对每个人都是免费的。它拥有世界上最大的社区之一，如果您在 Python 代码中遇到任何问题，都可以在这里寻求帮助。</p>
<h3 id="爬虫的基础知识">爬虫的基础知识</h3>
<p>网络抓取由两部分组成：网络爬虫和网络抓取器。简单地说，网络爬虫是一匹骏马，而网络搜刮器则是一辆战车。爬虫引导刮板，提取所需的数据。让我们来了解一下网络搜索的这两个组成部分：</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>爬虫</strong></p>
</li>
</ul>
<p><img src="/img/585ec96e5545a9417b24b34ab2527cb8.png" alt="Web Scraping Using Python">网络爬虫一般称为**“蜘蛛。”**它是一种人工智能技术，通过给定的链接浏览互联网来索引和搜索内容。它搜索程序员询问的相关信息。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>刮刀</strong></p>
</li>
</ul>
<p><img src="/img/664f007d6a11b0b10e203b3029d3fa71.png" alt="Web Scraping Using Python">网页抓取器是一种专用工具，旨在快速有效地从多个网站中提取数据。根据项目的不同，网页剪贴机在设计和复杂性上差别很大。</p>
<h3 id="网络爬虫是如何工作的？">网络爬虫是如何工作的？</h3>
<p>以下是执行爬虫的步骤。让我们了解一下网页抓取的工作原理。</p>
<p><strong>第一步:找到想要刮的 URL</strong></p>
<p>首先，你应该根据你的项目了解数据的需求。网页或网站包含大量信息。这就是为什么只废弃相关信息。简单地说，开发人员应该熟悉数据需求。</p>
<p><strong>步骤 2:检查页面</strong></p>
<p>数据以原始 <a href="https://www.javatpoint.com/html-tutorial">HTML</a> 格式提取，必须仔细解析，减少原始数据的噪音。在某些情况下，数据可以像姓名和地址一样简单，也可以像高维天气和股市数据一样复杂。</p>
<p><strong>第三步:写代码</strong></p>
<p>编写代码来提取信息，提供相关信息，并运行代码。</p>
<p><strong>第 4 步:将数据存入文件</strong></p>
<p>将该信息以所需的 csv、 <a href="https://www.javatpoint.com/xml-tutorial">xml</a> 、 <a href="https://www.javatpoint.com/json-tutorial">JSON</a> 文件格式存储。</p>
<h3 id="网页抓取入门">网页抓取入门</h3>
<p>Python 有大量的库，也为网络废弃提供了一个非常有用的库。让我们了解 Python 所需的库。</p>
<p><strong>用于刮网的库</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Selenium-</strong> Selenium 是一个开源的自动化测试库。它用于检查浏览器活动。要安装此库，请在终端中键入以下命令。</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install selenium</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="注意——使用-PyCharm-IDE-很好。">注意——使用 PyCharm IDE 很好。</h4>
<p><img src="/img/60e8af64500b4ee5161bfdae276bb1fc.png" alt="Web Scraping Using Python"></p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Pandas</strong></p>
</li>
</ul>
<p>Pandas 库用于<strong>数据操作和分析</strong>。它用于提取数据并以所需的格式存储。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>BeautifulSoup</strong></p>
</li>
</ul>
<p>BeautifulSoup is a Python library that is used to pull data of HTML and XML files. It is mainly designed for web scrapping. It works with the parser to provide a natural way of navigating, searching, and modifying the parse tree. The latest version of BeautifulSoup is 4.8.1.</p>
<p>让我们详细了解一下<strong>BeautifulSoup</strong>库。</p>
<p><strong>安装BeautifulSoup</strong></p>
<p>您可以通过键入以下命令来安装美观的套件:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install bs4</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>安装解析器</strong></p>
<p>BeautifulSoup 支持 HTML 解析器和几个第三方 Python 解析器。您可以根据您的依赖关系安装其中的任何一个。以下是美观组的解析器列表:</p>
<table>
<thead>
<tr>
<th>句法分析程序</th>
<th>典型用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Python 的 html.parser</td>
<td>BeautifulSoup(markup，“html.parser”)</td>
</tr>
<tr>
<td>lxml 的 HTML 解析器</td>
<td>BeautifulSoup(markup，“lxml”)</td>
</tr>
<tr>
<td>lxml 的 xml 解析器</td>
<td>BeautifulSoup(markup，“lxml-xml”)</td>
</tr>
<tr>
<td>Html5lib</td>
<td>BeautifulSoup(markup，“html5lib”)</td>
</tr>
</tbody>
</table>
<p>我们建议您安装 <strong>html5lib</strong> 解析器，因为它非常适合较新版本的 Python，或者您可以安装 <strong>lxml</strong> 解析器。</p>
<p>在您的终端中键入以下命令:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install html5lib</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/22d6e58b4ca0264102ccfe433bc14dd7.png" alt="Web Scraping Using Python"></p>
<p>BeautifulSoup用于将复杂的 HTML 文档转换成 Python 对象的复杂树。但是有几个主要使用的对象类型:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>标签</strong></p>
</li>
</ul>
<p>一个<strong>标签</strong>对象对应一个 XML 或者 HTML 原始文档。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">soup = bs4.BeautifulSoup(<span class="string">&quot;&lt;b class = &quot;</span>boldest<span class="string">&quot;&gt;Extremely bold&lt;/b&gt;)</span></span><br><span class="line"><span class="string">tag = soup.b</span></span><br><span class="line"><span class="string">type(tag)</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&quot;bs4.element.Tag&quot;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>标签包含许多属性和方法，但是标签最重要的特征是名称和属性。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>名称</strong></p>
</li>
</ul>
<p>每个标签都有一个名称，可以通过<strong>访问。名称:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">tag.name</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>属性</strong></p>
</li>
</ul>
<p>标签可以有任意数量的属性。标签<strong>有一个属性“id”，其值为“最粗”。我们可以通过将标签视为字典来访问标签的属性。</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">tag[<span class="built_in">id</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以添加、移除和修改标签的属性。这可以通过使用标签作为字典来完成。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># add the element</span></span><br><span class="line">tag[<span class="string">&#x27;id&#x27;</span>] = <span class="string">&#x27;verybold&#x27;</span></span><br><span class="line">tag[<span class="string">&#x27;another-attribute&#x27;</span>] = <span class="number">1</span></span><br><span class="line">tag</span><br><span class="line"><span class="comment"># delete the tag</span></span><br><span class="line"><span class="keyword">del</span> tag[<span class="string">&#x27;id&#x27;</span>]	</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>多值属性</strong></p>
</li>
</ul>
<p>在 HTML5 中，有些属性可以有多个值。类(由多个 css 组成)是最常见的多值属性。其他属性有 **rel、rev、accept-charset、headers、**和 <strong>accesskey</strong> 。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class_is_multi= &#123; <span class="string">&#x27;*&#x27;</span> : <span class="string">&#x27;class&#x27;</span>&#125;</span><br><span class="line">xml_soup = BeautifulSoup(<span class="string">&#x27;&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;&#x27;</span>, <span class="string">&#x27;xml&#x27;</span>, multi_valued_attributes=class_is_multi)</span><br><span class="line">xml_soup.p[<span class="string">&#x27;class&#x27;</span>]</span><br><span class="line"><span class="comment"># [u&#x27;body&#x27;, u&#x27;strikeout&#x27;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p>可导航字符串</p>
</li>
</ul>
<p>BeautifulSoup中的字符串引用标签中的文本。美化组使用<strong>导航字符串</strong>类来包含这些文本。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">tag.string</span><br><span class="line"><span class="comment"># u&#x27;Extremely bold&#x27;</span></span><br><span class="line"><span class="built_in">type</span>(tag.string)</span><br><span class="line"><span class="comment"># &lt;class &#x27;bs4.element.NavigableString&#x27;&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>字符串是不可变的，这意味着它不能被编辑。但是可以使用 <strong>replace_with()</strong> 替换为另一个字符串。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">tag.string.replace_with(<span class="string">&quot;No longer bold&quot;</span>)</span><br><span class="line">tag</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在某些情况下，如果您想在BeautifulSoup外使用<strong>导航字符串</strong>，则 <strong>unicode()</strong> 有助于将其转换为正常的 Python Unicode 字符串。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>BeautifulSoup object</strong></p>
</li>
</ul>
<p>BeautifulSoup输出对象将完整的解析文档作为一个整体来表示。在许多情况下，我们可以将其用作标记对象。这意味着它支持导航树和搜索树中描述的大多数方法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">doc=BeautifulSoup(<span class="string">&quot;&lt;document&gt;&lt;content/&gt;INSERT FOOTER HERE&lt;/document&quot;</span>,<span class="string">&quot;xml&quot;</span>)</span><br><span class="line">footer=BeautifulSoup(<span class="string">&quot;&lt;footer&gt;Here&#x27;s the footer&lt;/footer&gt;&quot;</span>,<span class="string">&quot;xml&quot;</span>)</span><br><span class="line">doc.find(text=<span class="string">&quot;INSERT FOOTER HERE&quot;</span>).replace_with(footer)</span><br><span class="line"><span class="built_in">print</span>(doc)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line"><span class="comment"># &lt;document&gt;&lt;content/&gt;&lt;footer&gt;Here&#x27;s the footer&lt;/footer&gt;&lt;/document&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="网络抓取示例">网络抓取示例:</h3>
<p>让我们举个例子，通过从网页中提取数据并检查整个页面来实际理解报废。</p>
<p>首先，在维基百科上打开你喜欢的页面，检查整个页面，在从网页中提取数据之前，你应该确保你的要求。考虑以下代码:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#importing the BeautifulSoup Library</span></span><br><span class="line"></span><br><span class="line">importbs4</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment">#Creating the requests</span></span><br><span class="line"></span><br><span class="line">res = requests.get(<span class="string">&quot;https://en.wikipedia.org/wiki/Machine_learning&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The object type:&quot;</span>,<span class="built_in">type</span>(res))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convert the request object to the Beautiful Soup Object</span></span><br><span class="line">soup = bs4.BeautifulSoup(res.text,<span class="string">&#x27;html5lib&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The object type:&quot;</span>,<span class="built_in">type</span>(soup)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The <span class="built_in">object</span> <span class="built_in">type</span> &lt;<span class="keyword">class</span> <span class="string">&#x27;requests.models.Response&#x27;</span>&gt;</span><br><span class="line">Convert the <span class="built_in">object</span> into: &lt;<span class="keyword">class</span> <span class="string">&#x27;bs4.BeautifulSoup&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在下面几行代码中，我们按照类名提取网页的所有标题。在这里，前端知识在检查网页时起着至关重要的作用。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">soup.select(<span class="string">&#x27;.mw-headline&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> soup.select(<span class="string">&#x27;.mw-headline&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(i.text,end = <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Overview,Machine learning tasks,History <span class="keyword">and</span> relationships to other fields,Relation to data mining,Relation to optimization,Relation to statistics, Theory,Approaches,Types of learning algorithms,Supervised learning,Unsupervised learning,Reinforcement learning,Self-learning,Feature learning,Sparse dictionary learning,Anomaly detection,Association rules,Models,Artificial neural networks,Decision trees,Support vector machines,Regression analysis,Bayesian networks,Genetic algorithms,Training models,Federated learning,Applications,Limitations,Bias,Model assessments,Ethics,Software,Free <span class="keyword">and</span> <span class="built_in">open</span>-source software,Proprietary software <span class="keyword">with</span> free <span class="keyword">and</span> <span class="built_in">open</span>-source editions,Proprietary software,Journals,Conferences,See also,References,Further reading,External links,</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们导入了 <strong>bs4</strong> 和<strong>请求</strong>库。在第三行中，我们创建了一个 <strong>res</strong> 对象，向网页发送请求。正如你所看到的，我们已经从网页上提取了所有的标题。</p>
<p><img src="/img/ff708269f4541f1279e7f6196ca8b84f.png" alt="Web Scraping Using Python"></p>
<p><strong>维基百科学习的网页</strong></p>
<p>让我们理解另一个例子；我们将对 URL 发出 GET 请求，并使用 BeautifulSoup 和 Python 内置的**“html 5lib”**解析器创建一个解析树对象(soup)。</p>
<p>这里我们将废弃给定链接<a href="https://www.javatpoint.com/">的网页(https://www.javatpoint.com/)。</a>考虑以下代码:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">following code:</span><br><span class="line"><span class="comment"># importing the libraries</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url=<span class="string">&quot;https://www.javatpoint.com/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Make a GET request to fetch the raw HTML content</span></span><br><span class="line">html_content = requests.get(url).text</span><br><span class="line"></span><br><span class="line"><span class="comment"># Parse the html content</span></span><br><span class="line">soup = BeautifulSoup(html_content, <span class="string">&quot;html5lib&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(soup.prettify()) <span class="comment"># print the parsed data of html</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的代码将显示 javatpoint 主页的所有 html 代码。</p>
<p>使用<strong>BeautifulSoup</strong>对象，即<strong>soup</strong>，我们可以收集所需的数据表。让我们使用<strong>soup</strong>对象打印一些有趣的信息:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>让我们打印网页的标题。</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">print</span>(soup.title)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>**输出:**它将给出如下输出:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;title&gt;Tutorials <span class="type">List</span> - Javatpoint&lt;/title&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p>在上面的输出中，标题中包含了 HTML 标记。如果需要不带标签的文本，可以使用以下代码:</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">print</span>(soup.title.text)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>**输出:**它将给出如下输出:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Tutorials <span class="type">List</span> - Javatpoint</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p>我们可以获得页面上的整个链接及其属性，如 href、标题和内部文本。考虑以下代码:</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> link <span class="keyword">in</span> soup.find_all(<span class="string">&quot;a&quot;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Inner Text is: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(link.text))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Title is: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(link.get(<span class="string">&quot;title&quot;</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;href is: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(link.get(<span class="string">&quot;href&quot;</span>)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>**输出:**将打印所有链接及其属性。这里我们展示了其中的一些:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">href <span class="keyword">is</span>: https://www.facebook.com/javatpoint</span><br><span class="line">Inner Text <span class="keyword">is</span>: </span><br><span class="line">The title <span class="keyword">is</span>: <span class="literal">None</span></span><br><span class="line">href <span class="keyword">is</span>: https://twitter.com/pagejavatpoint</span><br><span class="line">Inner Text <span class="keyword">is</span>: </span><br><span class="line">The title <span class="keyword">is</span>: <span class="literal">None</span></span><br><span class="line">href <span class="keyword">is</span>: https://www.youtube.com/channel/UCUnYvQVCrJoFWZhKK3O2xLg</span><br><span class="line">Inner Text <span class="keyword">is</span>: </span><br><span class="line">The title <span class="keyword">is</span>: <span class="literal">None</span></span><br><span class="line">href <span class="keyword">is</span>: https://javatpoint.blogspot.com</span><br><span class="line">Inner Text <span class="keyword">is</span>: Learn Java</span><br><span class="line">Title <span class="keyword">is</span>: <span class="literal">None</span></span><br><span class="line">href <span class="keyword">is</span>: https://www.javatpoint.com/java-tutorial</span><br><span class="line">Inner Text <span class="keyword">is</span>: Learn Data Structures</span><br><span class="line">Title <span class="keyword">is</span>: <span class="literal">None</span></span><br><span class="line">href <span class="keyword">is</span>: https://www.javatpoint.com/data-structure-tutorial</span><br><span class="line">Inner Text <span class="keyword">is</span>: Learn C Programming</span><br><span class="line">Title <span class="keyword">is</span>: <span class="literal">None</span></span><br><span class="line">href <span class="keyword">is</span>: https://www.javatpoint.com/c-programming-language-tutorial</span><br><span class="line">Inner Text <span class="keyword">is</span>: Learn C++ Tutorial</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="演示-从-Flipkart-网站抓取数据">演示:从 Flipkart 网站抓取数据</h3>
<p>在这个例子中，我们将从流行的电子商务网站之一 Flipkart 中删除手机价格、收视率和型号名称。以下是完成此任务的先决条件:</p>
<p><strong>先决条件:</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>Python 2.x 或 Python 3.x，安装了 <strong>Selenium、BeautifulSoup、Pandas</strong> 库。</p>
</li>
<li class="lvl-4">
<p>谷歌浏览器</p>
</li>
<li class="lvl-4">
<p>废弃解析器，如 html.parser、xlml 等。</p>
</li>
</ul>
<p><strong>第一步:找到想要抓取的网址</strong></p>
<p>第一步是找到你想抓取的网址。这里我们从动画中提取手机细节。这个页面的网址是 <a href="https://www.flipkart.com/search?q">https://www.flipkart.com/search?q</a> = iphones &amp; otracker = search &amp; otracker 1 = search &amp; market place = FLIPKART &amp; as-show = on &amp; as = off。</p>
<p><strong>第 2 步:检查页面</strong></p>
<p>有必要仔细检查页面，因为数据通常包含在标签中。所以我们需要检查选择想要的标签。要检查页面，右键单击元素，然后单击**“检查”**。</p>
<p><strong>第三步:找到要提取的数据</strong></p>
<p>提取价格、名称和评级，它们分别包含在“div”标签中。</p>
<p><strong>第四步:写代码</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoupas soup</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen <span class="keyword">as</span> uReq</span><br><span class="line"></span><br><span class="line"><span class="comment"># Request from the webpage</span></span><br><span class="line">myurl = <span class="string">&quot;https://www.flipkart.com/search?q=iphones&amp;otracker=search&amp;otracker1=search&amp;marketplace=FLIPKART&amp;as-show=on&amp;as=off&quot;</span></span><br><span class="line"></span><br><span class="line">uClient  = uReq(myurl)</span><br><span class="line">page_html = uClient.read()</span><br><span class="line">uClient.close()</span><br><span class="line"></span><br><span class="line">page_soup = soup(page_html, features=<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(soup.prettify(containers[0]))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This variable held all html of webpage</span></span><br><span class="line">containers = page_soup.find_all(<span class="string">&quot;div&quot;</span>,&#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;_3O0U0u&quot;</span>&#125;)</span><br><span class="line"><span class="comment"># container = containers[0]</span></span><br><span class="line"><span class="comment"># # print(soup.prettify(container))</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># price = container.find_all(&quot;div&quot;,&#123;&quot;class&quot;: &quot;col col-5-12 _2o7WAb&quot;&#125;)</span></span><br><span class="line"><span class="comment"># print(price[0].text)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ratings = container.find_all(&quot;div&quot;,&#123;&quot;class&quot;: &quot;niH0FQ&quot;&#125;)</span></span><br><span class="line"><span class="comment"># print(ratings[0].text)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># #</span></span><br><span class="line"><span class="comment"># # print(len(containers))</span></span><br><span class="line"><span class="comment"># print(container.div.img[&quot;alt&quot;])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Creating CSV File that will store all data </span></span><br><span class="line">filename = <span class="string">&quot;product1.csv&quot;</span></span><br><span class="line">f = <span class="built_in">open</span>(filename,<span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line">headers = <span class="string">&quot;Product_Name,Pricing,Ratings\n&quot;</span></span><br><span class="line">f.write(headers)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> container <span class="keyword">in</span> containers:</span><br><span class="line">    product_name = container.div.img[<span class="string">&quot;alt&quot;</span>]</span><br><span class="line"></span><br><span class="line">    price_container = container.find_all(<span class="string">&quot;div&quot;</span>, &#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;col col-5-12 _2o7WAb&quot;</span>&#125;)</span><br><span class="line">    price = price_container[<span class="number">0</span>].text.strip()</span><br><span class="line"></span><br><span class="line">    rating_container = container.find_all(<span class="string">&quot;div&quot;</span>,&#123;<span class="string">&quot;class&quot;</span>:<span class="string">&quot;niH0FQ&quot;</span>&#125;)</span><br><span class="line">    ratings = rating_container[<span class="number">0</span>].text</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(&quot;product_name:&quot;+product_name)</span></span><br><span class="line">    <span class="comment"># print(&quot;price:&quot;+price)</span></span><br><span class="line">    <span class="comment"># print(&quot;ratings:&quot;+ str(ratings))</span></span><br><span class="line"></span><br><span class="line">     edit_price = <span class="string">&#x27;&#x27;</span>.join(price.split(<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">     sym_rupee = edit_price.split(<span class="string">&quot;?&quot;</span>)</span><br><span class="line">     add_rs_price = <span class="string">&quot;Rs&quot;</span>+sym_rupee[<span class="number">1</span>]</span><br><span class="line">     split_price = add_rs_price.split(<span class="string">&quot;E&quot;</span>)</span><br><span class="line">     final_price = split_price[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">     split_rating = <span class="built_in">str</span>(ratings).split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">     final_rating = split_rating[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">     <span class="built_in">print</span>(product_name.replace(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;|&quot;</span>)+<span class="string">&quot;,&quot;</span>+final_price+<span class="string">&quot;,&quot;</span>+final_rating+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">f.write(product_name.replace(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;|&quot;</span>)+<span class="string">&quot;,&quot;</span>+final_price+<span class="string">&quot;,&quot;</span>+final_rating+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">f.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<p><img src="/img/66d71b28beb5b72ea04a97ccca0e6cfa.png" alt="Web Scraping Using Python"></p>
<p>我们取消了 iPhone 的细节，并将这些细节保存在 CSV 文件中，如您在输出中所见。在上面的代码中，出于测试目的，我们对几行代码进行了注释。您可以删除这些注释并观察输出。</p>
<p>在本教程中，我们讨论了网络爬取的所有基本概念，并描述了领先的在线电子商务网站 flipkart 的爬取示例。</p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 读取csv文件</title>
    <url>/posts/404ab4d1.html</url>
    <content><![CDATA[<h1>Python 读取 csv 文件</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-read-csv-file">https://www.javatpoint.com/python-read-csv-file</a></p>
</blockquote>
<h2 id="CSV-文件-2">CSV 文件</h2>
<p>A <strong>csv</strong> 代表“逗号分隔值”，它被定义为一种简单的文件格式，使用特定的结构来排列表格数据。它以纯文本形式存储表格数据，如电子表格或数据库，并具有通用的数据交换格式。一个 <strong>csv</strong> 文件打开到 excel 表中，行和列数据定义了标准格式。</p>
<h2 id="Python-CSV-模块函数-2">Python CSV 模块函数</h2>
<p>CSV 模块工作用于处理 CSV 文件，以便从指定的列中读取/写入和获取数据。CSV 函数有不同的类型，如下所示:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>csv.field_size_limit -</strong> 返回解析器当前允许的最大字段大小。</p>
</li>
<li class="lvl-4">
<p><strong>csv.get_dialect-</strong> 返回与名字相关联的方言。</p>
</li>
<li class="lvl-4">
<p><strong>csv.list_dialect-</strong> 返回所有已注册方言的名称。</p>
</li>
<li class="lvl-4">
<p><strong>csv.reader -</strong> 它从 csv 文件中读取数据</p>
</li>
<li class="lvl-4">
<p><strong>csv.register_dialect -</strong> 它将方言与名字联系起来。该名称必须是字符串或 Unicode 对象。</p>
</li>
<li class="lvl-4">
<p><strong>csv.writer -</strong> 它将数据写入 csv 文件</p>
</li>
<li class="lvl-4">
<p><strong>csv.unregister_dialect-</strong> 它从方言注册表中删除与该名称相关联的方言。如果名称不是注册的方言名称，则会引发错误。</p>
</li>
<li class="lvl-4">
<p><strong>csv.QUOTE_MINIMAL -</strong> 它指示编写器对象引用所有字段。csv。它指示编写器对象只引用那些包含特殊字符的字段，如 quotechar、分隔符等。</p>
</li>
<li class="lvl-4">
<p><strong>csv.QUOTE_NONNUMERIC -</strong> 它指示编写器对象引用所有非数字字段。</p>
</li>
<li class="lvl-4">
<p><strong>csv.QUOTE_NONE -</strong> 它指示编写器对象永远不要引用字段。</p>
</li>
</ul>
<h2 id="正在读取-CSV-文件">正在读取 CSV 文件</h2>
<p>Python 提供了各种函数来读取 csv 文件。我们正在描述几种读取函数的方法。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>使用 csv.reader()功能</strong></p>
</li>
</ul>
<p>在 Python 中， <strong>csv.reader()</strong> 模块用于读取 csv 文件。它获取文件的每一行，并列出所有的列。</p>
<p>我们取了一个名为 python.txt 的 txt 文件，它有默认的分隔符<strong>逗号(，</strong>，数据如下:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">name,department,birthday month  </span><br><span class="line">Parker,Accounting,November  </span><br><span class="line">Smith,IT,October  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> csv  </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;python.csv&#x27;</span>) <span class="keyword">as</span> csv_file:  </span><br><span class="line">    csv_reader = csv.reader(csv_file, delimiter=<span class="string">&#x27;,&#x27;</span>)  </span><br><span class="line">    line_count = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> csv_reader:  </span><br><span class="line">        <span class="keyword">if</span> line_count == <span class="number">0</span>:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Column names are <span class="subst">&#123;<span class="string">&quot;, &quot;</span>.join(row)&#125;</span>&#x27;</span>)  </span><br><span class="line">            line_count += <span class="number">1</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Column names are name, department, birthday month</span><br><span class="line">  Parker works <span class="keyword">in</span> the Accounting department, <span class="keyword">and</span> was born <span class="keyword">in</span> November.</span><br><span class="line">  Smith works <span class="keyword">in</span> the IT department, <span class="keyword">and</span> was born <span class="keyword">in</span> October.</span><br><span class="line">Processed <span class="number">3</span> lines.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们已经使用 <strong>open()</strong> 函数打开了‘python . CSV’。我们使用 <strong>csv.reader()</strong> 函数读取文件，返回一个可迭代的 reader 对象。<strong>阅读器</strong>对象已经包含了数据，我们使用<strong>对</strong>循环进行迭代，以打印每行的内容</p>
<h2 id="把-csv-文件读入字典">把 csv 文件读入字典</h2>
<p>我们也可以使用 <strong>DictReader()</strong> 函数将 csv 文件直接读入字典，而不是处理单个字符串元素的列表。</p>
<p>同样，我们的输入文件 python.txt 如下:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">name,department,birthday month  </span><br><span class="line">Parker,Accounting,November  </span><br><span class="line">Smith,IT,October  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> csv    </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;python.txt&#x27;</span>, mode=<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> csv_file:  </span><br><span class="line">    csv_reader = csv.DictReader(csv_file)  </span><br><span class="line">    line_count = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> csv_reader:  </span><br><span class="line">        <span class="keyword">if</span> line_count == <span class="number">0</span>:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;The Column names are as follows <span class="subst">&#123;<span class="string">&quot;, &quot;</span>.join(row)&#125;</span>&#x27;</span>)  </span><br><span class="line">            line_count += <span class="number">1</span>  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;\t<span class="subst">&#123;row[<span class="string">&quot;name&quot;</span>]&#125;</span> works in the <span class="subst">&#123;row[<span class="string">&quot;department&quot;</span>]&#125;</span> department, and was born in <span class="subst">&#123;row[<span class="string">&quot;birthday month&quot;</span>]&#125;</span>.&#x27;</span>)  </span><br><span class="line">        line_count += <span class="number">1</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Processed <span class="subst">&#123;line_count&#125;</span> lines.&#x27;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The Column names are <span class="keyword">as</span> follows name, department, birthday month</span><br><span class="line">   Parker works <span class="keyword">in</span> the Accounting department, <span class="keyword">and</span> was born <span class="keyword">in</span> November.</span><br><span class="line">   Smith works <span class="keyword">in</span> the IT department, <span class="keyword">and</span> was born <span class="keyword">in</span> October.</span><br><span class="line">Processed <span class="number">3</span> lines.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="用-Pandas-读取-csv-文件">用 Pandas 读取 csv 文件</h2>
<p>Pandas 被定义为建立在数字图书馆之上的开源图书馆。它为用户提供快速分析、数据清理和数据准备。</p>
<p>将 csv 文件读入 Pandas<strong>数据帧</strong>是快速直接的。我们不需要写足够多的代码来打开、分析和读取 pandas 中的 csv 文件，它将数据存储在<strong>数据帧</strong>中。</p>
<p>这里，我们要读取一个稍微复杂一点的文件，名为 hrdata.csv，其中包含公司员工的数据。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Name,Hire Date,Salary,Leaves Remaining  </span><br><span class="line">John Idle,08/<span class="number">15</span>/<span class="number">14</span>,<span class="number">50000.00</span>,<span class="number">10</span>  </span><br><span class="line">Smith Gilliam,04/07/<span class="number">15</span>,<span class="number">65000.00</span>,<span class="number">8</span>  </span><br><span class="line">Parker Chapman,02/<span class="number">21</span>/<span class="number">14</span>,<span class="number">45000.00</span>,<span class="number">10</span>  </span><br><span class="line">Jones Palin,<span class="number">10</span>/<span class="number">14</span>/<span class="number">13</span>,<span class="number">70000.00</span>,<span class="number">3</span>  </span><br><span class="line">Terry Gilliam,07/<span class="number">22</span>/<span class="number">14</span>,<span class="number">48000.00</span>,<span class="number">7</span>  </span><br><span class="line">Michael Palin,06/<span class="number">28</span>/<span class="number">13</span>,<span class="number">66000.00</span>,<span class="number">8</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas  </span><br><span class="line">df = pandas.read_csv(<span class="string">&#x27;hrdata.csv&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(df)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，这三行足以读取文件，其中只有一行在做实际的工作，即 pandas.read_csv()</p>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">         Name                Hire Date     Salary      Leaves Remaining</span><br><span class="line"><span class="number">0</span>     John Idle              03/<span class="number">15</span>/<span class="number">14</span>      <span class="number">50000.0</span>       <span class="number">10</span></span><br><span class="line"><span class="number">1</span>     Smith Gilliam          06/01/<span class="number">15</span>      <span class="number">65000.0</span>       <span class="number">8</span></span><br><span class="line"><span class="number">2</span>     Parker Chapman         05/<span class="number">12</span>/<span class="number">14</span>      <span class="number">45000.0</span>       <span class="number">10</span></span><br><span class="line"><span class="number">3</span>     Jones Palin            <span class="number">11</span>/01/<span class="number">13</span>      <span class="number">70000.0</span>       <span class="number">3</span></span><br><span class="line"><span class="number">4</span>     Terry Gilliam          08/<span class="number">12</span>/<span class="number">14</span>      <span class="number">48000.0</span>       <span class="number">7</span></span><br><span class="line"><span class="number">5</span>     Michael Palin          05/<span class="number">23</span>/<span class="number">13</span>      <span class="number">66000.0</span>       <span class="number">8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 读取excel文件</title>
    <url>/posts/4e02b307.html</url>
    <content><![CDATA[<h1>Python 读取 excel 文件</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-read-excel-file">https://www.javatpoint.com/python-read-excel-file</a></p>
</blockquote>
<p>Excel 是微软开发的电子表格应用。它是一个易于访问的工具，用于组织、分析和存储表中的数据。它广泛应用于世界各地的许多不同应用中。从分析师到首席执行官，各种专业人士都使用 Excel 进行快速统计和认真的数据处理。</p>
<h2 id="Excel-文档">Excel 文档</h2>
<p>Excel 电子表格文档称为工作簿，保存在带有<strong>的文件中。xlsx</strong> 分机。电子表格的第一行主要保留给标题，而第一列标识采样单位。每个工作簿可以包含多个工作表，这些工作表也称为工作表。位于特定列和行的框称为单元格，每个单元格可以包含一个数字或文本值。包含数据的单元格网格形成一张工作表。</p>
<p>活动工作表被定义为用户当前正在查看或在关闭 Excel 之前最后一次查看的工作表。</p>
<h2 id="从-Excel-文件中读取">从 Excel 文件中读取</h2>
<p>首先，你需要写一个命令来安装 <strong>xlrd</strong> 模块。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install xlrd  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="创建工作簿">创建工作簿</h2>
<p>工作簿包含 excel 文件中的所有数据。您可以从头开始创建新的工作簿，也可以从已经存在的 excel 文件轻松创建工作簿。</p>
<p><strong>输入文件</strong></p>
<p>我们已经拍摄了工作簿的快照。</p>
<p><img src="/img/ee573cf6c88593de27922bf5f6c7ad7a.png" alt="Python Read Excel File"></p>
<p><strong>代码</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Import the xlrd module    </span></span><br><span class="line"><span class="keyword">import</span> xlrd   </span><br><span class="line"></span><br><span class="line"><span class="comment"># Define the location of the file   </span></span><br><span class="line">loc = (<span class="string">&quot;path of file&quot;</span>)   </span><br><span class="line"></span><br><span class="line"><span class="comment"># To open the Workbook   </span></span><br><span class="line">wb = xlrd.open_workbook(loc)   </span><br><span class="line">sheet = wb.sheet_by_index(<span class="number">0</span>)   </span><br><span class="line"></span><br><span class="line"><span class="comment"># For row 0 and column 0   </span></span><br><span class="line">sheet.cell_value(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>**说明:**在上例中，我们首先导入了 xlrd 模块，定义了文件的位置。然后，我们从已经存在的 excel 文件中打开了工作簿。</p>
<h2 id="从-Pandas-那里阅读">从 Pandas 那里阅读</h2>
<p>Pandas 被定义为建立在 NumPy 库之上的开源库。它为用户提供了快速分析、数据清理和数据准备，并支持来自 URL 的 xls 和 xlsx 扩展。</p>
<p>这是一个 python 包，它提供了一种称为数据帧的有益数据结构。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Example - </span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd  </span><br><span class="line"></span><br><span class="line"><span class="comment"># Read the file  </span></span><br><span class="line">data = pd.read_csv(<span class="string">&quot;.csv&quot;</span>, low_memory=<span class="literal">False</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># Output the number of rows  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Total rows: &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(data)))  </span><br><span class="line"></span><br><span class="line"><span class="comment"># See which headers are available  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(data))  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="阅读-openpyxl">阅读 openpyxl</h2>
<p>首先，我们需要从命令行使用 pip 安装一个 openpyxl 模块。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install openpyxl  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之后，我们需要导入模块。</p>
<p>我们还可以使用 openpyxl 从现有的电子表格中读取数据。它还允许用户执行计算并添加不属于原始数据集的内容。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> openpyxl  </span><br><span class="line">my_wb = openpyxl.Workbook()  </span><br><span class="line">my_sheet = my_wb.active  </span><br><span class="line">my_sheet_title = my_sheet.title  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My sheet title: &quot;</span> + my_sheet_title)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">My sheet title: Sheet</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要了解 openpyxl 的更多信息，请访问我们完整的教程<a href="https://www.javatpoint.com/python-openpyxl">点击此处</a>。我们已经在本教程中讨论了基本细节。</p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 运算符</title>
    <url>/posts/f05d4701.html</url>
    <content><![CDATA[<h1>Python 运算符</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-operators">https://www.javatpoint.com/python-operators</a></p>
</blockquote>
<p>运算符可以定义为负责两个操作数之间特定操作的符号。运算符是一个程序的支柱，在这个程序上，逻辑是用特定的编程语言构建的。Python 提供了多种运算符，描述如下。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>算术运算符</p>
</li>
<li class="lvl-4">
<p>比较运算符</p>
</li>
<li class="lvl-4">
<p>赋值运算符</p>
</li>
<li class="lvl-4">
<p>逻辑运算符</p>
</li>
<li class="lvl-4">
<p>按位运算符</p>
</li>
<li class="lvl-4">
<p>成员操作符</p>
</li>
<li class="lvl-4">
<p>身份操作符</p>
</li>
</ul>
<h2 id="算术运算符">算术运算符</h2>
<p>算术运算符用于在两个操作数之间执行算术运算。它包括+(加法)、-(减法)、*(乘法)、/(除法)、%(提醒)、/(地板除法)和指数(**)运算符。</p>
<p>有关算术运算符的详细解释，请参考下表。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>+</strong></td>
<td>它用于相加两个操作数。例如，如果 a = 20，b = 10 =&gt; a+b = 30</td>
</tr>
<tr>
<td><strong>-</strong></td>
<td>它用于从第一个操作数中减去第二个操作数。如果第一个操作数小于第二个操作数，则该值为负。例如，如果 a = 20，b = 10 =&gt; a - b = 10</td>
</tr>
<tr>
<td><strong>/</strong></td>
<td>它返回第一个操作数除以第二个操作数后的商。例如，如果 a = 20，b = 10 =&gt; a/b = 2.0</td>
</tr>
<tr>
<td>*</td>
<td>它用于将一个操作数与另一个操作数相乘。例如，如果 a = 20，b = 10 =&gt; a * b = 200</td>
</tr>
<tr>
<td><strong>%</strong></td>
<td>它在第一个操作数除以第二个操作数后返回提醒。例如，如果 a = 20，b = 10 =&gt; a%b = 0</td>
</tr>
<tr>
<td>**</td>
<td>它是一个指数运算符，表示为计算第一个操作数与第二个操作数的幂。</td>
</tr>
<tr>
<td><strong>//</strong></td>
<td>它给出了两个操作数相除所产生的商的底数。</td>
</tr>
</tbody>
</table>
<h2 id="比较运算符">比较运算符</h2>
<p>比较运算符用于比较两个操作数的值，并相应地返回布尔值 true 或 false。下表描述了比较运算符。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>如果两个操作数的值相等，则条件为真。</td>
</tr>
<tr>
<td>！=</td>
<td>如果两个操作数的值不相等，则条件为真。</td>
</tr>
<tr>
<td>&lt;=</td>
<td>如果第一个操作数小于或等于第二个操作数，则条件为真。</td>
</tr>
<tr>
<td>&gt;=</td>
<td>如果第一个操作数大于或等于第二个操作数，则条件为真。</td>
</tr>
<tr>
<td>&gt;</td>
<td>如果第一个操作数大于第二个操作数，则条件为真。</td>
</tr>
<tr>
<td>&lt;</td>
<td>如果第一个操作数小于第二个操作数，则条件为真。</td>
</tr>
</tbody>
</table>
<h2 id="赋值运算符">赋值运算符</h2>
<p>赋值运算符用于将右表达式的值赋给左操作数。下表描述了赋值运算符。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>它将右表达式的值赋给左操作数。</td>
</tr>
<tr>
<td>+=</td>
<td>它将左操作数的值增加右操作数的值，并将修改后的值分配回左操作数。例如，如果 a = 10，b = 20 =&gt; a+ = b 将等于 a = a+ b，因此 a = 30。</td>
</tr>
<tr>
<td>-=</td>
<td>它将左操作数的值减少右操作数的值，并将修改后的值分配回左操作数。例如，如果 a = 20，b = 10 =&gt; a- = b 将等于 a = a- b，因此 a = 10。</td>
</tr>
<tr>
<td>*=</td>
<td>它将左操作数的值乘以右操作数的值，并将修改后的值赋回左操作数。例如，如果 a = 10，b = 20 =&gt; a* = b 将等于 a = a* b，因此 a = 200。</td>
</tr>
<tr>
<td>%=</td>
<td>它将左操作数的值除以右操作数的值，并将提醒分配回左操作数。例如，如果 a = 20，b = 10 =&gt; a % = b 将等于 a = a % b，因此 a = 0。</td>
</tr>
<tr>
<td>**=</td>
<td>a**=b 将等于 a=a<strong>b，例如，如果 a = 4，b =2，a</strong>=b 将为 a 分配 4**2 = 16。</td>
</tr>
<tr>
<td>//=</td>
<td>a/= b 将等于 a = a// b，例如，如果 a = 4，b = 3，a/= b 将为 a 分配 4//3 = 1。</td>
</tr>
</tbody>
</table>
<h2 id="按位运算符">按位运算符</h2>
<p>按位运算符对两个操作数的值执行逐位运算。考虑下面的例子。</p>
<p><strong>例如</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> a = <span class="number">7</span> </span><br><span class="line">   b = <span class="number">6</span>   </span><br><span class="line">then, binary (a) = 0111  </span><br><span class="line">    binary (b) = 0110  </span><br><span class="line"></span><br><span class="line">hence, a &amp; b = 0011  </span><br><span class="line">      a | b = 0111  </span><br><span class="line">             a ^ b = <span class="number">0</span>100  </span><br><span class="line">       ~ a = <span class="number">1000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;(二进制和)</td>
<td>如果两个操作数中同一位置的两位都是 1，则 1 被复制到结果中。否则，将复制 0。</td>
</tr>
<tr>
<td>(二进制或)</td>
<td>如果两个位都为零，则结果位将为 0；否则，结果位将为 1。</td>
</tr>
<tr>
<td>^(二进制异或)</td>
<td>如果两个位不同，则结果位将为 1；否则，结果位将为 0。</td>
</tr>
<tr>
<td>~(否定)</td>
<td>它计算操作数每个位的求反，即如果该位为 0，则结果位为 1，反之亦然。</td>
</tr>
<tr>
<td>&lt;</td>
<td>左操作数值向左移动右操作数中的位数。</td>
</tr>
<tr>
<td>&gt; &gt;(右移)</td>
<td>左操作数向右移动右操作数中的位数。</td>
</tr>
</tbody>
</table>
<h2 id="逻辑运算符">逻辑运算符</h2>
<p>逻辑运算符主要用于表达式求值以做出决策。Python 支持以下逻辑运算符。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>and</td>
<td>如果两个表达式都为真，则条件为真。如果 a 和 b 是两个表达式，a →真，b →真=&gt; a 和 b →真。</td>
</tr>
<tr>
<td>or</td>
<td>如果其中一个表达式为真，则条件为真。如果 a 和 b 是两个表达式，a →真，b →假=&gt; a 或 b →真。</td>
</tr>
<tr>
<td>not</td>
<td>如果表达式 <strong>a</strong> 为真，那么 not (a)将为假，反之亦然。</td>
</tr>
</tbody>
</table>
<h2 id="成员操作符">成员操作符</h2>
<p>Python 成员操作符用于检查 Python 数据结构中值的成员关系。如果数据结构中存在该值，则结果值为真，否则返回假。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>in</td>
<td>如果在第二个操作数(列表、元组或字典)中找到第一个操作数，则评估为真。</td>
</tr>
<tr>
<td>not in</td>
<td>如果在第二个操作数(列表、元组或字典)中找不到第一个操作数，则评估为真。</td>
</tr>
</tbody>
</table>
<h2 id="身份操作符">身份操作符</h2>
<p>标识运算符用于决定元素是某个类还是某个类型。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>is</td>
<td>如果两侧的引用指向同一个对象，则评估为真。</td>
</tr>
<tr>
<td>is not</td>
<td>如果两侧的引用不指向同一个对象，则评估为真。</td>
</tr>
</tbody>
</table>
<h2 id="运算符优先级">运算符优先级</h2>
<p>运算符的优先级对于找出答案是至关重要的，因为它使我们能够知道应该首先评估哪个运算符。下面给出了 Python 中运算符的优先级表。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>**</td>
<td>指数运算符的优先级高于表达式中使用的所有其他运算符。</td>
</tr>
<tr>
<td>~ + -</td>
<td>否定，一元正和负。</td>
</tr>
<tr>
<td>* / % //</td>
<td>乘法、除法、模块、提醒和楼层划分。</td>
</tr>
<tr>
<td>+ -</td>
<td>二进制加减</td>
</tr>
<tr>
<td>&gt;&gt; &lt;&lt;</td>
<td>左移。右移</td>
</tr>
<tr>
<td>&amp;</td>
<td>二进制和。</td>
</tr>
<tr>
<td>异或</td>
<td>二进制异或，与或</td>
</tr>
<tr>
<td>&lt;= &lt; &gt; &gt;=</td>
<td>比较运算符(小于、小于等于、大于、大于等于)。</td>
</tr>
<tr>
<td>&lt;&gt; ==！=</td>
<td>等式运算符。</td>
</tr>
<tr>
<td>= %= /= //= -= +=</td>
<td></td>
</tr>
<tr>
<td>*= **=</td>
<td>赋值运算符</td>
</tr>
<tr>
<td>is is not</td>
<td>身份运算符</td>
</tr>
<tr>
<td>n not in</td>
<td>成员操作符</td>
</tr>
<tr>
<td>not or and</td>
<td>逻辑运算符</td>
</tr>
</tbody>
</table>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 集合</title>
    <url>/posts/d8744cec.html</url>
    <content><![CDATA[<h1>Python 集合</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-set">https://www.javatpoint.com/python-set</a></p>
</blockquote>
<p>Python 集合是无序项目的集合。集合中的每个元素必须是唯一的、不可变的，并且集合移除重复的元素。集合是可变的，这意味着我们可以在它创建后修改它。</p>
<p>与 Python 中的其他集合不同，集合的元素没有附加索引，即我们不能通过索引直接访问集合的任何元素。但是，我们可以一起打印它们，或者我们可以通过循环集合来获得元素列表。</p>
<h2 id="创建集合">创建集合</h2>
<p>可以通过用花括号{}将逗号分隔的不可变项括起来来创建集合。Python 还提供了 set()方法，可用于通过传递的序列创建集合。</p>
<h3 id="示例-1-使用大括号">示例 1:使用大括号</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Days = &#123;<span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span>, <span class="string">&quot;Sunday&quot;</span>&#125;  </span><br><span class="line"><span class="built_in">print</span>(Days)  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Days))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;looping through the set elements ... &quot;</span>)  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Days:  </span><br><span class="line">    <span class="built_in">print</span>(i)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;Friday&#x27;</span>, <span class="string">&#x27;Tuesday&#x27;</span>, <span class="string">&#x27;Monday&#x27;</span>, <span class="string">&#x27;Saturday&#x27;</span>, <span class="string">&#x27;Thursday&#x27;</span>, <span class="string">&#x27;Sunday&#x27;</span>, <span class="string">&#x27;Wednesday&#x27;</span>&#125;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;set&#x27;</span>&gt;</span><br><span class="line">looping through the <span class="built_in">set</span> elements ... </span><br><span class="line">Friday</span><br><span class="line">Tuesday</span><br><span class="line">Monday</span><br><span class="line">Saturday</span><br><span class="line">Thursday</span><br><span class="line">Sunday</span><br><span class="line">Wednesday</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="示例-2-使用-set-方法">示例 2:使用 set()方法</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Days = <span class="built_in">set</span>([<span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span>, <span class="string">&quot;Sunday&quot;</span>])  </span><br><span class="line"><span class="built_in">print</span>(Days)  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Days))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;looping through the set elements ... &quot;</span>)  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Days:  </span><br><span class="line">    <span class="built_in">print</span>(i)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;Friday&#x27;</span>, <span class="string">&#x27;Wednesday&#x27;</span>, <span class="string">&#x27;Thursday&#x27;</span>, <span class="string">&#x27;Saturday&#x27;</span>, <span class="string">&#x27;Monday&#x27;</span>, <span class="string">&#x27;Tuesday&#x27;</span>, <span class="string">&#x27;Sunday&#x27;</span>&#125;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;set&#x27;</span>&gt;</span><br><span class="line">looping through the <span class="built_in">set</span> elements ... </span><br><span class="line">Friday</span><br><span class="line">Wednesday</span><br><span class="line">Thursday</span><br><span class="line">Saturday</span><br><span class="line">Monday</span><br><span class="line">Tuesday</span><br><span class="line">Sunday</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它可以包含任何类型的元素，如整数、浮点、元组等。但是可变元素(列表、字典、集合)不能是集合的成员。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creating a set which have immutable elements</span></span><br><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>, <span class="string">&quot;JavaTpoint&quot;</span>, <span class="number">20.5</span>, <span class="number">14</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(set1))</span><br><span class="line"><span class="comment">#Creating a set which have mutable element</span></span><br><span class="line">set2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="string">&quot;Javatpoint&quot;</span>,<span class="number">4</span>]&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(set2))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;set&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">5</span>-9605bb6fbc68&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">      <span class="number">4</span> </span><br><span class="line">      <span class="number">5</span> <span class="comment">#Creating a set which holds mutable elements</span></span><br><span class="line">----&gt; <span class="number">6</span> set2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="string">&quot;Javatpoint&quot;</span>,<span class="number">4</span>]&#125;</span><br><span class="line">      <span class="number">7</span> <span class="built_in">print</span>(<span class="built_in">type</span>(set2))</span><br><span class="line"></span><br><span class="line">TypeError: unhashable <span class="built_in">type</span>: <span class="string">&#x27;list&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们创建了两个集合，集合<strong>集合</strong>有不可变元素，集合 2 有一个可变元素作为列表。在检查 set2 的类型时，它引发了一个错误，这意味着 set 只能包含不可变的元素。</p>
<p>创建空集合有点不同，因为空的大括号{}也用于创建字典。所以 Python 提供了 set()方法，在没有参数的情况下创建一个空集合。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Empty curly braces will create dictionary</span></span><br><span class="line">set3 = &#123;&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(set3))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Empty set using set() function</span></span><br><span class="line">set4 = <span class="built_in">set</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(set4))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;set&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>让我们看看如果我们向集合提供重复的元素会发生什么。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">set5 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">10</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Return set with unique elements:&quot;</span>,set5)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Return <span class="built_in">set</span> <span class="keyword">with</span> unique elements: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们可以看到<strong>集合 5</strong> 由多个重复的元素组成，当我们打印它时，从集合中移除重复。</p>
<h2 id="向集合中添加项目">向集合中添加项目</h2>
<p>Python 提供了 <strong>add()</strong> 方法和 <strong>update()</strong> 方法，可用于向集合中添加特定的项目。add()方法用于添加单个元素，而 update()方法用于向集合中添加多个元素。考虑下面的例子。</p>
<h3 id="示例-1-使用-add-方法">示例:1 -使用 add()方法</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Months = <span class="built_in">set</span>([<span class="string">&quot;January&quot;</span>,<span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nprinting the original set ... &quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(months)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nAdding other months to the set...&quot;</span>);  </span><br><span class="line">Months.add(<span class="string">&quot;July&quot;</span>);  </span><br><span class="line">Months.add (<span class="string">&quot;August&quot;</span>);  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nPrinting the modified set...&quot;</span>);  </span><br><span class="line"><span class="built_in">print</span>(Months)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nlooping through the set elements ... &quot;</span>)  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Months:  </span><br><span class="line">    <span class="built_in">print</span>(i)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">printing the original <span class="built_in">set</span> ... </span><br><span class="line">&#123;<span class="string">&#x27;February&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;April&#x27;</span>, <span class="string">&#x27;March&#x27;</span>, <span class="string">&#x27;June&#x27;</span>, <span class="string">&#x27;January&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">Adding other months to the <span class="built_in">set</span>...</span><br><span class="line"></span><br><span class="line">Printing the modified <span class="built_in">set</span>...</span><br><span class="line">&#123;<span class="string">&#x27;February&#x27;</span>, <span class="string">&#x27;July&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;April&#x27;</span>, <span class="string">&#x27;March&#x27;</span>, <span class="string">&#x27;August&#x27;</span>, <span class="string">&#x27;June&#x27;</span>, <span class="string">&#x27;January&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">looping through the <span class="built_in">set</span> elements ... </span><br><span class="line">February</span><br><span class="line">July</span><br><span class="line">May</span><br><span class="line">April</span><br><span class="line">March</span><br><span class="line">August</span><br><span class="line">June</span><br><span class="line">January </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要在集合中添加多个项目，Python 提供了 <strong>update()</strong> 方法。它接受 iterable 作为参数。</p>
<p>考虑下面的例子。</p>
<h3 id="示例-2-使用-update-函数">示例- 2 使用 update()函数</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Months = <span class="built_in">set</span>([<span class="string">&quot;January&quot;</span>,<span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nprinting the original set ... &quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(Months)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nupdating the original set ... &quot;</span>)  </span><br><span class="line">Months.update([<span class="string">&quot;July&quot;</span>,<span class="string">&quot;August&quot;</span>,<span class="string">&quot;September&quot;</span>,<span class="string">&quot;October&quot;</span>]);  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nprinting the modified set ... &quot;</span>)   </span><br><span class="line"><span class="built_in">print</span>(Months);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">printing the original <span class="built_in">set</span> ... </span><br><span class="line">&#123;<span class="string">&#x27;January&#x27;</span>, <span class="string">&#x27;February&#x27;</span>, <span class="string">&#x27;April&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;June&#x27;</span>, <span class="string">&#x27;March&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">updating the original <span class="built_in">set</span> ... </span><br><span class="line">printing the modified <span class="built_in">set</span> ... </span><br><span class="line">&#123;<span class="string">&#x27;January&#x27;</span>, <span class="string">&#x27;February&#x27;</span>, <span class="string">&#x27;April&#x27;</span>, <span class="string">&#x27;August&#x27;</span>, <span class="string">&#x27;October&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;June&#x27;</span>, <span class="string">&#x27;July&#x27;</span>, <span class="string">&#x27;September&#x27;</span>, <span class="string">&#x27;March&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="从集合中移除项目">从集合中移除项目</h2>
<p>Python 提供了**丢弃()<strong>方法和</strong>移除()**方法，可用于从器械包中移除物品。这些函数之间的区别，使用 discard()函数如果集合中不存在该项，则集合保持不变，而 remove()方法将通过一个错误。</p>
<p>考虑下面的例子。</p>
<h3 id="示例-1-使用丢弃-方法">示例-1 使用丢弃()方法</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">months = <span class="built_in">set</span>([<span class="string">&quot;January&quot;</span>,<span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nprinting the original set ... &quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(months)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nRemoving some months from the set...&quot;</span>);  </span><br><span class="line">months.discard(<span class="string">&quot;January&quot;</span>);  </span><br><span class="line">months.discard(<span class="string">&quot;May&quot;</span>);  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nPrinting the modified set...&quot;</span>);  </span><br><span class="line"><span class="built_in">print</span>(months)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nlooping through the set elements ... &quot;</span>)  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> months:  </span><br><span class="line">    <span class="built_in">print</span>(i)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">printing the original <span class="built_in">set</span> ... </span><br><span class="line">&#123;<span class="string">&#x27;February&#x27;</span>, <span class="string">&#x27;January&#x27;</span>, <span class="string">&#x27;March&#x27;</span>, <span class="string">&#x27;April&#x27;</span>, <span class="string">&#x27;June&#x27;</span>, <span class="string">&#x27;May&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">Removing some months <span class="keyword">from</span> the <span class="built_in">set</span>...</span><br><span class="line"></span><br><span class="line">Printing the modified <span class="built_in">set</span>...</span><br><span class="line">&#123;<span class="string">&#x27;February&#x27;</span>, <span class="string">&#x27;March&#x27;</span>, <span class="string">&#x27;April&#x27;</span>, <span class="string">&#x27;June&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">looping through the <span class="built_in">set</span> elements ... </span><br><span class="line">February</span><br><span class="line">March</span><br><span class="line">April</span><br><span class="line">June</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Python 还提供了 <strong>remove()</strong> 方法来从集合中移除项目。考虑以下示例，使用**移除()**方法移除项目。</p>
<h3 id="示例-2-使用-remove-函数">示例-2 使用 remove()函数</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">months = <span class="built_in">set</span>([<span class="string">&quot;January&quot;</span>,<span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nprinting the original set ... &quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(months)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nRemoving some months from the set...&quot;</span>);  </span><br><span class="line">months.remove(<span class="string">&quot;January&quot;</span>);  </span><br><span class="line">months.remove(<span class="string">&quot;May&quot;</span>);  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nPrinting the modified set...&quot;</span>);  </span><br><span class="line"><span class="built_in">print</span>(months)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">printing the original <span class="built_in">set</span> ... </span><br><span class="line">&#123;<span class="string">&#x27;February&#x27;</span>, <span class="string">&#x27;June&#x27;</span>, <span class="string">&#x27;April&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;January&#x27;</span>, <span class="string">&#x27;March&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">Removing some months <span class="keyword">from</span> the <span class="built_in">set</span>...</span><br><span class="line"></span><br><span class="line">Printing the modified <span class="built_in">set</span>...</span><br><span class="line">&#123;<span class="string">&#x27;February&#x27;</span>, <span class="string">&#x27;June&#x27;</span>, <span class="string">&#x27;April&#x27;</span>, <span class="string">&#x27;March&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们还可以使用 pop()方法移除该项。一般来说，pop()方法总是会删除最后一项，但是集合是无序的，我们无法确定从集合中弹出哪个元素。</p>
<p>考虑以下示例，使用 pop()方法从集合中移除该项。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Months = <span class="built_in">set</span>([<span class="string">&quot;January&quot;</span>,<span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nprinting the original set ... &quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(Months)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nRemoving some months from the set...&quot;</span>);  </span><br><span class="line">Months.pop();  </span><br><span class="line">Months.pop();  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nPrinting the modified set...&quot;</span>);  </span><br><span class="line"><span class="built_in">print</span>(Months)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">printing the original <span class="built_in">set</span> ... </span><br><span class="line">&#123;<span class="string">&#x27;June&#x27;</span>, <span class="string">&#x27;January&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;April&#x27;</span>, <span class="string">&#x27;February&#x27;</span>, <span class="string">&#x27;March&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">Removing some months <span class="keyword">from</span> the <span class="built_in">set</span>...</span><br><span class="line"></span><br><span class="line">Printing the modified <span class="built_in">set</span>...</span><br><span class="line">&#123;<span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;April&#x27;</span>, <span class="string">&#x27;February&#x27;</span>, <span class="string">&#x27;March&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，<strong>月</strong>集合的最后一个元素是<strong>3 月</strong>，但是 pop()方法删除了<strong>6 月和 1 月</strong>，因为集合是无序的，pop()方法无法确定集合的最后一个元素。</p>
<p>Python 提供了 clear()方法来从集合中移除所有项目。</p>
<p>考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Months = <span class="built_in">set</span>([<span class="string">&quot;January&quot;</span>,<span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nprinting the original set ... &quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(Months)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nRemoving all the items from the set...&quot;</span>);  </span><br><span class="line">Months.clear()  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nPrinting the modified set...&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(Months)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">printing the original <span class="built_in">set</span> ... </span><br><span class="line">&#123;<span class="string">&#x27;January&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;June&#x27;</span>, <span class="string">&#x27;April&#x27;</span>, <span class="string">&#x27;March&#x27;</span>, <span class="string">&#x27;February&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">Removing <span class="built_in">all</span> the items <span class="keyword">from</span> the <span class="built_in">set</span>...</span><br><span class="line"></span><br><span class="line">Printing the modified <span class="built_in">set</span>...</span><br><span class="line"><span class="built_in">set</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="丢弃-和移除-之间的区别">丢弃()和移除()之间的区别</h2>
<p>尽管 <strong>discard()</strong> 和 <strong>remove()</strong> 方法都执行相同的任务，但是 discard()和 remove()之间有一个主要区别。</p>
<p>如果要使用 discard()从集合中删除的密钥在集合中不存在，Python 不会给出错误。程序保持其控制流程。</p>
<p>另一方面，如果要使用 remove()从集合中删除的项目在集合中不存在，Python 将会引发错误。</p>
<p>考虑下面的例子。</p>
<h3 id="示例-6">示例-</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Months = <span class="built_in">set</span>([<span class="string">&quot;January&quot;</span>,<span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nprinting the original set ... &quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(Months)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nRemoving items through discard() method...&quot;</span>);  </span><br><span class="line">Months.discard(<span class="string">&quot;Feb&quot;</span>); <span class="comment">#will not give an error although the key feb is not available in the set  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nprinting the modified set...&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(Months)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nRemoving items through remove() method...&quot;</span>);  </span><br><span class="line">Months.remove(<span class="string">&quot;Jan&quot;</span>) <span class="comment">#will give an error as the key jan is not available in the set.   </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nPrinting the modified set...&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(Months)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">printing the original <span class="built_in">set</span> ... </span><br><span class="line">&#123;<span class="string">&#x27;March&#x27;</span>, <span class="string">&#x27;January&#x27;</span>, <span class="string">&#x27;April&#x27;</span>, <span class="string">&#x27;June&#x27;</span>, <span class="string">&#x27;February&#x27;</span>, <span class="string">&#x27;May&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">Removing items through discard() method...</span><br><span class="line"></span><br><span class="line">printing the modified <span class="built_in">set</span>...</span><br><span class="line">&#123;<span class="string">&#x27;March&#x27;</span>, <span class="string">&#x27;January&#x27;</span>, <span class="string">&#x27;April&#x27;</span>, <span class="string">&#x27;June&#x27;</span>, <span class="string">&#x27;February&#x27;</span>, <span class="string">&#x27;May&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">Removing items through remove() method...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;set.py&quot;</span>, line <span class="number">9</span>, <span class="keyword">in</span> </span><br><span class="line">    Months.remove(<span class="string">&quot;Jan&quot;</span>)</span><br><span class="line">KeyError: <span class="string">&#x27;Jan&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Python-集合运算">Python 集合运算</h2>
<p>集合可以进行数学运算，如并集、交集、差集和对称差集。Python 提供了用操作符或方法执行这些操作的工具。我们将这些操作描述如下。</p>
<h3 id="两个集合的并集">两个集合的并集</h3>
<p>两个集合的并集是使用管道(|)运算符计算的。这两个集合的并集包含这两个集合中存在的所有项。</p>
<p><img src="img/233a7422ede4ec409b1a52c498e53e03.png" alt="Python Set"></p>
<p>考虑下面的例子来计算两个集合的并集。</p>
<p><strong>例 1:使用 union |运算符</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Days1 = &#123;<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;Tuesday&quot;</span>,<span class="string">&quot;Wednesday&quot;</span>,<span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Sunday&quot;</span>&#125;  </span><br><span class="line">Days2 = &#123;<span class="string">&quot;Friday&quot;</span>,<span class="string">&quot;Saturday&quot;</span>,<span class="string">&quot;Sunday&quot;</span>&#125;  </span><br><span class="line"><span class="built_in">print</span>(Days1|Days2) <span class="comment">#printing the union of the sets   </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;Friday&#x27;</span>, <span class="string">&#x27;Sunday&#x27;</span>, <span class="string">&#x27;Saturday&#x27;</span>, <span class="string">&#x27;Tuesday&#x27;</span>, <span class="string">&#x27;Wednesday&#x27;</span>, <span class="string">&#x27;Monday&#x27;</span>, <span class="string">&#x27;Thursday&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Python 还提供了**并集()**方法，也可以用来计算两个集合的并集。考虑下面的例子。</p>
<p><strong>例 2:使用 union()方法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Days1 = &#123;<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;Tuesday&quot;</span>,<span class="string">&quot;Wednesday&quot;</span>,<span class="string">&quot;Thursday&quot;</span>&#125;  </span><br><span class="line">Days2 = &#123;<span class="string">&quot;Friday&quot;</span>,<span class="string">&quot;Saturday&quot;</span>,<span class="string">&quot;Sunday&quot;</span>&#125;  </span><br><span class="line"><span class="built_in">print</span>(Days1.union(Days2)) <span class="comment">#printing the union of the sets   </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;Friday&#x27;</span>, <span class="string">&#x27;Monday&#x27;</span>, <span class="string">&#x27;Tuesday&#x27;</span>, <span class="string">&#x27;Thursday&#x27;</span>, <span class="string">&#x27;Wednesday&#x27;</span>, <span class="string">&#x27;Sunday&#x27;</span>, <span class="string">&#x27;Saturday&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="两个集合的交集">两个集合的交集</h3>
<p>两个集合的交集可以通过<strong>和&amp;</strong> 操作符或<strong>交集()功能</strong>进行。两个集合的交集被给出为两个集合中公共的元素的集合。</p>
<p><img src="img/f72532e85c58972275ffd7713edd3fe6.png" alt="Python Set"></p>
<p>考虑下面的例子。</p>
<p><strong>例 1:使用&amp;算子</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Days1 = &#123;<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>&#125;  </span><br><span class="line">Days2 = &#123;<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;Tuesday&quot;</span>,<span class="string">&quot;Sunday&quot;</span>, <span class="string">&quot;Friday&quot;</span>&#125;  </span><br><span class="line"><span class="built_in">print</span>(Days1&amp;Days2) <span class="comment">#prints the intersection of the two sets  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;Monday&#x27;</span>, <span class="string">&#x27;Tuesday&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例 2:使用交集()方法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">set1 = &#123;<span class="string">&quot;Devansh&quot;</span>,<span class="string">&quot;John&quot;</span>, <span class="string">&quot;David&quot;</span>, <span class="string">&quot;Martin&quot;</span>&#125;  </span><br><span class="line">set2 = &#123;<span class="string">&quot;Steve&quot;</span>, <span class="string">&quot;Milan&quot;</span>, <span class="string">&quot;David&quot;</span>, <span class="string">&quot;Martin&quot;</span>&#125;  </span><br><span class="line"><span class="built_in">print</span>(set1.intersection(set2)) <span class="comment">#prints the intersection of the two sets  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;Martin&#x27;</span>, <span class="string">&#x27;David&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例 3:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">20</span>,<span class="number">32</span>,<span class="number">5</span>,<span class="number">9</span>&#125;</span><br><span class="line">set3 = set1.intersection(set2)</span><br><span class="line"><span class="built_in">print</span>(set3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="交集-update-方法">交集 _update()方法</h2>
<p>**交集 _ 更新()**方法从原始集合中移除两个集合中不存在的项目(如果指定了多个集合，则移除所有集合)。</p>
<p>**交集 _ 更新()**方法不同于交集()方法，因为它通过移除不需要的项目来修改原始集合，另一方面，交集()方法返回新的集合。</p>
<p>考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&quot;Devansh&quot;</span>, <span class="string">&quot;bob&quot;</span>, <span class="string">&quot;castle&quot;</span>&#125;  </span><br><span class="line">b = &#123;<span class="string">&quot;castle&quot;</span>, <span class="string">&quot;dude&quot;</span>, <span class="string">&quot;emyway&quot;</span>&#125;  </span><br><span class="line">c = &#123;<span class="string">&quot;fuson&quot;</span>, <span class="string">&quot;gaurav&quot;</span>, <span class="string">&quot;castle&quot;</span>&#125;  </span><br><span class="line"></span><br><span class="line">a.intersection_update(b, c)  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;castle&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="两套之间的差异">两套之间的差异</h2>
<p>两个集合的差可以用减法(-)运算符或**交集()**方法计算。假设有两个集合 A 和 B，不同的是 A-B 表示结果集合将获得集合 B 中不存在的元素 A</p>
<p><img src="img/ae18426476e170c9a939dc15210de8fa.png" alt="Python Set"></p>
<p>考虑下面的例子。</p>
<p><strong>例 1:使用减法(-)运算符</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Days1 = &#123;<span class="string">&quot;Monday&quot;</span>,  <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>&#125;  </span><br><span class="line">Days2 = &#123;<span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Sunday&quot;</span>&#125;  </span><br><span class="line"><span class="built_in">print</span>(Days1-Days2) <span class="comment">#&#123;&quot;Wednesday&quot;, &quot;Thursday&quot; will be printed&#125;  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;Thursday&#x27;</span>, <span class="string">&#x27;Wednesday&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例 2:使用差分()方法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Days1 = &#123;<span class="string">&quot;Monday&quot;</span>,  <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>&#125;  </span><br><span class="line">Days2 = &#123;<span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Sunday&quot;</span>&#125;  </span><br><span class="line"><span class="built_in">print</span>(Days1.difference(Days2)) <span class="comment"># prints the difference of the two sets Days1 and Days2  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;Thursday&#x27;</span>, <span class="string">&#x27;Wednesday&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="两组对称差">两组对称差</h2>
<p>两组对称差用^算子或**对称 _ 差()**法计算。集合的对称差，它去掉了存在于两个集合中的元素。考虑以下示例:</p>
<p><img src="img/d04dd5a83e71270c7b8979a1cbfdadc5.png" alt="Python Set"></p>
<p><strong>示例- 1:使用^算子</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">b = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">10</span>&#125;</span><br><span class="line">c = a^b</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例- 2:使用对称 _ 差分()方法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">b = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">10</span>&#125;</span><br><span class="line">c = a.symmetric_difference(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="设置比较">设置比较</h2>
<p>Python 允许我们对集合使用比较运算符，即、&lt;=, &gt; =、==，通过比较运算符，我们可以检查一个集合是子集、超集还是其他集合的等价集合。根据集合中存在的项目，返回布尔值 true 或 false。</p>
<p>考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Days1 = &#123;<span class="string">&quot;Monday&quot;</span>,  <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>&#125;  </span><br><span class="line">Days2 = &#123;<span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>&#125;  </span><br><span class="line">Days3 = &#123;<span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Friday&quot;</span>&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">#Days1 is the superset of Days2 hence it will print true.   </span></span><br><span class="line"><span class="built_in">print</span> (Days1&gt;Days2)   </span><br><span class="line"></span><br><span class="line"><span class="comment">#prints false since Days1 is not the subset of Days2   </span></span><br><span class="line"><span class="built_in">print</span> (Days1</span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="FrozenSets">FrozenSets</h2>
<p>冻结集是正规集的不可变形式，即冻结集的项目不能改变，因此它可以用作字典中的关键字。</p>
<p>创建后不能更改冻结集的元素。我们不能通过使用 add()或 remove()等方法来更改或追加冻结集的内容。</p>
<p>frozenset()方法用于创建 frozenset 对象。可迭代序列被传递到这个方法中，该方法被转换成冻结集作为该方法的返回类型。</p>
<p>考虑以下示例来创建冻结集。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Frozenset = <span class="built_in">frozenset</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])   </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Frozenset))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nprinting the content of frozen set...&quot;</span>)  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Frozenset:  </span><br><span class="line">    <span class="built_in">print</span>(i);  </span><br><span class="line">Frozenset.add(<span class="number">6</span>) <span class="comment">#gives an error since we cannot change the content of Frozenset after creation   </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;frozenset&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line">printing the content of frozen <span class="built_in">set</span>...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;set.py&quot;</span>, line <span class="number">6</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    Frozenset.add(<span class="number">6</span>) <span class="comment">#gives an error since we can change the content of Frozenset after creation </span></span><br><span class="line">AttributeError: <span class="string">&#x27;frozenset&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;add&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="为字典做准备">为字典做准备</h2>
<p>如果我们将字典作为 frozenset()方法中的序列传递，它将只从字典中获取键，并返回一个 frozenset，该 frozen set 包含字典的键作为其元素。</p>
<p>考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Dictionary = &#123;<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Country&quot;</span>:<span class="string">&quot;USA&quot;</span>, <span class="string">&quot;ID&quot;</span>:<span class="number">101</span>&#125;   </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Dictionary))  </span><br><span class="line">Frozenset = <span class="built_in">frozenset</span>(Dictionary); <span class="comment">#Frozenset will contain the keys of the dictionary  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Frozenset))  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Frozenset:   </span><br><span class="line">    <span class="built_in">print</span>(i)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;frozenset&#x27;</span>&gt;</span><br><span class="line">Name</span><br><span class="line">Country</span><br><span class="line">ID</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="设置编程示例">设置编程示例</h3>
<p><strong>示例- 1:</strong> 编写一个程序，从集合中删除给定的数字。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">my_set = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">24</span>&#125;</span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the number you want to remove&quot;</span>))</span><br><span class="line">my_set.discard(n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;After Removing:&quot;</span>,my_set)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the number you want to remove:<span class="number">12</span></span><br><span class="line">After Removing: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">24</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例- 2:</strong> 编写一个程序，向集合中添加多个元素。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">set1 = <span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="string">&quot;John&quot;</span>,<span class="string">&quot;CS&quot;</span>])</span><br><span class="line">set1.update([<span class="string">&quot;Apple&quot;</span>,<span class="string">&quot;Mango&quot;</span>,<span class="string">&quot;Grapes&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(set1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;CS&#x27;</span>, <span class="string">&#x27;Mango&#x27;</span>, <span class="string">&#x27;Grapes&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例- 3:</strong> 写一个程序，求两个集合的并集。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">set1 = <span class="built_in">set</span>([<span class="string">&quot;Peter&quot;</span>,<span class="string">&quot;Joseph&quot;</span>, <span class="number">65</span>,<span class="number">59</span>,<span class="number">96</span>])</span><br><span class="line">set2  = <span class="built_in">set</span>([<span class="string">&quot;Peter&quot;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;Joseph&quot;</span>])</span><br><span class="line">set3 = set1.union(set2)</span><br><span class="line"><span class="built_in">print</span>(set3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">96</span>, <span class="number">65</span>, <span class="number">2</span>, <span class="string">&#x27;Joseph&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;Peter&#x27;</span>, <span class="number">59</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例- 4:</strong> 写一个程序，找出两个集合的交集。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">set1 = &#123;<span class="number">23</span>,<span class="number">44</span>,<span class="number">56</span>,<span class="number">67</span>,<span class="number">90</span>,<span class="number">45</span>,<span class="string">&quot;Javatpoint&quot;</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">13</span>,<span class="number">23</span>,<span class="number">56</span>,<span class="number">76</span>,<span class="string">&quot;Sachin&quot;</span>&#125;</span><br><span class="line">set3 = set1.intersection(set2)</span><br><span class="line"><span class="built_in">print</span>(set3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">56</span>, <span class="number">23</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例- 5:</strong> 编写向 frozenset 添加元素的程序。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">set1 = &#123;<span class="number">23</span>,<span class="number">44</span>,<span class="number">56</span>,<span class="number">67</span>,<span class="number">90</span>,<span class="number">45</span>,<span class="string">&quot;Javatpoint&quot;</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">13</span>,<span class="number">23</span>,<span class="number">56</span>,<span class="number">76</span>,<span class="string">&quot;Sachin&quot;</span>&#125;</span><br><span class="line">set3 = set1.intersection(set2)</span><br><span class="line"><span class="built_in">print</span>(set3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">TypeError: <span class="string">&#x27;frozenset&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的代码引发了一个错误，因为 frozensets 是不可变的，创建后不能更改。</p>
<p><strong>例- 6:</strong> 编写程序，找到发布者、发布者和超集。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">set1 = <span class="built_in">set</span>([<span class="string">&quot;Peter&quot;</span>,<span class="string">&quot;James&quot;</span>,<span class="string">&quot;Camroon&quot;</span>,<span class="string">&quot;Ricky&quot;</span>,<span class="string">&quot;Donald&quot;</span>])</span><br><span class="line">set2 = <span class="built_in">set</span>([<span class="string">&quot;Camroon&quot;</span>,<span class="string">&quot;Washington&quot;</span>,<span class="string">&quot;Peter&quot;</span>])</span><br><span class="line">set3 = <span class="built_in">set</span>([<span class="string">&quot;Peter&quot;</span>])</span><br><span class="line"></span><br><span class="line">issubset = set1 &gt;= set2</span><br><span class="line"><span class="built_in">print</span>(issubset)</span><br><span class="line">issuperset = set1 &lt;= set2</span><br><span class="line"><span class="built_in">print</span>(issuperset)</span><br><span class="line">issubset = set3 &lt;= set2</span><br><span class="line"><span class="built_in">print</span>(issubset)</span><br><span class="line">issuperset = set2 &gt;= set3</span><br><span class="line"><span class="built_in">print</span>(issuperset)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-内置的集合方法">Python 内置的集合方法</h2>
<p>Python 包含以下用于集合的方法。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>one</td>
<td>add(item)</td>
<td>它向集合中添加一个项目。如果该项目已经存在于集合中，则没有效果。</td>
</tr>
<tr>
<td>Two</td>
<td>clear()</td>
<td>它会从集合中删除所有项目。</td>
</tr>
<tr>
<td>three</td>
<td>copy()</td>
<td>它返回集合的一个浅拷贝。</td>
</tr>
<tr>
<td>four</td>
<td>difference_update(…)</td>
<td>它通过删除指定集合中的所有项目来修改该集合。</td>
</tr>
<tr>
<td>five</td>
<td>discard(item)</td>
<td>它从集合中移除指定的项目。</td>
</tr>
<tr>
<td>six</td>
<td>intersection()</td>
<td>它返回一个只包含两个集合的公共元素的新集合。(如果指定了两个以上的集合，则为所有集合)。</td>
</tr>
<tr>
<td>seven</td>
<td>intersection_update(…)</td>
<td>它从原始集合中删除两个集合中不存在的项目(如果指定了多个集合，则删除所有集合)。</td>
</tr>
<tr>
<td>eight</td>
<td>Isdisjoint(…)</td>
<td>如果两个集合有空交集，则返回真。</td>
</tr>
<tr>
<td>nine</td>
<td>Issubset（…）</td>
<td>报告另一个集合是否包含此集合。</td>
</tr>
<tr>
<td>Ten</td>
<td>Issuperset(…)</td>
<td>报告此集合是否包含另一个集合。</td>
</tr>
<tr>
<td>Eleven</td>
<td>pop()</td>
<td>移除并返回任意集合元素，即该集合的最后一个元素。如果集合为空，则引发键错误。</td>
</tr>
<tr>
<td>Twelve</td>
<td>remove(item)</td>
<td>从集合中移除元素；它必须是一个成员。如果元素不是成员，则引发键错误。</td>
</tr>
<tr>
<td>Thirteen</td>
<td>symmetric_difference(…)</td>
<td>从集合中移除元素；它必须是一个成员。如果元素不是成员，则引发键错误。</td>
</tr>
<tr>
<td>Fourteen</td>
<td>symmetric_difference_update(…)</td>
<td>用自身和另一个的对称差更新一个集合。</td>
</tr>
<tr>
<td>Fifteen</td>
<td>union(…)</td>
<td>将集合的并集作为新集合返回。(即任一集合中的所有元素。)</td>
</tr>
<tr>
<td>Sixteen</td>
<td>update()</td>
<td>用自己和他人的联合来更新集合。</td>
</tr>
</tbody>
</table>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 魔术方法</title>
    <url>/posts/b1ff7fde.html</url>
    <content><![CDATA[<h1>Python 魔术方法</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-magic-method">https://www.javatpoint.com/python-magic-method</a></p>
</blockquote>
<p>Python 魔法方法被定义为给类增加“魔法”的特殊方法。它以双下划线开始和结束，例如 <em>init</em> 或 <em>str</em>。</p>
<p>内置类定义了许多神奇的方法。dir()函数可以用来查看一个类继承的魔法方法的数量。它在方法名中有两个前缀和后缀下划线。</p>
<p>它最常用于定义预定义运算符的重载行为。</p>
<p><strong><strong>init</strong></strong></p>
<p>在创建类的实例之后，但在返回给调用方之前，调用 <em>init</em> method。当类的实例像其他编程语言(如 C++、Java、C#、PHP 等)中的构造器一样被创建时，它无需任何调用即可被调用。这些方法也称为 initialize，在 <em>new</em> 之后调用。这是您应该初始化实例变量的地方。</p>
<p><strong><strong>str</strong></strong></p>
<p>这个函数计算一个对象的“非正式的”或者可以很好打印的字符串表示，并且必须返回一个字符串对象。</p>
<p><strong>_ _ _ _ _ _ _</strong></p>
<p>此函数由 repr()内置函数调用，用于计算对象的“官方”字符串表示形式，并返回类型的机器可读表示形式。repr 的目标是明确的。</p>
<p><strong><strong>len</strong></strong></p>
<p>这个函数应该返回对象的长度。</p>
<p><strong>_ _ 呼叫 __</strong></p>
<p>我们可以通过添加 <em>call</em> magic 方法来调用一个对象，这是另一种不像 <em>call</em> 那样经常需要的方法。</p>
<p>如果在一个类中定义，那么这个类可以被调用。但是如果它是一个函数，实例本身而不是修改。</p>
<p>月 _ _ _ _ 日</p>
<p>正如 <em>init</em> 是一个构造器方法一样，<em>del</em> 就像一个析构器。如果您已经在 _init _ 中打开了一个文件，那么 <em>del</em> 可以关闭它。</p>
<p><strong>字节 __</strong></p>
<p>它提供计算对象的字节串表示，并且应该返回一个字符串对象。</p>
<p><strong><strong>ge</strong></strong></p>
<p>当使用&gt; =运算符并返回真或假时，调用此方法。</p>
<p><strong><strong>neg</strong></strong></p>
<p>为一元运算符调用此函数。</p>
<p><strong>_ _ _ _ _ _ _</strong></p>
<p>这个函数在有参数的指数上被调用。例如 a**=b。</p>
<p><strong><strong>le</strong></strong></p>
<p>使用&lt; =运算符进行比较时调用此函数。</p>
<p><strong>_ 非零 _</strong></p>
<p>该函数返回对象的布尔值。它在调用 bool (self)函数时被调用。</p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的`nsetools`</title>
    <url>/posts/501fc57a.html</url>
    <content><![CDATA[<h1>Python 中的<code>nsetools</code></h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/nsetools-in-python">https://www.javatpoint.com/nsetools-in-python</a></p>
</blockquote>
<p>在下面的教程中，我们将讨论 Python 编程语言中的 <strong>nsetools</strong> 库。我们将了解它的特点，并通过一些例子来说明。</p>
<p>那么，让我们开始吧。</p>
<h2 id="了解nsetools库">了解<code>nsetools</code>库</h2>
<p>印度国家证券交易所有限公司是印度主要的证券交易所，位于马哈拉施特拉邦的孟买。NSE 成立于 1992 年，是该国第一个非物质化的电子交易所。</p>
<p>Python 提供了一个库，允许程序员从国家证券交易所(印度)收集实时数据。这个库被称为<strong>n 工具</strong>。我们可以在不同的项目中使用这个库，这需要为提供的指数或股票获取实时报价，或者为进一步的数据分析创建大量的数据集。我们还可以创建命令行界面应用，以极快的速度向我们提供实时市场的详细信息，比任何网络浏览器都快。数据准确性仅与印度国家证券交易所有限公司官方网站上提供的数据一致。(<a href="http://www.nseindia.com">http://www.nseindia.com</a>)</p>
<h2 id="Python-nsetools-库的主要特性">Python nsetools 库的主要特性</h2>
<p>Python <strong>nsetools</strong> 库的一些关键特性如下:</p>
<ol>
<li class="lvl-4">
<p><strong>nsetools</strong>库开箱即用，没有任何设置要求。</p>
</li>
<li class="lvl-4">
<p>这个库帮助程序员以极快的速度获取牲畜代码和索引代码。</p>
</li>
<li class="lvl-4">
<p>它还提供了一套在全国证券交易所交易的所有股票和指数。</p>
</li>
<li class="lvl-4">
<p>此外，它还提供了一组:</p>
<ol>
<li class="lvl-8">Top losers</li>
<li class="lvl-8">Top gainers</li>
<li class="lvl-8">Most active</li>
</ol>
</li>
<li class="lvl-4">
<p>为了验证股票代码和指数代码，它还提供了几个有用的 API。</p>
</li>
<li class="lvl-4">
<p>该库可以选择以 JSON 格式返回数据。</p>
</li>
<li class="lvl-4">
<p>它有百分之百的单元测试覆盖率。</p>
</li>
</ol>
<h2 id="如何安装-Python-nsetools-库？">如何安装 Python nsetools 库？</h2>
<p><strong>nsetools</strong> 库的安装部分相当容易，没有外部依赖。该库的所有依赖项都是 Python 标准发行包的一部分。我们可以使用 pip 安装程序安装 <strong>nsetools</strong> 库，如下语法所示:</p>
<p><strong>语法:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ pip install nsetools</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="更新库">更新库</h3>
<p>如果我们中的一些人已经在他们的系统中安装了 <strong>nsetools</strong> 库，那么下面的命令将允许他们更新库。</p>
<p><strong>语法:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ pip install nsetools -upgrade</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Python-3-支持">Python 3 支持</h3>
<p>Python 3 对该库的支持已经包含在 1.0.0 等版本中。现在，这个库既可以用于 Python 2，也可以用于 Python 3。</p>
<h2 id="创建神经元特异性烯醇化酶对象">创建神经元特异性烯醇化酶对象</h2>
<p>我们可以使用 <strong>nsetools</strong> 库提供的 <strong>Nse()</strong> 功能创建一个 NSE 对象。在下面的例子中可以看到同样的情况:</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># importing the Nse() function from the nsetools library</span></span><br><span class="line"><span class="keyword">from</span> nsetools <span class="keyword">import</span> Nse</span><br><span class="line"></span><br><span class="line"><span class="comment"># creating an NSE object</span></span><br><span class="line">nse_obj = Nse()</span><br><span class="line"></span><br><span class="line"><span class="comment"># printing the value of the object</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;NSE Object:&quot;</span>, nse_obj)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">NSE Object: Driver Class <span class="keyword">for</span> National Stock Exchange (NSE)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的代码片段中，我们已经从库中导入了所需的函数。然后我们定义了一个变量，它使用 <strong>Nse()</strong> 函数来创建一个 Nse 对象。然后，我们为用户打印了变量值。</p>
<h2 id="使用nsetools库获取信息">使用<code>nsetools</code>库获取信息</h2>
<p>让我们考虑一个演示使用<strong>n 工具</strong>收集信息的例子。</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># importing the Nse() function from the nsetools library</span></span><br><span class="line"><span class="keyword">from</span> nsetools <span class="keyword">import</span> Nse</span><br><span class="line"></span><br><span class="line"><span class="comment"># creating an NSE object</span></span><br><span class="line">nse_obj = Nse()</span><br><span class="line"></span><br><span class="line"><span class="comment"># getting quotation of the company</span></span><br><span class="line">the_quotation = nse_obj.get_quote(<span class="string">&#x27;sbin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># printing the name of the company</span></span><br><span class="line"><span class="built_in">print</span>(the_quotation[<span class="string">&quot;companyName&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># printing average price</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Average Price: &quot;</span> + <span class="built_in">str</span>(the_quotation[<span class="string">&quot;averagePrice&quot;</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">State Bank of India</span><br><span class="line">Average Price: <span class="number">431.97</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的代码片段中，我们已经导入了所需的模块，并使用 <strong>Nse()</strong> 函数创建了一个 NSE 对象。然后，我们定义了另一个变量，该变量使用 NSE 对象上的 <strong>get_quote()</strong> 函数来获取指定公司的报价。然后，我们为用户打印了所需的详细信息。</p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的Gmail API</title>
    <url>/posts/ee89ccac.html</url>
    <content><![CDATA[<h1>Python 中的 Gmail API</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/gmail-api-in-python">https://www.javatpoint.com/gmail-api-in-python</a></p>
</blockquote>
<p>在本教程中，我们将学习 Python 中的 Gmail API，我们还将学习如何使用 Python 中的 Gmail API 来执行许多 Gmail 操作，如发送电子邮件、搜索电子邮件、删除电子邮件等。为此，我们将学习在 Python 脚本中设置 Gmail API。首先，让我们简单介绍一下 Gmail API 及其基本介绍。</p>
<h2 id="Gmail-APIs">Gmail APIs</h2>
<p>Gmail 是当今世界上最受欢迎的邮件服务，几乎所有人和许多组织都在使用它。在过去的几年里，许多 Gmail 功能随着人工智能的使用而得到了增强，包括撰写电子邮件时的建议和安全功能(检测欺诈和垃圾邮件)。</p>
<p>Gmail API 是基于<a href="https://www.javatpoint.com/restful-web-services-tutorial">RESTful</a>API 的 API，允许其用户与我们的 Gmail 账户进行交互，它帮助我们使用 Python 脚本使用其功能。</p>
<h3 id="在-Python-中使用-Gmail-APIs-的先决条件">在 Python 中使用 Gmail APIs 的先决条件</h3>
<p>在 Python 脚本中使用 Gmail API 时，我们必须满足以下要求:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>我们应该有一个高于或等于 2.6 的 Python 版本。</p>
</li>
<li class="lvl-4">
<p>我们必须有一个启用了 Gmail 服务的谷歌账户。</p>
</li>
<li class="lvl-4">
<p>系统必须安装<strong>美化程序</strong>库(如果没有，那么我们应该在命令终端中使用‘pip install bsp’语法将其安装在我们的设备中)。</p>
</li>
<li class="lvl-4">
<p>我们应该有谷歌 OAuth 库和谷歌 API 客户端的基本知识。</p>
</li>
</ul>
<h3 id="所需库的安装">所需库的安装:</h3>
<p>在启用 Gmail API 在我们的 <a href="https://www.javatpoint.com/python-tutorial">Python</a> 脚本中使用它们之前，让我们首先在系统中安装预先需要的库。要安装启用 Gmail APIs 所需的库，我们应该遵循以下步骤:</p>
<p>**第一步:**打开系统的命令提示终端，确定我们的设备有活动的互联网连接。</p>
<p>**第二步:**在终端写下以下命令:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install --upgrade google-api-python-client google-auth-httplib2 google-auth-oauthlib</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，按 enter 键开始安装库。</p>
<p><img src="/img/f0a3e87989d641b983759a957bdaab5f.png" alt="Gmail API in Python"></p>
<p>正如我们所看到的，启用 Gmail APIs 所需的库已经成功安装在我们的系统中。现在，我们可以在本教程中继续启用 Gmail APIs 部分。</p>
<h3 id="在我们的设备中启用-Gmail-API">在我们的设备中启用 Gmail API</h3>
<p>我们必须遵循以下给定的步骤在我们的设备中启用 Gmail API，以便我们可以在 Python 脚本中使用这些 API:</p>
<p><strong>第一步:在谷歌云控制台上创建新项目:</strong></p>
<p>在这一步中，首先我们要用我们的谷歌账号登录到谷歌云控制台**(<a href="https://console.cloud.google.com/?pli=1">https://console.cloud.google.com/?pli=1</a>)**，然后我们要点击‘新建项目’创建一个新项目。</p>
<p><img src="/img/fe0d5660f983fe0fce39b08b76c725c9.png" alt="Gmail API in Python"></p>
<p>如果我们已经有一个现有的项目，那么我们也可以继续现有的项目。</p>
<p><strong>步骤 2:</strong> 现在，我们必须从已经创建的项目菜单中转到 API 和服务选项。</p>
<p><img src="/img/8ad63aef46fb13b1e777680d66b0dd3a.png" alt="Gmail API in Python"></p>
<p>**第三步:**现在，我们可以看到选项‘启用 Gmail API 和服务’，我们必须选择这个选项才能为项目启用 Gmail API。</p>
<p><img src="/img/18095fef1e53259fae0df202eefc2c35.png" alt="Gmail API in Python"></p>
<p><strong>第四步:同意画面配置:</strong></p>
<p>现在，在这一步中，我们将通过单击菜单中给出的**“审核同意屏幕”**选项来配置我们创建的项目的同意屏幕。只有在同意屏幕尚未配置的情况下，我们才能看到此选项。</p>
<p><img src="/img/feb0001cff6e58ccda0e0b4ca053e065.png" alt="Gmail API in Python"></p>
<p>**第五步:**现在，我们要输入自己选择的应用名称，保存项目。</p>
<p>**第 6 步:**现在，点击凭证选项，转到凭证。</p>
<p><img src="/img/8c388f8930db5a6bad408409649a94f7.png" alt="Gmail API in Python"></p>
<p><strong>步骤 7:创建 OAuth 客户端标识:</strong></p>
<p>现在，我们点击**“创建凭证”**选项，转到 OAuth 客户端 ID 创建它。</p>
<p>我们按照以下顺序过程执行此操作，为我们的项目创建一个新的 OAuth 客户端标识:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>首先，我们选择应用类型作为项目的桌面应用。<br>
<img src="/img/39200cebc294c1e5e18e8f6a473d115e.png" alt="Gmail API in Python"></p>
</li>
<li class="lvl-4">
<p>之后，我们输入应用名称(可以与我们在上述步骤中设置的名称相同，也可以不同)，然后单击创建按钮。</p>
</li>
<li class="lvl-4">
<p>现在，将为我们的项目创建 OAuth 客户端 ID，我们下载它，并用“credentials.json”名称和格式保存它，以供将来参考。<br>
<img src="/img/2631afff357d3df3a145652f2dd15379.png" alt="Gmail API in Python"></p>
</li>
</ul>
<p>现在，我们已经完成了启用 Gmail API 的所有步骤，我们可以开始在 Python 脚本中使用 Gmail API 了。</p>
<h4 id="注意-我们必须保存客户标识和密码，以便在将来需要时参考。">注意:我们必须保存客户标识和密码，以便在将来需要时参考。</h4>
<p><strong>导入必要的模块</strong></p>
<p>现在，我们已经设置了所有必要的 API，我们应该继续导入所有必要的模块。让我们看看下面导入模块的例子。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Importing os and pickle module in program</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="comment"># Creating utils for Gmail APIs</span></span><br><span class="line"><span class="keyword">from</span> googleapiclient.discovery <span class="keyword">import</span> build</span><br><span class="line"><span class="keyword">from</span> google_auth_oauthlib.flow <span class="keyword">import</span> InstalledAppFlow</span><br><span class="line"><span class="keyword">from</span> google.auth.transport.requests <span class="keyword">import</span> Request</span><br><span class="line"><span class="comment"># Importing libraries for encoding/decoding messages in base64</span></span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> urlsafe_b64decode, urlsafe_b64encode</span><br><span class="line"><span class="comment"># Importing libraries for dealing with the attachment of MIME types in Gmail</span></span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.mime.image <span class="keyword">import</span> MIMEImage</span><br><span class="line"><span class="keyword">from</span> email.mime.audio <span class="keyword">import</span> MIMEAudio</span><br><span class="line"><span class="keyword">from</span> email.mime.base <span class="keyword">import</span> MIMEBase</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> mimetypes <span class="keyword">import</span> guess_type <span class="keyword">as</span> guess_mime_type</span><br><span class="line"></span><br><span class="line"><span class="comment"># Request all access from Gmail APIs and project</span></span><br><span class="line">SCOPES = [<span class="string">&#x27;https://mail.google.com/&#x27;</span>]</span><br><span class="line">OurEmailID = <span class="string">&#x27;OurMail@gmail.com&#x27;</span> <span class="comment"># giving our Gmail Id</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># using a default function to authenticate Gmail APIs</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">authenticateGmailAPIs</span>():</span><br><span class="line">    creds = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># Authorizing the Gmail APIs with tokens of pickles</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">&quot;token.pickle&quot;</span>): <span class="comment"># using if else statement</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;token.pickle&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> token:</span><br><span class="line">            creds = pickle.load(token)</span><br><span class="line">    <span class="comment"># If there are no valid credentials available in device, we will let the user sign in manually</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> creds <span class="keyword">or</span> <span class="keyword">not</span> creds.valid:</span><br><span class="line">        <span class="keyword">if</span> creds <span class="keyword">and</span> creds.expired <span class="keyword">and</span> creds.refresh_token:</span><br><span class="line">            creds.refresh(Request())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flow = InstalledAppFlow.from_client_secrets_file(<span class="string">&#x27;client_secret_107196167488-dh4b2pmpivffe011kic4em9a4ugrcooi.apps.googleusercontent.com.json&#x27;</span>, SCOPES) <span class="comment"># downloaded credential name</span></span><br><span class="line">            creds = flow.run_local_server(port=<span class="number">0</span>) <span class="comment"># running credentials</span></span><br><span class="line">        <span class="comment"># Save the credentials for the next run</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;token.pickle&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> token:</span><br><span class="line">            pickle.dump(creds, token)</span><br><span class="line">    <span class="keyword">return</span> build(<span class="string">&#x27;Gmail&#x27;</span>, <span class="string">&#x27;v1&#x27;</span>, credentials=creds) <span class="comment"># using Gmail to authenticate</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the Gmail API service by calling the function</span></span><br><span class="line">service = authenticateGmailAPIs()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Please visit this URL to authorize this application: https://accounts.google.com/o/oauth2/auth?response_type=code&amp;client_id=<span class="number">107196167488</span>-dh4b2pmpivffe011kic4em9a4ugrcooi.apps.googleusercontent.com&amp;redirect_uri=http%3A%2F%2Flocalhost%3A55991%2F&amp;scope=https%3A%2F%2Fmail.google.com%2F&amp;state=kfXlNyjvbKetyUK0op7OF9WY7shrKS&amp;access_type=offline</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/17a8e1524365d3e91a1d4e9bcec3dba9.png" alt="Gmail API in Python"></p>
<p><strong>解释-</strong></p>
<p>当我们运行上面给定的程序时，我们会看到一个选择浏览器的选项，如上图所示，如果我们没有看到这样的选项，我们需要点击输出中给定的链接。然后，我们可以选择我们选择的浏览器或系统的默认浏览器来继续这个过程。现在，当我们选择浏览器时，我们将被重定向到我们的浏览器，并可以看到在其中打开的以下选项卡:</p>
<p><img src="/img/c4a79c42c38a6bb6b1d0050eb1a86ad3.png" alt="Gmail API in Python"></p>
<p>现在，我们勾选对话框中显示的复选框选项，以提供所需的权限，然后，我们将不得不单击继续选项。点击继续后，我们可以看到以下窗口将在同一选项卡中打开:</p>
<p><img src="/img/5c3914060be54037e1a84ab766dd51b2.png" alt="Gmail API in Python"></p>
<p>如窗口所示，启用 Gmail API 的身份验证部分已经完成，我们已经将 Gmail 帐户与我们创建的 Gmail API 项目相链接。</p>
<h4 id="注意-当然，我们必须把我们可以连接到-Gmail-APIs-的邮件放在上面程序中提供的“【电子邮件保护】”的地方，以供将来使用-Gmail-APIs-时参考。">注意:当然，我们必须把我们可以连接到 Gmail APIs 的邮件放在上面程序中提供的“<a href="/cdn-cgi/l/email-protection">【电子邮件保护】</a>”的地方，以供将来使用 Gmail APIs 时参考。</h4>
<h2 id="使用-Python-中的-Gmail-APIs-执行操作">使用 Python 中的 Gmail APIs 执行操作</h2>
<p>现在，我们已经用 Python 脚本在我们的项目中完全设置并启用了 Gmail APIs。现在，我们可以使用 Python 程序从 Gmail 帐户执行许多操作。</p>
<p>我们可以在 Python 脚本中使用 Gmail APIs 执行以下 Gmail 操作:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>发送电子邮件</p>
</li>
<li class="lvl-4">
<p>搜索电子邮件</p>
</li>
<li class="lvl-4">
<p>删除电子邮件或整个电子邮件历史记录</p>
</li>
<li class="lvl-4">
<p>阅读电子邮件</p>
</li>
<li class="lvl-4">
<p>标记已读/未读电子邮件等。</p>
</li>
</ul>
<p>在本教程中，我们将只讨论在 Python 程序中使用 Gmail APIs 发送电子邮件，我们将学习使用 Python 脚本编写执行此操作的代码。</p>
<h3 id="发送电子邮件">发送电子邮件</h3>
<p>我们可以通过编写一个 Python 程序并在其中使用启用的 Gmail APIs 来简单地编写和发送一封电子邮件。在这一部分，我们将编写一个 Python 程序，通过运行该程序，我们就可以从 Gmail 帐户发送电子邮件。</p>
<p>为了更好地理解它，请看下面的 Python 程序:</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># importing os and pickle module in program</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="comment"># Creating utils for Gmail APIs</span></span><br><span class="line"><span class="keyword">from</span> googleapiclient.discovery <span class="keyword">import</span> build</span><br><span class="line"><span class="keyword">from</span> google_auth_oauthlib.flow <span class="keyword">import</span> InstalledAppFlow</span><br><span class="line"><span class="keyword">from</span> google.auth.transport.requests <span class="keyword">import</span> Request</span><br><span class="line"><span class="comment"># Importing libraries for encoding/decoding messages in base64</span></span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> urlsafe_b64decode, urlsafe_b64encode</span><br><span class="line"><span class="comment"># Importing libraries for dealing with the attachment of MIME types in Gmail</span></span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.mime.image <span class="keyword">import</span> MIMEImage</span><br><span class="line"><span class="keyword">from</span> email.mime.audio <span class="keyword">import</span> MIMEAudio</span><br><span class="line"><span class="keyword">from</span> email.mime.base <span class="keyword">import</span> MIMEBase</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> mimetypes <span class="keyword">import</span> guess_type <span class="keyword">as</span> guess_mime_type</span><br><span class="line"></span><br><span class="line"><span class="comment"># Request all access from Gmail APIs and project</span></span><br><span class="line">SCOPES = [<span class="string">&#x27;https://mail.google.com/&#x27;</span>] <span class="comment"># providing the scope for Gmail APIs</span></span><br><span class="line">OurEmailID = <span class="string">&#x27;OurMail@gmail.com&#x27;</span> <span class="comment"># giving our Gmail Id</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># using a default function to authenticate Gmail APIs</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">authenticateGmailAPIs</span>():</span><br><span class="line">    creds = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># authorizing the Gmail APIs with tokens of pickles</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">&quot;token.pickle&quot;</span>): <span class="comment"># using if else statement</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;token.pickle&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> token:</span><br><span class="line">            creds = pickle.load(token)</span><br><span class="line">    <span class="comment"># if there are no valid credentials available in device, we will let the user sign in manually</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> creds <span class="keyword">or</span> <span class="keyword">not</span> creds.valid:</span><br><span class="line">        <span class="keyword">if</span> creds <span class="keyword">and</span> creds.expired <span class="keyword">and</span> creds.refresh_token:</span><br><span class="line">            creds.refresh(Request())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flow = InstalledAppFlow.from_client_secrets_file(<span class="string">&#x27;client_secret_107196167488-dh4b2pmpivffe011kic4em9a4ugrcooi.apps.googleusercontent.com.json&#x27;</span>, SCOPES) <span class="comment"># downloaded credential name</span></span><br><span class="line">            creds = flow.run_local_server(port=<span class="number">0</span>) <span class="comment"># running credentials</span></span><br><span class="line">        <span class="comment"># save the credentials for the next run</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;token.pickle&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> token:</span><br><span class="line">            pickle.dump(creds, token)</span><br><span class="line">    <span class="keyword">return</span> build(<span class="string">&#x27;gmail&#x27;</span>, <span class="string">&#x27;v1&#x27;</span>, credentials=creds) <span class="comment"># using Gmail to authenticate</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the Gmail API service by calling the function</span></span><br><span class="line">ServicesGA = authenticateGmailAPIs()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using a default funnction to add attachments in Mail</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">AddAttachment</span>(<span class="params">mail, NameofFile</span>):</span><br><span class="line">    content_type, encoding = guess_mime_type(NameofFile)</span><br><span class="line">    <span class="keyword">if</span> content_type <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> encoding <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: <span class="comment"># defining none file type attachment</span></span><br><span class="line">        content_type = <span class="string">&#x27;application/octet-stream&#x27;</span></span><br><span class="line">    main_type, sub_type = content_type.split(<span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> main_type == <span class="string">&#x27;text&#x27;</span>: <span class="comment"># defining text file type attachment</span></span><br><span class="line">        fp = <span class="built_in">open</span>(NameofFile, <span class="string">&#x27;rb&#x27;</span>) <span class="comment"># opening file</span></span><br><span class="line">        msg = MIMEText(fp.read().decode(), _subtype = sub_type)</span><br><span class="line">        fp.close() </span><br><span class="line">    <span class="keyword">elif</span> main_type == <span class="string">&#x27;image&#x27;</span>: <span class="comment"># defining image file type attachment</span></span><br><span class="line">        fp = <span class="built_in">open</span>(NameofFile, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">        msg = MIMEImage(fp.read(), _subtype = sub_type)</span><br><span class="line">        fp.close()</span><br><span class="line">    <span class="keyword">elif</span> main_type == <span class="string">&#x27;audio&#x27;</span>: <span class="comment"># defining audio file type attachment</span></span><br><span class="line">        fp = <span class="built_in">open</span>(NameofFile, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">        msg = MIMEAudio(fp.read(), _subtype = sub_type) <span class="comment"># reading file</span></span><br><span class="line">        fp.close()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        fp = <span class="built_in">open</span>(NameofFile, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">        msg = MIMEBase(main_type, sub_type)</span><br><span class="line">        msg.set_payload(fp.read())</span><br><span class="line">        fp.close() <span class="comment"># closing file</span></span><br><span class="line">    NameofFile = os.path.basename(NameofFile)</span><br><span class="line">    msg.add_header(<span class="string">&#x27;Content-Disposition&#x27;</span>, <span class="string">&#x27;attachment&#x27;</span>, NameofFile = NameofFile)</span><br><span class="line">    mail.attach(msg) <span class="comment"># composing the mail with given attachment</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Creating mail with a default function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">CreateMail</span>(<span class="params">RecieverMail, SubofMail, BodyofMail, attachments=[]</span>): <span class="comment"># various import content of mail as function&#x27;s parameter</span></span><br><span class="line">    <span class="comment"># Using if else to check if there is any attachment in mail or not</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> attachments: <span class="comment"># no attachment is given in the mail</span></span><br><span class="line">        mail = MIMEText(BodyofMail) <span class="comment"># Body of Mail</span></span><br><span class="line">        mail[<span class="string">&#x27;to&#x27;</span>] = RecieverMail <span class="comment"># mail ID of Reciever</span></span><br><span class="line">        mail[<span class="string">&#x27;from&#x27;</span>] = OurEmailID <span class="comment"># our mail ID</span></span><br><span class="line">        mail[<span class="string">&#x27;subject&#x27;</span>] = SubofMail <span class="comment"># Subject of Mail</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># attachment is given in the mail</span></span><br><span class="line">        mail = MIMEMultipart()</span><br><span class="line">        mail[<span class="string">&#x27;to&#x27;</span>] = RecieverMail</span><br><span class="line">        mail[<span class="string">&#x27;from&#x27;</span>] = OurEmailID</span><br><span class="line">        mail[<span class="string">&#x27;subject&#x27;</span>] = SubofMail</span><br><span class="line">        mail.attach(MIMEText(BodyofMail))</span><br><span class="line">        <span class="keyword">for</span> NameofFile <span class="keyword">in</span> attachments:</span><br><span class="line">            AddAttachment(mail, NameofFile)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;raw&#x27;</span>: urlsafe_b64encode(mail.as_bytes()).decode()&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creating a default function to send a mail</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SendMail</span>(<span class="params">ServicesGA, RecieverMail, SubofMail, BodyofMail, attachments=[]</span>):</span><br><span class="line">    <span class="keyword">return</span> ServicesGA.users().messages().send(</span><br><span class="line">      userId = <span class="string">&quot;me&quot;</span>,</span><br><span class="line">      body = CreateMail(RecieverMail, SubofMail, BodyofMail, attachments)</span><br><span class="line">    ).execute() <span class="comment"># Body of the mail with execute() function</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sending an email by adding important content, i.e., Reciever&#x27;s mail, Subject, Body, etc.</span></span><br><span class="line">SendMail(ServicesGA, <span class="string">&quot;Reciever@gmail.com&quot;</span>, <span class="string">&quot;Python Project i.e., This is the subject of Mail we are send/img!&quot;</span>, </span><br><span class="line">            <span class="string">&quot;Now, this is the body of the email we are writing and we can add only written text here!&quot;</span>, [<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;client_secret_107196167488-dh4b2pmpivffe011kic4em9a4ugrcooi.apps.googleusercontent.com.json&quot;</span>]) <span class="comment"># calling out default SendMail() function</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<p><img src="//img/a347707cf327a1d3cd8dca59bdd88e7e.png" alt="Gmail API in Python"></p>
<p>如果我们把我们的邮件放在收件人邮件的地方，即<a href="/cdn-cgi/l/email-protection">【email protected】</a>，我们会发现邮件实际上是发送给我们在运行程序时作为收件人邮件输入的邮件，与我们在上面的输出图像中看到的一样。</p>
<h2 id="结论-3">结论</h2>
<p>要将 Gmail API 与我们的 Python 脚本或简单地与 Python 一起使用，首先，我们必须启用它们，并使用我们的 Gmail 帐户在谷歌云中创建一个项目。</p>
<p>我们还可以执行许多其他操作，如阅读、删除等。，在我们的 Python 程序中使用 Gmail APIs 就像发送电子邮件一样。我们还可以通过运行我们的 Python 脚本(通过 Gmail APIs 启用)将许多东西修改到我们通过 Gmail APIs 项目验证的 Gmail 帐户中。</p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的网格搜索</title>
    <url>/posts/ef3a60d1.html</url>
    <content><![CDATA[<h1>Python 中的网格搜索</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/grid-search-in-python">https://www.javatpoint.com/grid-search-in-python</a></p>
</blockquote>
<p>在本教程中，我们将讨论用于优化超参数的网格搜索。我们还将了解网格搜索的工作原理，以及它在优化机器学习方法性能方面的实现。</p>
<p><strong>超参数调整</strong>对于<a href="https://www.javatpoint.com/machine-learning">机器学习(ML)</a> 模型的适当工作具有重要意义。像<strong>网格搜索</strong>这样的方法似乎是超参数优化的基本工具。</p>
<p><strong>网格搜索</strong>方法考虑一些超参数组合，并选择返回较低错误分数的组合。当只有一些超参数需要优化时，这种方法特别有用。然而，当机器学习模型的复杂性增加时，它的性能优于其他加权随机搜索方法。</p>
<p>让我们从理解网格搜索开始。</p>
<h2 id="理解网格搜索">理解网格搜索</h2>
<p><strong>网格搜索</strong>是一种优化算法，它允许我们从我们提供的参数选择列表中选择最佳参数来优化问题，从而使‘试错’方法自动化。虽然我们可以将其应用于多个优化问题；然而，最常见的是将其用于机器学习，以获得模型提供最佳精度的参数。</p>
<p>让我们考虑模型以输入的形式接受以下三个参数:</p>
<ol>
<li class="lvl-4">
<p>隐藏层数[2，4]</p>
</li>
<li class="lvl-4">
<p>每层神经元数量[5，10]</p>
</li>
<li class="lvl-4">
<p>时代数量[10，50]</p>
</li>
</ol>
<p>如果我们想为每个参数输入尝试两个选项(如上面方括号中所指定的)，它会估计不同的组合。例如，一个可能的组合可以是[2，5，10]。手动找到这样的组合将是一件令人头痛的事情。</p>
<p>现在，假设我们有 10 个不同的参数作为输入，我们想要为每个参数尝试 5 个可能的值。每当我们想要更改参数值、重新执行代码以及记录每个参数组合的输出时，都需要程序员手动输入。</p>
<p>网格搜索自动执行该过程，因为它接受每个参数的可能值并执行代码，以便尝试每个可能的组合，输出组合的结果并输出具有最佳精度的组合。</p>
<h2 id="安装所需的库">安装所需的库</h2>
<p>在我们开始用 <a href="https://www.javatpoint.com/python-tutorial">Python 编程语言</a>实现网格搜索之前，让我们简单讨论一下系统中需要安装的一些必要的库和框架。</p>
<p>这些库和框架如下:</p>
<ol>
<li class="lvl-4">
<p>Python 3</p>
</li>
<li class="lvl-4">
<p>num py</p>
</li>
<li class="lvl-4">
<p><a href="https://www.javatpoint.com/python-pandas">Pandas</a></p>
</li>
<li class="lvl-4">
<p><a href="https://www.javatpoint.com/keras">硬</a></p>
</li>
<li class="lvl-4">
<p>Scikit-Learn</p>
</li>
</ol>
<p>它们都很容易安装。我们可以使用 pip 安装程序来安装这些库，如下所示:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ pip install numpy tensorflow pandas scikit-learn keras</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="注意-如果在执行任何软件包时出现任何问题，请尝试重新安装并参考每个软件包的官方文档。">注意:如果在执行任何软件包时出现任何问题，请尝试重新安装并参考每个软件包的官方文档。</h4>
<p>现在，让我们开始用 Python 实现网格搜索</p>
<h2 id="Python-中网格搜索的实现">Python 中网格搜索的实现</h2>
<p>在下一节中，我们将了解如何在实际应用中实现网格搜索。我们将简单地执行代码，并深入讨论网格搜索部分，而不是讨论机器学习和数据预处理部分。</p>
<p>那么，让我们开始吧。</p>
<p>我们将使用饮食数据集，该数据集包含基于各种属性(如性别、年龄和饮食类型)的不同人的身高和体重数据。借助 Pandas <strong>read_csv()</strong> 功能，我们可以直接从在线资源导入数据。</p>
<p>但在此之前，我们必须导入所需的包:</p>
<p><strong>文件:mygrid.py</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV, KFold</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Dropout</span><br><span class="line"><span class="keyword">from</span> keras.wrappers.scikit_learn <span class="keyword">import</span> KerasClassifier</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> Adam</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的代码片段中，我们已经导入了项目所需的包和库。还可以保存程序文件并执行它，以便检查库和包是否正确安装和导入。</p>
<p>一旦包成功导入，我们必须使用下面的代码片段来导入数据集并打印它的前五行。</p>
<p><strong>文件:mygrid.py</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># importing the dataset</span></span><br><span class="line">mydf = pd.read_csv(<span class="string">&quot;Diet_Dataset.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># printing the first five lines of dataset</span></span><br><span class="line"><span class="built_in">print</span>(mydf.head())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">   Person gender  Age  Height  pre.weight  Diet  weight6weeks</span><br><span class="line"><span class="number">0</span>      <span class="number">25</span>          <span class="number">41</span>     <span class="number">171</span>          <span class="number">60</span>     <span class="number">2</span>          <span class="number">60.0</span></span><br><span class="line"><span class="number">1</span>      <span class="number">26</span>          <span class="number">32</span>     <span class="number">174</span>         <span class="number">103</span>     <span class="number">2</span>         <span class="number">103.0</span></span><br><span class="line"><span class="number">2</span>       <span class="number">1</span>      <span class="number">0</span>   <span class="number">22</span>     <span class="number">159</span>          <span class="number">58</span>     <span class="number">1</span>          <span class="number">54.2</span></span><br><span class="line"><span class="number">3</span>       <span class="number">2</span>      <span class="number">0</span>   <span class="number">46</span>     <span class="number">192</span>          <span class="number">60</span>     <span class="number">1</span>          <span class="number">54.0</span></span><br><span class="line"><span class="number">4</span>       <span class="number">3</span>      <span class="number">0</span>   <span class="number">55</span>     <span class="number">170</span>          <span class="number">64</span>     <span class="number">1</span>          <span class="number">63.3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的代码片段中，我们使用<strong>Pandas</strong>库的 <strong>read_csv()</strong> 导入数据集，并将其存储在 <strong>mydf</strong> 变量中。然后，我们使用 <strong>head()</strong> 函数和 <strong>mydf</strong> 变量打印了前五行。</p>
<p>现在，让我们将数据划分为要素集和标签集，以便对数据集应用标准缩放。</p>
<p>其代码片段如下所示:</p>
<p><strong>文件:mygrid.py</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># converting dataframe into numpy array</span></span><br><span class="line">mydataset = mydf.values</span><br><span class="line"></span><br><span class="line">X = mydataset[:, <span class="number">0</span>:<span class="number">6</span>]</span><br><span class="line">Y = mydataset[:, <span class="number">6</span>].astype(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Normalizing the data using sklearn StandardScaler</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"></span><br><span class="line">myscaler = StandardScaler().fit(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Transforming and displaying the training data</span></span><br><span class="line">X_stdized = myscaler.transform(X)</span><br><span class="line"></span><br><span class="line">mydata = pd.DataFrame(X_stdized)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的代码片段中，我们已经将<strong>Pandas</strong>数据帧转换成了 <strong>NumPy</strong> 数组。然后我们从 <strong>sklearn</strong> 库中导入了<strong>标准缩放器</strong>模块，并使用该函数对数据进行归一化。然后，我们使用 <strong>transform()</strong> 函数转换并显示了训练数据。</p>
<p>现在，让我们考虑下面的代码片段，以便创建一个简单的深度学习模型。</p>
<p><strong>文件:mygrid.py</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># defining the function to create model</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_my_model</span>(<span class="params">learnRate, dropoutRate</span>):</span><br><span class="line">    <span class="comment"># Creating model</span></span><br><span class="line">    mymodel = Sequential()</span><br><span class="line">    mymodel.add(Dense(<span class="number">6</span>, input_dim = <span class="number">6</span>, kernel_initializer = <span class="string">&#x27;normal&#x27;</span>, activation = <span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    mymodel.add(Dropout(dropoutRate))</span><br><span class="line">    mymodel.add(Dense(<span class="number">3</span>, input_dim = <span class="number">6</span>, kernel_initializer = <span class="string">&#x27;normal&#x27;</span>, activation = <span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    mymodel.add(Dropout(dropoutRate))</span><br><span class="line">    mymodel.add(Dense(<span class="number">1</span>, activation = <span class="string">&#x27;sigmoid&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Compiling the model</span></span><br><span class="line">    my_Adam = Adam(learning_rate = learnRate)</span><br><span class="line">    mymodel.<span class="built_in">compile</span>(loss = <span class="string">&#x27;binary_crossentropy&#x27;</span>, optimizer = my_Adam, metrics = [<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> mymodel</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>下面的代码片段将函数定义为 <strong>create_my_model()</strong> 接受两个参数，即 <strong>learnRate</strong> 和<strong>dropoultrate</strong>。然后，我们使用<strong>顺序()<strong>功能将模型创建为</strong>我的模型</strong>。我们还使用了 <strong>add()</strong> 以及 <strong>Dense()</strong> 和**drop()**功能。然后我们使用 <strong>compile()</strong> 函数编译了模型。</p>
<p>因此，当我们执行代码时，这将导致加载数据集，对其进行预处理，并创建机器学习模型。因为我们只对理解网格搜索的工作感兴趣，所以我们没有执行训练/测试分割，我们已经在完整的数据集上拟合了模型。</p>
<p>现在，我们将在下一节中了解网格搜索如何通过优化参数使程序员的生活变得更容易。</p>
<h3 id="不使用网格搜索训练模型">不使用网格搜索训练模型</h3>
<p>在下面显示的代码片段中，我们将借助随机决定的或基于直觉的参数值创建一个模型，并看看我们的模型如何运行:</p>
<p><strong>文件:mygrid.py</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Declaring the values of the parameter</span></span><br><span class="line">dropoutRate = <span class="number">0.1</span></span><br><span class="line">epochs = <span class="number">1</span></span><br><span class="line">batchSize = <span class="number">20</span></span><br><span class="line">learnRate = <span class="number">0.001</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Creating the model object by calling the create_my_model function we created above</span></span><br><span class="line">mymodel = create_my_model(learnRate, dropoutRate)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fitting the model onto the training data</span></span><br><span class="line">mymodel.fit(X_stdized, Y, batch_size = batchSize, epochs = epochs, verbose = <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>/<span class="number">4</span> [==============================] - 41s 14ms/step - loss: <span class="number">0.9364</span> - accuracy: <span class="number">0.0000e+00</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的代码片段中，我们已经分别声明了参数的值，即<strong>dropoultrate、epochs、batchSize</strong> 和 <strong>learnRate</strong> 。然后，我们通过调用 <strong>create_my_model()</strong> 函数来创建模型对象。然后，我们将模型拟合到训练数据上。</p>
<p>结果，我们得到的精度是 0.0000e+00。</p>
<h3 id="利用网格搜索优化超参数">利用网格搜索优化超参数</h3>
<p>如果我们没有使用网格搜索方法，我们可以在上面创建的模型上直接调用 <strong>fit()</strong> 函数。但是为了利用网格搜索方法，我们必须向 <strong>create_my_model()</strong> 函数传递一些参数。此外，我们必须用各种选项声明网格，以尝试每个参数。让我们在不同的地方表演。</p>
<p>首先，我们将尝试修改 <strong>create_my_model()</strong> 函数，以便接受来自调用函数的参数，如下所示:</p>
<p><strong>文件:mygrid.py</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_my_model</span>(<span class="params">learnRate, dropoutRate</span>):</span><br><span class="line">    <span class="comment"># Creating the model</span></span><br><span class="line">    mymodel = Sequential()</span><br><span class="line">    mymodel.add(Dense(<span class="number">6</span>, input_dim = <span class="number">6</span>, kernel_initializer = <span class="string">&#x27;normal&#x27;</span>, activation = <span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    mymodel.add(Dropout(dropoutRate))</span><br><span class="line">    mymodel.add(Dense(<span class="number">3</span>, input_dim = <span class="number">6</span>, kernel_initializer = <span class="string">&#x27;normal&#x27;</span>, activation = <span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    mymodel.add(Dropout(dropoutRate))</span><br><span class="line">    mymodel.add(Dense(<span class="number">1</span>, activation = <span class="string">&#x27;sigmoid&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Compile the model</span></span><br><span class="line">    myadam = Adam(learning_rate = learnRate)</span><br><span class="line">    mymodel.<span class="built_in">compile</span>(loss = <span class="string">&#x27;binary_crossentropy&#x27;</span>, optimizer = myadam, metrics = [<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> mymodel</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creating the model object</span></span><br><span class="line">mymodel = KerasClassifier(build_fn = create_my_model, verbose = <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的代码片段中，我们对之前的 <strong>create_my_model</strong> 函数进行了一些更改，并使用了 <strong>KerasClassifier</strong> 来创建模型对象。</p>
<p>现在，让我们实现网格搜索算法，并在其上拟合数据集:</p>
<p><strong>文件:mygrid.py</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Defining the arguments that we want to use in Grid Search along</span></span><br><span class="line"><span class="comment"># with the list of values that we want to try out</span></span><br><span class="line">learnRate = [<span class="number">0.001</span>, <span class="number">0.02</span>, <span class="number">0.2</span>]</span><br><span class="line">dropoutRate = [<span class="number">0.0</span>, <span class="number">0.2</span>, <span class="number">0.4</span>]</span><br><span class="line">batchSize = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line">epochs = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Making a dictionary of the grid search parameters</span></span><br><span class="line">paramgrid = <span class="built_in">dict</span>(learnRate = learnRate, dropoutRate = dropoutRate, batch_size = batchSize, epochs = epochs )</span><br><span class="line"></span><br><span class="line"><span class="comment"># Building and fitting the GridSearchCV</span></span><br><span class="line">mygrid = GridSearchCV(estimator = mymodel, param_grid = paramgrid, cv = KFold(random_state = <span class="literal">None</span>), verbose = <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">gridresults = mygrid.fit(X_stdized, Y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Summarizing the results in a readable format</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Best: &quot;</span> + gridresults.best_score_ + <span class="string">&quot; using &quot;</span> + gridresults.best_params_)</span><br><span class="line"></span><br><span class="line">means = gridresults.cv_results_[<span class="string">&#x27;mean_test_score&#x27;</span>]</span><br><span class="line">stds = gridresults.cv_results_[<span class="string">&#x27;std_test_score&#x27;</span>]</span><br><span class="line">params = gridresults.cv_results_[<span class="string">&#x27;params&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> mean, stdev, param <span class="keyword">in</span> <span class="built_in">zip</span>(means, stds, params):</span><br><span class="line">    <span class="built_in">print</span>(mean + <span class="string">&quot;(&quot;</span> + stdev + <span class="string">&quot;)&quot;</span> + <span class="string">&quot; with: &quot;</span> + param)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Best: <span class="number">0.00347268912077</span>, using &#123;batch_size=<span class="number">10</span>, dropoutRate=<span class="number">0.4</span>, epochs=<span class="number">5</span>, learnRate=<span class="number">0.2</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>上述输出显示了产生最佳精度的参数组合。</p>
<p>最后，我们可以得出结论，网格搜索在 Python 编程语言中非常容易实现，并且节省了我们大量的人工时间。我们可以列出所有想要调优的参数，声明需要测试的值，执行代码，然后忘掉它。这个过程是如此简单和方便，以至于它需要程序员更少的输入。一旦找到最佳参数组合，我们就可以将它用于最终模型。</p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python找到第`n`个斐波那契数</title>
    <url>/posts/8af701f5.html</url>
    <content><![CDATA[<h1>Python 程序：找到第<code>n</code>个斐波那契数</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-program-to-find-the-nth-fibonacci-number">https://www.javatpoint.com/python-program-to-find-the-nth-fibonacci-number</a></p>
</blockquote>
<p>在下面的教程中，我们将了解如何使用 Python 找到第<code>n</code>个斐波那契数。我们可以定义一个斐波那契数，下面的数字是前面两个数字的和。</p>
<p>斐波那契数列的前两个元素分别是 0 和 1。我们可以通过将前面两个元素相加来计算级数的第三个元素，得到的第三项为 0 + 1，等于 1。同样，第四项将是第二项和第三项的总和，即 1 + 1 = 2，以此类推。这一系列数字被称为斐波那契数列。</p>
<p>递归关系定义了如下所示的斐波那契数:</p>
<p><strong>F<sub>n</sub>= F<sub>n-1</sub>+F<sub>n-2</sub></strong></p>
<p>使用 Python 编程语言有不同的方法可以找到第<code>n</code>个斐波那契数。其中一些如下:</p>
<ol>
<li class="lvl-4">
<p>用递归法求第<code>n</code>个斐波那契数</p>
</li>
<li class="lvl-4">
<p>用动态规划法求第<code>n</code>个斐波那契数</p>
</li>
<li class="lvl-4">
<p>利用动态规划和空间优化寻找第<code>n</code>个斐波那契数</p>
</li>
<li class="lvl-4">
<p>用数组求第<code>n</code>个斐波那契数</p>
</li>
</ol>
<p>在这些方法中，最基本的两种是递归方法和动态方法。</p>
<p>让我们通过例子来详细了解这些方法的工作原理。</p>
<h2 id="用递归法求第n个斐波那契数">用递归法求第<code>n</code>个斐波那契数</h2>
<p>递归这个术语是用来定义自身内部的东西的。在像 Python 这样的编程语言中，递归指的是函数调用自身的过程。有了正确的代码，递归将创建一个有限循环。</p>
<p>为了更好地理解，让我们考虑下面的代码片段。</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># defining the function for Fibonacci Series</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Fibonacci_Series</span>(<span class="params">n</span>): </span><br><span class="line">    <span class="comment"># using if-else conditional statement</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Oops! Incorrect input&quot;</span>)</span><br><span class="line">    <span class="comment"># First Fibonacci number is 0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">0</span>: </span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>) </span><br><span class="line">    <span class="comment"># Second Fibonacci number is 1 </span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> (Fibonacci_Series(n - <span class="number">1</span>) + Fibonacci_Series(n - <span class="number">2</span>)) </span><br><span class="line"><span class="comment"># printing the 12th element of the Fibonacci Series</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;12th Element of the Fibonacci Series:&quot;</span>, Fibonacci_Series(<span class="number">12</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">12th Element of the Fibonacci Series: <span class="number">144</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的代码片段中，我们定义了一个函数为<strong>斐波那契数列()</strong>，该函数接受一个参数为 <strong>n</strong> 。</p>
<p>而且，我们知道斐波那契数列的前两个元素是 <strong>0</strong> 和 <strong>1</strong> 。在输入为 <strong>n = 1</strong> 或 <strong>n = 2</strong> (斐波那契数列的第一项或第二项)的情况下，我们使用 <strong>if-else</strong> 条件语句返回 <strong>0</strong> 或 <strong>1</strong> 。如果 <strong>n</strong> 的值大于 <strong>2</strong> ，函数将以较低的输入值调用自身。我们可以观察到代码返回**(斐波那契数列(n - 1) +斐波那契数列(n - 2))** 。在这里，函数以较低的值调用自己，除非它达到 <strong>n = 1</strong> 和 <strong>n = 2</strong> 的基值，并且我们从前面知道， <strong>n = 1</strong> 返回 <strong>0</strong> ， <strong>n = 2</strong> 返回 <strong>1</strong> 。然后，返回值被连续相加以产生斐波那契数列的序列。</p>
<h2 id="用动态规划法求第n个斐波那契数">用动态规划法求第<code>n</code>个斐波那契数</h2>
<p>动态编程也使用递归；然而，它主要利用 <strong>if-els</strong> e 条件语句。在语句中，斐波那契数的值存储在一个变量中。借助递归，重复加法让我们得到这个斐波那契数。</p>
<p>让我们考虑下面的例子来理解同样的事情。</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># defining the function to find the nth Fibonacci Number</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Fibonacci_series</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="comment"># Taking First two terms of the Fibonacci Series as 0 and 1</span></span><br><span class="line">    fib_Array = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="comment"># Here, as we know that the first two terms of Fibonacci Series are 0 and 1,</span></span><br><span class="line">    <span class="comment"># we append the remaining values (Fibonacci numbers from index 2 to x)</span></span><br><span class="line">    <span class="comment"># in the array using recursion and return the last element. </span></span><br><span class="line">    <span class="comment"># In the range function, we take range(2, x + 1) instead of range(2, x).</span></span><br><span class="line">    <span class="comment"># This is because range function in python iterates until the value</span></span><br><span class="line">    <span class="comment"># before the upper limit. So, if we take from 2 to x, it would only</span></span><br><span class="line">    <span class="comment"># iterate from second to (x - 1)th element.</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, x + <span class="number">1</span>):</span><br><span class="line">        fib_Array.append(fib_Array[n - <span class="number">1</span>] + fib_Array[n - <span class="number">2</span>])</span><br><span class="line">    <span class="keyword">return</span> fib_Array[x]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;12th Term of Fibonacci Series:&quot;</span>, Fibonacci_series(<span class="number">12</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">12th Term of Fibonacci Series: <span class="number">144</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的代码片段中，我们将函数定义为<strong>斐波那契数列()</strong>，它接受参数作为变量 <strong>x</strong> 。我们创建了一个一维数组作为 <strong>fib_Array</strong> ，数据元素 <strong>0</strong> 和 <strong>1</strong> 位于其第 0 个和第 1 个索引中。然后，如果提供的输入(’ <strong>x</strong> ')小于或等于 <strong>2</strong> ，这也是数组 <strong>fib_Array</strong> 的长度，则返回 <strong>0</strong> 作为 <strong>x = 1</strong> 的第一个数字， <strong>1</strong> 作为 <strong>x = 2</strong> 的第二个数字。如果 <strong>x</strong> 的值大于 <strong>2</strong> ，我们已经使用递归调用并插入了前面的两个数据元素。然而，我们没有直接返回第<code>n</code>个斐波那契数，而是将每个求和元素附加到 <strong>fib_Array</strong> 数组中。最后，我们返回了数组的最后一个元素(即第<code>n</code>个元素)，并为用户打印了值。</p>
<h2 id="利用动态规划和空间优化寻找第n个斐波那契数">利用动态规划和空间优化寻找第<code>n</code>个斐波那契数</h2>
<p>这种方法几乎与动态规划完全相同。然而，动态编程利用递归来完成循环加法，而这种方法利用 <code>for</code>循环。</p>
<p>让我们考虑下面的例子来理解同样的事情。</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># defing the function to return the nth element of the Fibonacci Series</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Fibonacci_series</span>(<span class="params">x</span>): </span><br><span class="line">    <span class="comment"># assiging the variables</span></span><br><span class="line">    m = <span class="number">0</span></span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">    <span class="comment"># using the if-elif-else conditional statements</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Wrong input&quot;</span>) </span><br><span class="line">    <span class="keyword">elif</span> x == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> m </span><br><span class="line">    <span class="keyword">elif</span> x == <span class="number">1</span>: </span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># using the for-loop </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, x + <span class="number">1</span>): </span><br><span class="line">            o = m + n</span><br><span class="line">            m = n </span><br><span class="line">            n = o </span><br><span class="line">        <span class="keyword">return</span> n </span><br><span class="line"><span class="comment"># printing the twelveth term of the Fibonacci Series</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;12th element of the Fibonacci Series:&quot;</span>, Fibonacci_series(<span class="number">12</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">12th element of the Fibonacci Series: <span class="number">144</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的代码片段中，我们定义了一个函数并分配了两个变量， <strong>m = 0</strong> 和 <strong>n = 1</strong> 。这些元素是斐波那契数列的第一个和第二个元素。然后我们使用了 <strong>if-elif-else</strong> 条件语句，其中程序为输入值 <strong>x = 1</strong> 返回 <strong>0</strong> ，为输入值 <strong>x = 2</strong> 返回 <strong>1</strong> 。如果 <strong>x</strong> 的值大于 <strong>2</strong> ，我们在 <strong>(2，x + 1)</strong> 范围内使用了 <strong>i</strong> 的 <strong>for-loop</strong> 。我们取了一个变量 o 来存储数列中前面两个元素的和。一旦 <strong>o</strong> 取 <strong>m + n</strong> 的值， <strong>m</strong> 的值被重新分配给 <strong>n</strong> 。随后， <strong>n</strong> 的值被重新分配给 <strong>o</strong> 的值。这个过程继续，值 3 继续重新分配，直到循环结束。一旦循环终止，该函数返回 <strong>n</strong> 的值，该值存储第<code>n</code>个斐波那契数的值。</p>
<h2 id="用数组求第n个斐波那契数">用数组求第<code>n</code>个斐波那契数</h2>
<p>在这个方法中，我们使用 <strong>for-loop</strong> 通过重复加法创建一个大小为 <strong>x</strong> 的数组。因此，返回第<code>n</code>个斐波那契数。</p>
<p>让我们考虑下面的例子来理解同样的事情。</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># defining the function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Fibonacci_series</span>(<span class="params">x</span>): </span><br><span class="line">  <span class="comment"># creating an array in the function</span></span><br><span class="line">   fib_Array = [<span class="number">0</span>] * (x + <span class="number">1</span>)</span><br><span class="line">   fib_Array[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">   <span class="comment"># adding elements of the series to the array using addition of previous two elements.</span></span><br><span class="line">   <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">2</span>, x + <span class="number">1</span>):</span><br><span class="line">      fib_Array[n] = fib_Array[n - <span class="number">1</span>] + fib_Array[n - <span class="number">2</span>] </span><br><span class="line">   <span class="keyword">return</span> fib_Array[x]</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;12th element of the Fibonacci series:&quot;</span>, Fibonacci_series(<span class="number">12</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">12th element of the Fibonacci series: <span class="number">144</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的代码片段中，我们已经定义了函数。在函数中，我们创建了一个数组来寻找斐波那契数列的第<code>n</code>个元素。然后，我们使用 <strong>for-loop</strong> 通过重复前面两个元素的添加，将序列的元素添加到数组中。最后，第<code>n</code>个元素被返回并打印给用户。</p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python高阶函数</title>
    <url>/posts/62ad0d63.html</url>
    <content><![CDATA[<h1>Python 高阶函数</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-high-order-function">https://www.javatpoint.com/python-high-order-function</a></p>
</blockquote>
<p>因为我们必须了解 Python 函数的基本概念，所以我们应该继续讨论一些与 Python 函数相关的高级概念。在本教程中，我们将讨论 Python 中高阶函数的重要方面，例如什么是高阶函数，我们如何在 Python 中定义它们，如何在 Python 中使用它们，以及高阶函数的属性是什么。</p>
<h3 id="先决条件-2">先决条件:</h3>
<p>要了解 Python 中的高阶函数，我们必须具备以下概念的基本知识:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>Python 函数</p>
</li>
<li class="lvl-4">
<p>Parameters</p>
</li>
<li class="lvl-4">
<p>Python 对象</p>
</li>
<li class="lvl-4">
<p>Python 装饰器</p>
</li>
</ul>
<p>首先，让我们从第一件事开始，即高阶函数，并了解它们的一个基本情况。</p>
<h2 id="高阶函数">高阶函数</h2>
<p>将另一个函数作为参数的函数或在输出中返回另一个函数作为返回的函数称为高阶函数。高阶函数与程序中给出的其他函数一起工作。</p>
<p>关于高阶函数的一个事实是，高阶函数既适用于两个函数，也适用于将函数作为其参数或作为其结果返回函数的方法。在 <a href="https://www.javatpoint.com/python-tutorial">Python</a> 中，这个高阶函数的概念得到了方方面面的支持。</p>
<h3 id="Python-中高阶函数的性质">Python 中高阶函数的性质</h3>
<p>现在，在本节中，我们将讨论同样适用于 Python 的高阶函数的一些重要属性。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>在高阶函数中，我们可以在变量中存储函数。</p>
</li>
<li class="lvl-4">
<p>在高阶函数中，函数可以充当对象类型的瞬间。</p>
</li>
<li class="lvl-4">
<p>在高阶函数中，我们可以将一个函数作为另一个函数的结果返回。</p>
</li>
<li class="lvl-4">
<p>在高阶函数中，我们可以将一个函数作为参数或自变量传递给另一个函数。</p>
</li>
<li class="lvl-4">
<p>我们可以以列表、哈希表等数据结构格式存储 Python 高阶函数。</p>
</li>
</ul>
<h2 id="Python-中的高阶函数">Python 中的高阶函数</h2>
<p>现在，在本节中，我们将具体讨论 Python 高阶函数以及如何定义它们。我们将讨论在 Python 程序中定义和使用高阶函数的方法和手段。</p>
<p>以下是我们将在本教程中讨论的在 Python 代码中定义高阶函数的方法。</p>
<ol>
<li class="lvl-4">
<p>在高阶函数中使用函数作为对象</p>
</li>
<li class="lvl-4">
<p>作为高阶函数的结果返回函数</p>
</li>
<li class="lvl-4">
<p>函数作为另一个函数的参数</p>
</li>
<li class="lvl-4">
<p>装饰者作为高阶函数</p>
</li>
</ol>
<p>现在，我们将详细讨论上面给出的每种方法，并了解它们在 Python 程序中作为高阶函数的实现。</p>
<h3 id="方法-1-在高阶函数中使用函数作为对象">方法 1:在高阶函数中使用函数作为对象</h3>
<p>在 Python 中，我们甚至可以给变量分配一个给定的函数。将函数赋值到变量中不会调用实际函数，相反，它会创建对所创建函数的引用。因此，它使得这种将函数赋值为变量对象的赋值将在程序中创建一个高阶函数。</p>
<p>查看下面的示例程序，了解我们上面讨论的方法的实现:</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># a default function to take another function parameter</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spell</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="comment"># Making text in upper</span></span><br><span class="line">    <span class="keyword">return</span> text.upper() </span><br><span class="line"><span class="comment"># Taking text as user input</span></span><br><span class="line">text = <span class="built_in">input</span>(<span class="string">&quot;Enter a text to print it in uppercase and double: &quot;</span>)</span><br><span class="line"><span class="comment"># Spell function with text</span></span><br><span class="line"><span class="built_in">print</span>(spell(text)) </span><br><span class="line"><span class="comment"># Assigning variable with the default function</span></span><br><span class="line">scream = spell</span><br><span class="line"><span class="comment"># Scream with text variable</span></span><br><span class="line"><span class="built_in">print</span>(scream(text))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter a text to <span class="built_in">print</span> it <span class="keyword">in</span> uppercase <span class="keyword">and</span> double: JavaTPoint</span><br><span class="line">JAVATPOINT</span><br><span class="line">JAVATPOINT</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="方法-2-将函数作为另一个函数的参数">方法 2:将函数作为另一个函数的参数</h3>
<p>基本上，Python 函数就像 Python 对象，因此我们可以使用 Python 函数将它们作为参数传递给另一个函数，这将在程序中创建一个高阶函数。</p>
<p>看下面的程序来理解上面给出的方法的实现:</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Default function for making text uppercase</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scream</span>(<span class="params">word</span>): </span><br><span class="line">    <span class="keyword">return</span> word.upper() </span><br><span class="line"><span class="comment"># Default function for making text lowercase</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spell</span>(<span class="params">word</span>): </span><br><span class="line">    <span class="keyword">return</span> word.lower() </span><br><span class="line"><span class="comment"># A third function that work as a high order function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">funct</span>): </span><br><span class="line">    <span class="comment"># Storing the function in a variable in high order function </span></span><br><span class="line">    speaking = funct(<span class="string">&quot;Hello Python Developers! You are welcomed to JavaTpoint&quot;</span>) </span><br><span class="line">    <span class="built_in">print</span>(speaking)  </span><br><span class="line"><span class="comment"># Printing text in uppercase</span></span><br><span class="line">speak(scream)</span><br><span class="line"><span class="comment"># Printing text in lowercase</span></span><br><span class="line">speak(spell)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">HELLO PYTHON DEVELOPERS! YOU ARE WELCOMED TO JAVATPOINT</span><br><span class="line">hello python developers! you are welcomed to javatpoint</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="方法-3-返回函数作为高阶函数的结果">方法 3:返回函数作为高阶函数的结果</h3>
<p>我们还可以将一个函数作为另一个函数的结果作为一个对象返回，这使得该函数成为一个高阶函数。</p>
<p>查看下面的示例程序，了解我们上面讨论的方法的实现:</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># A default function for addition</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Adding</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="comment"># Nested function with second number </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Addition</span>(<span class="params">b</span>): </span><br><span class="line">            <span class="keyword">return</span> a + b <span class="comment"># addition of two numbers</span></span><br><span class="line">    <span class="keyword">return</span> Addition <span class="comment"># Result</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Taking both number variable as user input</span></span><br><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter First Number: &quot;</span>))</span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter Second Number: &quot;</span>))</span><br><span class="line"><span class="comment"># Assigning nested adding function to a variable</span></span><br><span class="line">AddVariable = Adding(a)</span><br><span class="line"><span class="comment"># Using variable as high order function</span></span><br><span class="line">Result = AddVariable(b)</span><br><span class="line"><span class="comment"># Printing result</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sum of Two numbers given by you is: &quot;</span>, Result)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter First Number: <span class="number">24</span></span><br><span class="line">Enter Second Number: <span class="number">26</span></span><br><span class="line">Sum of Two numbers given by you <span class="keyword">is</span>:  <span class="number">50</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="方法-4-装饰器作为高阶函数">方法 4:装饰器作为高阶函数</h3>
<p>我们可以使用装饰器作为 Python 中最常用的高阶函数。Python 中的装饰器允许我们修改我们在程序中定义的方法或函数的行为，它还允许我们将一个函数包装在另一个函数中，以扩展包装或父函数的行为。我们甚至可以将一个函数包装在另一个函数中，甚至不需要永久修改父函数。</p>
<p>在 Python 装饰器中，一个函数被作为另一个函数的参数，然后这些装饰器在包装的函数中被调用。请看下面 Python 程序中定义的装饰器的示例语法。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Using a decorator</span></span><br><span class="line"><span class="meta">@JTP_Decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Python_Decorator</span>(): </span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>装饰器的上述语法相当于下面高阶函数的 Python 代码。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Using Python default function as Python decorators</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Python_Decorator</span>(): </span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">Python_Decorator = @JTP_Decorator(Python_Decorator)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面给出的代码中，我们将@JTP_Decorator 称为默认 Python_Decorator()函数中的一个可调用函数。我们将不得不在这个结构中添加一些额外的代码，我们将获得作为包装函数的输出。</p>
<p>看下面的程序来理解上面给定方法的实现:</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Using default function as Python decorators</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Python_Decorator</span>(<span class="params">funct</span>):</span><br><span class="line">       <span class="comment"># Inner nested function</span></span><br><span class="line">       <span class="keyword">def</span> <span class="title function_">inner</span>(): </span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&quot;This line of code will be printed before the execution of high order function&quot;</span>)</span><br><span class="line">              funct() </span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&quot;This line of code will be printed after the execution of high order function&quot;</span>)</span><br><span class="line">       <span class="keyword">return</span> inner </span><br><span class="line"><span class="comment"># A default function as decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">JTP_Decorator</span>(): </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This line of code will be printed inside the execution of high order function&quot;</span>)</span><br><span class="line">JTP_Decorator = Python_Decorator(JTP_Decorator) <span class="comment"># Python decorator as high order function </span></span><br><span class="line"><span class="comment"># Python decorator calling out as high order function </span></span><br><span class="line">JTP_Decorator()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">This line of code will be printed before the execution of high order function</span><br><span class="line">This line of code will be printed inside the execution of high order function</span><br><span class="line">This line of code will be printed after the execution of high order function</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>pyspark.mllib</title>
    <url>/posts/ca8c56c3.html</url>
    <content><![CDATA[<h1><code>pyspark.mllib</code></h1>
<p>机器学习是一种数据分析技术，它将数据与统计工具相结合来预测输出。这种预测被各种企业行业用来做出有利的决策。</p>
<p>PySpark 提供了一个名为 <strong>mllib</strong> 的机器学习 API。PySpark 的 mllib 支持各种机器学习算法，如分类、回归聚类、协同过滤和降维以及底层优化原语。下面给出了各种机器学习概念:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>分类</strong></p>
</li>
</ul>
<p><strong>pyspark.mllib</strong> 库支持多种分类方法，如二元分类、多类分类和回归分析。该对象可能属于不同的类。分类的目的是根据信息区分数据。<strong>随机森林、朴素贝叶斯、决策树</strong>是分类中最有用的算法。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>聚类</strong></p>
</li>
</ul>
<p>聚类是一个无监督的机器学习问题。当您不知道如何对数据进行分类时，会用到它；我们需要算法来找到模式，并相应地对数据进行分类。流行的聚类算法有 <strong>K 均值聚类、高斯混合模型、层次聚类。</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>fpm</strong></p>
</li>
</ul>
<p>fpm 是指频繁模式匹配，用于挖掘各种项目、项目集、子序列或其他子结构。它主要用于大规模数据集。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>线藻</strong></p>
</li>
</ul>
<p><strong>mllib.linalg</strong> 实用程序用于线性代数。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>推荐</strong></p>
</li>
</ul>
<p>用于定义推荐的相关数据。它能够预测未来的偏好，并推荐最热门的项目。比如在线娱乐平台<strong>网飞</strong>电影收藏量巨大，有时候人们在挑选喜欢的项目时会面临困难。这是推荐发挥重要作用的领域。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>mllib 回归</strong></p>
</li>
</ul>
<p>回归用于寻找变量之间的关系和依赖关系。它发现数据的每个特征之间的相关性，并预测未来的值。</p>
<p>mllib 包支持许多其他算法、类和函数。在这里我们将了解 <strong>pyspak.mllib</strong> 的基本概念。</p>
<h2 id="MLlib-功能">MLlib 功能</h2>
<p><strong>PySpark mllib</strong> 对迭代算法很有用。特点如下:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>**提取:**从“行”数据中提取特征。</p>
</li>
<li class="lvl-4">
<p>**变换:**用于缩放、转换或修改要素。</p>
</li>
<li class="lvl-4">
<p>**选择:**从更大的特征集中选择有用的子集。</p>
</li>
<li class="lvl-4">
<p>**位置敏感哈希:**它将特征变换的各个方面与其他算法相结合。</p>
</li>
</ul>
<p>让我们来看看 PySpark MLlib 的基本库。</p>
<h3 id="线性回归">线性回归</h3>
<p>线性回归用于寻找变量之间的关系和依赖关系。考虑以下代码:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">frompyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line">spark = SparkSession.builder.appName(<span class="string">&#x27;Customer&#x27;</span>).getOrCreate()</span><br><span class="line">frompyspark.ml.regression <span class="keyword">import</span> LinearRegression</span><br><span class="line">dataset = spark.read.csv(<span class="string">r&#x27;C:\Users\DEVANSH SHARMA\Ecommerce-Customers.csv&#x27;</span>)</span><br><span class="line">dataset.show(<span class="number">10</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">+--------------------+--------------------+----------------+------------------+------------------+------------------+--------------------+-------------------+</span><br><span class="line">|                 _c0|                 _c1|             _c2|               _c3|               _c4|               _c5|                 _c6|                _c7|</span><br><span class="line">+--------------------+--------------------+----------------+------------------+------------------+------------------+--------------------+-------------------+</span><br><span class="line">|               Email|             Address|          Avatar|Avg Session Length|       Time on App|   Time on Website|Length of Membership|Yearly Amount Spent|</span><br><span class="line">|[email protected]|<span class="number">835</span> Frank TunnelW...|          Violet| <span class="number">34.49726772511229</span>| <span class="number">12.65565114916675</span>| <span class="number">39.57766801952616</span>|  <span class="number">4.0826206329529615</span>|  <span class="number">587.9510539684005</span>|</span><br><span class="line">|   [email protected]|<span class="number">4547</span> Archer Commo...|       DarkGreen| <span class="number">31.92627202636016</span>|<span class="number">11.109460728682564</span>|<span class="number">37.268958868297744</span>|    <span class="number">2.66403418213262</span>|  <span class="number">392.2049334443264</span>|</span><br><span class="line">|    [email protected]|<span class="number">24645</span> Valerie Uni...|          Bisque|<span class="number">33.000914755642675</span>|<span class="number">11.330278057777512</span>|<span class="number">37.110597442120856</span>|   <span class="number">4.104543202376424</span>| <span class="number">487.54750486747207</span>|</span><br><span class="line">|riverar[email protected]|<span class="number">1414</span> David Throug...|     SaddleBrown| <span class="number">34.30555662975554</span>|<span class="number">13.717513665142507</span>| <span class="number">36.72128267790313</span>|   <span class="number">3.120178782748092</span>|  <span class="number">581.8523440352177</span>|</span><br><span class="line">|[email protected]|<span class="number">14023</span> Rodriguez P...|MediumAquaMarine| <span class="number">33.33067252364639</span>|<span class="number">12.795188551078114</span>| <span class="number">37.53665330059473</span>|   <span class="number">4.446308318351434</span>|  <span class="number">599.4060920457634</span>|</span><br><span class="line">|[email protected]|<span class="number">645</span> Martha Park A...|     FloralWhite|<span class="number">33.871037879341976</span>|<span class="number">12.026925339755056</span>| <span class="number">34.47687762925054</span>|   <span class="number">5.493507201364199</span>|   <span class="number">637.102447915074</span>|</span><br><span class="line">|[email protected]|<span class="number">68388</span> Reyes Light...|   DarkSlateBlue| <span class="number">32.02159550138701</span>|<span class="number">11.366348309710526</span>| <span class="number">36.68377615286961</span>|   <span class="number">4.685017246570912</span>|  <span class="number">521.5721747578274</span>|</span><br><span class="line">|  [email protected]|Unit <span class="number">6538</span> Box <span class="number">898.</span>..|            Aqua|<span class="number">32.739142938380326</span>| <span class="number">12.35195897300293</span>| <span class="number">37.37335885854755</span>|  <span class="number">4.4342734348999375</span>|  <span class="number">549.9041461052942</span>|</span><br><span class="line">|[email protected]|<span class="number">860</span> Lee KeyWest D...|          Salmon| <span class="number">33.98777289568564</span>|<span class="number">13.386235275676436</span>|<span class="number">37.534497341555735</span>|  <span class="number">3.2734335777477144</span>|  <span class="number">570.2004089636196</span>|</span><br><span class="line">+--------------------+--------------------+----------------+------------------+------------------+------------------+--------------------+-------------------+</span><br><span class="line">only showing top <span class="number">10</span> rows</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在下面的代码中，我们正在导入 <strong>VectorAssembler</strong> 库来创建一个新的列独立特性:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">frompyspark.ml.linalg <span class="keyword">import</span> Vectors</span><br><span class="line">frompyspark.ml.feature <span class="keyword">import</span> VectorAssembler</span><br><span class="line">featureassembler = VectorAssembler(inputCols = [<span class="string">&quot;Avg Session Length&quot;</span>,<span class="string">&quot;Time on App&quot;</span>,<span class="string">&quot;Time on Website&quot;</span>],outputCol = <span class="string">&quot;Independent Features&quot;</span>)</span><br><span class="line">output = featureassembler.transform(dataset)</span><br><span class="line">output.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">+------------------+</span><br><span class="line">Independent Feature</span><br><span class="line">+------------------+</span><br><span class="line">|<span class="number">34.49726772511229</span> |</span><br><span class="line">|<span class="number">31.92627202636016</span> |</span><br><span class="line">|<span class="number">33.000914755642675</span>|</span><br><span class="line">|<span class="number">34.30555662975554</span> |</span><br><span class="line">|<span class="number">33.33067252364639</span> |</span><br><span class="line">|<span class="number">33.871037879341976</span>|</span><br><span class="line">|<span class="number">32.02159550138701</span> |</span><br><span class="line">|<span class="number">32.739142938380326</span>|</span><br><span class="line">|<span class="number">33.98777289568564</span> |</span><br><span class="line">+------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">z = featureassembler.transform(dataset)</span><br><span class="line">finlized_data = z.select(<span class="string">&quot;Indepenent feature&quot;</span>, <span class="string">&quot;Yearly Amount Spent&quot;</span>,)</span><br><span class="line">z.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">+--------------------++-------------------+</span><br><span class="line">|Independent Feature | Yearly Amount Spent|</span><br><span class="line">+--------------------++-------------------+</span><br><span class="line">|<span class="number">34.49726772511229</span>   | <span class="number">587.9510539684005</span>  |</span><br><span class="line">|<span class="number">31.92627202636016</span>   | <span class="number">392.2049334443264</span>  |</span><br><span class="line">|<span class="number">33.000914755642675</span>  | <span class="number">487.5475048674720</span>  |</span><br><span class="line">|<span class="number">34.30555662975554</span>   | <span class="number">581.8523440352177</span>  |</span><br><span class="line">|<span class="number">33.33067252364639</span>   | <span class="number">599.4060920457634</span>  |</span><br><span class="line">|<span class="number">33.871037879341976</span>  | <span class="number">637.102447915074</span>   |</span><br><span class="line">|<span class="number">32.02159550138701</span>   | <span class="number">521.5721747578274</span>  |</span><br><span class="line">|<span class="number">32.739142938380326</span>  | <span class="number">549.9041461052942</span>  |</span><br><span class="line">|<span class="number">33.98777289568564</span>   | <span class="number">570.2004089636196</span>  |</span><br><span class="line">+--------------------++-------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>PySpark 提供了**线性回归()**函数来查找任何给定数据集的预测。语法如下:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">regressor = LinearRegression(featureCol = <span class="string">&#x27;column_name1&#x27;</span>, labelCol = <span class="string">&#x27;column_name2 &#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="平均聚类">平均聚类</h2>
<p>K- Mean 聚类算法是最流行和最常用的算法之一。它用于将数据点聚类成预定义数量的聚类。下面的例子展示了 MLlib K-Means 集群库的使用:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyspark.ml.clustering <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">from</span> pyspark.ml.evaluation <span class="keyword">import</span> ClusteringEvaluator</span><br><span class="line"><span class="comment"># Loads data.</span></span><br><span class="line">dataset = spark.read.<span class="built_in">format</span>(<span class="string">&quot;libsvm&quot;</span>).load(<span class="string">r&quot;C:\Users\DEVANSH SHARMA\Iris.csv&quot;</span>)</span><br><span class="line"><span class="comment"># Trains a k-means model.</span></span><br><span class="line">kmeans = KMeans().setK(<span class="number">2</span>).setSeed(<span class="number">1</span>)</span><br><span class="line">model = kmeans.fit(dataset)</span><br><span class="line"><span class="comment"># Make predictions</span></span><br><span class="line">predictions = model.transform(dataset)</span><br><span class="line"><span class="comment"># Evaluate clustering by computing Silhouette score</span></span><br><span class="line">evaluator = ClusteringEvaluator()</span><br><span class="line">silhouette = evaluator.evaluate(predictions)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Silhouette with squared euclidean distance = &quot;</span> + <span class="built_in">str</span>(silhouette))</span><br><span class="line"><span class="comment"># Shows the result.</span></span><br><span class="line">centers = model.clusterCenters()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Cluster Centers: &quot;</span>)</span><br><span class="line"><span class="keyword">for</span> center <span class="keyword">in</span> centers:</span><br><span class="line">    <span class="built_in">print</span>(center)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="PySpark-MLlib-的参数">PySpark MLlib 的参数</h3>
<p><strong>PySpark MLlib</strong> 的几个重要参数如下:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>评级</strong></p>
</li>
</ul>
<p>它是 RDD 的评级或(用户标识，产品标识，评级)元组。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>排名</strong></p>
</li>
</ul>
<p>它表示计算的特征矩阵的秩(特征的数量)。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>迭代</strong></p>
</li>
</ul>
<p>它代表 ALS 的迭代次数。(默认值:5)</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>λ</strong></p>
</li>
</ul>
<p>它是正则化参数。(默认值:0.01)</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>区块</strong></p>
</li>
</ul>
<p>它用于并行计算一些块。</p>
<h3 id="协同过滤">协同过滤</h3>
<p>协同过滤是一种通常用于推荐系统的技术。这项技术的重点是填充用户项目中缺失的条目。关联矩阵 <strong><a href="http://spark.ml">spark.ml</a></strong> 目前支持基于模型的协同过滤。在协同过滤中，用户和产品由一小组隐藏因素描述，这些因素可用于预测缺失条目。</p>
<h3 id="正则化参数的缩放">正则化参数的缩放</h3>
<p>正则化参数<strong>正则化参数</strong>被缩放以解决最小二乘问题。最小二乘问题出现在用户在更新用户因素时生成的评分数，或产品在更新产品因素时收到的评分数。</p>
<h3 id="冷启动策略">冷启动策略</h3>
<p>**ALS 模型(替代最小二乘模型)**用于预测，同时进行常见的预测问题。测试数据集中的用户或项目在训练模型期间可能不存在时遇到的问题。它可能发生在下面给出的两种情况下:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>在预测中，模型不是针对没有评级历史的用户和项目进行训练的(称为冷启动策略)。</p>
</li>
<li class="lvl-4">
<p>在交叉验证过程中，数据在训练集和评估集之间进行分割。遇到不在训练集中的评估集中的用户和项目是很普遍的。</p>
</li>
</ul>
<p>Let’s consider the following example, where we load ratings data from the MovieLens dataset. Each row is containing a user, a movie, rating and a timestamp.</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#importing the libraries</span></span><br><span class="line">frompyspark.ml.evaluation <span class="keyword">import</span> RegressionEvaluator</span><br><span class="line">frompyspark.ml.recommendation <span class="keyword">import</span> ALS</span><br><span class="line">frompyspark.sql <span class="keyword">import</span> Row</span><br><span class="line">no_of_lines = spark.read.text(<span class="string">r&quot;C:\Users\DEVANSH SHARMA\MovieLens.csv&quot;</span>).rdd</span><br><span class="line">no_of_parts = no_of_lines.<span class="built_in">map</span>(<span class="keyword">lambda</span> row: row.value.split(<span class="string">&quot;::&quot;</span>))</span><br><span class="line">ratingsRDD = no_of_lines.<span class="built_in">map</span>(<span class="keyword">lambda</span> p: Row(userId=<span class="built_in">int</span>(p[<span class="number">0</span>]), movieId=<span class="built_in">int</span>(p[<span class="number">1</span>]),</span><br><span class="line">                                     rating=<span class="built_in">float</span>(p[<span class="number">2</span>]), timestamp=long(p[<span class="number">3</span>])))</span><br><span class="line">ratings = spark.createDataFrame(ratingsRDD)</span><br><span class="line">(training, test) = ratings.randomSplit([<span class="number">0.8</span>, <span class="number">0.2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Develop the recommendation model using ALS on the training data</span></span><br><span class="line"><span class="comment"># Note we set cold start strategy to make sure that we don&#x27;t get NaN evaluation metrics.</span></span><br><span class="line">als = ALS(maxIter=<span class="number">5</span>, regParam=<span class="number">0.01</span>, userCol=<span class="string">&quot;userId&quot;</span>, itemCol=<span class="string">&quot;movieId&quot;</span>, ratingCol=<span class="string">&quot;rating&quot;</span>,</span><br><span class="line">    coldStartStrategy=<span class="string">&quot;drop&quot;</span>)</span><br><span class="line">model = als.fit(training)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calculate the model by computing the RMSE on the test data</span></span><br><span class="line">predictions = model.transform(test)</span><br><span class="line">evaluator = RegressionEvaluator(metricName=<span class="string">&quot;rmse&quot;</span>, labelCol=<span class="string">&quot;rating&quot;</span>,</span><br><span class="line">predictionCol=<span class="string">&quot;prediction&quot;</span>)</span><br><span class="line">rmse = evaluator.evaluate(predictions)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Root-mean-square error = &quot;</span> + <span class="built_in">str</span>(rmse))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Evaluate top 10 movie recommendations for each user</span></span><br><span class="line">userRecs = model.recommendForAllUsers(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># Evaluate top 10 user recommendations for each movie</span></span><br><span class="line">movieRecs = model.recommendForAllItems(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># Evaluate top 10 movie recommendations for a specified set of users</span></span><br><span class="line">users = ratings.select(als.getUserCol()).distinct().limit(<span class="number">3</span>)</span><br><span class="line">userSubsetRecs = model.recommendForUserSubset(users, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># Evalute top 10 user recommendations for a specified set of movies</span></span><br><span class="line">movies = ratings.select(als.getItemCol()).distinct().limit(<span class="number">3</span>)</span><br><span class="line">movieSubSetRecs = model.recommendForItemSubset(movies, <span class="number">10</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>如何用GEOPY计算两点之间的距离</title>
    <url>/posts/477a984f.html</url>
    <content><![CDATA[<h1>如何用 GEOPY 计算两点之间的距离？</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/how-to-calculate-distance-between-two-points-using-geopy">https://www.javatpoint.com/how-to-calculate-distance-between-two-points-using-geopy</a></p>
</blockquote>
<p><strong>geopy</strong>是一个帮助计算地理距离的 Python 库。在本教程中，我们将讨论用户如何计算地球上两个地方之间距离的不同方法。</p>
<p>首先，用户必须使用以下命令安装<strong>geopy</strong>:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install geopy</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>安装成功后，我们准备与地质图书馆合作。</p>
<h2 id="计算两点之间的距离">计算两点之间的距离</h2>
<p>下面是用来计算两点之间距离的重要方法。</p>
<h3 id="方法-1-使用测地线距离">方法 1:使用测地线距离</h3>
<p>测地线距离是地球任何表面上两点之间最短路径的长度。在下面的示例中，我们将展示用户如何根据纬度和经度数据计算测地线距离。</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># First, import the geodesic module from the geopy library</span></span><br><span class="line"><span class="keyword">from</span> geopy.distance <span class="keyword">import</span> geodesic <span class="keyword">as</span> GD</span><br><span class="line"></span><br><span class="line"><span class="comment"># Then, load the latitude and longitude data for New York &amp; Texas</span></span><br><span class="line">New_York = (<span class="number">40.7128</span>, <span class="number">74.0060</span>)</span><br><span class="line">Texas = (<span class="number">31.9686</span>, <span class="number">99.9018</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># At last, print the distance between two points calculated in kilo-metre</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;The distance between New York and Texas is: &quot;</span>, GD(New_York, Texas).km)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The distance between New York <span class="keyword">and</span> Texas <span class="keyword">is</span>:  <span class="number">2507.14797665193</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="方法-2-使用大圆距离">方法 2:使用大圆距离</h3>
<p>大圆距离是球面上两点之间的最短路径。在这种情况下，我们将假设地球是完美的球体。以下示例显示了用户如何使用两点的经度和纬度数据来计算大圆距离。</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># First, import the great_circle module from the geopy library</span></span><br><span class="line"><span class="keyword">from</span> geopy.distance <span class="keyword">import</span> great_circle <span class="keyword">as</span> GC</span><br><span class="line"></span><br><span class="line"><span class="comment"># Then, load the latitude and longitude data for New York &amp; Texas</span></span><br><span class="line">New_York = (<span class="number">40.7128</span>, <span class="number">74.0060</span>)</span><br><span class="line">Texas = (<span class="number">31.9686</span>, <span class="number">99.9018</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># At last, print the distance between two points calculated in kilo-metre</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;The distance between New York and Texas is: &quot;</span>, GC(New_York, Texas).km)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The distance between New York <span class="keyword">and</span> Texas <span class="keyword">is</span>:  <span class="number">2503.045970189156</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="方法三-利用哈弗斯公式">方法三:利用哈弗斯公式</h3>
<p>正交距离用于计算地球表面两个纬度和经度点之间的最短距离。</p>
<p>使用这种方法，用户需要有两个点的坐标 <strong>(P 和 Q)。</strong></p>
<p>首先，他们必须将纬度和经度点的值从十进制度转换为弧度，然后将纬度和经度的值除以(180/π)。用户应该使用“π = 22/7”的值。那么，(180/π)的值将是“57.29577”。如果用户想要计算以英里为单位的距离，他们可以使用地球半径的值，即“3，963”。如果用户想以千米为单位计算距离，他们可以使用值“6，378.80”。</p>
<p><strong>公式:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">How to calculate the value of latitude <span class="keyword">in</span> radians:</span><br><span class="line">The value of Latitude <span class="keyword">in</span> Radian: Latitude (La1) = La1 / (<span class="number">180</span>/?)</span><br><span class="line">OR</span><br><span class="line">The value of Latitude <span class="keyword">in</span> Radian: Latitude (La1) = La1 / <span class="number">57.29577</span></span><br><span class="line">How to calculate the value of longitude <span class="keyword">in</span> radians:</span><br><span class="line">The value of Longitude <span class="keyword">in</span> Radian: Longitude (Lo1) = Lo1 / (<span class="number">180</span>/?)</span><br><span class="line">OR</span><br><span class="line">The value of Longitude <span class="keyword">in</span> Radian: Longitude (Lo1) = Lo1 / <span class="number">57.29577</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用户需要用经纬度表示 P 点和 Q 点的坐标，然后用上面的公式转换成弧度。</p>
<p>现在，使用以下公式计算两点之间的距离。</p>
<p><strong>公式:</strong></p>
<p><strong>英里:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Distance (D) = <span class="number">3963.0</span> * arccos[(sin(La1) * sin(La2)) + cos(La1) * cos(La2) * cos(Lo2 - Lo1)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>公里:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Distance (D) = <span class="number">3963.0</span> * arccos[(sin(La1) * sin(La2)) + cos(La1) * cos(La2) * cos(Lo2 - Lo1)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因此，用户可以使用哈弗辛公式计算地球上两个给定点之间的最短距离。</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> radians, cos, sin, asin, sqrt</span><br><span class="line"><span class="comment"># For calculating the distance in Kilometres </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">distance_1</span>(<span class="params">La1, La2, Lo1, Lo2</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The math module contains the function name &quot;radians&quot; which is used for converting the degrees value into radians.</span></span><br><span class="line">    Lo1 = radians(Lo1)</span><br><span class="line">    Lo2 = radians(Lo2)</span><br><span class="line">    La1 = radians(La1)</span><br><span class="line">    La2 = radians(La2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Using the &quot;Haversine formula&quot;</span></span><br><span class="line">    D_Lo = Lo2 - Lo1</span><br><span class="line">    D_La = La2 - La1</span><br><span class="line">    P = sin(D_La / <span class="number">2</span>)**<span class="number">2</span> + cos(La1) * cos(La2) * sin(D_Lo / <span class="number">2</span>)**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">    Q = <span class="number">2</span> * asin(sqrt(P))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The radius of earth in kilometres.</span></span><br><span class="line">    R_km = <span class="number">6371</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Then, we will calculate the result</span></span><br><span class="line">    <span class="keyword">return</span>(Q * R_km)</span><br><span class="line"></span><br><span class="line"><span class="comment"># driver code</span></span><br><span class="line">La1 = <span class="number">40.7128</span></span><br><span class="line">La2 = <span class="number">31.9686</span></span><br><span class="line">Lo1 = -<span class="number">74.0060</span></span><br><span class="line">Lo2 = -<span class="number">99.9018</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;The distance between New York and Texas is: &quot;</span>, distance_1(La1, La2, Lo1, Lo2), <span class="string">&quot;K.M&quot;</span>)</span><br><span class="line"><span class="comment"># For calculating the distance in Miles</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">distance_2</span>(<span class="params">La1, La2, Lo1, Lo2</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The math module contains the function name &quot;radians&quot; which is used for converting the degrees value into radians.</span></span><br><span class="line">    Lo1 = radians(Lo1)</span><br><span class="line">    Lo2 = radians(Lo2)</span><br><span class="line">    La1 = radians(La1)</span><br><span class="line">    La2 = radians(La2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Using the &quot;Haversine formula&quot;</span></span><br><span class="line">    D_Lo = Lo2 - Lo1</span><br><span class="line">    D_La = La2 - La1</span><br><span class="line">    P = sin(D_La / <span class="number">2</span>)**<span class="number">2</span> + cos(La1) * cos(La2) * sin(D_Lo / <span class="number">2</span>)**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">    Q = <span class="number">2</span> * asin(sqrt(P))</span><br><span class="line">    <span class="comment"># The radius of earth in Miles.</span></span><br><span class="line">    R_Mi = <span class="number">3963</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Then, we will calculate the result</span></span><br><span class="line">    <span class="keyword">return</span>(Q * R_Mi)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;The distance between New York and Texas is: &quot;</span>, distance_2(La1, La2, Lo1, Lo2), <span class="string">&quot;Miles&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The distance between New York <span class="keyword">and</span> Texas <span class="keyword">is</span>:  <span class="number">2503.04243426357</span> K.M</span><br><span class="line">The distance between New York <span class="keyword">and</span> Texas <span class="keyword">is</span>:  <span class="number">1556.985899699659</span> Miles</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="结论-4">结论</h2>
<p>在本教程中，我们已经讨论了使用地质库计算地球表面两点之间距离的各种方法。我们已经展示了每种方法的示例。</p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>如何用Python语言绘制谷歌地图</title>
    <url>/posts/9ac12a82.html</url>
    <content><![CDATA[<h1>如何用 Python 语言绘制谷歌地图</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/how-to-plot-the-google-map-using-folium-package-in-python">https://www.javatpoint.com/how-to-plot-the-google-map-using-folium-package-in-python</a></p>
</blockquote>
<p>leaf 包建立在 Python 生态系统的<strong>数据争论</strong>优势和 JavaScript 语言的<strong>leaf.js 库</strong>的映射优势之上。用户可以使用 Python 操作他们的数据，然后通过叶包使用<strong>leaf.js</strong> 地图将其可视化。leaf package 是一种将数据可视化到 Leaflet.js 地图上的简单方法，该地图已经使用 Python 进行了操作。</p>
<h3 id="必需的模块和库">必需的模块和库</h3>
<p>**Folium:**用户可以使用以下命令安装叶包。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install folium</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>**Geopy:**Python 的 Geopy 模块让 <a href="https://www.javatpoint.com/python-tutorial">Python</a> 用户可以轻松定位地球表面的地标、城市、国家的坐标。要安装 geopy 模块，用户可以使用以下命令:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install geopy</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>成功安装两个库后，我们按照以下步骤绘制谷歌地图。</p>
<h3 id="步骤-1-创建基础地图">步骤 1:创建基础地图</h3>
<p>用户可以使用以下程序创建基础地图:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># First, import folium package</span></span><br><span class="line"><span class="keyword">import</span> folium</span><br><span class="line"><span class="keyword">from</span> geopy.geocoders <span class="keyword">import</span> Nominatim <span class="keyword">as</span> NT</span><br><span class="line"><span class="comment"># Initialize Nominatim API</span></span><br><span class="line">geo_locator = NT(user_agent = <span class="string">&quot;geoapiExercises&quot;</span>)</span><br><span class="line"><span class="comment"># write the place</span></span><br><span class="line">place_1 = <span class="string">&quot;Yemen&quot;</span></span><br><span class="line"></span><br><span class="line">location_1 = geo_locator.geocode(place_1)</span><br><span class="line"><span class="comment"># now, it will search for the location by using the latitude and longitude, with zoom_start = 15</span></span><br><span class="line">user_map1 = folium.Map(location = [location_1.longitude, location_1.latitude],</span><br><span class="line">                                        zoom_start = <span class="number">15</span> )</span><br><span class="line"><span class="comment"># At last, open the base map</span></span><br><span class="line">user_map1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<p><img src="/img/9ce219b58513c81edb50da5eeb4e666e.png" alt="How to Plot the Google Map using folium package in Python"></p>
<h3 id="步骤-2-添加圆形标记">步骤 2:添加圆形标记</h3>
<p>用户可以使用以下代码用圆圈和弹出文本标记该区域:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> folium</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> geopy.geocoders <span class="keyword">import</span> Nominatim <span class="keyword">as</span> NT</span><br><span class="line"></span><br><span class="line">geo_locator = NT(user_agent = <span class="string">&quot;geoapiExercises&quot;</span>)</span><br><span class="line"></span><br><span class="line">place_1 = <span class="string">&quot;Yemen&quot;</span></span><br><span class="line"></span><br><span class="line">location_1 = geo_locator.geocode(place_1)</span><br><span class="line"></span><br><span class="line">user_map1 = folium.Map(location = [location_1.longitude, location_1.latitude],</span><br><span class="line">                                        zoom_start = <span class="number">15</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># CircleMarker with radius</span></span><br><span class="line">folium.CircleMarker(location = [location_1.longitude, location_1.latitude],</span><br><span class="line">                    radius = <span class="number">45</span>, popup = <span class="string">&#x27; YEMEN &#x27;</span>).add_to(user_map1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now, open the Map with circular Mark</span></span><br><span class="line">user_map1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<p><img src="/img/33d6945ebb967444ba52f9c8a34fc6ad.png" alt="How to Plot the Google Map using folium package in Python"></p>
<h3 id="步骤-3-用弹出文本为降落伞样式标记添加简单标记">步骤 3:用弹出文本为降落伞样式标记添加简单标记</h3>
<p>用户可以使用以下代码。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> folium</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> geopy.geocoders <span class="keyword">import</span> Nominatim <span class="keyword">as</span> NT</span><br><span class="line"></span><br><span class="line">geo_locator = NT(user_agent = <span class="string">&quot;geoapiExercises&quot;</span>)</span><br><span class="line"></span><br><span class="line">place_1 = <span class="string">&quot;Yemen&quot;</span></span><br><span class="line"></span><br><span class="line">location_1 = geo_locator.geocode(place_1)</span><br><span class="line"></span><br><span class="line">user_map1 = folium.Map(location = [location_1.longitude, location_1.latitude],</span><br><span class="line">                                        zoom_start = <span class="number">15</span>)</span><br><span class="line"><span class="comment">#Now, we will pass the string in popup parameter</span></span><br><span class="line">folium.Marker([location_1.longitude, location_1.latitude],</span><br><span class="line">               popup = [<span class="string">&#x27;YEMEN&#x27;</span>]).add_to(user_map1)</span><br><span class="line"><span class="comment"># now, open the map </span></span><br><span class="line">user_map1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<p><img src="/img/bf2329cb858eae909fef6c0f04824c26.png" alt="How to Plot the Google Map using folium package in Python"></p>
<h3 id="第四步-在地图上添加线条">第四步:在地图上添加线条</h3>
<p>用户可以使用以下代码在地图上添加直线来连接两个坐标。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># First, import folium package</span></span><br><span class="line"><span class="keyword">import</span> folium</span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="keyword">from</span> geopy.geocoders <span class="keyword">import</span> Nominatim <span class="keyword">as</span> NT</span><br><span class="line"></span><br><span class="line">geo_locator = NT(user_agent = <span class="string">&quot;geoapiExercises&quot;</span>)</span><br><span class="line"></span><br><span class="line">place_1 = <span class="string">&quot;Aden&quot;</span></span><br><span class="line">place_2 = <span class="string">&quot;Yemen&quot;</span></span><br><span class="line">location_1 = geo_locator.geocode(place_1)</span><br><span class="line">location_2 = geo_locator.geocode(place_2)</span><br><span class="line">user_map1 = folium.Map(location = [location_1.longitude, location_1.latitude],</span><br><span class="line">                                        zoom_start = <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">folium.Marker([location_1.longitude, location_1.latitude],</span><br><span class="line">               popup = [<span class="string">&#x27;Aden&#x27;</span>]).add_to(user_map1)</span><br><span class="line"></span><br><span class="line">folium.Marker([location_2.longitude, location_2.latitude],</span><br><span class="line">              popup = <span class="string">&#x27;Yemen&#x27;</span>).add_to(user_map1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now, we will add the line on the map by using Polyline method .</span></span><br><span class="line"><span class="comment"># it will connect both coordinates by the line</span></span><br><span class="line"></span><br><span class="line">folium.PolyLine(locations = [[location_1.longitude, location_1.latitude], [location_2.longitude, location_2.latitude]],</span><br><span class="line">                line_opacity = <span class="number">0.5</span>).add_to(user_map1)</span><br><span class="line"><span class="comment"># now, open the map</span></span><br><span class="line">user_map1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<p><img src="/img/b0734cf6f0b1dee3903f0cde74586895.png" alt="How to Plot the Google Map using folium package in Python"></p>
<p><strong>解释</strong></p>
<p>我们使用<strong>geopy</strong>库来获取位置的经纬度。然后我们使用<strong>folium</strong>包的<strong>folium.map</strong>方法创建谷歌地图的基础。</p>
<p>在步骤 2 中，我们使用“<strong>folium.CircleMarker</strong>，用于用弹出文本在位置上标记圆形标记。在第三步中，我们使用了“<strong>folium.Marker</strong>，在所述位置添加降落伞样式标记。最后一步，我们用“<strong>folium.PolyLine</strong>“用于连接地图上两个不同位置的两个标记。</p>
<h2 id="结论-5">结论</h2>
<p>在本教程中，我们展示了用户如何绘制谷歌地图，并在地图上添加不同的所需功能，如圆形标记、降落伞标记、弹出文本以及连接地图上两个坐标的线条。</p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>第一个 Python 程序</title>
    <url>/posts/ba17123e.html</url>
    <content><![CDATA[<h1>第一个 Python 程序</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-example">https://www.javatpoint.com/python-example</a></p>
</blockquote>
<p>在本节中，我们将讨论 Python 的基本语法，我们将运行一个简单的程序在控制台上打印 <strong>Hello World</strong> 。</p>
<p>Python 为我们提供了两种运行程序的方法:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>使用交互式解释器提示</p>
</li>
<li class="lvl-4">
<p>使用脚本文件</p>
</li>
</ul>
<p>让我们详细讨论每一个。</p>
<h2 id="交互式解释器提示">交互式解释器提示</h2>
<p><a href="https://www.javatpoint.com/python-tutorial">Python</a> 为我们提供了在交互提示下逐一执行 Python 语句的功能。最好是在关注我们的 <a href="https://www.javatpoint.com/python-programs">Python 程序</a>的每一行的输出的情况下。</p>
<p>要打开交互模式，请打开终端(或命令提示符)并键入 python(如果系统上同时安装了 Python2 和 python3，请键入 Python3)。</p>
<p>它将打开以下提示，我们可以在其中执行 Python 语句，并检查它们对控制台的影响。</p>
<p><img src="/img/b45b70cd8f3d59bcbc252417a190a6db.png" alt="First Python Program"></p>
<p>写完打印语句后，按<strong>进入</strong>键。</p>
<p><img src="/img/5fc64e68cf8744644243ee5b7fdf9bb3.png" alt="First Python Program"></p>
<p>在这里，我们得到消息**“你好世界！”**印在控制台上。</p>
<h2 id="使用脚本文件-脚本模式编程">使用脚本文件(脚本模式编程)</h2>
<p>解释器提示最好是运行代码的单行语句。然而，我们不能每次都在终端上写代码。不适合写多行代码。</p>
<p>使用脚本模式，我们可以将多行代码写入一个文件，稍后可以执行。为此，我们需要打开记事本这样的编辑器，创建一个名为的文件，用<strong>保存。py</strong> 扩展，代表**“Python”。**现在，我们将使用脚本模式实现上面的示例。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> (<span class="string">&quot;hello world&quot;</span>); <span class="comment">#here, we have used print() function to print the message on the console.  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要运行这个名为 <a href="http://first.py">first.py</a> 的文件，我们需要在终端上运行以下命令。</p>
<p><img src="img/f19ed885a491edbfb873f83d2907bc55.png" alt="First Python Program"></p>
<p>**第一步:<strong>打开 Python 交互 Shell，点击</strong>【文件】<strong>然后选择</strong>【新建】**会打开一个新的空白脚本，我们可以在里面写代码。</p>
<p><img src="img/0858ba1570404037dd8f10c1741dcedd.png" alt="First Python Program"></p>
<p>**第 2 步:<strong>现在写代码，按</strong>“Ctrl+S”**保存文件。</p>
<p><img src="img/e66ce69a2ce386f6c6b489c90bc23742.png" alt="First Python Program"></p>
<p><strong>步骤- 3:</strong> 保存代码后，我们可以通过点击“运行”或“运行模块”来运行。它将向 Shell 显示输出。</p>
<p><img src="img/020dad4b47a6767ed07a348d901f20bc.png" alt="First Python Program"></p>
<p>输出如下所示。</p>
<p><img src="img/6a3877bf279f2292a4db17b383a8ec7b.png" alt="First Python Program"></p>
<p><strong>步骤- 4:</strong> 除此之外，我们还可以使用操作系统终端运行文件。但是，我们应该知道保存文件的目录的路径。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>打开命令行提示符并导航到目录。</p>
</li>
</ul>
<p><img src="img/6f11cb17f8b541703857a0e8edce7014.png" alt="First Python Program"></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>我们需要键入 <strong>python</strong> 关键字，后跟文件名，然后点击回车运行 python 文件。</p>
</li>
</ul>
<p><img src="img/9ef6f35eaf4c763b0033d7ef3c9e6f02.png" alt="First Python Program"></p>
<h2 id="多行语句">多行语句</h2>
<p>多行语句像编辑器一样写入记事本，用<strong>保存。py</strong> 分机。在下面的例子中，我们已经使用 Python 脚本定义了多个代码行的执行。</p>
<p><strong>代码:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;Andrew Venis&quot;</span></span><br><span class="line">branch = <span class="string">&quot;Computer Science&quot;</span></span><br><span class="line">age = <span class="string">&quot;25&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My name is: &quot;</span>, name, )</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My age is: &quot;</span>, age)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>脚本文件:</strong></p>
<p><img src="img/131fb000877205dbba7f512ded2fcb41.png" alt="First Python Program"><br>
<img src="img/e44277f08e7ff3adf2813f5cf209d85c.png" alt="First Python Program"></p>
<h3 id="脚本模式的利弊">脚本模式的利弊</h3>
<p>脚本模式也没有什么优点和缺点。让我们了解以下在脚本模式下运行代码的优点。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>我们可以运行多行代码。</p>
</li>
<li class="lvl-4">
<p>在脚本模式下调试很容易。</p>
</li>
<li class="lvl-4">
<p>它适合初学者，也适合专家。</p>
</li>
</ul>
<p>让我们看看脚本模式的缺点。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>如果我们对代码进行任何更改，我们必须每次都保存代码。</p>
</li>
<li class="lvl-4">
<p>当我们运行一行或几行代码时，可能会很乏味。</p>
</li>
</ul>
<h2 id="开始使用-PyCharm">开始使用 PyCharm</h2>
<p>在我们的第一个程序中，我们在 CentOS 上使用了 gedit 作为编辑器。在 Windows 上，我们有记事本或记事本++这样的替代工具来编辑代码。但是，这些编辑器不能用作 python 的 IDE，因为它们不能显示语法相关的建议。</p>
<p>JetBrains 提供了最流行和广泛使用的跨平台 IDE <strong>PyCharm</strong> 来运行 python 程序。</p>
<h2 id="PyCharm-安装">PyCharm 安装</h2>
<p>正如我们已经说过的，PyCharm 是一个跨平台的 IDE，因此它可以安装在各种操作系统上。在本节教程中，我们将介绍 PyCharm 在 Windows、 <a href="https://www.javatpoint.com/how-to-install-pycharm-on-mac">MacOS</a> 、 <a href="https://www.javatpoint.com/how-to-install-pycharm-on-centos">CentOS</a> 和 <a href="https://www.javatpoint.com/how-to-install-pycharm-in-ubuntu">Ubuntu</a> 上的安装过程。</p>
<h3 id="Windows-操作系统">Windows 操作系统</h3>
<p>在 Windows 上安装 PyCharm 非常简单。要在 Windows 操作系统上安装 PyCharm，请访问链接<a href="https://www.jetbrains.com/pycharm/download/download-thanks.html?platform=windows">https://www . jet brains . com/py charm/download/download-thanks . html？platform=windows</a> 下载可执行的安装程序。<strong>双击</strong>安装程序(。exe)文件，并通过在每一步单击“下一步”来安装 PyCharm。</p>
<p>要为 Pycharm 创建第一个程序，请执行以下步骤。</p>
<p>**第一步。**打开 Pycharm 编辑器。点击“创建新项目”选项创建新项目。</p>
<p><img src="img/6c4a690a830fb7756898d1777ba07013.png" alt="First Python Program"></p>
<p>**第 2 步。**选择保存项目的位置。</p>
<ol>
<li class="lvl-4">
<p>我们可以将新创建的项目保存在所需的内存位置，也可以保持文件位置不变，但至少要将项目默认名称<strong>无标题</strong>更改为**“第一个项目”**或其他有意义的名称。</p>
</li>
<li class="lvl-4">
<p>Pycharm 自动找到安装的 Python 解释器。</p>
</li>
<li class="lvl-4">
<p>更改名称后，点击“创建”按钮。</p>
</li>
</ol>
<p><img src="img/1254113c7e0bc5fbfff0ae27039a7215.png" alt="First Python Program"></p>
<p><strong>第三步。<strong>点击</strong>文件</strong>菜单，选择**【新增】**。通过点击“新建”选项，它将显示各种文件格式。选择“Python 文件”。</p>
<p><img src="img/97ee94acbd380ae231054d316f737607.png" alt="First Python Program"></p>
<p>**第 4 步。**现在输入 Python 文件的名称，点击“确定”。我们已经编写了“第一个程序”。</p>
<p><img src="img/f73fd80a7f51cedf5cbab514d090894e.png" alt="First Python Program"></p>
<p>**第 5 步。**现在输入第一个程序-打印(“你好世界”)，然后点击“运行”菜单运行程序。</p>
<p><img src="img/753315c8a9172f1b605d0dde9d5a705c.png" alt="First Python Program"></p>
<p>**第 6 步。**输出将出现在屏幕底部。</p>
<p><img src="img/3776fdd928ef18fb45916d3eb5014387.png" alt="First Python Program"></p>
<h2 id="Python-的基本语法">Python 的基本语法</h2>
<h3 id="Python-中的缩进和注释">Python 中的缩进和注释</h3>
<p>缩进是 Python 编程语言中最重要的概念。缩进使用不当会导致代码中出现**“缩进错误”**。</p>
<p>缩进只是在需要时在语句前添加空格。没有缩进，Python 不知道接下来要执行哪条语句。缩进还定义了哪些语句属于哪个块。如果没有缩进或者缩进不当，会显示“<strong>缩进错误”</strong>，中断我们的代码。</p>
<p><img src="img/51c622414ab8177982d7b601b5abd9c3.png" alt="First Python Program"></p>
<p>Python 缩进定义了属于特定块的特定语句组。诸如 <a href="https://www.javatpoint.com/c-programming-language-tutorial">C</a> 、 <a href="https://www.javatpoint.com/cpp-tutorial">C++</a> 、 <a href="https://www.javatpoint.com/java-tutorial">java</a> 等编程语言使用花括号{}来定义代码块。</p>
<p>在 Python 中，右边同一级别的语句属于同一个块。我们可以用四个空格来定义缩进。让我们看看下面几行代码。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list1:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">4</span>:</span><br><span class="line">       <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;End of for loop&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">End of <span class="keyword">for</span> loop</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的代码中，<code>for</code>循环有一个代码块，如果语句的代码块在 <code>for</code>循环内部。都缩进了四个空格。最后一条 <strong>print()</strong> 语句不缩进；这意味着它不属于 <code>for</code>循环。</p>
<h3 id="Python-中的注释">Python 中的注释</h3>
<p><a href="python-comments">注释</a>对于定义代码并帮助我们和其他人理解代码至关重要。通过查看注释，我们可以很容易地理解我们用代码写的每一行的意图。我们还可以非常容易地找到错误，修复它们，并在其他应用中使用。</p>
<p>在 Python 中，我们可以使用# hash 字符应用注释。Python 解释器完全忽略后跟哈希字符的行。一个好的程序员总是在稳定的情况下使用注释来编写代码。让我们看看下面的注释示例。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">name  = <span class="string">&quot;Thomas&quot;</span>   <span class="comment"># Assigning string value to the name variable </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以在 Python 代码的每一行添加注释。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Fees = <span class="number">10000</span>      <span class="comment"># defining course fees is 10000</span></span><br><span class="line">Fees = <span class="number">20000</span>      <span class="comment"># defining course fees is 20000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最好在目的不明显的代码的代码段的任何一行中添加代码。这是在编码时学习的最佳实践。</p>
<h3 id="注释的类型">注释的类型</h3>
<p>Python 提供了以两种方式编写注释的工具——单行注释和多行注释。</p>
<p><strong>单行注释-</strong> 单行注释以 hash #字符开始，后面是文本，以便进一步解释。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># defining the marks of a student </span></span><br><span class="line">Marks = <span class="number">90</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们也可以在代码语句旁边写一个注释。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Name = <span class="string">&quot;James&quot;</span>   <span class="comment"># the name of a student is James</span></span><br><span class="line">Marks = <span class="number">90</span>            <span class="comment"># defining student&#x27;s marks</span></span><br><span class="line">Branch = <span class="string">&quot;Computer Science&quot;</span>   <span class="comment"># defining student branch</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>多行注释-</strong> Python 没有对多行注释的明确支持，但是我们可以对多行使用 hash #字符。<strong>例如-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># we are defining for loop</span></span><br><span class="line"><span class="comment"># To iterate the given list.</span></span><br><span class="line"><span class="comment"># run this code.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们也可以用另一种方式。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot; &quot;</span> <span class="string">&quot; </span></span><br><span class="line"><span class="string">This is an example</span></span><br><span class="line"><span class="string">Of multi-line comment</span></span><br><span class="line"><span class="string">Using triple-quotes </span></span><br><span class="line"><span class="string">&quot;</span> <span class="string">&quot; &quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这是评论的基本介绍。请访问我们的 <strong>Python 评论</strong>教程详细了解。</p>
<h2 id="Python-标识符">Python 标识符</h2>
<p>Python 标识符是指用于标识变量、函数、模块、类、模块或其他对象的名称。命名 Python 变量时，几乎没有什么规则可遵循。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>变量名必须以英文字母或下划线（<code>_</code>）开头。</p>
</li>
<li class="lvl-4">
<p>变量名不能以数字开头。</p>
</li>
<li class="lvl-4">
<p>变量名中不允许有特殊字符。</p>
</li>
<li class="lvl-4">
<p>变量的名称区分大小写。</p>
</li>
</ul>
<p>让我们理解下面的例子。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">number = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line">_a = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(_a)</span><br><span class="line"></span><br><span class="line">x_y = <span class="number">1000</span></span><br><span class="line"><span class="built_in">print</span>(x_y)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">1000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们已经定义了 Python 编程语言的基本语法。我们必须熟悉任何编程语言的核心概念。一旦我们记住了上面提到的概念。学习 Python 的旅程将变得更加容易。</p>
<h3 id="CentOS">CentOS</h3>
<p>要在 CentOS 上安装 PyCharm，请访问链接<a href="how-to-install-pycharm-on-centos"><em>【https://www.javatpoint.com/how-to-install-pycharm-on-centos】</em></a>。该链接将指导您在 CentOS 上安装 PyCharm。</p>
<h3 id="苹果">苹果</h3>
<p>要在 MacOS 上安装 PyCharm，请访问链接<a href="how-to-install-pycharm-on-mac"><em>【https://www.javatpoint.com/how-to-install-pycharm-on-mac】</em></a>。该链接将指导您在 MacOS 上安装 PyCharm。</p>
<h3 id="人的本质">人的本质</h3>
<p>要在 Ubuntu 上安装 PyCharm，请访问链接<a href="how-to-install-pycharm-in-ubuntu"><em>【https://www.javatpoint.com/how-to-install-pycharm-in-ubuntu】</em></a>。该链接将指导您在 Ubuntu 上安装 PyCharm。</p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python OOP概念</title>
    <url>/posts/39d0c80e.html</url>
    <content><![CDATA[<h1>Python OOP 概念</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-oops-concepts">https://www.javatpoint.com/python-oops-concepts</a></p>
</blockquote>
<p>像其他通用编程语言一样，Python 从一开始就是一种面向对象的语言。它允许我们使用面向对象的方法开发应用。在 <a href="https://www.javatpoint.com/python-tutorial">Python</a> 中，我们可以轻松创建和使用类和对象。</p>
<p>面向对象的范例是使用类和对象来设计程序。对象与真实单词实体相关，如书、房子、铅笔等。oops 概念侧重于编写可重用的代码。通过创建对象来解决问题是一种普遍的技术。</p>
<p>面向对象编程系统的主要原理如下。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>类</p>
</li>
<li class="lvl-4">
<p>对象</p>
</li>
<li class="lvl-4">
<p>方法</p>
</li>
<li class="lvl-4">
<p>继承</p>
</li>
<li class="lvl-4">
<p>多态性</p>
</li>
<li class="lvl-4">
<p>数据抽象</p>
</li>
<li class="lvl-4">
<p>封装</p>
</li>
</ul>
<h2 id="班级">班级</h2>
<p>该类可以定义为对象的集合。它是一个逻辑实体，具有一些特定的属性和方法。例如:如果您有一个雇员类，那么它应该包含一个属性和方法，即电子邮件 id、姓名、年龄、工资等。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>:   </span><br><span class="line">        &lt;statement-<span class="number">1</span>&gt;   </span><br><span class="line">        .   </span><br><span class="line">        .    </span><br><span class="line">        &lt;statement-N&gt;   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="目标">目标</h2>
<p>对象是具有状态和行为的实体。它可以是任何真实世界的物体，如鼠标、键盘、椅子、桌子、笔等。</p>
<p>Python 中的一切都是对象，几乎一切都有属性和方法。所有函数都有一个内置属性 <strong>doc</strong>，它返回函数源代码中定义的 docstring。</p>
<p>当我们定义一个类时，它需要创建一个对象来分配内存。考虑下面的例子。</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">car</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,modelname, year</span>):</span><br><span class="line">        self.modelname = modelname</span><br><span class="line">        self.year = year</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.modelname,self.year)</span><br><span class="line"></span><br><span class="line">c1 = car(<span class="string">&quot;Toyota&quot;</span>, <span class="number">2016</span>)</span><br><span class="line">c1.display()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Toyota <span class="number">2016</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们已经创建了名为 car 的类，它有两个属性 modelname 和 year。我们已经创建了一个 c1 对象来访问类属性。c1 对象将为这些值分配内存。我们将在下一个教程中学习更多关于类和对象的知识。</p>
<h2 id="方法">方法</h2>
<p>方法是与对象关联的函数。在 Python 中，方法不是类实例独有的。任何对象类型都可以有方法。</p>
<h2 id="继承">继承</h2>
<p>继承是面向对象编程最重要的方面，它模拟了现实世界中的继承概念。它指定子对象获取父对象的所有属性和行为。</p>
<p>通过使用继承，我们可以创建一个使用另一个类的所有属性和行为的类。新类称为派生类或子类，而获取其属性的类称为基类或父类。</p>
<p>它提供了代码的重用性。</p>
<h2 id="多态性">多态性</h2>
<p>多态性包含两个词“聚”和“形”。多边形意味着很多，变形意味着形状。通过多态性，我们理解一个任务可以用不同的方式执行。比如——你有一个类动物，所有的动物都会说话。但是他们说话不同。在这里，“说话”行为在某种意义上是多态的，并且取决于动物。所以，抽象的“动物”概念实际上并不“说话”，而是具体的动物(如狗和猫)有一个具体实施的动作“说话”。</p>
<h2 id="封装">封装</h2>
<p>封装也是面向对象编程的一个重要方面。它用于限制对方法和变量的访问。在封装中，代码和数据被包装在一个单元中，不会被意外修改。</p>
<h2 id="数据抽象">数据抽象</h2>
<p>数据抽象和封装都经常被用作同义词。两者几乎是同义词，因为数据抽象是通过封装实现的。</p>
<p>抽象用于隐藏内部细节，只显示功能。抽象事物意味着给事物命名，这样名字就抓住了一个函数或整个程序的核心。</p>
<h2 id="面向对象和面向过程的编程语言">面向对象和面向过程的编程语言</h2>
<p>面向对象和面向过程编程的区别如下:</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>面向对象编程</th>
<th>面向过程编程</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.</td>
<td>面向对象编程是解决问题的方法，用于通过使用对象完成计算的地方。</td>
<td>过程编程使用一系列指令来逐步进行计算。</td>
</tr>
<tr>
<td>2.</td>
<td>它使开发和维护更加容易。</td>
<td>在过程编程中，当项目变得冗长时，维护代码并不容易。</td>
</tr>
<tr>
<td>3.</td>
<td>它模拟真实世界的实体。因此，现实世界的问题可以通过 oops 轻松解决。</td>
<td>它没有模拟真实世界。它对被分成称为函数的小部分的逐步指令起作用。</td>
</tr>
<tr>
<td>4.</td>
<td>它提供数据隐藏。所以它比过程语言更安全。您不能从任何地方访问私人数据。</td>
<td>过程语言没有为数据绑定提供任何合适的方式，因此不太安全。</td>
</tr>
<tr>
<td>5.</td>
<td>面向对象编程语言的例子是 C++、Java、。Net、Python、C#等。</td>
<td>过程语言例子有:C，Fortran，Pascal，VB 等。</td>
</tr>
</tbody>
</table>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 面向对象</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 中的抽象</title>
    <url>/posts/4bd79900.html</url>
    <content><![CDATA[<h1>Python 中的抽象</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/abstraction-in-python">https://www.javatpoint.com/abstraction-in-python</a></p>
</blockquote>
<p>抽象用于向用户隐藏函数的内部功能。用户只与功能的基本实现交互，但内部工作是隐藏的。用户熟悉**“什么功能”<strong>但是不知道</strong>“它是怎么做的。”**</p>
<p>简单地说，我们都使用智能手机，并且非常熟悉它的功能，如摄像头、录音机、拨号等。，但我们不知道这些操作是如何在后台发生的。我们再举一个例子——当我们使用电视遥控器增加音量时。我们不知道按一个键如何增加电视的音量。我们只知道按“+”按钮来增加音量。</p>
<p>这正是在<a href="https://www.javatpoint.com/python-oops-concepts">面向对象概念</a>中工作的抽象。</p>
<h2 id="为什么抽象很重要？">为什么抽象很重要？</h2>
<p>在 Python 中，抽象用于隐藏不相关的数据/类，以降低复杂性。也提高了应用效率。接下来，我们将学习如何使用 <a href="https://www.javatpoint.com/python-programs">Python 程序</a>实现抽象。</p>
<h2 id="Python-中的抽象类">Python 中的抽象类</h2>
<p>在 <a href="https://www.javatpoint.com/python-tutorial">Python</a> 中，抽象可以通过使用抽象类和接口来实现。</p>
<p>由一个或多个抽象方法组成的类称为抽象类。抽象方法不包含它们的实现。抽象类可以被子类继承，抽象方法在子类中得到定义。抽象类是另一个类的蓝图。当我们设计大型函数时，抽象类可能很有用。抽象类也有助于为组件的不同实现提供标准接口。Python 提供了 <strong>abc</strong> 模块来使用 Python 程序中的抽象。让我们看看下面的语法。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们从 <strong>abc</strong> 模块导入 ABC 类。</p>
<h2 id="抽象基类">抽象基类</h2>
<p>抽象基类是一组子类接口的通用应用。它可以被第三方使用，第三方将提供诸如插件的实现。当我们使用大型代码库来努力记住所有的类时，这也是有益的。</p>
<h2 id="抽象类的工作">抽象类的工作</h2>
<p>与其他高级语言不同，Python 本身不提供抽象类。我们需要导入 abc 模块，它为定义抽象基类提供了基础。ABC 的工作原理是将基类的方法装饰成抽象的。它将具体的类注册为抽象基的实现。我们使用***@ abstract method】***装饰器来定义一个抽象方法，或者如果我们不为该方法提供定义，它会自动成为抽象方法。让我们理解下面的例子。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Python program demonstrate</span></span><br><span class="line"><span class="comment"># abstract base class work </span></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>(<span class="title class_ inherited__">ABC</span>): </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">mileage</span>(<span class="params">self</span>): </span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tesla</span>(<span class="title class_ inherited__">Car</span>): </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">mileage</span>(<span class="params">self</span>): </span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;The mileage is 30kmph&quot;</span>) </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Suzuki</span>(<span class="title class_ inherited__">Car</span>): </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">mileage</span>(<span class="params">self</span>): </span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;The mileage is 25kmph &quot;</span>) </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Duster</span>(<span class="title class_ inherited__">Car</span>): </span><br><span class="line">	 <span class="keyword">def</span> <span class="title function_">mileage</span>(<span class="params">self</span>): </span><br><span class="line">		  <span class="built_in">print</span>(<span class="string">&quot;The mileage is 24kmph &quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Renault</span>(<span class="title class_ inherited__">Car</span>): </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mileage</span>(<span class="params">self</span>): </span><br><span class="line">		    <span class="built_in">print</span>(<span class="string">&quot;The mileage is 27kmph &quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Driver code </span></span><br><span class="line">t= Tesla () </span><br><span class="line">t.mileage() </span><br><span class="line"></span><br><span class="line">r = Renault() </span><br><span class="line">r.mileage() </span><br><span class="line"></span><br><span class="line">s = Suzuki() </span><br><span class="line">s.mileage() </span><br><span class="line">d = Duster() </span><br><span class="line">d.mileage()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The mileage <span class="keyword">is</span> 30kmph</span><br><span class="line">The mileage <span class="keyword">is</span> 27kmph </span><br><span class="line">The mileage <span class="keyword">is</span> 25kmph </span><br><span class="line">The mileage <span class="keyword">is</span> 24kmph</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>解释-</strong></p>
<p>在上面的代码中，我们已经导入了 <strong>abc 模块</strong>来创建抽象基类。我们创建了继承了 ABC 类的 Car 类，并定义了一个名为里程()的抽象方法。然后，我们从三个不同的子类继承了基类，并以不同的方式实现了抽象方法。我们创建了对象来调用抽象方法。</p>
<p>让我们理解另一个例子。</p>
<p>让我们理解另一个例子。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Python program to define </span></span><br><span class="line"><span class="comment"># abstract class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Polygon</span>(<span class="title class_ inherited__">ABC</span>): </span><br><span class="line"></span><br><span class="line">   <span class="comment"># abstract method </span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">sides</span>(<span class="params">self</span>): </span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span>(<span class="title class_ inherited__">Polygon</span>): </span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">sides</span>(<span class="params">self</span>): </span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Triangle has 3 sides&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pentagon</span>(<span class="title class_ inherited__">Polygon</span>): </span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">sides</span>(<span class="params">self</span>): </span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Pentagon has 5 sides&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hexagon</span>(<span class="title class_ inherited__">Polygon</span>): </span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">sides</span>(<span class="params">self</span>): </span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Hexagon has 6 sides&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">square</span>(<span class="title class_ inherited__">Polygon</span>): </span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">sides</span>(<span class="params">self</span>): </span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;I have 4 sides&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Driver code </span></span><br><span class="line">t = Triangle() </span><br><span class="line">t.sides() </span><br><span class="line"></span><br><span class="line">s = square() </span><br><span class="line">s.sides() </span><br><span class="line"></span><br><span class="line">p = Pentagon() </span><br><span class="line">p.sides() </span><br><span class="line"></span><br><span class="line">k = Hexagon() </span><br><span class="line">K.sides() </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Triangle has <span class="number">3</span> sides</span><br><span class="line">Square has <span class="number">4</span> sides</span><br><span class="line">Pentagon has <span class="number">5</span> sides</span><br><span class="line">Hexagon has <span class="number">6</span> sides</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>解释-</strong></p>
<p>在上面的代码中，我们定义了名为 Polygon 的抽象基类，并定义了抽象方法。这个基类由不同的子类继承。我们在每个子类中实现了抽象方法。我们创建了子类的对象，并调用了 <strong>sides()</strong> 方法。每个子类中的**边()**方法的隐藏实现开始发挥作用。抽象类中定义的抽象方法 <strong>sides()</strong> 方法从未被调用。</p>
<h2 id="需要记住的要点-2">需要记住的要点</h2>
<p>下面是我们应该记住的关于 Python 中抽象基类的几点。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>抽象类可以包含普通方法和抽象方法。</p>
</li>
<li class="lvl-4">
<p>无法实例化抽象；我们不能为抽象类创建对象。</p>
</li>
</ul>
<p>抽象对于向用户隐藏核心功能至关重要。我们已经介绍了 Python 中抽象的所有基本概念。</p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 面向对象</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 构造器</title>
    <url>/posts/f1d84d54.html</url>
    <content><![CDATA[<h1>Python 构造器</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-constructors">https://www.javatpoint.com/python-constructors</a></p>
</blockquote>
<p>构造器是一种特殊类型的方法(函数)，用于初始化类的实例成员。</p>
<p>在 C++或 Java 中，构造器与其类同名，但在 Python 中它对构造器的处理不同。它用于创建对象。</p>
<p>构造器可以有两种类型。</p>
<ol>
<li class="lvl-4">
<p>参数化构造器</p>
</li>
<li class="lvl-4">
<p>非参数化构造器</p>
</li>
</ol>
<p>构造器定义是在我们创建这个类的对象时执行的。构造器还验证对象是否有足够的资源来执行任何启动任务。</p>
<h2 id="用-python-创建构造器">用 python 创建构造器</h2>
<p>在 Python 中，方法 <strong><strong>init</strong>()</strong> 模拟类的构造器。当类实例化时调用此方法。它接受<strong>self</strong>-关键字作为允许访问类的属性或方法的第一个参数。</p>
<p>我们可以在创建类对象时传递任意数量的参数，这取决于 <strong><strong>init</strong>()</strong> 的定义。它主要用于初始化类属性。每个类都必须有一个构造器，即使它只是依赖于默认的构造器。</p>
<p>考虑下面的例子来初始化<strong>雇员</strong>类属性。</p>
<h3 id="例子-19">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, <span class="built_in">id</span></span>):</span><br><span class="line">        self.<span class="built_in">id</span> = <span class="built_in">id</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ID: %d \nName: %s&quot;</span> % (self.<span class="built_in">id</span>, self.name))</span><br><span class="line"></span><br><span class="line">emp1 = Employee(<span class="string">&quot;John&quot;</span>, <span class="number">101</span>)</span><br><span class="line">emp2 = Employee(<span class="string">&quot;David&quot;</span>, <span class="number">102</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># accessing display() method to print employee 1 information</span></span><br><span class="line"></span><br><span class="line">emp1.display()</span><br><span class="line"></span><br><span class="line"><span class="comment"># accessing display() method to print employee 2 information</span></span><br><span class="line">emp2.display()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ID: <span class="number">101</span> </span><br><span class="line">Name: John</span><br><span class="line">ID: <span class="number">102</span> </span><br><span class="line">Name: David</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="计算一个类的对象数">计算一个类的对象数</h3>
<p>当我们创建类的对象时，会自动调用构造器。考虑下面的例子。</p>
<h3 id="例子-20">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:  </span><br><span class="line">    count = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):  </span><br><span class="line">        Student.count = Student.count + <span class="number">1</span>  </span><br><span class="line">s1=Student()  </span><br><span class="line">s2=Student()  </span><br><span class="line">s3=Student()  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The number of students:&quot;</span>,Student.count)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The number of students: <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Python-非参数化构造器">Python 非参数化构造器</h2>
<p>当我们不想操作只有 self 作为参数的值或构造器时，使用非参数化构造器。考虑下面的例子。</p>
<h3 id="例子-21">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="comment"># Constructor - non parameterized</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This is non parametrized constructor&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">self,name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>,name)</span><br><span class="line">student = Student()</span><br><span class="line">student.show(<span class="string">&quot;John&quot;</span>)    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Python-参数化构造器">Python 参数化构造器</h2>
<p>参数化构造器有多个参数以及<strong>自身</strong>。考虑下面的例子。</p>
<h3 id="例子-22">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="comment"># Constructor - parameterized</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This is parametrized constructor&quot;</span>)</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>,self.name)</span><br><span class="line">student = Student(<span class="string">&quot;John&quot;</span>)</span><br><span class="line">student.show()  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">This <span class="keyword">is</span> parametrized constructor</span><br><span class="line">Hello John</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Python-默认构造器">Python 默认构造器</h2>
<p>当我们没有在类中包含构造器或者忘记声明它时，那么它就变成了默认的构造器。它不执行任何任务，但初始化对象。考虑下面的例子。</p>
<h3 id="例子-23">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    roll_num = <span class="number">101</span></span><br><span class="line">    name = <span class="string">&quot;Joseph&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.roll_num,self.name)</span><br><span class="line"></span><br><span class="line">st = Student()</span><br><span class="line">st.display()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">101</span> Joseph</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="一个类中有多个构造器">一个类中有多个构造器</h2>
<p>让我们看看另一个场景，如果我们在类中声明两个相同的构造器会发生什么。</p>
<h3 id="例子-24">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The First Constructor&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The second contructor&quot;</span>)</span><br><span class="line"></span><br><span class="line">st = Student()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The Second Constructor</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，对象 <strong>st</strong> 调用了第二个构造器，而两者具有相同的配置。第一种方法不能被 <strong>st</strong> 对象访问。在内部，如果类有多个构造器，该类的对象将总是调用最后一个构造器。</p>
<h4 id="注意-Python-中不允许构造器重载。">注意:Python 中不允许构造器重载。</h4>
<h2 id="Python-内置的类函数">Python 内置的类函数</h2>
<p>下表描述了类中定义的内置函数。</p>
<p>| 序号 | 功能 | 描述 |<br>
| one | getattr（obj，name，default） | 它用于访问对象的属性。 |<br>
| Two | setattr(obj、name、value) | 它用于为对象的特定属性设置特定值。 |<br>
| three | delaattr(obj，name) | 它用于删除特定属性。 |<br>
| four | hasattr(obj，name) | 如果对象包含某些特定属性，则返回 true。 |</p>
<h3 id="例子-25">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, <span class="built_in">id</span>, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.<span class="built_in">id</span> = <span class="built_in">id</span></span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># creates the object of the class Student</span></span><br><span class="line">s = Student(<span class="string">&quot;John&quot;</span>, <span class="number">101</span>, <span class="number">22</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># prints the attribute name of the object s</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(s, <span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># reset the value of attribute age to 23</span></span><br><span class="line"><span class="built_in">setattr</span>(s, <span class="string">&quot;age&quot;</span>, <span class="number">23</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># prints the modified value of age</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(s, <span class="string">&#x27;age&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># prints true if the student contains the attribute with name id</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(s, <span class="string">&#x27;id&#x27;</span>))</span><br><span class="line"><span class="comment"># deletes the attribute age</span></span><br><span class="line"><span class="built_in">delattr</span>(s, <span class="string">&#x27;age&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># this will give an error since the attribute age has been deleted</span></span><br><span class="line"><span class="built_in">print</span>(s.age)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">John</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line">AttributeError: <span class="string">&#x27;Student&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;age&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="内置类属性">内置类属性</h2>
<p>除了其他属性，Python 类还包含一些内置的类属性，这些属性提供了关于该类的信息。</p>
<p>下表给出了内置的类属性。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>one</td>
<td><strong>dict</strong></td>
<td>它提供了包含类命名空间信息的字典。</td>
</tr>
<tr>
<td>Two</td>
<td><strong>doc</strong></td>
<td>它包含一个包含类文档的字符串</td>
</tr>
<tr>
<td>three</td>
<td><strong>name</strong></td>
<td>它用于访问类名。</td>
</tr>
<tr>
<td>four</td>
<td><strong>moudle</strong></td>
<td>它用于访问定义该类的模块。</td>
</tr>
<tr>
<td>five</td>
<td><strong>base</strong></td>
<td>它包含一个包含所有基类的元组。</td>
</tr>
</tbody>
</table>
<h3 id="例子-26">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,<span class="built_in">id</span>,age</span>):  </span><br><span class="line">        self.name = name;  </span><br><span class="line">        self.<span class="built_in">id</span> = <span class="built_in">id</span>;  </span><br><span class="line">        self.age = age  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display_details</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Name:%s, ID:%d, age:%d&quot;</span>%(self.name,self.<span class="built_in">id</span>))  </span><br><span class="line">s = Student(<span class="string">&quot;John&quot;</span>,<span class="number">101</span>,<span class="number">22</span>)  </span><br><span class="line"><span class="built_in">print</span>(s.__doc__)  </span><br><span class="line"><span class="built_in">print</span>(s.__dict__)  </span><br><span class="line"><span class="built_in">print</span>(s.__module__)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">None</span></span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;id&#x27;</span>: <span class="number">101</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">22</span>&#125;</span><br><span class="line">__main__</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 面向对象</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 类和对象</title>
    <url>/posts/a39fbc03.html</url>
    <content><![CDATA[<h1>Python 类和对象</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-objects-classes">https://www.javatpoint.com/python-objects-classes</a></p>
</blockquote>
<p>我们在之前的教程中已经讨论过，类是一个虚拟实体，可以看作是一个对象的蓝图。该类在实例化时就存在了。我们举个例子来理解一下。</p>
<p>假设一个类是一个建筑的原型。一栋建筑包含了所有关于楼层、房间、门、窗等的细节。基于这些细节，我们可以建造任意多的建筑。因此，建筑可以被看作一个类，我们可以创建尽可能多的这个类的对象。</p>
<p>另一方面，对象是类的实例。创建对象的过程可以称为实例化。</p>
<p>在教程的这一部分，我们将讨论用 Python 创建类和对象。我们还将讨论如何使用对象访问类属性。</p>
<h2 id="用-Python-创建类">用 Python 创建类</h2>
<p>在 Python 中，可以通过使用关键字 class，后跟类名来创建一个类。下面给出了创建类的语法。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>:  </span><br><span class="line">    <span class="comment">#statement_suite   </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>In Python, we must notice that each class is associated with a documentation string which can be accessed by using <strong><class-name>.<strong>doc</strong>.</strong> A class contains a statement suite including fields, constructor, function, etc. definition.</p>
<p>考虑下面的例子来创建一个类 <strong>Employee</strong> ，它包含两个字段作为 Employee id 和 name。</p>
<p>该类还包含一个功能<strong>显示()</strong>，用于显示<strong>员工的信息。</strong></p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>:  </span><br><span class="line">    <span class="built_in">id</span> = <span class="number">10</span> </span><br><span class="line">    name = <span class="string">&quot;Devansh&quot;</span>  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span> (self):  </span><br><span class="line">        <span class="built_in">print</span>(self.<span class="built_in">id</span>,self.name)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里 <strong>self</strong> 作为引用变量，引用当前类对象。它总是函数定义中的第一个参数。但是，在函数调用中，使用 <strong>self</strong> 是可选的。</p>
<h3 id="自参数">自参数</h3>
<p>self 参数引用类的当前实例并访问类变量。我们可以用任何东西代替自我，但它必须是属于类的任何函数的第一个参数。</p>
<h2 id="创建类的实例">创建类的实例</h2>
<p>如果我们想在另一个类或方法中使用类属性，就需要实例化一个类。可以通过使用类名调用类来实例化类。</p>
<p>下面给出了创建类实例的语法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;<span class="built_in">object</span>-name&gt; = &lt;<span class="keyword">class</span>-name&gt;(&lt;arguments&gt;)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面的示例创建在上面的示例中定义的雇员类的实例。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>:  </span><br><span class="line">    <span class="built_in">id</span> = <span class="number">10</span> </span><br><span class="line">    name = <span class="string">&quot;John&quot;</span>  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span> (self):  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ID: %d \nName: %s&quot;</span>%(self.<span class="built_in">id</span>,self.name))  </span><br><span class="line"><span class="comment"># Creating a emp instance of Employee class</span></span><br><span class="line">emp = Employee()  </span><br><span class="line">emp.display()  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ID: <span class="number">10</span> </span><br><span class="line">Name: John</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们创建了 Employee 类，它有两个名为 id 和 name 的属性，并为它们赋值。我们可以观察到我们在显示功能中通过了自我作为参数。它用于引用同一个类属性。</p>
<p>我们创建了一个名为 **emp 的新实例对象。**通过使用它，我们可以访问类的属性。</p>
<h2 id="删除对象">删除对象</h2>
<p>我们可以使用 del 关键字删除对象或对象本身的属性。考虑下面的例子。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>:</span><br><span class="line">    <span class="built_in">id</span> = <span class="number">10</span></span><br><span class="line">    name = <span class="string">&quot;John&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ID: %d \nName: %s&quot;</span> % (self.<span class="built_in">id</span>, self.name))</span><br><span class="line">    <span class="comment"># Creating a emp instance of Employee class</span></span><br><span class="line"></span><br><span class="line">emp = Employee()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Deleting the property of object</span></span><br><span class="line"><span class="keyword">del</span> emp.<span class="built_in">id</span></span><br><span class="line"><span class="comment"># Deleting the object itself</span></span><br><span class="line"><span class="keyword">del</span> emp</span><br><span class="line">emp.display()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它将通过属性错误，因为我们已经删除了对象 <strong>emp</strong> 。</p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 面向对象</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 继承</title>
    <url>/posts/1aca788d.html</url>
    <content><![CDATA[<h1>Python 继承</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/inheritance-in-python">https://www.javatpoint.com/inheritance-in-python</a></p>
</blockquote>
<p>继承是面向对象范例的一个重要方面。继承为程序提供了代码可重用性，因为我们可以使用现有的类来创建新的类，而不是从头开始创建。</p>
<p>在继承中，子类获取属性，并且可以访问父类中定义的所有数据成员和函数。子类也可以向父类的函数提供其特定的实现。在教程的这一部分，我们将详细讨论继承。</p>
<p>在 python 中，派生类只需在派生类名称后面的括号中提到基类，就可以继承基类。考虑以下语法将基类继承到派生类中。</p>
<p><img src="/img/f53e3a2c176d1eb4316086e13535992b.png" alt="Python Inheritance"></p>
<h3 id="句法-3">句法</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span>-<span class="keyword">class</span>(base <span class="keyword">class</span>):</span><br><span class="line">	&lt;<span class="keyword">class</span>-suite&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一个类可以通过在括号内提及所有类来继承多个类。请考虑以下语法。</p>
<h3 id="句法-4">句法</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derive</span>-<span class="keyword">class</span>(&lt;base <span class="keyword">class</span> <span class="number">1</span>&gt;, &lt;base <span class="keyword">class</span> <span class="number">2</span>&gt;, ..... &lt;base <span class="keyword">class</span> <span class="title class_">n</span>&gt;):</span><br><span class="line">	&lt;<span class="keyword">class</span> - suite&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例-1-14">例 1</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Animal Speaking&quot;</span>)</span><br><span class="line"><span class="comment">#child class Dog inherits the base class Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bark</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;dog barking&quot;</span>)</span><br><span class="line">d = Dog()</span><br><span class="line">d.bark()</span><br><span class="line">d.speak()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">dog barking</span><br><span class="line">Animal Speaking</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-多级继承">Python 多级继承</h2>
<p>像其他面向对象语言一样，python 中的多级继承是可能的。当一个派生类继承另一个派生类时，多级继承被存档。在 python 中，多级继承的存档级别不限。</p>
<p><img src="/img/19bc180ddb40dd02c854cd688a1b9f42.png" alt="Python Inheritance"></p>
<p>下面给出了多级继承的语法。</p>
<h3 id="句法-5">句法</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">class1</span>:</span><br><span class="line">	&lt;<span class="keyword">class</span>-suite&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">class2</span>(<span class="title class_ inherited__">class1</span>):</span><br><span class="line">	&lt;<span class="keyword">class</span> <span class="title class_">suite</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">class3</span>(<span class="title class_ inherited__">class2</span>):</span><br><span class="line">	&lt;<span class="keyword">class</span> <span class="title class_">suite</span>&gt;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例子-27">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Animal Speaking&quot;</span>)</span><br><span class="line"><span class="comment">#The child class Dog inherits the base class Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bark</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;dog barking&quot;</span>)</span><br><span class="line"><span class="comment">#The child class Dogchild inherits another child class Dog</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogChild</span>(<span class="title class_ inherited__">Dog</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Eating bread...&quot;</span>)</span><br><span class="line">d = DogChild()</span><br><span class="line">d.bark()</span><br><span class="line">d.speak()</span><br><span class="line">d.eat()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">dog barking</span><br><span class="line">Animal Speaking</span><br><span class="line">Eating bread...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-多重继承">Python 多重继承</h2>
<p>Python 为我们提供了在子类中继承多个基类的灵活性。</p>
<p><img src="/img/4866eec31edce10046a77685e4950642.png" alt="Python Inheritance"></p>
<p>下面给出了执行多重继承的语法。</p>
<h3 id="句法-6">句法</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span>:</span><br><span class="line">	&lt;<span class="keyword">class</span>-suite&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span>:</span><br><span class="line">	&lt;<span class="keyword">class</span>-suite&gt;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseN</span>:</span><br><span class="line">	&lt;<span class="keyword">class</span>-suite&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>(Base1, Base2, ...... BaseN):</span><br><span class="line">	&lt;<span class="keyword">class</span>-suite&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例子-28">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculation1</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Summation</span>(<span class="params">self,a,b</span>):</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculation2</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Multiplication</span>(<span class="params">self,a,b</span>):</span><br><span class="line">        <span class="keyword">return</span> a*b;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>(Calculation1,Calculation2):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Divide</span>(<span class="params">self,a,b</span>):</span><br><span class="line">        <span class="keyword">return</span> a/b;</span><br><span class="line">d = Derived()</span><br><span class="line"><span class="built_in">print</span>(d.Summation(<span class="number">10</span>,<span class="number">20</span>))</span><br><span class="line"><span class="built_in">print</span>(d.Multiplication(<span class="number">10</span>,<span class="number">20</span>))</span><br><span class="line"><span class="built_in">print</span>(d.Divide(<span class="number">10</span>,<span class="number">20</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">200</span></span><br><span class="line"><span class="number">0.5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="issubclass-sub，sup-方法">issubclass(sub，sup)方法</h2>
<p>issubclass(sub，sup)方法用于检查指定类之间的关系。如果第一个类是第二个类的子类，则返回 true，否则返回 false。</p>
<p>考虑下面的例子。</p>
<h3 id="例子-29">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculation1</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Summation</span>(<span class="params">self,a,b</span>):</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculation2</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Multiplication</span>(<span class="params">self,a,b</span>):</span><br><span class="line">        <span class="keyword">return</span> a*b;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>(Calculation1,Calculation2):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Divide</span>(<span class="params">self,a,b</span>):</span><br><span class="line">        <span class="keyword">return</span> a/b;</span><br><span class="line">d = Derived()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(Derived,Calculation2))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(Calculation1,Calculation2))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="isinstance-obj，class-方法">isinstance (obj，class)方法</h2>
<p>isinstance()方法用于检查对象和类之间的关系。如果第一个参数(即 obj)是第二个参数(即类)的实例，则返回 true。</p>
<p>考虑下面的例子。</p>
<h3 id="例子-30">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculation1</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Summation</span>(<span class="params">self,a,b</span>):</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculation2</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Multiplication</span>(<span class="params">self,a,b</span>):</span><br><span class="line">        <span class="keyword">return</span> a*b;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>(Calculation1,Calculation2):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Divide</span>(<span class="params">self,a,b</span>):</span><br><span class="line">        <span class="keyword">return</span> a/b;</span><br><span class="line">d = Derived()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(d,Derived))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="方法重写">方法重写</h2>
<p>我们可以在子类中提供父类方法的一些具体实现。当父类方法在子类中用一些特定的实现来定义时，这个概念被称为方法重写。在子类中需要父类方法的不同定义的情况下，我们可能需要执行方法重写。</p>
<p>考虑下面的例子，在 python 中执行方法重写。</p>
<h3 id="例子-31">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;speaking&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Barking&quot;</span>)</span><br><span class="line">d = Dog()</span><br><span class="line">d.speak()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Barking</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="方法重写的真实例子">方法重写的真实例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">getroi</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SBI</span>(<span class="title class_ inherited__">Bank</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getroi</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ICICI</span>(<span class="title class_ inherited__">Bank</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getroi</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">b1 = Bank()</span><br><span class="line">b2 = SBI()</span><br><span class="line">b3 = ICICI()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Bank Rate of interest:&quot;</span>,b1.getroi());</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;SBI Rate of interest:&quot;</span>,b2.getroi());</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ICICI Rate of interest:&quot;</span>,b3.getroi());</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Bank Rate of interest: <span class="number">10</span></span><br><span class="line">SBI Rate of interest: <span class="number">7</span></span><br><span class="line">ICICI Rate of interest: <span class="number">8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="python-中的数据抽象">python 中的数据抽象</h2>
<p>抽象是面向对象编程的一个重要方面。在 python 中，我们还可以通过向要隐藏的属性添加双下划线(___)作为前缀来执行数据隐藏。此后，通过对象，该属性在类外部将不可见。</p>
<p>考虑下面的例子。</p>
<h3 id="例子-32">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>:</span><br><span class="line">    __count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        Employee.__count = Employee.__count+<span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The number of employees&quot;</span>,Employee.__count)</span><br><span class="line">emp = Employee()</span><br><span class="line">emp2 = Employee()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(emp.__count)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    emp.display()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The number of employees <span class="number">2</span></span><br><span class="line">AttributeError: <span class="string">&#x27;Employee&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;__count&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 面向对象</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python MongoDB</title>
    <url>/posts/5870e75d.html</url>
    <content><![CDATA[<h1>Python MongoDB 连接</h1>
<p>为了在 Python 编程语言和 MongoDB 数据库之间建立连接，我们需要首先安装 <strong>pymongo</strong> 驱动程序。这里，我们正在创建一个连接到数据库并执行基本数据库操作的示例。</p>
<p>该示例包括以下步骤:</p>
<h3 id="1-安装驱动程序">1)安装驱动程序</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">$ pip install pymongo</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/6b67e4a354285a2a5a1097efc1a195dc.png" alt="MongoDB Python mongodb connectivity 1"></p>
<h3 id="2-创建-Python-文件">2)创建 Python 文件</h3>
<p><strong>// <a href="http://connect.py">connect.py</a></strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient <span class="comment"># import mongo client to connect</span></span><br><span class="line"><span class="keyword">import</span> pprint</span><br><span class="line"><span class="comment"># Creating instance of mongoclient</span></span><br><span class="line">client = MongoClient()</span><br><span class="line"><span class="comment"># Creating database</span></span><br><span class="line">db = client.javatpoint</span><br><span class="line">employee = &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;101&quot;</span>,</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;Peter&quot;</span>,</span><br><span class="line"><span class="string">&quot;profession&quot;</span>: <span class="string">&quot;Software Engineer&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># Creating document</span></span><br><span class="line">employees = db.employees</span><br><span class="line"><span class="comment"># Inserting data</span></span><br><span class="line">employees.insert_one(employee)</span><br><span class="line"><span class="comment"># Fetching data</span></span><br><span class="line">pprint.pprint(employees.find_one())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-执行-Python-脚本">3)执行 Python 脚本</h3>
<p>该脚本在控制台上打印插入的记录。</p>
<p><img src="/img/7b25a0abd092d4bab6723be1029166cd.png" alt="MongoDB Python mongodb connectivity 2"></p>
<h3 id="4-进入蒙古-Shell">4)进入蒙古 Shell</h3>
<p>现在，进入 MongoDB 数据库 Shell，查看创建的数据库和集合。</p>
<p>我们可以使用以下命令进入数据库。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">$ mongo</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/9c4889d684147a1d4bbf6bd06bec2fc5.png" alt="MongoDB Python mongodb connectivity 3"></p>
<h3 id="5-检查数据库">5)检查数据库</h3>
<p>以下命令用于显示可用的数据库。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&gt; show dbs</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/a8c731ad5cf838b756f0f59a5b6b4392.png" alt="MongoDB Python mongodb connectivity 4"></p>
<h3 id="6-支票收款">6)支票收款</h3>
<p>以下命令用于显示数据库中的可用集合。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&gt; show collections</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/2c688704f1aec56132f9441cdf58f666.png" alt="MongoDB Python mongodb connectivity 5"></p>
<h3 id="7-访问记录">7)访问记录</h3>
<p>我们可以看到特定集合中存储的记录。以下命令用于显示记录。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&gt; db.employees.find()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/cd7e15a6c5e300e5c97f358f36da7f2d.png" alt="MongoDB Python mongodb connectivity 6"></p>
<hr>
]]></content>
      <categories>
        <category>python</category>
        <category>python 数据库</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python SQLite</title>
    <url>/posts/d5f6c82e.html</url>
    <content><![CDATA[<h1>Python SQLite 连接</h1>
<p>首先，您必须在系统上安装 python 和 sqlite。</p>
<h2 id="安装-Python">安装 Python</h2>
<p>使用以下代码:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade python</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/98ddb8f0a2d623e271691c9e6f46a3e1.png" alt="SQLite Connect sqlite with python 1"></p>
<p>按 y，安装将在几秒钟内完成。</p>
<h2 id="安装-SQLite">安装 SQLite</h2>
<p><strong>安装步骤</strong></p>
<p>键入以下命令:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">sudo apt-get install sqlite3 libsqlite3-dev</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>安装后检查安装，sqlite 终端会给你提示和版本信息？</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">sqlite3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>转到所需文件夹并创建数据库:</p>
<p>sqlite3 数据库. db</p>
<p>它将在您发出命令的文件夹中创建 database.db。</p>
<p>要检查数据库是否已创建，请在 sqlite3 终端中使用以下命令:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">.databases</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="注意-要使用-Python-连接-SQLite，您不需要单独安装连接模块，因为默认情况下，它是与-Python-2-5-x-版一起发货的。">注意:要使用 Python 连接 SQLite，您不需要单独安装连接模块，因为默认情况下，它是与 Python 2.5 . x 版一起发货的。</h4>
<hr>
<h2 id="使用-Python-的-SQLite">使用 Python 的 SQLite</h2>
<p>创建一个 python 文件“<a href="http://connect.py">connect.py</a>”，包含以下代码:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">conn = sqlite3.connect(<span class="string">&#x27;javatpoint.db&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Opened database successfully&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>在命令提示符下执行以下语句:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">python connect.py</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/39d1342661f43a70acd451c3accf2bd6.png" alt="SQLite Connect sqlite with python 2"></p>
<p>现在已经创建了与 javatpoint 数据库的连接。现在，您可以创建一个表。</p>
<h2 id="创建表">创建表</h2>
<p>在数据库“javatpoint”中创建一个表“Employees”。</p>
<p>创建一个 python 文件“<a href="http://createtable.py">createtable.py</a>”，包含以下代码:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">conn = sqlite3.connect(<span class="string">&#x27;javatpoint.db&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Opened database successfully&quot;</span>;</span><br><span class="line"></span><br><span class="line">conn.execute(<span class="string">&#x27;&#x27;&#x27;CREATE TABLE Employees</span></span><br><span class="line"><span class="string">       (ID INT PRIMARY KEY     NOT NULL,</span></span><br><span class="line"><span class="string">       NAME           TEXT    NOT NULL,</span></span><br><span class="line"><span class="string">       AGE            INT     NOT NULL,</span></span><br><span class="line"><span class="string">       ADDRESS        CHAR(50),</span></span><br><span class="line"><span class="string">       SALARY         REAL);&#x27;&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Table created successfully&quot;</span>;</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在命令提示符下执行以下语句:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">python createtable.py</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/34a96bf81fb97cd19581923a0abaf526.png" alt="SQLite Connect sqlite with python 3"></p>
<p>在“javatpoint”数据库中创建了一个表“Employees”。</p>
<h2 id="插入记录">插入记录</h2>
<p>在“员工”表中插入一些记录。</p>
<p>创建一个 python 文件“<a href="http://connection.py">connection.py</a>”，包含以下代码:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">conn = sqlite3.connect(<span class="string">&#x27;javatpoint.db&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Opened database successfully&quot;</span>;</span><br><span class="line"></span><br><span class="line">conn.execute(<span class="string">&quot;INSERT INTO Employees (ID,NAME,AGE,ADDRESS,SALARY) \</span></span><br><span class="line"><span class="string">      VALUES (1, &#x27;Ajeet&#x27;, 27, &#x27;Delhi&#x27;, 20000.00 )&quot;</span>);</span><br><span class="line"></span><br><span class="line">conn.execute(<span class="string">&quot;INSERT INTO Employees (ID,NAME,AGE,ADDRESS,SALARY) \</span></span><br><span class="line"><span class="string">      VALUES (2, &#x27;Allen&#x27;, 22, &#x27;London&#x27;, 25000.00 )&quot;</span>);</span><br><span class="line"></span><br><span class="line">conn.execute(<span class="string">&quot;INSERT INTO Employees (ID,NAME,AGE,ADDRESS,SALARY) \</span></span><br><span class="line"><span class="string">      VALUES (3, &#x27;Mark&#x27;, 29, &#x27;CA&#x27;, 200000.00 )&quot;</span>);</span><br><span class="line"></span><br><span class="line">conn.execute(<span class="string">&quot;INSERT INTO Employees (ID,NAME,AGE,ADDRESS,SALARY) \</span></span><br><span class="line"><span class="string">      VALUES (4, &#x27;Kanchan&#x27;, 22, &#x27;Ghaziabad &#x27;, 65000.00 )&quot;</span>);</span><br><span class="line"></span><br><span class="line">conn.commit()</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Records inserted successfully&quot;</span>;</span><br><span class="line">conn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>在命令提示符下执行以下语句:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">python connection.py</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/7ba1b156540a9f1a241f221e4591a53a.png" alt="SQLite Connect sqlite with python 4"></p>
<p>记录插入成功。</p>
<h2 id="选择记录">选择记录</h2>
<p>现在，您可以使用 SELECT 语句从“雇员”表中获取并显示您的记录。</p>
<p>创建一个 python 文件“<a href="http://select.py">select.py</a>”，包含以下代码:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">conn = sqlite3.connect(<span class="string">&#x27;javatpoint.db&#x27;</span>)</span><br><span class="line"></span><br><span class="line">data = conn.execute(<span class="string">&quot;select * from Employees&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> data:</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;ID = &quot;</span>, row[<span class="number">0</span>]</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;NAME = &quot;</span>, row[<span class="number">1</span>]</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;ADDRESS = &quot;</span>, row[<span class="number">2</span>]</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;SALARY = &quot;</span>, row[<span class="number">3</span>], <span class="string">&quot;\n&quot;</span></span><br><span class="line"></span><br><span class="line">conn.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在命令提示符下执行以下语句:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">python select.py </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/1b56a244bc056f0a2efd7eb0cb1e2d87.png" alt="SQLite Connect sqlite with python 5"></p>
<p>查看您之前插入的所有记录。</p>
<p>通过同样的过程，您可以使用 Python 更新和删除 SQLite 数据库中的表。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>python 数据库</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python MySQL</title>
    <url>/posts/b52f47b.html</url>
    <content><![CDATA[<h1>Python Mysql</h1>
<h2 id="安装-mysql-connector">安装 mysql.connector</h2>
<p>要将 python 应用与 MySQL 数据库连接起来，我们必须在程序中导入 mysql.connector 模块。</p>
<p>mysql.connector 不是 python 安装附带的内置模块。我们需要安装它让它工作。</p>
<p>执行以下命令，使用 pip 安装程序安装它。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;  python -m pip install mysql-connector</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>或者按照以下步骤操作。</strong></p>
<p>1.点击链接:</p>
<p><a href="https://files.pythonhosted.org/packages/8f/6d/fb8ebcbbaee68b172ce3dfd08c7b8660d09f91d8d5411298bcacbd309f96/mysql-connector-python-8.0.13.tar.gz">https://files . python hosted . org/packages/8f/6d/fb8 ebcbaee 68 b 172 C3 DFD 08 c7b 8660d 09 f 91 d8d 5411298 bcacbd 309 f 96/MySQL-connector-python-8 . 0 . 13 . tar . gz</a>下载源代码。</p>
<p>2.提取存档文件。</p>
<p>3.打开终端(windows 的 CMD)，将当前工作目录改为源代码目录。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$  cd mysql-connector-python-<span class="number">8.0</span><span class="number">.13</span>/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4.使用参数 build 运行名为 <a href="http://setup.py">setup.py</a> 的文件。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ python setup.py build</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>5.运行以下命令来安装 mysql 连接器。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ python setup.py install</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为 python 安装 mysql 连接器需要一点时间。一旦这个过程结束，我们可以通过在 python shell 上导入 mysql 连接器来验证安装。</p>
<p><img src="/img/083f0797ba9ceb12c3ede098c2b9fb57.png" alt="Environment Setup"></p>
<p>因此，我们已经成功地在系统上安装了 python 的 mysql 连接器。</p>
<h2 id="数据库连接">数据库连接</h2>
<p>将 python 应用连接到我们的数据库有以下步骤。</p>
<ol>
<li class="lvl-4">
<p>导入 mysql.connector 模块</p>
</li>
<li class="lvl-4">
<p>创建连接对象。</p>
</li>
<li class="lvl-4">
<p>创建光标对象</p>
</li>
<li class="lvl-4">
<p>执行查询</p>
</li>
</ol>
<hr>
<h3 id="创建连接">创建连接</h3>
<p>为了在 MySQL 数据库和 python 应用之间创建连接，使用了 mysql.connector 模块的 connect()方法。</p>
<p>在方法调用中传递数据库详细信息，如主机名、用户名和数据库密码。方法返回连接对象。</p>
<p>使用 connect()的语法如下。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Connection-Object= mysql.connector.connect(host = &lt;host-name&gt; , user = &lt;username&gt; , passwd = &lt;password&gt; )</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>考虑下面的例子。</p>
<h4 id="例子-33">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#printing the connection object </span></span><br><span class="line"><span class="built_in">print</span>(myconn)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;mysql.connector.connection.MySQLConnection <span class="built_in">object</span> at <span class="number">0x7fb142edd780</span>&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，我们必须注意，如果我们想要连接到特定的数据库，我们可以在 connect()方法中指定数据库名称。</p>
<h4 id="例子-34">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>, database = <span class="string">&quot;mydb&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#printing the connection object </span></span><br><span class="line"><span class="built_in">print</span>(myconn) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;mysql.connector.connection.MySQLConnection <span class="built_in">object</span> at <span class="number">0x7ff64aa3d7b8</span>&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="创建光标对象">创建光标对象</h3>
<p>光标对象可以被定义为 Python 数据库 API 2.0 中指定的抽象。它通过与数据库的相同连接，方便我们拥有多个独立的工作环境。我们可以通过调用连接对象的“cursor”函数来创建 cursor 对象。游标对象是对数据库执行查询的一个重要方面。</p>
<p>下面给出了创建光标对象的语法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;my_cur&gt;  = conn.cursor()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="例子-35">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>, database = <span class="string">&quot;mydb&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#printing the connection object </span></span><br><span class="line"><span class="built_in">print</span>(myconn) </span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cur)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;mysql.connector.connection.MySQLConnection <span class="built_in">object</span> at <span class="number">0x7faa17a15748</span>&gt; </span><br><span class="line">MySQLCursor: (Nothing executed yet)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="创建新数据库">创建新数据库</h2>
<h3 id="获取现有数据库的列表">获取现有数据库的列表</h3>
<p>我们可以通过使用下面的 MySQL 查询获得所有数据库的列表。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;  show databases;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="例子-36">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    dbs = cur.execute(<span class="string">&quot;show databases&quot;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> cur:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;EmployeeDB&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;Test&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;TestDB&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;information_schema&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;javatpoint&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;javatpoint1&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;mydb&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;mysql&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;performance_schema&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;testDB&#x27;</span>,)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="创建新数据库-2">创建新数据库</h3>
<p>可以使用以下 SQL 查询创建新数据库。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;  create database &lt;database-name&gt;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="例子-37">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#creating a new database</span></span><br><span class="line">    cur.execute(<span class="string">&quot;create database PythonDB2&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#getting the list of all the databases which will now include the new database PythonDB</span></span><br><span class="line">    dbs = cur.execute(<span class="string">&quot;show databases&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> cur:</span><br><span class="line">        <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;EmployeeDB&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;PythonDB&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;Test&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;TestDB&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;anshika&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;information_schema&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;javatpoint&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;javatpoint1&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;mydb&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;mydb1&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;mysql&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;performance_schema&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;testDB&#x27;</span>,)</span><br></pre></td></tr></table></figure>
<h2 id="创建表-2">创建表</h2>
<p>在教程的这一部分中，我们将创建新的表 Employee。我们必须在建立连接对象时提到数据库名称。</p>
<p>我们可以使用 SQL 的 CREATE TABLE 语句来创建新表。在我们的数据库 PythonDB 中，Employee 表最初将有四列，即姓名、id、工资和 department_id。</p>
<p>以下查询用于创建新表“员工”。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;  create table Employee (name varchar(<span class="number">20</span>) <span class="keyword">not</span> null, <span class="built_in">id</span> <span class="built_in">int</span> primary key, salary <span class="built_in">float</span> <span class="keyword">not</span> null, Dept_Id <span class="built_in">int</span> <span class="keyword">not</span> null)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例子-38">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#Creating a table with name Employee having four columns i.e., name, id, salary, and department id</span></span><br><span class="line">    dbs = cur.execute(<span class="string">&quot;create table Employee(name varchar(20) not null, id int(20) not null primary key, salary float not null, Dept_id int not null)&quot;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/c30547e8ba0cf5d1e626271c47116e06.png" alt="Creating table"></p>
<p>现在，我们可以检查数据库中是否存在雇员表。</p>
<h3 id="更改表">更改表</h3>
<p>有时，我们可能会忘记创建一些列，或者我们可能需要更新表模式。如果需要，alter 语句用于更改表架构。在这里，我们将把列 branch_name 添加到表 Employee 中。以下 SQL 查询用于此目的。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">alter table Employee add branch_name varchar(<span class="number">20</span>) <span class="keyword">not</span> null</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>考虑下面的例子。</p>
<h4 id="例子-39">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#adding a column branch name to the table Employee</span></span><br><span class="line">    cur.execute(<span class="string">&quot;alter table Employee add branch_name varchar(20) not null&quot;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/d8598d4a08bc5c8a614636f212cfaa4c.png" alt="Creating the table"></p>
<h2 id="插入操作">插入操作</h2>
<h3 id="向表中添加记录">向表中添加记录</h3>
<p><strong>INSERT INTO</strong> 语句用于向表中添加一条记录。在 python 中，我们可以用格式说明符(%s)代替值。</p>
<p>我们在游标的 execute()方法中以元组的形式提供实际值。</p>
<p>考虑下面的例子。</p>
<h4 id="例子-40">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line">sql = <span class="string">&quot;insert into Employee(name, id, salary, dept_id, branch_name) values (%s, %s, %s, %s, %s)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#The row values are provided in the form of tuple </span></span><br><span class="line">val = (<span class="string">&quot;John&quot;</span>, <span class="number">110</span>, <span class="number">25000.00</span>, <span class="number">201</span>, <span class="string">&quot;Newyork&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#inserting the values into the table</span></span><br><span class="line">    cur.execute(sql,val)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#commit the transaction </span></span><br><span class="line">    myconn.commit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cur.rowcount,<span class="string">&quot;record inserted!&quot;</span>)</span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> record inserted!</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/b8ab14d98505f34fba8b08b3be886acd.png" alt="Insert Operation"></p>
<hr>
<h3 id="插入多行">插入多行</h3>
<p>我们还可以使用 python 脚本一次插入多行。多行被称为各种元组的列表。</p>
<p>列表的每个元素被视为一个特定的行，而元组的每个元素被视为一个特定的列值(属性)。</p>
<p>考虑下面的例子。</p>
<h4 id="例子-41">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line">sql = <span class="string">&quot;insert into Employee(name, id, salary, dept_id, branch_name) values (%s, %s, %s, %s, %s)&quot;</span></span><br><span class="line">val = [(<span class="string">&quot;John&quot;</span>, <span class="number">102</span>, <span class="number">25000.00</span>, <span class="number">201</span>, <span class="string">&quot;Newyork&quot;</span>),(<span class="string">&quot;David&quot;</span>,<span class="number">103</span>,<span class="number">25000.00</span>,<span class="number">202</span>,<span class="string">&quot;Port of spain&quot;</span>),(<span class="string">&quot;Nick&quot;</span>,<span class="number">104</span>,<span class="number">90000.00</span>,<span class="number">201</span>,<span class="string">&quot;Newyork&quot;</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#inserting the values into the table</span></span><br><span class="line">    cur.executemany(sql,val)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#commit the transaction </span></span><br><span class="line">    myconn.commit()</span><br><span class="line">    <span class="built_in">print</span>(cur.rowcount,<span class="string">&quot;records inserted!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> records inserted! </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/785a85c85699bfe41b9ba3818386cfc0.png" alt="Insert Operation"></p>
<hr>
<h3 id="行标识">行标识</h3>
<p>在 SQL 中，一个特定的行由一个插入 id 来表示，该 id 被称为行 id。我们可以通过使用 cursor 对象的属性 lastrowid 来获取最后插入的行 id。</p>
<p>考虑下面的例子。</p>
<h4 id="例子-42">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line">sql = <span class="string">&quot;insert into Employee(name, id, salary, dept_id, branch_name) values (%s, %s, %s, %s, %s)&quot;</span></span><br><span class="line"></span><br><span class="line">val = (<span class="string">&quot;Mike&quot;</span>,<span class="number">105</span>,<span class="number">28000</span>,<span class="number">202</span>,<span class="string">&quot;Guyana&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#inserting the values into the table</span></span><br><span class="line">    cur.execute(sql,val)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#commit the transaction </span></span><br><span class="line">    myconn.commit()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#getting rowid</span></span><br><span class="line">    <span class="built_in">print</span>(cur.rowcount,<span class="string">&quot;record inserted! id:&quot;</span>,cur.lastrowid)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> record inserted! Id: <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="读取操作">读取操作</h2>
<p>SELECT 语句用于从数据库中读取值。我们可以通过在 SQL 中使用各种子句来限制选择查询的输出，如 where、limit 等。</p>
<p>Python 提供的 fetchall()方法以行的形式返回存储在表中的数据。我们可以迭代结果来获得单个行。</p>
<p>在教程的这一部分，我们将使用 python 脚本从数据库中提取数据。我们还将格式化输出，将其打印在控制台上。</p>
<h3 id="例子-43">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#Reading the Employee data    </span></span><br><span class="line">    cur.execute(<span class="string">&quot;select * from Employee&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#fetching the rows from the cursor object</span></span><br><span class="line">    result = cur.fetchall()</span><br><span class="line">    <span class="comment">#printing the result</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> result:</span><br><span class="line">        <span class="built_in">print</span>(x);</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;John&#x27;</span>, <span class="number">101</span>, <span class="number">25000.0</span>, <span class="number">201</span>, <span class="string">&#x27;Newyork&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;John&#x27;</span>, <span class="number">102</span>, <span class="number">25000.0</span>, <span class="number">201</span>, <span class="string">&#x27;Newyork&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;David&#x27;</span>, <span class="number">103</span>, <span class="number">25000.0</span>, <span class="number">202</span>, <span class="string">&#x27;Port of spain&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;Nick&#x27;</span>, <span class="number">104</span>, <span class="number">90000.0</span>, <span class="number">201</span>, <span class="string">&#x27;Newyork&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;Mike&#x27;</span>, <span class="number">105</span>, <span class="number">28000.0</span>, <span class="number">202</span>, <span class="string">&#x27;Guyana&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="读取特定列">读取特定列</h3>
<p>我们可以通过提及特定列的名称来阅读它们，而不是使用星号(*)。</p>
<p>在下面的示例中，我们将从 Employee 表中读取姓名、id 和工资，并将其打印在控制台上。</p>
<h4 id="例子-44">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#Reading the Employee data    </span></span><br><span class="line">    cur.execute(<span class="string">&quot;select name, id, salary from Employee&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#fetching the rows from the cursor object</span></span><br><span class="line">    result = cur.fetchall()</span><br><span class="line">    <span class="comment">#printing the result</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> result:</span><br><span class="line">        <span class="built_in">print</span>(x);</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;John&#x27;</span>, <span class="number">101</span>, <span class="number">25000.0</span>)</span><br><span class="line">(<span class="string">&#x27;John&#x27;</span>, <span class="number">102</span>, <span class="number">25000.0</span>)</span><br><span class="line">(<span class="string">&#x27;David&#x27;</span>, <span class="number">103</span>, <span class="number">25000.0</span>)</span><br><span class="line">(<span class="string">&#x27;Nick&#x27;</span>, <span class="number">104</span>, <span class="number">90000.0</span>)</span><br><span class="line">(<span class="string">&#x27;Mike&#x27;</span>, <span class="number">105</span>, <span class="number">28000.0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="fetchone-方法">fetchone()方法</h3>
<p>fetchone()方法仅用于从表中获取一行。fetchone()方法返回结果集的下一行。</p>
<p>考虑下面的例子。</p>
<h4 id="例子-45">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#Reading the Employee data    </span></span><br><span class="line">    cur.execute(<span class="string">&quot;select name, id, salary from Employee&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#fetching the first row from the cursor object</span></span><br><span class="line">    result = cur.fetchone()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#printing the result</span></span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;John&#x27;</span>, <span class="number">101</span>, <span class="number">25000.0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="格式化结果">格式化结果</h3>
<p>我们可以通过迭代游标对象的 fetchall()或 fetchone()方法产生的结果来格式化结果，因为结果作为不可读的元组对象存在。</p>
<p>考虑下面的例子。</p>
<h4 id="例子-46">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">#Reading the Employee data    </span></span><br><span class="line">    cur.execute(<span class="string">&quot;select name, id, salary from Employee&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#fetching the rows from the cursor object</span></span><br><span class="line">    result = cur.fetchall()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Name    id    Salary&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> result:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s    %d    %d&quot;</span>%(row[<span class="number">0</span>],row[<span class="number">1</span>],row[<span class="number">2</span>]))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Name    <span class="built_in">id</span>    Salary</span><br><span class="line">John    <span class="number">101</span>    <span class="number">25000</span></span><br><span class="line">John    <span class="number">102</span>    <span class="number">25000</span></span><br><span class="line">David    <span class="number">103</span>    <span class="number">25000</span></span><br><span class="line">Nick    <span class="number">104</span>    <span class="number">90000</span></span><br><span class="line">Mike    <span class="number">105</span>    <span class="number">28000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="使用-where-子句">使用 where 子句</h3>
<p>我们可以使用 where 子句来限制 select 语句产生的结果。这将只提取那些满足 where 条件的列。</p>
<p>考虑下面的例子。</p>
<h4 id="示例-打印以-j-开头的名称">示例:打印以 j 开头的名称</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#Reading the Employee data    </span></span><br><span class="line">    cur.execute(<span class="string">&quot;select name, id, salary from Employee where name like &#x27;J%&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#fetching the rows from the cursor object</span></span><br><span class="line">    result = cur.fetchall()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Name    id    Salary&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> result:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s    %d    %d&quot;</span>%(row[<span class="number">0</span>],row[<span class="number">1</span>],row[<span class="number">2</span>]))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Name    <span class="built_in">id</span>    Salary</span><br><span class="line">John    <span class="number">101</span>    <span class="number">25000</span></span><br><span class="line">John    <span class="number">102</span>    <span class="number">25000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="示例-打印-id-101、102-和-103-的名称">示例:打印 id = 101、102 和 103 的名称</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#Reading the Employee data    </span></span><br><span class="line">    cur.execute(<span class="string">&quot;select name, id, salary from Employee where id in (101,102,103)&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#fetching the rows from the cursor object</span></span><br><span class="line">    result = cur.fetchall()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Name    id    Salary&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> result:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s    %d    %d&quot;</span>%(row[<span class="number">0</span>],row[<span class="number">1</span>],row[<span class="number">2</span>]))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Name    <span class="built_in">id</span>    Salary</span><br><span class="line">John    <span class="number">101</span>    <span class="number">25000</span></span><br><span class="line">John    <span class="number">102</span>    <span class="number">25000</span></span><br><span class="line">David    <span class="number">103</span>    <span class="number">2500</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="排序结果">排序结果</h3>
<p>ORDER BY 子句用于排序结果。考虑下面的例子。</p>
<h4 id="例子-47">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#Reading the Employee data    </span></span><br><span class="line">    cur.execute(<span class="string">&quot;select name, id, salary from Employee order by name&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#fetching the rows from the cursor object</span></span><br><span class="line">    result = cur.fetchall()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Name    id    Salary&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> result:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s    %d    %d&quot;</span>%(row[<span class="number">0</span>],row[<span class="number">1</span>],row[<span class="number">2</span>]))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Name    <span class="built_in">id</span>    Salary</span><br><span class="line">David   <span class="number">103</span>    <span class="number">25000</span></span><br><span class="line">John    <span class="number">101</span>    <span class="number">25000</span></span><br><span class="line">John    <span class="number">102</span>    <span class="number">25000</span></span><br><span class="line">Mike    <span class="number">105</span>    <span class="number">28000</span></span><br><span class="line">Nick    <span class="number">104</span>    <span class="number">90000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="DESC-的命令">DESC 的命令</h3>
<p>这将按特定列的降序排序结果。</p>
<h4 id="例子-48">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#Reading the Employee data    </span></span><br><span class="line">    cur.execute(<span class="string">&quot;select name, id, salary from Employee order by name desc&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#fetching the rows from the cursor object</span></span><br><span class="line">    result = cur.fetchall()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#printing the result</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Name    id    Salary&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> result:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s    %d    %d&quot;</span>%(row[<span class="number">0</span>],row[<span class="number">1</span>],row[<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Name    <span class="built_in">id</span>    Salary</span><br><span class="line">Nick    <span class="number">104</span>    <span class="number">90000</span></span><br><span class="line">Mike    <span class="number">105</span>    <span class="number">28000</span></span><br><span class="line">John    <span class="number">101</span>    <span class="number">25000</span></span><br><span class="line">John    <span class="number">102</span>    <span class="number">25000</span></span><br><span class="line">David    <span class="number">103</span>    <span class="number">25000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="更新操作">更新操作</h2>
<p>UPDATE-SET 语句用于更新表中的任何列。以下 SQL 查询用于更新列。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;  update Employee <span class="built_in">set</span> name = <span class="string">&#x27;alex&#x27;</span> where <span class="built_in">id</span> = <span class="number">110</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>考虑下面的例子。</p>
<h3 id="例子-49">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#updating the name of the employee whose id is 110</span></span><br><span class="line">    cur.execute(<span class="string">&quot;update Employee set name = &#x27;alex&#x27; where id = 110&quot;</span>)</span><br><span class="line">    myconn.commit()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"></span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/c643f3f52fdcfd1ba2dfb5ab0df49823.png" alt="Update Operation"></p>
<hr>
<h3 id="删除操作">删除操作</h3>
<p>DELETE FROM 语句用于从表中删除特定记录。这里，我们必须使用 WHERE 子句强加一个条件，否则表中的所有记录都将被删除。</p>
<p>以下 SQL 查询用于从表中删除 id 为 110 的员工详细信息。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;  delete <span class="keyword">from</span> Employee where <span class="built_in">id</span> = <span class="number">110</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>考虑下面的例子。</p>
<h4 id="例子-50">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#Deleting the employee details whose id is 110</span></span><br><span class="line">    cur.execute(<span class="string">&quot;delete from Employee where id = 110&quot;</span>)</span><br><span class="line">    myconn.commit()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"></span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="连接操作">连接操作</h2>
<p>我们可以通过使用 join 语句在两个或多个表中使用一些公共列来组合它们。</p>
<p>我们的数据库中只有一个表，让我们用两列 department _ id 和 department_name 再创建一个 Departments 表。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">create table Departments (Dept_id <span class="built_in">int</span>(<span class="number">20</span>) primary key <span class="keyword">not</span> null, Dept_Name varchar(<span class="number">20</span>) <span class="keyword">not</span> null);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/5f85a3be9e4f39b417a671195807d75d.png" alt="Join Operation"></p>
<p>因为我们已经创建了一个新的表 Departments，如上图所示。然而，我们还没有在其中插入任何值。</p>
<p>让我们插入一些部门 id 和部门名称，以便将其映射到我们的员工表。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">insert into Departments values (<span class="number">201</span>, <span class="string">&quot;CS&quot;</span>);</span><br><span class="line">insert into Departments values (<span class="number">202</span>, <span class="string">&quot;IT&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>让我们看看每个表中插入的值。请看下图。</p>
<p><img src="/img/ae533e74525b952342ab1660ca5c6af1.png" alt="Join Operation"></p>
<p>现在，让我们创建一个 python 脚本，将公共列(即 dept_id)上的两个表连接起来。</p>
<h3 id="例子-51">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#joining the two tables on departments_id</span></span><br><span class="line">    cur.execute(<span class="string">&quot;select Employee.id, Employee.name, Employee.salary, Departments.Dept_id, Departments.Dept_Name from Departments join Employee on Departments.Dept_id = Employee.Dept_id&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ID    Name    Salary    Dept_Id    Dept_Name&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> cur:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%d    %s    %d    %d    %s&quot;</span>%(row[<span class="number">0</span>], row[<span class="number">1</span>],row[<span class="number">2</span>],row[<span class="number">3</span>],row[<span class="number">4</span>]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ID    Name    Salary    Dept_Id    Dept_Name</span><br><span class="line"><span class="number">101</span>   John    <span class="number">25000</span>    	<span class="number">201</span>    		CS</span><br><span class="line"><span class="number">102</span>   John    <span class="number">25000</span>    	<span class="number">201</span>    		CS</span><br><span class="line"><span class="number">103</span>   David   <span class="number">25000</span>       <span class="number">202</span>    		IT</span><br><span class="line"><span class="number">104</span>   Nick    <span class="number">90000</span>   	<span class="number">201</span>    		CS</span><br><span class="line"><span class="number">105</span>   Mike    <span class="number">28000</span>   	<span class="number">202</span>   		IT</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="右连接">右连接</h3>
<p>右连接显示右侧表的所有列，因为我们在数据库 PythonDB 中有两个表，即 Departments 和 Employee。表中没有任何员工不在任何部门工作(部门标识为空的员工)。然而，为了理解右连接的概念，让我们创建一个。</p>
<p>在 MySQL 服务器上执行以下查询。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">insert into Employee(name, <span class="built_in">id</span>, salary, branch_name) values (<span class="string">&quot;Alex&quot;</span>,<span class="number">108</span>,<span class="number">29900</span>,<span class="string">&quot;Mumbai&quot;</span>); </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这将插入一个不在任何部门工作的员工 Alex(部门 id 为空)。</p>
<p>现在，我们在“员工”表中有一名员工，其部门 id 不在“部门”表中。现在让我们在两个表上执行正确的连接。</p>
<h4 id="例子-52">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#joining the two tables on departments_id</span></span><br><span class="line">    result = cur.execute(<span class="string">&quot;select Employee.id, Employee.name, Employee.salary, Departments.Dept_id, Departments.Dept_Name from Departments right join Employee on Departments.Dept_id = Employee.Dept_id&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;ID    Name    Salary    Dept_Id    Dept_Name&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> row <span class="keyword">in</span> cur:</span><br><span class="line">        <span class="built_in">print</span>(row[<span class="number">0</span>],<span class="string">&quot;    &quot;</span>, row[<span class="number">1</span>],<span class="string">&quot;    &quot;</span>,row[<span class="number">2</span>],<span class="string">&quot;    &quot;</span>,row[<span class="number">3</span>],<span class="string">&quot;    &quot;</span>,row[<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ID    Name    Salary    Dept_Id    Dept_Name</span><br><span class="line"><span class="number">101</span>      John      <span class="number">25000.0</span>      <span class="number">201</span>      CS</span><br><span class="line"><span class="number">102</span>      John      <span class="number">25000.0</span>      <span class="number">201</span>      CS</span><br><span class="line"><span class="number">103</span>      David      <span class="number">25000.0</span>      <span class="number">202</span>      IT</span><br><span class="line"><span class="number">104</span>      Nick      <span class="number">90000.0</span>      <span class="number">201</span>      CS</span><br><span class="line"><span class="number">105</span>      Mike      <span class="number">28000.0</span>      <span class="number">202</span>      IT</span><br><span class="line"><span class="number">108</span>      Alex      <span class="number">29900.0</span>      <span class="literal">None</span>      <span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="左连接">左连接</h3>
<p>左连接包含左侧表中的所有数据。它对右连接的效果正好相反。考虑下面的例子。</p>
<h4 id="例子-53">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#joining the two tables on departments_id</span></span><br><span class="line">    result = cur.execute(<span class="string">&quot;select Employee.id, Employee.name, Employee.salary, Departments.Dept_id, Departments.Dept_Name from Departments left join Employee on Departments.Dept_id = Employee.Dept_id&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ID    Name    Salary    Dept_Id    Dept_Name&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> cur:</span><br><span class="line">        <span class="built_in">print</span>(row[<span class="number">0</span>],<span class="string">&quot;    &quot;</span>, row[<span class="number">1</span>],<span class="string">&quot;    &quot;</span>,row[<span class="number">2</span>],<span class="string">&quot;    &quot;</span>,row[<span class="number">3</span>],<span class="string">&quot;    &quot;</span>,row[<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ID    Name    Salary    Dept_Id    Dept_Name</span><br><span class="line"><span class="number">101</span>      John      <span class="number">25000.0</span>      <span class="number">201</span>      CS</span><br><span class="line"><span class="number">102</span>      John      <span class="number">25000.0</span>      <span class="number">201</span>      CS</span><br><span class="line"><span class="number">103</span>      David      <span class="number">25000.0</span>      <span class="number">202</span>      IT</span><br><span class="line"><span class="number">104</span>      Nick      <span class="number">90000.0</span>      <span class="number">201</span>      CS</span><br><span class="line"><span class="number">105</span>      Mike      <span class="number">28000.0</span>      <span class="number">202</span>      IT</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="执行事务">执行事务</h2>
<p>事务确保数据库的数据一致性。我们必须确保在执行数据库操作时，不能有多个应用修改记录。这些事务具有以下属性。</p>
<ol>
<li class="lvl-4">
<p><strong>原子性</strong><br>
要么事务完成，要么什么都没发生。如果一个事务包含 4 个查询，那么所有这些查询都必须执行，或者都不执行。</p>
</li>
<li class="lvl-4">
<p><strong>一致性</strong><br>
事务开始前数据库必须一致，事务完成后数据库也必须一致。</p>
</li>
<li class="lvl-4">
<p><strong>隔离</strong><br>
事务的中间结果在当前事务之外不可见。</p>
</li>
<li class="lvl-4">
<p><strong>持久性</strong><br>
一旦事务被提交，即使在系统故障后，其影响也是持久的。</p>
</li>
</ol>
<hr>
<h3 id="Python-commit-方法">Python commit()方法</h3>
<p>Python 提供了 commit()方法，确保对</p>
<p>数据库不断地发生变化。</p>
<p>下面给出了使用 commit()方法的语法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">conn.commit() <span class="comment">#conn is the connection object </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在调用 commit()之前，修改数据库记录的所有操作都不会发生。</p>
<hr>
<h3 id="Python-rollback-方法">Python rollback()方法</h3>
<p>rollback()方法用于恢复对数据库所做的更改。这种方法很有用，因为如果在数据库操作过程中发生了一些错误，我们可以回滚该事务以保持数据库的一致性。</p>
<p>使用 rollback()的语法如下。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Conn.rollback()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="关闭连接">关闭连接</h3>
<p>一旦我们完成了所有关于数据库的操作，我们就需要关闭数据库连接。Python 提供了 close()方法。下面给出了使用 close()方法的语法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">conn.close() </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在下面的示例中，我们删除了所有在 CS 部门工作的员工。</p>
<h4 id="例子-54">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cur.execute(<span class="string">&quot;delete from Employee where Dept_id = 201&quot;</span>)</span><br><span class="line">    myconn.commit()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Deleted !&quot;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Can&#x27;t delete !&quot;</span>)</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Deleted !</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
        <category>python 数据库</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
