<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java 8 并发教程：原子变量和 ConcurrentMap</title>
    <url>/posts/4121201d.html</url>
    <content><![CDATA[<ul class="lvl-0">
<li class="lvl-2">
<p>第一部分：<a href="/posts/7e39f321.html">线程和执行器</a></p>
</li>
<li class="lvl-2">
<p>第二部分：<a href="/posts/4c4d17bf.html">同步和锁</a></p>
</li>
<li class="lvl-2">
<p>第三部分：<a href="/posts/4121201d.html">原子变量和 ConcurrentMap</a></p>
</li>
</ul>
<h2 id="AtomicInteger"><code>AtomicInteger</code></h2>
<p><code>java.concurrent.atomic</code>包包含了许多实用的类，用于执行原子操作。如果你能够在多线程中同时且安全地执行某个操作，而不需要<code>synchronized</code>关键字或<a href="/posts/4c4d17bf.html">上一章</a>中的锁，那么这个操作就是原子的。</p>
<p>本质上，原子操作严重依赖于比较与交换（CAS），它是由多数现代CPU直接支持的原子指令。这些指令通常比同步块要快。所以在只需要并发修改单个可变变量的情况下，我建议你优先使用原子类，而不是<a href="/posts/4c4d17bf.html">上一章</a>展示的锁。</p>
<blockquote>
<p>译者注：对于其它语言，一些语言的原子操作用锁实现，而不是原子指令。</p>
</blockquote>
<p>现在让我们选取一个原子类，例如<code>AtomicInteger</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">atomicInt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">1000</span>)</span><br><span class="line">    .forEach(i -&gt; executor.submit(atomicInt::incrementAndGet));</span><br><span class="line"></span><br><span class="line">stop(executor);</span><br><span class="line"></span><br><span class="line">System.out.println(atomicInt.get());    <span class="comment">// =&gt; 1000</span></span><br></pre></td></tr></table></figure>
<p>通过使用<code>AtomicInteger</code>代替<code>Integer</code>，我们就能线程安全地并发增加数值，而不需要同步访问变量。<code>incrementAndGet()</code>方法是原子操作，所以我们可以在多个线程中安全调用它。</p>
<p><code>AtomicInteger</code>支持多种原子操作。<code>updateAndGet()</code>接受lambda表达式，以便在整数上执行任意操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">atomicInt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">1000</span>)</span><br><span class="line">    .forEach(i -&gt; &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt;</span><br><span class="line">            atomicInt.updateAndGet(n -&gt; n + <span class="number">2</span>);</span><br><span class="line">        executor.submit(task);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">stop(executor);</span><br><span class="line"></span><br><span class="line">System.out.println(atomicInt.get());    <span class="comment">// =&gt; 2000</span></span><br></pre></td></tr></table></figure>
<p><code>accumulateAndGet()</code>方法接受另一种类型<code>IntBinaryOperator</code>的lambda表达式。我们在下个例子中，使用这个方法并发计算0~1000所有值的和：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">atomicInt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">1000</span>)</span><br><span class="line">    .forEach(i -&gt; &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt;</span><br><span class="line">            atomicInt.accumulateAndGet(i, (n, m) -&gt; n + m);</span><br><span class="line">        executor.submit(task);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">stop(executor);</span><br><span class="line"></span><br><span class="line">System.out.println(atomicInt.get());    <span class="comment">// =&gt; 499500</span></span><br></pre></td></tr></table></figure>
<p>其它实用的原子类有<code>AtomicBoolean</code>、<code>AtomicLong</code> 和 <code>AtomicReference</code>。</p>
<h2 id="LongAdder"><code>LongAdder</code></h2>
<p><code>LongAdder</code>是<code>AtomicLong</code>的替代，用于向某个数值连续添加值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">1000</span>)</span><br><span class="line">    .forEach(i -&gt; executor.submit(adder::increment));</span><br><span class="line"></span><br><span class="line">stop(executor);</span><br><span class="line"></span><br><span class="line">System.out.println(adder.sumThenReset());   <span class="comment">// =&gt; 1000</span></span><br></pre></td></tr></table></figure>
<p><code>LongAdder</code>提供了<code>add()</code>和<code>increment()</code>方法，就像原子数值类一样，同样是线程安全的。但是这个类在内部维护一系列变量来减少线程之间的争用，而不是求和计算单一结果。实际的结果可以通过调用<code>sum()</code>或<code>sumThenReset()</code>来获取。</p>
<p>当多线程的更新比读取更频繁时，这个类通常比原子数值类性能更好。这种情况在抓取统计数据时经常出现，例如，你希望统计Web服务器上请求的数量。<code>LongAdder</code>缺点是较高的内存开销，因为它在内存中储存了一系列变量。</p>
<h2 id="LongAccumulator"><code>LongAccumulator</code></h2>
<p><code>LongAccumulator</code>是<code>LongAdder</code>的更通用的版本。<code>LongAccumulator</code>以类型为<code>LongBinaryOperator</code>lambda表达式构建，而不是仅仅执行加法操作，像这段代码展示的那样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LongBinaryOperator</span> <span class="variable">op</span> <span class="operator">=</span> (x, y) -&gt; <span class="number">2</span> * x + y;</span><br><span class="line"><span class="type">LongAccumulator</span> <span class="variable">accumulator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAccumulator</span>(op, <span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">    .forEach(i -&gt; executor.submit(() -&gt; accumulator.accumulate(i)));</span><br><span class="line"></span><br><span class="line">stop(executor);</span><br><span class="line"></span><br><span class="line">System.out.println(accumulator.getThenReset());     <span class="comment">// =&gt; 2539</span></span><br></pre></td></tr></table></figure>
<p>我们使用函数<code>2 * x + y</code>创建了<code>LongAccumulator</code>，初始值为1。每次调用<code>accumulate(i)</code>的时候，当前结果和值<code>i</code>都会作为参数传入lambda表达式。</p>
<p><code>LongAccumulator</code>就像<code>LongAdder</code>那样，在内部维护一系列变量来减少线程之间的争用。</p>
<h2 id="ConcurrentMap"><code>ConcurrentMap</code></h2>
<p><code>ConcurrentMap</code>接口继承自<code>Map</code>接口，并定义了最实用的并发集合类型之一。Java8通过将新的方法添加到这个接口，引入了函数式编程。</p>
<p>在下面的代码中，我们使用这个映射示例来展示那些新的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConcurrentMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;han&quot;</span>, <span class="string">&quot;solo&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;r2&quot;</span>, <span class="string">&quot;d2&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;c3&quot;</span>, <span class="string">&quot;p0&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>forEach()</code>方法接受类型为<code>BiConsumer</code>的lambda表达式，以映射的键和值作为参数传递。它可以作为<code>for-each</code>循环的替代，来遍历并发映射中的元素。迭代在当前线程上串行执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.forEach((key, value) -&gt; System.out.printf(<span class="string">&quot;%s = %s\n&quot;</span>, key, value));</span><br></pre></td></tr></table></figure>
<p>新方法<code>putIfAbsent()</code>只在提供的键不存在时，将新的值添加到映射中。至少在<code>ConcurrentHashMap</code>的实现中，这一方法像<code>put()</code>一样是线程安全的，所以你在不同线程中并发访问映射时，不需要任何同步机制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.putIfAbsent(<span class="string">&quot;c3&quot;</span>, <span class="string">&quot;p1&quot;</span>);</span><br><span class="line">System.out.println(value);    <span class="comment">// p0</span></span><br></pre></td></tr></table></figure>
<p><code>getOrDefault()</code>方法返回指定键的值。在传入的键不存在时，会返回默认值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.getOrDefault(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;there&quot;</span>);</span><br><span class="line">System.out.println(value);    <span class="comment">// there</span></span><br></pre></td></tr></table></figure>
<p><code>replaceAll()</code>接受类型为<code>BiFunction</code>的lambda表达式。<code>BiFunction</code>接受两个参数并返回一个值。函数在这里以每个元素的键和值调用，并返回要映射到当前键的新值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.replaceAll((key, value) -&gt; <span class="string">&quot;r2&quot;</span>.equals(key) ? <span class="string">&quot;d3&quot;</span> : value);</span><br><span class="line">System.out.println(map.get(<span class="string">&quot;r2&quot;</span>));    <span class="comment">// d3</span></span><br></pre></td></tr></table></figure>
<p><code>compute()</code>允许我们转换单个元素，而不是替换映射中的所有值。这个方法接受需要处理的键，和用于指定值的转换的<code>BiFunction</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.compute(<span class="string">&quot;foo&quot;</span>, (key, value) -&gt; value + value);</span><br><span class="line">System.out.println(map.get(<span class="string">&quot;foo&quot;</span>));   <span class="comment">// barbar</span></span><br></pre></td></tr></table></figure>
<p>除了<code>compute()</code>之外还有两个变体：<code>computeIfAbsent()</code> 和 <code>computeIfPresent()</code>。这些方法的函数式参数只在键不存在或存在时被调用。</p>
<p>最后，<code>merge()</code>方法可以用于以映射中的现有值来统一新的值。这个方法接受键、需要并入现有元素的新值，以及指定两个值的合并行为的<code>BiFunction</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.merge(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;boo&quot;</span>, (oldVal, newVal) -&gt; newVal + <span class="string">&quot; was &quot;</span> + oldVal);</span><br><span class="line">System.out.println(map.get(<span class="string">&quot;foo&quot;</span>));   <span class="comment">// boo was foo</span></span><br></pre></td></tr></table></figure>
<h2 id="ConcurrentHashMap"><code>ConcurrentHashMap</code></h2>
<p>所有这些方法都是<code>ConcurrentMap</code>接口的一部分，因此可在所有该接口的实现上调用。此外，最重要的实现<code>ConcurrentHashMap</code>使用了一些新的方法来改进，便于在映射上执行并行操作。</p>
<p>就像并行流那样，这些方法使用特定的<code>ForkJoinPool</code>，由Java8中的<code>ForkJoinPool.commonPool()</code>提供。该池使用了取决于可用核心数量的预置并行机制。我的电脑有四个核心可用，这会使并行性的结果为3：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(ForkJoinPool.getCommonPoolParallelism());  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>这个值可以通过设置下列JVM参数来增减：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Djava.util.concurrent.ForkJoinPool.common.parallelism=5</span><br></pre></td></tr></table></figure>
<p>我们使用相同的映射示例来展示，但是这次我们使用具体的<code>ConcurrentHashMap</code>实现而不是<code>ConcurrentMap</code>接口，所以我们可以访问这个类的所有公共方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;han&quot;</span>, <span class="string">&quot;solo&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;r2&quot;</span>, <span class="string">&quot;d2&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;c3&quot;</span>, <span class="string">&quot;p0&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>Java8引入了三种类型的并行操作：<code>forEach</code>、<code>search</code> 和 <code>reduce</code>。这些操作中每个都以四种形式提供，接受以键、值、元素或键值对为参数的函数。</p>
<p>所有这些方法的第一个参数是通用的<code>parallelismThreshold</code>。这一阈值表示操作并行执行时的最小集合大小。例如，如果你传入阈值500，而映射的实际大小是499，那么操作就会在单线程上串行执行。在下一个例子中，我们使用阈值1，始终强制并行执行来展示。</p>
<h3 id="forEach"><code>forEach</code></h3>
<p><code>forEach()</code>方法可以并行迭代映射中的键值对。<code>BiConsumer</code>以当前迭代元素的键和值调用。为了将并行执行可视化，我们向控制台打印了当前线程的名称。要注意在我这里底层的<code>ForkJoinPool</code>最多使用三个线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.forEach(<span class="number">1</span>, (key, value) -&gt;</span><br><span class="line">    System.out.printf(<span class="string">&quot;key: %s; value: %s; thread: %s\n&quot;</span>,</span><br><span class="line">        key, value, Thread.currentThread().getName()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// key: r2; value: d2; thread: main</span></span><br><span class="line"><span class="comment">// key: foo; value: bar; thread: ForkJoinPool.commonPool-worker-1</span></span><br><span class="line"><span class="comment">// key: han; value: solo; thread: ForkJoinPool.commonPool-worker-2</span></span><br><span class="line"><span class="comment">// key: c3; value: p0; thread: main</span></span><br></pre></td></tr></table></figure>
<h3 id="search"><code>search</code></h3>
<p><code>search()</code>方法接受<code>BiFunction</code>并为当前的键值对返回一个非空的搜索结果，或者在当前迭代不匹配任何搜索条件时返回<code>null</code>。只要返回了非空的结果，就不会往下搜索了。要记住<code>ConcurrentHashMap</code>是无序的。搜索函数应该不依赖于映射实际的处理顺序。如果映射的多个元素都满足指定搜索函数，结果是非确定的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> map.search(<span class="number">1</span>, (key, value) -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;foo&quot;</span>.equals(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ForkJoinPool.commonPool-worker-2</span></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="comment">// ForkJoinPool.commonPool-worker-3</span></span><br><span class="line"><span class="comment">// Result: bar</span></span><br></pre></td></tr></table></figure>
<p>下面是另一个例子，仅仅搜索映射中的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> map.searchValues(<span class="number">1</span>, value -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">    <span class="keyword">if</span> (value.length() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ForkJoinPool.commonPool-worker-2</span></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="comment">// ForkJoinPool.commonPool-worker-1</span></span><br><span class="line"><span class="comment">// Result: solo</span></span><br></pre></td></tr></table></figure>
<h3 id="reduce"><code>reduce</code></h3>
<p><code>reduce()</code>方法已经在Java 8 的数据流之中用过了，它接受两个<code>BiFunction</code>类型的lambda表达式。第一个函数将每个键值对转换为任意类型的单一值。第二个函数将所有这些转换后的值组合为单一结果，并忽略所有可能的<code>null</code>值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> map.reduce(<span class="number">1</span>,</span><br><span class="line">    (key, value) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Transform: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value;</span><br><span class="line">    &#125;,</span><br><span class="line">    (s1, s2) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Reduce: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> s1 + <span class="string">&quot;, &quot;</span> + s2;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Transform: ForkJoinPool.commonPool-worker-2</span></span><br><span class="line"><span class="comment">// Transform: main</span></span><br><span class="line"><span class="comment">// Transform: ForkJoinPool.commonPool-worker-3</span></span><br><span class="line"><span class="comment">// Reduce: ForkJoinPool.commonPool-worker-3</span></span><br><span class="line"><span class="comment">// Transform: main</span></span><br><span class="line"><span class="comment">// Reduce: main</span></span><br><span class="line"><span class="comment">// Reduce: main</span></span><br><span class="line"><span class="comment">// Result: r2=d2, c3=p0, han=solo, foo=bar</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="http://winterbe.com/posts/2015/04/30/java8-concurrency-tutorial-synchronized-locks-examples/">Java 8 Concurrency Tutorial: Synchronization and Locks</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java 8 并发教程：同步和锁</title>
    <url>/posts/4c4d17bf.html</url>
    <content><![CDATA[<ul class="lvl-0">
<li class="lvl-2">
<p>第一部分：<a href="/posts/7e39f321.html">线程和执行器</a></p>
</li>
<li class="lvl-2">
<p>第二部分：<a href="/posts/4c4d17bf.html">同步和锁</a></p>
</li>
<li class="lvl-2">
<p>第三部分：<a href="/posts/4121201d.html">原子变量和 ConcurrentMap</a></p>
</li>
</ul>
<h2 id="同步">同步</h2>
<p>当我们编写这种多线程代码时，我们需要特别注意共享可变变量的并发访问。假设我们打算增加某个可被多个线程同时访问的整数。</p>
<p>我们定义了<code>count</code>字段，带有<code>increment()</code>方法来使<code>count</code>加一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    count = count + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当多个线程并发调用这个方法时，我们就会遇到大麻烦：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">10000</span>)</span><br><span class="line">    .forEach(i -&gt; executor.submit(<span class="built_in">this</span>::increment));</span><br><span class="line"></span><br><span class="line">stop(executor);</span><br><span class="line"></span><br><span class="line">System.out.println(count);  <span class="comment">// 9965</span></span><br></pre></td></tr></table></figure>
<p>我们没有看到<code>count</code>为10000的结果，上面代码的实际结果在每次执行时都不同。原因是我们在不同的线程上共享可变变量，并且变量访问没有同步机制，这会产生<a href="http://en.wikipedia.org/wiki/Race_condition">竞争条件</a>。</p>
<p>增加一个数值需要三个步骤：（1）读取当前值，（2）使这个值加一，（3）将新的值写到变量。如果两个线程同时执行，就有可能出现两个线程同时执行步骤1，于是会读到相同的当前值。这会导致无效的写入，所以实际的结果会偏小。上面的例子中，对<code>count</code>的非同步并发访问丢失了35次增加操作，但是你在自己执行代码时会看到不同的结果。</p>
<p>幸运的是，Java自从很久之前就通过<code>synchronized</code>关键字支持线程同步。我们可以使用<code>synchronized</code>来修复上面在增加<code>count</code>时的竞争条件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">incrementSync</span><span class="params">()</span> &#123;</span><br><span class="line">    count = count + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们并发调用<code>incrementSync()</code>时，我们得到了<code>count</code>为10000的预期结果。没有再出现任何竞争条件，并且结果在每次代码执行中都很稳定：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">10000</span>)</span><br><span class="line">    .forEach(i -&gt; executor.submit(<span class="built_in">this</span>::incrementSync));</span><br><span class="line"></span><br><span class="line">stop(executor);</span><br><span class="line"></span><br><span class="line">System.out.println(count);  <span class="comment">// 10000</span></span><br></pre></td></tr></table></figure>
<p><code>synchronized</code>关键字也可用于语句块：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">incrementSync</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        count = count + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java在内部使用所谓的“监视器”（monitor），也称为监视器锁（monitor lock）或内在锁（ intrinsic lock）来管理同步。监视器绑定在对象上，例如，当使用同步方法时，每个方法都共享相应对象的相同监视器。</p>
<p>所有隐式的监视器都实现了重入（reentrant）特性。重入的意思是锁绑定在当前线程上。线程可以安全地多次获取相同的锁，而不会产生死锁（例如，同步方法调用相同对象的另一个同步方法）。</p>
<h2 id="锁">锁</h2>
<p>并发API支持多种显式的锁，它们由<code>Lock</code>接口规定，用于代替<code>synchronized</code>的隐式锁。锁对细粒度的控制支持多种方法，因此它们比隐式的监视器具有更大的开销。</p>
<p>锁的多个实现在标准JDK中提供，它们会在下面的章节中展示。</p>
<h3 id="ReentrantLock"><code>ReentrantLock</code></h3>
<p><code>ReentrantLock</code>类是互斥锁，与通过<code>synchronized</code>访问的隐式监视器具有相同行为，但是具有扩展功能。就像它的名称一样，这个锁实现了重入特性，就像隐式监视器一样。</p>
<p>让我们看看使用<code>ReentrantLock</code>之后的上面的例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>锁可以通过<code>lock()</code>来获取，通过<code>unlock()</code>来释放。把你的代码包装在<code>try-finally</code>代码块中来确保异常情况下的解锁非常重要。这个方法是线程安全的，就像同步副本那样。如果另一个线程已经拿到锁了，再次调用<code>lock()</code>会阻塞当前线程，直到锁被释放。在任意给定的时间内，只有一个线程可以拿到锁。</p>
<p>锁对细粒度的控制支持多种方法，就像下面的例子那样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Locked: &quot;</span> + lock.isLocked());</span><br><span class="line">    System.out.println(<span class="string">&quot;Held by me: &quot;</span> + lock.isHeldByCurrentThread());</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">locked</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">    System.out.println(<span class="string">&quot;Lock acquired: &quot;</span> + locked);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">stop(executor);</span><br></pre></td></tr></table></figure>
<p>在第一个任务拿到锁的一秒之后，第二个任务获得了锁的当前状态的不同信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Locked: true</span><br><span class="line">Held by me: false</span><br><span class="line">Lock acquired: false</span><br></pre></td></tr></table></figure>
<p><code>tryLock()</code>方法是<code>lock()</code>方法的替代，它尝试拿锁而不阻塞当前线程。在访问任何共享可变变量之前，必须使用布尔值结果来检查锁是否已经被获取。</p>
<h3 id="ReadWriteLock"><code>ReadWriteLock</code></h3>
<p><code>ReadWriteLock</code>接口规定了锁的另一种类型，包含用于读写访问的一对锁。读写锁的理念是，只要没有任何线程写入变量，并发读取可变变量通常是安全的。所以读锁可以同时被多个线程持有，只要没有线程持有写锁。这样可以提升性能和吞吐量，因为读取比写入更加频繁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    lock.writeLock().lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.writeLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的例子在暂停一秒之后，首先获取写锁来向映射添加新的值。在这个任务完成之前，两个其它的任务被启动，尝试读取映射中的元素，并暂停一秒：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">readTask</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    lock.readLock().lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.readLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">executor.submit(readTask);</span><br><span class="line">executor.submit(readTask);</span><br><span class="line"></span><br><span class="line">stop(executor);</span><br></pre></td></tr></table></figure>
<p>当你执行这一代码示例时，你会注意到两个读任务需要等待写任务完成。在释放了写锁之后，两个读任务会同时执行，并同时打印结果。它们不需要相互等待完成，因为读锁可以安全同步获取，只要没有其它线程获取了写锁。</p>
<h3 id="StampedLock"><code>StampedLock</code></h3>
<p>Java 8 自带了一种新的锁，叫做<code>StampedLock</code>，它同样支持读写锁，就像上面的例子那样。与<code>ReadWriteLock</code>不同的是，<code>StampedLock</code>的锁方法会返回表示为<code>long</code>的标记。你可以使用这些标记来释放锁，或者检查锁是否有效。此外，<code>StampedLock</code>支持另一种叫做乐观锁（optimistic locking）的模式。</p>
<p>让我们使用<code>StampedLock</code>代替<code>ReadWriteLock</code>重写上面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">StampedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlockWrite(stamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">readTask</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlockRead(stamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">executor.submit(readTask);</span><br><span class="line">executor.submit(readTask);</span><br><span class="line"></span><br><span class="line">stop(executor);</span><br></pre></td></tr></table></figure>
<p>通过<code>readLock()</code> 或 <code>writeLock()</code>来获取读锁或写锁会返回一个标记，它可以在稍后用于在<code>finally</code>块中解锁。要记住<code>StampedLock</code>并没有实现重入特性。每次调用加锁都会返回一个新的标记，并且在没有可用的锁时阻塞，即使相同线程已经拿锁了。所以你需要额外注意不要出现死锁。</p>
<p>就像前面的<code>ReadWriteLock</code>例子那样，两个读任务都需要等待写锁释放。之后两个读任务同时向控制台打印信息，因为多个读操作不会相互阻塞，只要没有线程拿到写锁。</p>
<p>下面的例子展示了乐观锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="type">StampedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Optimistic Lock Valid: &quot;</span> + lock.validate(stamp));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Optimistic Lock Valid: &quot;</span> + lock.validate(stamp));</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Optimistic Lock Valid: &quot;</span> + lock.validate(stamp));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(stamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Write Lock acquired&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(stamp);</span><br><span class="line">        System.out.println(<span class="string">&quot;Write done&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">stop(executor);</span><br></pre></td></tr></table></figure>
<p>乐观的读锁通过调用<code>tryOptimisticRead()</code>获取，它总是返回一个标记而不阻塞当前线程，无论锁是否真正可用。如果已经有写锁被拿到，返回的标记等于0。你需要总是通过<code>lock.validate(stamp)</code>检查标记是否有效。</p>
<p>执行上面的代码会产生以下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Optimistic Lock Valid: true</span><br><span class="line">Write Lock acquired</span><br><span class="line">Optimistic Lock Valid: false</span><br><span class="line">Write done</span><br><span class="line">Optimistic Lock Valid: false</span><br></pre></td></tr></table></figure>
<p>乐观锁在刚刚拿到锁之后是有效的。和普通的读锁不同的是，乐观锁不阻止其他线程同时获取写锁。在第一个线程暂停一秒之后，第二个线程拿到写锁而无需等待乐观的读锁被释放。此时，乐观的读锁就不再有效了。甚至当写锁释放时，乐观的读锁还处于无效状态。</p>
<p>所以在使用乐观锁时，你需要每次在访问任何共享可变变量之后都要检查锁，来确保读锁仍然有效。</p>
<p>有时，将读锁转换为写锁而不用再次解锁和加锁十分实用。<code>StampedLock</code>为这种目的提供了<code>tryConvertToWriteLock()</code>方法，就像下面那样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="type">StampedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            stamp = lock.tryConvertToWriteLock(stamp);</span><br><span class="line">            <span class="keyword">if</span> (stamp == <span class="number">0L</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Could not convert to write lock&quot;</span>);</span><br><span class="line">                stamp = lock.writeLock();</span><br><span class="line">            &#125;</span><br><span class="line">            count = <span class="number">23</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(stamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">stop(executor);</span><br></pre></td></tr></table></figure>
<p>第一个任务获取读锁，并向控制台打印<code>count</code>字段的当前值。但是如果当前值是零，我们希望将其赋值为<code>23</code>。我们首先需要将读锁转换为写锁，来避免打破其它线程潜在的并发访问。<code>tryConvertToWriteLock()</code>的调用不会阻塞，但是可能会返回为零的标记，表示当前没有可用的写锁。这种情况下，我们调用<code>writeLock()</code>来阻塞当前线程，直到有可用的写锁。</p>
<h2 id="信号量">信号量</h2>
<p>除了锁之外，并发API也支持计数的信号量。不过锁通常用于变量或资源的互斥访问，信号量可以维护整体的准入许可。这在一些不同场景下，例如你需要限制你程序某个部分的并发访问总数时非常实用。</p>
<p>下面是一个例子，演示了如何限制对通过<code>sleep(5)</code>模拟的长时间运行任务的访问：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">longRunningTask</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">permit</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        permit = semaphore.tryAcquire(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span> (permit) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Semaphore acquired&quot;</span>);</span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Could not acquire semaphore&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (permit) &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">    .forEach(i -&gt; executor.submit(longRunningTask));</span><br><span class="line"></span><br><span class="line">stop(executor);</span><br></pre></td></tr></table></figure>
<p>执行器可能同时运行10个任务，但是我们使用了大小为5的信号量，所以将并发访问限制为5。使用<code>try-finally</code>代码块在异常情况中合理释放信号量十分重要。</p>
<p>执行上述代码产生如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Semaphore acquired</span><br><span class="line">Semaphore acquired</span><br><span class="line">Semaphore acquired</span><br><span class="line">Semaphore acquired</span><br><span class="line">Semaphore acquired</span><br><span class="line">Could not acquire semaphore</span><br><span class="line">Could not acquire semaphore</span><br><span class="line">Could not acquire semaphore</span><br><span class="line">Could not acquire semaphore</span><br><span class="line">Could not acquire semaphore</span><br></pre></td></tr></table></figure>
<p>信号量限制对通过<code>sleep(5)</code>模拟的长时间运行任务的访问，最大5个线程。每个随后的<code>tryAcquire()</code>调用在经过最大为一秒的等待超时之后，会向控制台打印不能获取信号量的结果。</p>
<blockquote>
<p>原文：<a href="http://winterbe.com/posts/2015/04/30/java8-concurrency-tutorial-synchronized-locks-examples/">Java 8 Concurrency Tutorial: Synchronization and Locks</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java 8 并发教程：线程和执行器</title>
    <url>/posts/7e39f321.html</url>
    <content><![CDATA[<ul class="lvl-0">
<li class="lvl-2">
<p>第一部分：<a href="/posts/7e39f321.html">线程和执行器</a></p>
</li>
<li class="lvl-2">
<p>第二部分：<a href="/posts/4c4d17bf.html">同步和锁</a></p>
</li>
<li class="lvl-2">
<p>第三部分：<a href="/posts/4121201d.html">原子变量和 ConcurrentMap</a></p>
</li>
</ul>
<p>并发在Java5中首次被引入并在后续的版本中不断得到增强。在这篇文章中介绍的大部分概念同样适用于以前的Java版本。不过我的代码示例聚焦于Java8，大量使用lambda表达式和其他新特性。如果你对lambda表达式不属性，我推荐你首先阅读我的<a href="http://winterbe.com/posts/2014/03/16/java-8-tutorial/">Java 8 教程</a>。</p>
<h2 id="Thread-和-Runnable"><code>Thread</code> 和 <code>Runnable</code></h2>
<p>所有的现代操作系统都通过进程和线程来支持并发。进程是通常彼此独立运行的程序的实例，比如，如果你启动了一个Java程序，操作系统产生一个新的进程，与其他程序一起并行执行。在这些进程的内部，我们使用线程并发执行代码，因此，我们可以最大限度的利用CPU可用的核心（core）。</p>
<p>Java从JDK1.0开始执行线程。在开始一个新的线程之前，你必须指定由这个线程执行的代码，通常称为task。这可以通过实现<code>Runnable</code>——一个定义了一个无返回值无参数的<code>run()</code>方法的函数接口，如下面的代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello &quot;</span> + threadName);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">task.run();</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Done!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>因为<code>Runnable</code>是一个函数接口，所以我们利用lambda表达式将当前的线程名打印到控制台。首先，在开始一个线程前我们在主线程中直接运行runnable。</p>
<p>控制台输出的结果可能像下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello main</span><br><span class="line">Hello Thread-0</span><br><span class="line">Done!</span><br></pre></td></tr></table></figure>
<p>或者这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello main</span><br><span class="line">Done!</span><br><span class="line">Hello Thread-0</span><br></pre></td></tr></table></figure>
<p>由于我们不能预测这个runnable是在打印’done’前执行还是在之后执行。顺序是不确定的，因此在大的程序中编写并发程序是一个复杂的任务。</p>
<p>我们可以将线程休眠确定的时间。在这篇文章接下来的代码示例中我们可以通过这种方法来模拟长时间运行的任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;Foo &quot;</span> + name);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Bar &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>
<p>当你运行上面的代码时，你会注意到在第一条打印语句和第二条打印语句之间存在一分钟的延迟。<code>TimeUnit</code>在处理单位时间时一个有用的枚举类。你可以通过调用<code>Thread.sleep(1000)</code>来达到同样的目的。</p>
<p>使用<code>Thread</code>类是很单调的且容易出错。由于并发API在2004年Java5发布的时候才被引入。这些API位于<code>java.util.concurrent</code>包下，包含很多处理并发编程的有用的类。自从这些并发API引入以来，在随后的新的Java版本发布过程中得到不断的增强，甚至Java8提供了新的类和方法来处理并发。</p>
<p>接下来，让我们走进并发API中最重要的一部——executor services。</p>
<h2 id="Executor"><code>Executor</code></h2>
<p>并发API引入了<code>ExecutorService</code>作为一个在程序中直接使用Thread的高层次的替换方案。Executos支持运行异步任务，通常管理一个线程池，这样一来我们就不需要手动去创建新的线程。在不断地处理任务的过程中，线程池内部线程将会得到复用，因此，在我们可以使用一个executor service来运行和我们想在我们整个程序中执行的一样多的并发任务。</p>
<p>下面是使用executors的第一个代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">System.out.println(<span class="string">&quot;Hello &quot;</span> + threadName);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; Hello pool-1-thread-1</span></span><br></pre></td></tr></table></figure>
<p><code>Executors</code>类提供了便利的工厂方法来创建不同类型的 executor services。在这个示例中我们使用了一个单线程线程池的 executor。</p>
<p>代码运行的结果类似于上一个示例，但是当运行代码时，你会注意到一个很大的差别：Java进程从没有停止！Executors必须显式的停止-否则它们将持续监听新的任务。</p>
<p><code>ExecutorService</code>提供了两个方法来达到这个目的——<code>shutdwon()</code>会等待正在执行的任务执行完而<code>shutdownNow()</code>会终止所有正在执行的任务并立即关闭execuotr。</p>
<p>这是我喜欢的通常关闭executors的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;attempt to shutdown executor&quot;</span>);</span><br><span class="line">    executor.shutdown();</span><br><span class="line">    executor.awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;tasks interrupted&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!executor.isTerminated()) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;cancel non-finished tasks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    executor.shutdownNow();</span><br><span class="line">    System.out.println(<span class="string">&quot;shutdown finished&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>executor通过等待指定的时间让当前执行的任务终止来“温柔的”关闭executor。在等待最长5分钟的时间后，execuote最终会通过中断所有的正在执行的任务关闭。</p>
<h3 id="Callable-和-Future"><code>Callable</code> 和 <code>Future</code></h3>
<p>除了<code>Runnable</code>，executor还支持另一种类型的任务——<code>Callable</code>。Callables也是类似于runnables的函数接口，不同之处在于，Callable返回一个值。</p>
<p>下面的lambda表达式定义了一个callable：在休眠一分钟后返回一个整数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Callable&lt;Integer&gt; task = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;task interrupted&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Callbale也可以像runnbales一样提交给 executor services。但是callables的结果怎么办？因为<code>submit()</code>不会等待任务完成，executor service不能直接返回callable的结果。不过，executor 可以返回一个<code>Future</code>类型的结果，它可以用来在稍后某个时间取出实际的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">Future&lt;Integer&gt; future = executor.submit(task);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;future done? &quot;</span> + future.isDone());</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;future done? &quot;</span> + future.isDone());</span><br><span class="line">System.out.print(<span class="string">&quot;result: &quot;</span> + result);</span><br></pre></td></tr></table></figure>
<p>在将callable提交给exector之后，我们先通过调用<code>isDone()</code>来检查这个future是否已经完成执行。我十分确定这会发生什么，因为在返回那个整数之前callable会休眠一分钟、</p>
<p>在调用<code>get()</code>方法时，当前线程会阻塞等待，直到callable在返回实际的结果123之前执行完成。现在future执行完毕，我们可以在控制台看到如下的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">future done? <span class="literal">false</span></span><br><span class="line">future done? <span class="literal">true</span></span><br><span class="line">result: <span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>Future与底层的executor service紧密的结合在一起。记住，如果你关闭executor，所有的未中止的future都会抛出异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">executor.shutdownNow();</span><br><span class="line">future.get();</span><br></pre></td></tr></table></figure>
<p>你可能注意到我们这次创建executor的方式与上一个例子稍有不同。我们使用<code>newFixedThreadPool(1)</code>来创建一个单线程线程池的 execuot service。这等同于使用<code>newSingleThreadExecutor</code>不过使用第二种方式我们可以稍后通过简单的传入一个比1大的值来增加线程池的大小。</p>
<h3 id="超时">超时</h3>
<p>任何<code>future.get()</code>调用都会阻塞，然后等待直到callable中止。在最糟糕的情况下，一个callable持续运行——因此使你的程序将没有响应。我们可以简单的传入一个时长来避免这种情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    Future&lt;Integer&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;task interrupted&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">    future.get(<span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p>运行上面的代码将会产生一个<code>TimeoutException</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.util.concurrent.TimeoutException</span><br><span class="line">    at java.util.concurrent.FutureTask.get(FutureTask.java:205)</span><br></pre></td></tr></table></figure>
<p>你可能已经猜到俄为什么会排除这个异常。我们指定的最长等待时间为1分钟，而这个callable在返回结果之前实际需要两分钟。</p>
<h3 id="invokeAll"><code>invokeAll</code></h3>
<p>Executors支持通过<code>invokeAll()</code>一次批量提交多个callable。这个方法结果一个callable的集合，然后返回一个future的列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newWorkStealingPool();</span><br><span class="line"></span><br><span class="line">List&lt;Callable&lt;String&gt;&gt; callables = Arrays.asList(</span><br><span class="line">        () -&gt; <span class="string">&quot;task1&quot;</span>,</span><br><span class="line">        () -&gt; <span class="string">&quot;task2&quot;</span>,</span><br><span class="line">        () -&gt; <span class="string">&quot;task3&quot;</span>);</span><br><span class="line"></span><br><span class="line">executor.invokeAll(callables)</span><br><span class="line">    .stream()</span><br><span class="line">    .map(future -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> future.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们利用Java8中的函数流（stream）来处理<code>invokeAll()</code>调用返回的所有future。我们首先将每一个future映射到它的返回值，然后将每个值打印到控制台。如果你还不属性stream，可以阅读我的<a href="http://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/">Java8 Stream 教程</a>。</p>
<h3 id="invokeAny"><code>invokeAny</code></h3>
<p>批量提交callable的另一种方式就是<code>invokeAny()</code>，它的工作方式与<code>invokeAll()</code>稍有不同。在等待future对象的过程中，这个方法将会阻塞直到第一个callable中止然后返回这一个callable的结果。</p>
<p>为了测试这种行为，我们利用这个帮助方法来模拟不同执行时间的callable。这个方法返回一个callable，这个callable休眠指定 的时间直到返回给定的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Callable&lt;String&gt; <span class="title function_">callable</span><span class="params">(String result, <span class="type">long</span> sleepSeconds)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(sleepSeconds);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们利用这个方法创建一组callable，这些callable拥有不同的执行时间，从1分钟到3分钟。通过<code>invokeAny()</code>将这些callable提交给一个executor，返回最快的callable的字符串结果-在这个例子中为任务2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newWorkStealingPool();</span><br><span class="line"></span><br><span class="line">List&lt;Callable&lt;String&gt;&gt; callables = Arrays.asList(</span><br><span class="line">callable(<span class="string">&quot;task1&quot;</span>, <span class="number">2</span>),</span><br><span class="line">callable(<span class="string">&quot;task2&quot;</span>, <span class="number">1</span>),</span><br><span class="line">callable(<span class="string">&quot;task3&quot;</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> executor.invokeAny(callables);</span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; task2</span></span><br></pre></td></tr></table></figure>
<p>上面这个例子又使用了另一种方式来创建executor——调用<code>newWorkStealingPool()</code>。这个工厂方法是Java8引入的，返回一个<code>ForkJoinPool</code>类型的 executor，它的工作方法与其他常见的execuotr稍有不同。与使用一个固定大小的线程池不同，<code>ForkJoinPools</code>使用一个并行因子数来创建，默认值为主机CPU的可用核心数。</p>
<p>ForkJoinPools 在Java7时引入，将会在这个系列后面的教程中详细讲解。让我们深入了解一下 scheduled executors 来结束本次教程。</p>
<h2 id="ScheduledExecutor"><code>ScheduledExecutor</code></h2>
<p>我们已经学习了如何在一个 executor 中提交和运行一次任务。为了持续的多次执行常见的任务，我们可以利用调度线程池。</p>
<p><code>ScheduledExecutorService</code>支持任务调度，持续执行或者延迟一段时间后执行。</p>
<p>下面的实例，调度一个任务在延迟3分钟后执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> 				Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Scheduling: &quot;</span> + System.nanoTime());</span><br><span class="line">ScheduledFuture&lt;?&gt; future = executor.schedule(task, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">TimeUnit.MILLISECONDS.sleep(<span class="number">1337</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">remainingDelay</span> <span class="operator">=</span> future.getDelay(TimeUnit.MILLISECONDS);</span><br><span class="line">System.out.printf(<span class="string">&quot;Remaining Delay: %sms&quot;</span>, remainingDelay);</span><br></pre></td></tr></table></figure>
<p>调度一个任务将会产生一个专门的future类型——<code>ScheduleFuture</code>，它除了提供了Future的所有方法之外，他还提供了<code>getDelay()</code>方法来获得剩余的延迟。在延迟消逝后，任务将会并发执行。</p>
<p>为了调度任务持续的执行，executors 提供了两个方法<code>scheduleAtFixedRate()</code>和<code>scheduleWithFixedDelay()</code>。第一个方法用来以固定频率来执行一个任务，比如，下面这个示例中，每分钟一次：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> 	Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Scheduling: &quot;</span> + System.nanoTime());</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">initialDelay</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">period</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">executor.scheduleAtFixedRate(task, initialDelay, period, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p>另外，这个方法还接收一个初始化延迟，用来指定这个任务首次被执行等待的时长。</p>
<p>请记住：<code>scheduleAtFixedRate()</code>并不考虑任务的实际用时。所以，如果你指定了一个period为1分钟而任务需要执行2分钟，那么线程池为了性能会更快的执行。</p>
<p>在这种情况下，你应该考虑使用<code>scheduleWithFixedDelay()</code>。这个方法的工作方式与上我们上面描述的类似。不同之处在于等待时间 period 的应用是在一次任务的结束和下一个任务的开始之间。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> 		Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Scheduling: &quot;</span> + System.nanoTime());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;task interrupted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">executor.scheduleWithFixedDelay(task, <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p>这个例子调度了一个任务，并在一次执行的结束和下一次执行的开始之间设置了一个1分钟的固定延迟。初始化延迟为0，任务执行时间为0。所以我们分别在0s,3s,6s,9s等间隔处结束一次执行。如你所见，<code>scheduleWithFixedDelay()</code>在你不能预测调度任务的执行时长时是很有用的。</p>
<blockquote>
<p>原文：<a href="http://winterbe.com/posts/2015/04/07/java8-concurrency-tutorial-thread-executor-examples/">Java 8 Concurrency Tutorial: Threads and Executors</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java8 Stream 教程</title>
    <url>/posts/1c02b8ff.html</url>
    <content><![CDATA[<h1>Java 8 数据流教程</h1>
<h2 id="数据流如何工作">数据流如何工作</h2>
<p>数据流表示元素的序列，并支持不同种类的操作来执行元素上的计算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; myList =</span><br><span class="line">    Arrays.asList(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;c2&quot;</span>, <span class="string">&quot;c1&quot;</span>);</span><br><span class="line"></span><br><span class="line">myList</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(s -&gt; s.startsWith(<span class="string">&quot;c&quot;</span>))</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .sorted()</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// C1</span></span><br><span class="line"><span class="comment">// C2</span></span><br></pre></td></tr></table></figure>
<p>数据流操作要么是衔接操作，要么是终止操作。衔接操作返回数据流，所以我们可以把多个衔接操作不使用分号来链接到一起。终止操作无返回值，或者返回一个不是流的结果。在上面的例子中，<code>filter</code>、<code>map</code>和<code>sorted</code>都是衔接操作，而<code>forEach</code>是终止操作。列表上的所有流式操作请见<a href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">数据流的Javadoc</a>。你在上面例子中看到的这种数据流的链式操作也叫作操作流水线。</p>
<p>多数数据流操作都接受一些lambda表达式参数，函数式接口用来指定操作的具体行为。这些操作的大多数必须是无干扰而且是无状态的。它们是什么意思呢？</p>
<p>当一个函数不修改数据流的底层数据源，它就是<a href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#NonInterference">无干扰的</a>。例如，在上面的例子中，没有任何lambda表达式通过添加或删除集合元素修改<code>myList</code>。</p>
<p>当一个函数的操作的执行是确定性的，它就是<a href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#Statelessness">无状态的</a>。例如，在上面的例子中，没有任何lambda表达式依赖于外部作用域中任何在操作过程中可变的变量或状态。</p>
<h2 id="数据流的不同类型">数据流的不同类型</h2>
<p>数据流可以从多种数据源创建，尤其是集合。<code>List</code>和<code>Set</code>支持新方法<code>stream()</code> 和 <code>parallelStream()</code>，来创建串行流或并行流。并行流能够在多个线程上执行操作，它们会在之后的章节中讲到。我们现在来看看串行流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.asList(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;a3&quot;</span>)</span><br><span class="line">    .stream()</span><br><span class="line">    .findFirst()</span><br><span class="line">    .ifPresent(System.out::println);  <span class="comment">// a1</span></span><br></pre></td></tr></table></figure>
<p>在对象列表上调用<code>stream()</code>方法会返回一个通常的对象流。但是我们不需要创建一个集合来创建数据流，就像下面那样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;a3&quot;</span>)</span><br><span class="line">    .findFirst()</span><br><span class="line">    .ifPresent(System.out::println);  <span class="comment">// a1</span></span><br></pre></td></tr></table></figure>
<p>只要使用<code>Stream.of()</code>，就可以从一系列对象引用中创建数据流。</p>
<p>除了普通的对象数据流，Java8还自带了特殊种类的流，用于处理基本数据类型<code>int</code>、<code>long</code> 和 <code>double</code>。你可能已经猜到了它是<code>IntStream</code>、<code>LongStream</code> 和 <code>DoubleStream</code>。</p>
<p><code>IntStream</code>可以使用<code>IntStream.range()</code>替换通常的<code>for</code>循环：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>所有这些基本数据流都像通常的对象数据流一样，但有一些不同。基本的数据流使用特殊的lambda表达式，例如，<code>IntFunction</code>而不是<code>Function</code>，<code>IntPredicate</code>而不是<code>Predicate</code>。而且基本数据流支持额外的聚合终止操作<code>sum()</code>和<code>average()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.stream(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)</span><br><span class="line">    .map(n -&gt; <span class="number">2</span> * n + <span class="number">1</span>)</span><br><span class="line">    .average()</span><br><span class="line">    .ifPresent(System.out::println);  <span class="comment">// 5.0</span></span><br></pre></td></tr></table></figure>
<p>有时需要将通常的对象数据流转换为基本数据流，或者相反。出于这种目的，对象数据流支持特殊的映射操作<code>mapToInt()</code>、<code>mapToLong()</code> 和 <code>mapToDouble()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;a3&quot;</span>)</span><br><span class="line">    .map(s -&gt; s.substring(<span class="number">1</span>))</span><br><span class="line">    .mapToInt(Integer::parseInt)</span><br><span class="line">    .max()</span><br><span class="line">    .ifPresent(System.out::println);  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>基本数据流可以通过<code>mapToObj()</code>转换为对象数据流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    .mapToObj(i -&gt; <span class="string">&quot;a&quot;</span> + i)</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a1</span></span><br><span class="line"><span class="comment">// a2</span></span><br><span class="line"><span class="comment">// a3</span></span><br></pre></td></tr></table></figure>
<p>下面是组合示例：浮点数据流首先映射为整数数据流，之后映射为字符串的对象数据流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>)</span><br><span class="line">    .mapToInt(Double::intValue)</span><br><span class="line">    .mapToObj(i -&gt; <span class="string">&quot;a&quot;</span> + i)</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a1</span></span><br><span class="line"><span class="comment">// a2</span></span><br><span class="line"><span class="comment">// a3</span></span><br></pre></td></tr></table></figure>
<h2 id="处理顺序">处理顺序</h2>
<p>既然我们已经了解了如何创建并使用不同种类的数据流，让我们深入了解数据流操作在背后如何执行吧。</p>
<p>衔接操作的一个重要特性就是延迟性。观察下面没有终止操作的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filter: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>执行这段代码时，不向控制台打印任何东西。这是因为衔接操作只在终止操作调用时被执行。</p>
<p>让我们通过添加终止操作<code>forEach</code>来扩展这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filter: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.println(<span class="string">&quot;forEach: &quot;</span> + s));</span><br></pre></td></tr></table></figure>
<p>执行这段代码会得到如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filter:  d2</span><br><span class="line">forEach: d2</span><br><span class="line">filter:  a2</span><br><span class="line">forEach: a2</span><br><span class="line">filter:  b1</span><br><span class="line">forEach: b1</span><br><span class="line">filter:  b3</span><br><span class="line">forEach: b3</span><br><span class="line">filter:  c</span><br><span class="line">forEach: c</span><br></pre></td></tr></table></figure>
<p>结果的顺序可能出人意料。原始的方法会在数据流的所有元素上，一个接一个地水平执行所有操作。但是每个元素在调用链上垂直移动。第一个字符串<code>&quot;d2&quot;</code>首先经过<code>filter</code>然后是<code>forEach</code>，执行完后才开始处理第二个字符串<code>&quot;a2&quot;</code>。</p>
<p>这种行为可以减少每个元素上所执行的实际操作数量，就像我们在下个例子中看到的那样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;map: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .anyMatch(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;anyMatch: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.startsWith(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// map:      d2</span></span><br><span class="line"><span class="comment">// anyMatch: D2</span></span><br><span class="line"><span class="comment">// map:      a2</span></span><br><span class="line"><span class="comment">// anyMatch: A2</span></span><br></pre></td></tr></table></figure>
<p>只要提供的数据元素满足了谓词，<code>anyMatch</code>操作就会返回<code>true</code>。对于第二个传递<code>&quot;A2&quot;</code>的元素，它的结果为真。由于数据流的链式调用是垂直执行的，<code>map</code>这里只需要执行两次。所以<code>map</code>会执行尽可能少的次数，而不是把所有元素都映射一遍。</p>
<h3 id="为什么顺序如此重要">为什么顺序如此重要</h3>
<p>下面的例子由两个衔接操作<code>map</code>和<code>filter</code>，以及一个终止操作<code>forEach</code>组成。让我们再来看看这些操作如何执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;map: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filter: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.startsWith(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.println(<span class="string">&quot;forEach: &quot;</span> + s));</span><br><span class="line"></span><br><span class="line"><span class="comment">// map:     d2</span></span><br><span class="line"><span class="comment">// filter:  D2</span></span><br><span class="line"><span class="comment">// map:     a2</span></span><br><span class="line"><span class="comment">// filter:  A2</span></span><br><span class="line"><span class="comment">// forEach: A2</span></span><br><span class="line"><span class="comment">// map:     b1</span></span><br><span class="line"><span class="comment">// filter:  B1</span></span><br><span class="line"><span class="comment">// map:     b3</span></span><br><span class="line"><span class="comment">// filter:  B3</span></span><br><span class="line"><span class="comment">// map:     c</span></span><br><span class="line"><span class="comment">// filter:  C</span></span><br></pre></td></tr></table></figure>
<p>就像你可能猜到的那样，<code>map</code>和<code>filter</code>会对底层集合的每个字符串调用五次，而<code>forEach</code>只会调用一次。</p>
<p>如果我们调整操作顺序，将<code>filter</code>移动到调用链的顶端，就可以极大减少操作的执行次数:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filter: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.startsWith(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;map: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.println(<span class="string">&quot;forEach: &quot;</span> + s));</span><br><span class="line"></span><br><span class="line"><span class="comment">// filter:  d2</span></span><br><span class="line"><span class="comment">// filter:  a2</span></span><br><span class="line"><span class="comment">// map:     a2</span></span><br><span class="line"><span class="comment">// forEach: A2</span></span><br><span class="line"><span class="comment">// filter:  b1</span></span><br><span class="line"><span class="comment">// filter:  b3</span></span><br><span class="line"><span class="comment">// filter:  c</span></span><br></pre></td></tr></table></figure>
<p>现在，<code>map</code>只会调用一次，所以操作流水线对于更多的输入元素会执行更快。在整合复杂的方法链时，要记住这一点。</p>
<p>让我们通过添加额外的方法<code>sorted</code>来扩展上面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">    .sorted((s1, s2) -&gt; &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;sort: %s; %s\n&quot;</span>, s1, s2);</span><br><span class="line">        <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">    &#125;)</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filter: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.startsWith(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;map: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.println(<span class="string">&quot;forEach: &quot;</span> + s));</span><br></pre></td></tr></table></figure>
<p>排序是一类特殊的衔接操作。它是有状态的操作，因为你需要在处理中保存状态来对集合中的元素排序。</p>
<p>执行这个例子会得到如下输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sort:    a2; d2</span><br><span class="line">sort:    b1; a2</span><br><span class="line">sort:    b1; d2</span><br><span class="line">sort:    b1; a2</span><br><span class="line">sort:    b3; b1</span><br><span class="line">sort:    b3; d2</span><br><span class="line">sort:    c; b3</span><br><span class="line">sort:    c; d2</span><br><span class="line">filter:  a2</span><br><span class="line">map:     a2</span><br><span class="line">forEach: A2</span><br><span class="line">filter:  b1</span><br><span class="line">filter:  b3</span><br><span class="line">filter:  c</span><br><span class="line">filter:  d2</span><br></pre></td></tr></table></figure>
<p>首先，排序操作在整个输入集合上执行。也就是说，<code>sorted</code>以水平方式执行。所以这里<code>sorted</code>对输入集合中每个元素的多种组合调用了八次。</p>
<p>我们同样可以通过重排调用链来优化性能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filter: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.startsWith(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .sorted((s1, s2) -&gt; &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;sort: %s; %s\n&quot;</span>, s1, s2);</span><br><span class="line">        <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;map: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.println(<span class="string">&quot;forEach: &quot;</span> + s));</span><br><span class="line"></span><br><span class="line"><span class="comment">// filter:  d2</span></span><br><span class="line"><span class="comment">// filter:  a2</span></span><br><span class="line"><span class="comment">// filter:  b1</span></span><br><span class="line"><span class="comment">// filter:  b3</span></span><br><span class="line"><span class="comment">// filter:  c</span></span><br><span class="line"><span class="comment">// map:     a2</span></span><br><span class="line"><span class="comment">// forEach: A2</span></span><br></pre></td></tr></table></figure>
<p>这个例子中<code>sorted</code>永远不会调用，因为<code>filter</code>把输入集合减少至只有一个元素。所以对于更大的输入集合会极大提升性能。</p>
<h2 id="复用数据流">复用数据流</h2>
<p>Java8的数据流不能被复用。一旦你调用了任何终止操作，数据流就关闭了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream =</span><br><span class="line">    Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">        .filter(s -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line">stream.anyMatch(s -&gt; <span class="literal">true</span>);    <span class="comment">// ok</span></span><br><span class="line">stream.noneMatch(s -&gt; <span class="literal">true</span>);   <span class="comment">// exception</span></span><br></pre></td></tr></table></figure>
<p>在相同数据流上，在<code>anyMatch</code>之后调用<code>noneMatch</code>会产生下面的异常：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalStateException: stream has already been operated upon or closed</span><br><span class="line">    at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:229)</span><br><span class="line">    at java.util.stream.ReferencePipeline.noneMatch(ReferencePipeline.java:459)</span><br><span class="line">    at com.winterbe.java8.Streams5.test7(Streams5.java:38)</span><br><span class="line">    at com.winterbe.java8.Streams5.main(Streams5.java:28)</span><br></pre></td></tr></table></figure>
<p>要克服这个限制，我们需要为每个我们想要执行的终止操作创建新的数据流调用链。例如，我们创建一个数据流供应器，来构建新的数据流，并且设置好所有衔接操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Supplier&lt;Stream&lt;String&gt;&gt; streamSupplier =</span><br><span class="line">    () -&gt; Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">            .filter(s -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line">streamSupplier.get().anyMatch(s -&gt; <span class="literal">true</span>);   <span class="comment">// ok</span></span><br><span class="line">streamSupplier.get().noneMatch(s -&gt; <span class="literal">true</span>);  <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<p>每次对<code>get()</code>的调用都构造了一个新的数据流，我们将其保存来调用终止操作。</p>
<h2 id="高级操作">高级操作</h2>
<p>数据流执行大量的不同操作。我们已经了解了一些最重要的操作，例如<code>filter</code>和<code>map</code>。我将它们留给你来探索所有其他的可用操作（请见<a href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">数据流的Javadoc</a>）。下面让我们深入了解一些更复杂的操作：<code>collect</code>、<code>flatMap</code>和<code>reduce</code>。</p>
<p>这一节的大部分代码示例使用下面的<code>Person</code>列表来演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    Person(String name, <span class="type">int</span> age) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; persons =</span><br><span class="line">    Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Max&quot;</span>, <span class="number">18</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Peter&quot;</span>, <span class="number">23</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Pamela&quot;</span>, <span class="number">23</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;David&quot;</span>, <span class="number">12</span>));</span><br></pre></td></tr></table></figure>
<h3 id="collect"><code>collect</code></h3>
<p><code>collect</code>是非常有用的终止操作，将流中的元素存放在不同类型的结果中，例如<code>List</code>、<code>Set</code>或者<code>Map</code>。<code>collect</code>接受收集器（Collector），它由四个不同的操作组成：供应器（supplier）、累加器（accumulator）、组合器（combiner）和终止器（finisher）。这在开始听起来十分复杂，但是Java8通过内置的<code>Collectors</code>类支持多种内置的收集器。所以对于大部分常见操作，你并不需要自己实现收集器。</p>
<p>让我们以一个非常常见的用例来开始：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; filtered =</span><br><span class="line">    persons</span><br><span class="line">        .stream()</span><br><span class="line">        .filter(p -&gt; p.name.startsWith(<span class="string">&quot;P&quot;</span>))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(filtered);    <span class="comment">// [Peter, Pamela]</span></span><br></pre></td></tr></table></figure>
<p>就像你看到的那样，它非常简单，只是从流的元素中构造了一个列表。如果需要以<code>Set</code>来替代<code>List</code>，只需要使用<code>Collectors.toSet()</code>就好了。</p>
<p>下面的例子按照年龄对所有人进行分组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, List&lt;Person&gt;&gt; personsByAge = persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(Collectors.groupingBy(p -&gt; p.age));</span><br><span class="line"></span><br><span class="line">personsByAge</span><br><span class="line">    .forEach((age, p) -&gt; System.out.format(<span class="string">&quot;age %s: %s\n&quot;</span>, age, p));</span><br><span class="line"></span><br><span class="line"><span class="comment">// age 18: [Max]</span></span><br><span class="line"><span class="comment">// age 23: [Peter, Pamela]</span></span><br><span class="line"><span class="comment">// age 12: [David]</span></span><br></pre></td></tr></table></figure>
<p>收集器十分灵活。你也可以在流的元素上执行聚合，例如，计算所有人的平均年龄：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Double</span> <span class="variable">averageAge</span> <span class="operator">=</span> persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(Collectors.averagingInt(p -&gt; p.age));</span><br><span class="line"></span><br><span class="line">System.out.println(averageAge);     <span class="comment">// 19.0</span></span><br></pre></td></tr></table></figure>
<p>如果你对更多统计学方法感兴趣，概要收集器返回一个特殊的内置概要统计对象，所以我们可以简单计算最小年龄、最大年龄、算术平均年龄、总和和数量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">IntSummaryStatistics</span> <span class="variable">ageSummary</span> <span class="operator">=</span></span><br><span class="line">    persons</span><br><span class="line">        .stream()</span><br><span class="line">        .collect(Collectors.summarizingInt(p -&gt; p.age));</span><br><span class="line"></span><br><span class="line">System.out.println(ageSummary);</span><br><span class="line"><span class="comment">// IntSummaryStatistics&#123;count=4, sum=76, min=12, average=19.000000, max=23&#125;</span></span><br></pre></td></tr></table></figure>
<p>下面的例子将所有人连接为一个字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">phrase</span> <span class="operator">=</span> persons</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(p -&gt; p.age &gt;= <span class="number">18</span>)</span><br><span class="line">    .map(p -&gt; p.name)</span><br><span class="line">    .collect(Collectors.joining(<span class="string">&quot; and &quot;</span>, <span class="string">&quot;In Germany &quot;</span>, <span class="string">&quot; are of legal age.&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(phrase);</span><br><span class="line"><span class="comment">// In Germany Max and Peter and Pamela are of legal age.</span></span><br></pre></td></tr></table></figure>
<p>连接收集器接受分隔符，以及可选的前缀和后缀。</p>
<p>为了将数据流中的元素转换为映射，我们需要指定键和值如何被映射。要记住键必须是唯一的，否则会抛出<code>IllegalStateException</code>异常。你可以选择传递一个合并函数作为额外的参数来避免这个异常。</p>
<p>既然我们知道了一些最强大的内置收集器，让我们来尝试构建自己的特殊收集器吧。我们希望将流中的所有人转换为一个字符串，包含所有大写的名称，并以<code>|</code>分割。为了完成它，我们通过<code>Collector.of()</code>创建了一个新的收集器。我们需要传递一个收集器的四个组成部分：供应器、累加器、组合器和终止器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collector&lt;Person, StringJoiner, String&gt; personNameCollector =</span><br><span class="line">    Collector.of(</span><br><span class="line">        () -&gt; <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot; | &quot;</span>),          <span class="comment">// supplier</span></span><br><span class="line">        (j, p) -&gt; j.add(p.name.toUpperCase()),  <span class="comment">// accumulator</span></span><br><span class="line">        (j1, j2) -&gt; j1.merge(j2),               <span class="comment">// combiner</span></span><br><span class="line">        StringJoiner::toString);                <span class="comment">// finisher</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">names</span> <span class="operator">=</span> persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(personNameCollector);</span><br><span class="line"></span><br><span class="line">System.out.println(names);  <span class="comment">// MAX | PETER | PAMELA | DAVID</span></span><br></pre></td></tr></table></figure>
<p>由于Java中的字符串是不可变的，我们需要一个助手类<code>StringJointer</code>。让收集器构造我们的字符串。供应器最开始使用相应的分隔符构造了这样一个<code>StringJointer</code>。累加器用于将每个人的大写名称加到<code>StringJointer</code>中。组合器知道如何把两个<code>StringJointer</code>合并为一个。最后一步，终结器从<code>StringJointer</code>构造出预期的字符串。</p>
<h3 id="flatMap"><code>flatMap</code></h3>
<p>我们已经了解了如何通过使用<code>map</code>操作，将流中的对象转换为另一种类型。<code>map</code>有时十分受限，因为每个对象只能映射为一个其它对象。但如何我希望将一个对象转换为多个或零个其他对象呢？<code>flatMap</code>这时就会派上用场。</p>
<p><code>flatMap</code>将流中的每个元素，转换为其它对象的流。所以每个对象会被转换为零个、一个或多个其它对象，以流的形式返回。这些流的内容之后会放进<code>flatMap</code>所返回的流中。</p>
<p>在我们了解<code>flatMap</code>如何使用之前，我们需要相应的类型体系：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    List&lt;Bar&gt; bars = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Foo(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Bar(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面，我们使用我们自己的关于流的知识来实例化一些对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Foo&gt; foos = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// create foos</span></span><br><span class="line">IntStream</span><br><span class="line">    .range(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    .forEach(i -&gt; foos.add(<span class="keyword">new</span> <span class="title class_">Foo</span>(<span class="string">&quot;Foo&quot;</span> + i)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// create bars</span></span><br><span class="line">foos.forEach(f -&gt;</span><br><span class="line">    IntStream</span><br><span class="line">        .range(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">        .forEach(i -&gt; f.bars.add(<span class="keyword">new</span> <span class="title class_">Bar</span>(<span class="string">&quot;Bar&quot;</span> + i + <span class="string">&quot; &lt;- &quot;</span> + f.name))));</span><br></pre></td></tr></table></figure>
<p>现在我们拥有了含有三个<code>foo</code>的列表，每个都含有三个<code>bar</code>。</p>
<p><code>flatMap</code>接受返回对象流的函数。所以为了处理每个<code>foo</code>上的<code>bar</code>对象，我们需要传递相应的函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">foos.stream()</span><br><span class="line">    .flatMap(f -&gt; f.bars.stream())</span><br><span class="line">    .forEach(b -&gt; System.out.println(b.name));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bar1 &lt;- Foo1</span></span><br><span class="line"><span class="comment">// Bar2 &lt;- Foo1</span></span><br><span class="line"><span class="comment">// Bar3 &lt;- Foo1</span></span><br><span class="line"><span class="comment">// Bar1 &lt;- Foo2</span></span><br><span class="line"><span class="comment">// Bar2 &lt;- Foo2</span></span><br><span class="line"><span class="comment">// Bar3 &lt;- Foo2</span></span><br><span class="line"><span class="comment">// Bar1 &lt;- Foo3</span></span><br><span class="line"><span class="comment">// Bar2 &lt;- Foo3</span></span><br><span class="line"><span class="comment">// Bar3 &lt;- Foo3</span></span><br></pre></td></tr></table></figure>
<p>像你看到的那样，我们成功地将含有三个<code>foo</code>对象中的流转换为含有九个<code>bar</code>对象的流。</p>
<p>最后，上面的代码示例可以简化为流式操作的单一流水线：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    .mapToObj(i -&gt; <span class="keyword">new</span> <span class="title class_">Foo</span>(<span class="string">&quot;Foo&quot;</span> + i))</span><br><span class="line">    .peek(f -&gt; IntStream.range(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">        .mapToObj(i -&gt; <span class="keyword">new</span> <span class="title class_">Bar</span>(<span class="string">&quot;Bar&quot;</span> + i + <span class="string">&quot; &lt;- &quot;</span> + f.name))</span><br><span class="line">        .forEach(f.bars::add))</span><br><span class="line">    .flatMap(f -&gt; f.bars.stream())</span><br><span class="line">    .forEach(b -&gt; System.out.println(b.name));</span><br></pre></td></tr></table></figure>
<p><code>flatMap</code>也可用于Java8引入的<code>Optional</code>类。<code>Optional</code>的<code>flatMap</code>操作返回一个<code>Optional</code>或其他类型的对象。所以它可以用于避免烦人的<code>null</code>检查。</p>
<p>考虑像这样更复杂的层次结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    Nested nested;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Nested</span> &#123;</span><br><span class="line">    Inner inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">    String foo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了处理外层示例上的内层字符串<code>foo</code>，你需要添加多个<code>null</code>检查来避免潜在的<code>NullPointerException</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line"><span class="keyword">if</span> (outer != <span class="literal">null</span> &amp;&amp; outer.nested != <span class="literal">null</span> &amp;&amp; outer.nested.inner != <span class="literal">null</span>) &#123;</span><br><span class="line">    System.out.println(outer.nested.inner.foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用<code>Optional</code>的<code>flatMap</code>操作来完成相同的行为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional.of(<span class="keyword">new</span> <span class="title class_">Outer</span>())</span><br><span class="line">    .flatMap(o -&gt; Optional.ofNullable(o.nested))</span><br><span class="line">    .flatMap(n -&gt; Optional.ofNullable(n.inner))</span><br><span class="line">    .flatMap(i -&gt; Optional.ofNullable(i.foo))</span><br><span class="line">    .ifPresent(System.out::println);</span><br></pre></td></tr></table></figure>
<p>如果存在的话，每个<code>flatMap</code>的调用都会返回预期对象的<code>Optional</code>包装，否则为<code>null</code>的<code>Optional</code>包装。</p>
<h3 id="reduce-2"><code>reduce</code></h3>
<p>归约操作将所有流中的元素组合为单一结果。Java8支持三种不同类型的<code>reduce</code>方法。第一种将流中的元素归约为流中的一个元素。让我们看看我们如何使用这个方法来计算出最老的人：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .reduce((p1, p2) -&gt; p1.age &gt; p2.age ? p1 : p2)</span><br><span class="line">    .ifPresent(System.out::println);    <span class="comment">// Pamela</span></span><br></pre></td></tr></table></figure>
<p><code>reduce</code>方法接受<code>BinaryOperator</code>积累函数。它实际上是两个操作数类型相同的<code>BiFunction</code>。<code>BiFunction</code>就像是<code>Function</code>，但是接受两个参数。示例中的函数比较两个人的年龄，来返回年龄较大的人。</p>
<p>第二个<code>reduce</code>方法接受一个初始值，和一个<code>BinaryOperator</code>累加器。这个方法可以用于从流中的其它<code>Person</code>对象中构造带有聚合后名称和年龄的新<code>Person</code>对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">result</span> <span class="operator">=</span></span><br><span class="line">    persons</span><br><span class="line">        .stream()</span><br><span class="line">        .reduce(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>), (p1, p2) -&gt; &#123;</span><br><span class="line">            p1.age += p2.age;</span><br><span class="line">            p1.name += p2.name;</span><br><span class="line">            <span class="keyword">return</span> p1;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">System.out.format(<span class="string">&quot;name=%s; age=%s&quot;</span>, result.name, result.age);</span><br><span class="line"><span class="comment">// name=MaxPeterPamelaDavid; age=76</span></span><br></pre></td></tr></table></figure>
<p>第三个<code>reduce</code>对象接受三个参数：初始值，<code>BiFunction</code>累加器和<code>BinaryOperator</code>类型的组合器函数。由于初始值的类型不一定为<code>Person</code>，我们可以使用这个归约函数来计算所有人的年龄总和。：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">ageSum</span> <span class="operator">=</span> persons</span><br><span class="line">    .stream()</span><br><span class="line">    .reduce(<span class="number">0</span>, (sum, p) -&gt; sum += p.age, (sum1, sum2) -&gt; sum1 + sum2);</span><br><span class="line"></span><br><span class="line">System.out.println(ageSum);  <span class="comment">// 76</span></span><br></pre></td></tr></table></figure>
<p>你可以看到结果是76。但是背后发生了什么？让我们通过添加一些调试输出来扩展上面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">ageSum</span> <span class="operator">=</span> persons</span><br><span class="line">    .stream()</span><br><span class="line">    .reduce(<span class="number">0</span>,</span><br><span class="line">        (sum, p) -&gt; &#123;</span><br><span class="line">            System.out.format(<span class="string">&quot;accumulator: sum=%s; person=%s\n&quot;</span>, sum, p);</span><br><span class="line">            <span class="keyword">return</span> sum += p.age;</span><br><span class="line">        &#125;,</span><br><span class="line">        (sum1, sum2) -&gt; &#123;</span><br><span class="line">            System.out.format(<span class="string">&quot;combiner: sum1=%s; sum2=%s\n&quot;</span>, sum1, sum2);</span><br><span class="line">            <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// accumulator: sum=0; person=Max</span></span><br><span class="line"><span class="comment">// accumulator: sum=18; person=Peter</span></span><br><span class="line"><span class="comment">// accumulator: sum=41; person=Pamela</span></span><br><span class="line"><span class="comment">// accumulator: sum=64; person=David</span></span><br></pre></td></tr></table></figure>
<p>你可以看到，累加器函数做了所有工作。它首先使用初始值<code>0</code>和第一个人Max来调用累加器。接下来的三步中<code>sum</code>会持续增加，直到76。</p>
<p>等一下。好像组合器从来没有调用过？以并行方式执行相同的流会揭开这个秘密：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">ageSum</span> <span class="operator">=</span> persons</span><br><span class="line">    .parallelStream()</span><br><span class="line">    .reduce(<span class="number">0</span>,</span><br><span class="line">        (sum, p) -&gt; &#123;</span><br><span class="line">            System.out.format(<span class="string">&quot;accumulator: sum=%s; person=%s\n&quot;</span>, sum, p);</span><br><span class="line">            <span class="keyword">return</span> sum += p.age;</span><br><span class="line">        &#125;,</span><br><span class="line">        (sum1, sum2) -&gt; &#123;</span><br><span class="line">            System.out.format(<span class="string">&quot;combiner: sum1=%s; sum2=%s\n&quot;</span>, sum1, sum2);</span><br><span class="line">            <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// accumulator: sum=0; person=Pamela</span></span><br><span class="line"><span class="comment">// accumulator: sum=0; person=David</span></span><br><span class="line"><span class="comment">// accumulator: sum=0; person=Max</span></span><br><span class="line"><span class="comment">// accumulator: sum=0; person=Peter</span></span><br><span class="line"><span class="comment">// combiner: sum1=18; sum2=23</span></span><br><span class="line"><span class="comment">// combiner: sum1=23; sum2=12</span></span><br><span class="line"><span class="comment">// combiner: sum1=41; sum2=35</span></span><br></pre></td></tr></table></figure>
<p>这个流的并行执行行为会完全不同。现在实际上调用了组合器。由于累加器被并行调用，组合器需要用于计算部分累加值的总和。</p>
<p>下一节我们会深入了解并行流。</p>
<h2 id="并行流">并行流</h2>
<p>流可以并行执行，在大量输入元素上可以提升运行时的性能。并行流使用公共的<code>ForkJoinPool</code>，由<code>ForkJoinPool.commonPool()</code>方法提供。底层线程池的大小最大为五个线程 – 取决于CPU的物理核数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ForkJoinPool</span> <span class="variable">commonPool</span> <span class="operator">=</span> ForkJoinPool.commonPool();</span><br><span class="line">System.out.println(commonPool.getParallelism());    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>在我的机器上，公共池默认初始化为3。这个值可以通过设置下列JVM参数来增减：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Djava.util.concurrent.ForkJoinPool.common.parallelism=5</span><br></pre></td></tr></table></figure>
<p>集合支持<code>parallelStream()</code>方法来创建元素的并行流。或者你可以在已存在的数据流上调用衔接方法<code>parallel()</code>，将串行流转换为并行流。</p>
<p>为了描述并行流的执行行为，下面的例子向<code>sout</code>打印了当前线程的信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.asList(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;c2&quot;</span>, <span class="string">&quot;c1&quot;</span>)</span><br><span class="line">    .parallelStream()</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.format(<span class="string">&quot;filter: %s [%s]\n&quot;</span>,</span><br><span class="line">            s, Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.format(<span class="string">&quot;map: %s [%s]\n&quot;</span>,</span><br><span class="line">            s, Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.format(<span class="string">&quot;forEach: %s [%s]\n&quot;</span>,</span><br><span class="line">        s, Thread.currentThread().getName()));</span><br></pre></td></tr></table></figure>
<p>通过分析调试输出，我们可以对哪个线程用于执行流式操作拥有更深入的理解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filter:  b1 [main]</span><br><span class="line">filter:  a2 [ForkJoinPool.commonPool-worker-1]</span><br><span class="line">map:     a2 [ForkJoinPool.commonPool-worker-1]</span><br><span class="line">filter:  c2 [ForkJoinPool.commonPool-worker-3]</span><br><span class="line">map:     c2 [ForkJoinPool.commonPool-worker-3]</span><br><span class="line">filter:  c1 [ForkJoinPool.commonPool-worker-2]</span><br><span class="line">map:     c1 [ForkJoinPool.commonPool-worker-2]</span><br><span class="line">forEach: C2 [ForkJoinPool.commonPool-worker-3]</span><br><span class="line">forEach: A2 [ForkJoinPool.commonPool-worker-1]</span><br><span class="line">map:     b1 [main]</span><br><span class="line">forEach: B1 [main]</span><br><span class="line">filter:  a1 [ForkJoinPool.commonPool-worker-3]</span><br><span class="line">map:     a1 [ForkJoinPool.commonPool-worker-3]</span><br><span class="line">forEach: A1 [ForkJoinPool.commonPool-worker-3]</span><br><span class="line">forEach: C1 [ForkJoinPool.commonPool-worker-2]</span><br></pre></td></tr></table></figure>
<p>就像你看到的那样，并行流使用了所有公共的<code>ForkJoinPool</code>中的可用线程来执行流式操作。在连续的运行中输出可能有所不同，因为所使用的特定线程是非特定的。</p>
<p>让我们通过添加额外的流式操作<code>sort</code>来扩展这个示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.asList(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;c2&quot;</span>, <span class="string">&quot;c1&quot;</span>)</span><br><span class="line">    .parallelStream()</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.format(<span class="string">&quot;filter: %s [%s]\n&quot;</span>,</span><br><span class="line">            s, Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.format(<span class="string">&quot;map: %s [%s]\n&quot;</span>,</span><br><span class="line">            s, Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .sorted((s1, s2) -&gt; &#123;</span><br><span class="line">        System.out.format(<span class="string">&quot;sort: %s &lt;&gt; %s [%s]\n&quot;</span>,</span><br><span class="line">            s1, s2, Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.format(<span class="string">&quot;forEach: %s [%s]\n&quot;</span>,</span><br><span class="line">        s, Thread.currentThread().getName()));</span><br></pre></td></tr></table></figure>
<p>结果起初可能比较奇怪：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filter:  c2 [ForkJoinPool.commonPool-worker-3]</span><br><span class="line">filter:  c1 [ForkJoinPool.commonPool-worker-2]</span><br><span class="line">map:     c1 [ForkJoinPool.commonPool-worker-2]</span><br><span class="line">filter:  a2 [ForkJoinPool.commonPool-worker-1]</span><br><span class="line">map:     a2 [ForkJoinPool.commonPool-worker-1]</span><br><span class="line">filter:  b1 [main]</span><br><span class="line">map:     b1 [main]</span><br><span class="line">filter:  a1 [ForkJoinPool.commonPool-worker-2]</span><br><span class="line">map:     a1 [ForkJoinPool.commonPool-worker-2]</span><br><span class="line">map:     c2 [ForkJoinPool.commonPool-worker-3]</span><br><span class="line">sort:    A2 &lt;&gt; A1 [main]</span><br><span class="line">sort:    B1 &lt;&gt; A2 [main]</span><br><span class="line">sort:    C2 &lt;&gt; B1 [main]</span><br><span class="line">sort:    C1 &lt;&gt; C2 [main]</span><br><span class="line">sort:    C1 &lt;&gt; B1 [main]</span><br><span class="line">sort:    C1 &lt;&gt; C2 [main]</span><br><span class="line">forEach: A1 [ForkJoinPool.commonPool-worker-1]</span><br><span class="line">forEach: C2 [ForkJoinPool.commonPool-worker-3]</span><br><span class="line">forEach: B1 [main]</span><br><span class="line">forEach: A2 [ForkJoinPool.commonPool-worker-2]</span><br><span class="line">forEach: C1 [ForkJoinPool.commonPool-worker-1]</span><br></pre></td></tr></table></figure>
<p><code>sort</code>看起来只在主线程上串行执行。实际上，并行流上的<code>sort</code>在背后使用了Java8中新的方法<code>Arrays.parallelSort()</code>。如<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#parallelSort-T:A-">javadoc</a>所说，这个方法会参照数据长度来决定以串行或并行来执行。</p>
<blockquote>
<p>如果指定数据的长度小于最小粒度，它使用相应的<code>Arrays.sort</code>方法来排序。</p>
</blockquote>
<p>返回上一节中<code>reduce</code>的例子。我们已经发现了组合器函数只在并行流中调用，而不在串行流中调用。让我们来观察实际上涉及到哪个线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; persons = Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Max&quot;</span>, <span class="number">18</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Peter&quot;</span>, <span class="number">23</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Pamela&quot;</span>, <span class="number">23</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;David&quot;</span>, <span class="number">12</span>));</span><br><span class="line"></span><br><span class="line">persons</span><br><span class="line">    .parallelStream()</span><br><span class="line">    .reduce(<span class="number">0</span>,</span><br><span class="line">        (sum, p) -&gt; &#123;</span><br><span class="line">            System.out.format(<span class="string">&quot;accumulator: sum=%s; person=%s [%s]\n&quot;</span>,</span><br><span class="line">                sum, p, Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">return</span> sum += p.age;</span><br><span class="line">        &#125;,</span><br><span class="line">        (sum1, sum2) -&gt; &#123;</span><br><span class="line">            System.out.format(<span class="string">&quot;combiner: sum1=%s; sum2=%s [%s]\n&quot;</span>,</span><br><span class="line">                sum1, sum2, Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>控制台的输出表明，累加器和组合器都在所有可用的线程上并行执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">accumulator: sum=0; person=Pamela; [main]</span><br><span class="line">accumulator: sum=0; person=Max;    [ForkJoinPool.commonPool-worker-3]</span><br><span class="line">accumulator: sum=0; person=David;  [ForkJoinPool.commonPool-worker-2]</span><br><span class="line">accumulator: sum=0; person=Peter;  [ForkJoinPool.commonPool-worker-1]</span><br><span class="line">combiner:    sum1=18; sum2=23;     [ForkJoinPool.commonPool-worker-1]</span><br><span class="line">combiner:    sum1=23; sum2=12;     [ForkJoinPool.commonPool-worker-2]</span><br><span class="line">combiner:    sum1=41; sum2=35;     [ForkJoinPool.commonPool-worker-2]</span><br></pre></td></tr></table></figure>
<p>总之，并行流对拥有大量输入元素的数据流具有极大的性能提升。但是要记住一些并行流的操作，例如<code>reduce</code>和<code>collect</code>需要额外的计算（组合操作），这在串行执行时并不需要。</p>
<p>此外我们已经了解，所有并行流操作都共享相同的JVM相关的公共<code>ForkJoinPool</code>。所以你可能需要避免实现又慢又卡的流式操作，因为它可能会拖慢你应用中严重依赖并行流的其它部分。</p>
<blockquote>
<p>原文：<a href="http://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/">Java 8 Stream Tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java 8 教程</title>
    <url>/posts/a12dc1dc.html</url>
    <content><![CDATA[<h3 id="允许在接口中有默认方法实现">允许在接口中有默认方法实现</h3>
<p>Java 8 允许我们使用default关键字，为接口声明添加非抽象的方法实现。这个特性又被称为<strong>扩展方法</strong>。下面是我们的第一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Formula</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> a)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">double</span> <span class="title function_">sqrt</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在接口Formula中，除了抽象方法caculate以外，还定义了一个默认方法sqrt。Formula的实现类只需要实现抽象方法caculate就可以了。默认方法sqrt可以直接使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Formula</span> <span class="variable">formula</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Formula</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sqrt(a * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">formula.calculate(<span class="number">100</span>);     <span class="comment">// 100.0</span></span><br><span class="line">formula.sqrt(<span class="number">16</span>);           <span class="comment">// 4.0</span></span><br></pre></td></tr></table></figure>
<p>formula对象以匿名对象的形式实现了Formula接口。代码很啰嗦：用了6行代码才实现了一个简单的计算功能：a*100开平方根。我们在下一节会看到，Java 8 还有一种更加优美的方法，能够实现包含单个函数的对象。</p>
<h3 id="Lambda表达式">Lambda表达式</h3>
<p>让我们从最简单的例子开始，来学习如何对一个string列表进行排序。我们首先使用Java 8之前的方法来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;peter&quot;</span>, <span class="string">&quot;anna&quot;</span>, <span class="string">&quot;mike&quot;</span>, <span class="string">&quot;xenia&quot;</span>);</span><br><span class="line"></span><br><span class="line">Collections.sort(names, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>静态工具方法Collections.sort接受一个list，和一个Comparator接口作为输入参数，Comparator的实现类可以对输入的list中的元素进行比较。通常情况下，你可以直接用创建匿名Comparator对象，并把它作为参数传递给sort方法。</p>
<p>除了创建匿名对象以外，Java 8 还提供了一种更简洁的方式，Lambda表达式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>你可以看到，这段代码就比之前的更加简短和易读。但是，它还可以更加简短：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure>
<p>只要一行代码，包含了方法体。你甚至可以连大括号对{}和return关键字都省略不要。不过这还不是最短的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(names, (a, b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure>
<p>Java编译器能够自动识别参数的类型，所以你就可以省略掉类型不写。让我们再深入地研究一下lambda表达式的威力吧。</p>
<h3 id="函数式接口">函数式接口</h3>
<p>Lambda表达式如何匹配Java的类型系统？每一个lambda都能够通过一个特定的接口，与一个给定的类型进行匹配。一个所谓的函数式接口必须要有且仅有一个抽象方法声明。每个与之对应的lambda表达式必须要与抽象方法的声明相匹配。由于默认方法不是抽象的，因此你可以在你的函数式接口里任意添加默认方法。</p>
<p>任意只包含一个抽象方法的接口，我们都可以用来做成lambda表达式。为了让你定义的接口满足要求，你应当在接口前加上@FunctionalInterface 标注。编译器会注意到这个标注，如果你的接口中定义了第二个抽象方法的话，编译器会抛出异常。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Converter</span>&lt;F, T&gt; &#123;</span><br><span class="line">    T <span class="title function_">convert</span><span class="params">(F from)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">converted</span> <span class="operator">=</span> converter.convert(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(converted);    <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<p>注意，如果你不写@FunctionalInterface 标注，程序也是正确的。</p>
<h3 id="方法和构造函数引用">方法和构造函数引用</h3>
<p>上面的代码实例可以通过静态方法引用，使之更加简洁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">converted</span> <span class="operator">=</span> converter.convert(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(converted);   <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<p>Java 8 允许你通过::关键字获取方法或者构造函数的的引用。上面的例子就演示了如何引用一个静态方法。而且，我们还可以对一个对象的方法进行引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Something</span> &#123;</span><br><span class="line">    String <span class="title function_">startsWith</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(s.charAt(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Something</span> <span class="variable">something</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Something</span>();</span><br><span class="line">Converter&lt;String, String&gt; converter = something::startsWith;</span><br><span class="line"><span class="type">String</span> <span class="variable">converted</span> <span class="operator">=</span> converter.convert(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">System.out.println(converted);    <span class="comment">// &quot;J&quot;</span></span><br></pre></td></tr></table></figure>
<p>让我们看看如何使用::关键字引用构造函数。首先我们定义一个示例bean，包含不同的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line"></span><br><span class="line">    Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Person(String firstName, String lastName) &#123;</span><br><span class="line">        <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">        <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们定义一个person工厂接口，用来创建新的person对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PersonFactory</span>&lt;P <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; &#123;</span><br><span class="line">    P <span class="title function_">create</span><span class="params">(String firstName, String lastName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们通过构造函数引用来把所有东西拼到一起，而不是像以前一样，通过手动实现一个工厂来这么做。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PersonFactory&lt;Person&gt; personFactory = Person::<span class="keyword">new</span>;</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> personFactory.create(<span class="string">&quot;Peter&quot;</span>, <span class="string">&quot;Parker&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>我们通过Person::new来创建一个Person类构造函数的引用。Java编译器会自动地选择合适的构造函数来匹配PersonFactory.create函数的签名，并选择正确的构造函数形式。</p>
<h3 id="Lambda的范围">Lambda的范围</h3>
<p>对于lambdab表达式外部的变量，其访问权限的粒度与匿名对象的方式非常类似。你能够访问局部对应的外部区域的局部final变量，以及成员变量和静态变量。</p>
<h4 id="访问局部变量">访问局部变量</h4>
<p>我们可以访问lambda表达式外部的final局部变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line"></span><br><span class="line">stringConverter.convert(<span class="number">2</span>);     <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>但是与匿名对象不同的是，变量num并不需要一定是final。下面的代码依然是合法的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line"></span><br><span class="line">stringConverter.convert(<span class="number">2</span>);     <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>然而，num在编译的时候被隐式地当做final变量来处理。下面的代码就不合法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line">num = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>在lambda表达式内部企图改变num的值也是不允许的。</p>
<h4 id="访问成员变量和静态变量">访问成员变量和静态变量</h4>
<p>与局部变量不同，我们在lambda表达式的内部能获取到对成员变量或静态变量的读写权。这种访问行为在匿名对象里是非常典型的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lambda4</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> outerStaticNum;</span><br><span class="line">    <span class="type">int</span> outerNum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testScopes</span><span class="params">()</span> &#123;</span><br><span class="line">        Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123;</span><br><span class="line">            outerNum = <span class="number">23</span>;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(from);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123;</span><br><span class="line">            outerStaticNum = <span class="number">72</span>;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(from);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="访问默认接口方法">访问默认接口方法</h4>
<p>还记得第一节里面formula的那个例子么？ 接口Formula定义了一个默认的方法sqrt，该方法能够访问formula所有的对象实例，包括匿名对象。这个对lambda表达式来讲则无效。</p>
<p>默认方法无法在lambda表达式内部被访问。因此下面的代码是无法通过编译的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Formula</span> <span class="variable">formula</span> <span class="operator">=</span> (a) -&gt; sqrt( a * <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<h3 id="内置函数式接口">内置函数式接口</h3>
<p>JDK 1.8 API中包含了很多内置的函数式接口。有些是在以前版本的Java中大家耳熟能详的，例如Comparator接口，或者Runnable接口。对这些现成的接口进行实现，可以通过@FunctionalInterface 标注来启用Lambda功能支持。</p>
<p>此外，Java 8 API 还提供了很多新的函数式接口，来降低程序员的工作负担。有些新的接口已经在<a href="https://code.google.com/p/guava-libraries/">Google Guava</a>库中很有名了。如果你对这些库很熟的话，你甚至闭上眼睛都能够想到，这些接口在类库的实现过程中起了多么大的作用。</p>
<h4 id="Predicates">Predicates</h4>
<p>Predicate是一个布尔类型的函数，该函数只有一个输入参数。Predicate接口包含了多种默认方法，用于处理复杂的逻辑动词（and, or，negate）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">predicate.test(<span class="string">&quot;foo&quot;</span>);              <span class="comment">// true</span></span><br><span class="line">predicate.negate().test(<span class="string">&quot;foo&quot;</span>);     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</span><br><span class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</span><br><span class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</span><br></pre></td></tr></table></figure>
<h4 id="Functions">Functions</h4>
<p>Function接口接收一个参数，并返回单一的结果。默认方法可以将多个函数串在一起（compse, andThen）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;</span><br><span class="line">Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);</span><br><span class="line"></span><br><span class="line">backToString.apply(<span class="string">&quot;123&quot;</span>);     <span class="comment">// &quot;123&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="Suppliers">Suppliers</h4>
<p>Supplier接口产生一个给定类型的结果。与Function不同的是，Supplier没有输入参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Supplier&lt;Person&gt; personSupplier = Person::<span class="keyword">new</span>;</span><br><span class="line">personSupplier.get();   <span class="comment">// new Person</span></span><br></pre></td></tr></table></figure>
<h4 id="Consumers">Consumers</h4>
<p>Consumer代表了在一个输入参数上需要进行的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(<span class="string">&quot;Hello, &quot;</span> + p.firstName);</span><br><span class="line">greeter.accept(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Luke&quot;</span>, <span class="string">&quot;Skywalker&quot;</span>));</span><br></pre></td></tr></table></figure>
<h4 id="Comparators">Comparators</h4>
<p>Comparator接口在早期的Java版本中非常著名。Java 8 为这个接口添加了不同的默认方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</span><br><span class="line"></span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Wonderland&quot;</span>);</span><br><span class="line"></span><br><span class="line">comparator.compare(p1, p2);             <span class="comment">// &gt; 0</span></span><br><span class="line">comparator.reversed().compare(p1, p2);  <span class="comment">// &lt; 0</span></span><br></pre></td></tr></table></figure>
<h4 id="Optionals">Optionals</h4>
<p>Optional不是一个函数式接口，而是一个精巧的工具接口，用来防止NullPointerException产生。这个概念在下一节会显得很重要，所以我们在这里快速地浏览一下Optional的工作原理。</p>
<p>Optional是一个简单的值容器，这个值可以是null，也可以是non-null。考虑到一个方法可能会返回一个non-null的值，也可能返回一个空值。为了不直接返回null，我们在Java 8中就返回一个Optional.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; optional = Optional.of(<span class="string">&quot;bam&quot;</span>);</span><br><span class="line"></span><br><span class="line">optional.isPresent();           <span class="comment">// true</span></span><br><span class="line">optional.get();                 <span class="comment">// &quot;bam&quot;</span></span><br><span class="line">optional.orElse(<span class="string">&quot;fallback&quot;</span>);    <span class="comment">// &quot;bam&quot;</span></span><br><span class="line"></span><br><span class="line">optional.ifPresent((s) -&gt; System.out.println(s.charAt(<span class="number">0</span>)));     <span class="comment">// &quot;b&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="Streams">Streams</h3>
<p>java.util.Stream表示了某一种元素的序列，在这些元素上可以进行各种操作。Stream操作可以是中间操作，也可以是完结操作。完结操作会返回一个某种类型的值，而中间操作会返回流对象本身，并且你可以通过多次调用同一个流操作方法来将操作结果串起来（就像StringBuffer的append方法一样————译者注）。Stream是在一个源的基础上创建出来的，例如java.util.Collection中的list或者set（map不能作为Stream的源）。Stream操作往往可以通过顺序或者并行两种方式来执行。</p>
<p>我们先了解一下序列流。首先，我们通过string类型的list的形式创建示例数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stringCollection = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">stringCollection.add(<span class="string">&quot;ddd2&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;aaa2&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;bbb1&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;aaa1&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;bbb3&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;bbb2&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;ddd1&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>Java 8中的Collections类的功能已经有所增强，你可以之直接通过调用Collections.stream()或者Collection.parallelStream()方法来创建一个流对象。下面的章节会解释这个最常用的操作。</p>
<h4 id="Filter">Filter</h4>
<p>Filter接受一个predicate接口类型的变量，并将所有流对象中的元素进行过滤。该操作是一个中间操作，因此它允许我们在返回结果的基础上再进行其他的流操作（forEach）。ForEach接受一个function接口类型的变量，用来执行对每一个元素的操作。ForEach是一个中止操作。它不返回流，所以我们不能再调用其他的流操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .filter((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;aaa2&quot;, &quot;aaa1&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="Sorted">Sorted</h4>
<p>Sorted是一个中间操作，能够返回一个排过序的流对象的视图。流对象中的元素会默认按照自然顺序进行排序，除非你自己指定一个Comparator接口来改变排序规则。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .sorted()</span><br><span class="line">    .filter((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;aaa1&quot;, &quot;aaa2&quot;</span></span><br></pre></td></tr></table></figure>
<p>一定要记住，sorted只是创建一个流对象排序的视图，而不会改变原来集合中元素的顺序。原来string集合中的元素顺序是没有改变的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(stringCollection);</span><br><span class="line"><span class="comment">// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</span></span><br></pre></td></tr></table></figure>
<h4 id="Map">Map</h4>
<p>map是一个对于流对象的中间操作，通过给定的方法，它能够把流对象中的每一个元素对应到另外一个对象上。下面的例子就演示了如何把每个string都转换成大写的string. 不但如此，你还可以把每一种对象映射成为其他类型。对于带泛型结果的流对象，具体的类型还要由传递给map的泛型方法来决定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .sorted((a, b) -&gt; b.compareTo(a))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;DDD2&quot;, &quot;DDD1&quot;, &quot;CCC&quot;, &quot;BBB3&quot;, &quot;BBB2&quot;, &quot;AAA2&quot;, &quot;AAA1&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="Match">Match</h4>
<p>匹配操作有多种不同的类型，都是用来判断某一种规则是否与流对象相互吻合的。所有的匹配操作都是终结操作，只返回一个boolean类型的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">anyStartsWithA</span> <span class="operator">=</span></span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .anyMatch((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(anyStartsWithA);      <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">allStartsWithA</span> <span class="operator">=</span></span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .allMatch((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(allStartsWithA);      <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">noneStartsWithZ</span> <span class="operator">=</span></span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .noneMatch((s) -&gt; s.startsWith(<span class="string">&quot;z&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(noneStartsWithZ);      <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="Count">Count</h4>
<p>Count是一个终结操作，它的作用是返回一个数值，用来标识当前流对象中包含的元素数量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">startsWithB</span> <span class="operator">=</span></span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .filter((s) -&gt; s.startsWith(<span class="string">&quot;b&quot;</span>))</span><br><span class="line">        .count();</span><br><span class="line"></span><br><span class="line">System.out.println(startsWithB);    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h4 id="Reduce">Reduce</h4>
<p>该操作是一个终结操作，它能够通过某一个方法，对元素进行削减操作。该操作的结果会放在一个Optional变量里返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; reduced =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .sorted()</span><br><span class="line">        .reduce((s1, s2) -&gt; s1 + <span class="string">&quot;#&quot;</span> + s2);</span><br><span class="line"></span><br><span class="line">reduced.ifPresent(System.out::println);</span><br><span class="line"><span class="comment">// &quot;aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="Parallel-Streams">Parallel Streams</h3>
<p>像上面所说的，流操作可以是顺序的，也可以是并行的。顺序操作通过单线程执行，而并行操作则通过多线程执行。</p>
<p>下面的例子就演示了如何使用并行流进行操作来提高运行效率，代码非常简单。</p>
<p>首先我们创建一个大的list，里面的元素都是唯一的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line">List&lt;String&gt; values = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(max);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">    <span class="type">UUID</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID();</span><br><span class="line">    values.add(uuid.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们测量一下对这个集合进行排序所使用的时间。</p>
<h4 id="顺序排序">顺序排序</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> values.stream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">millis</span> <span class="operator">=</span> TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;sequential sort took: %d ms&quot;</span>, millis));</span><br><span class="line"></span><br><span class="line"><span class="comment">// sequential sort took: 899 ms</span></span><br></pre></td></tr></table></figure>
<h4 id="并行排序">并行排序</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> values.parallelStream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">millis</span> <span class="operator">=</span> TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;parallel sort took: %d ms&quot;</span>, millis));</span><br><span class="line"></span><br><span class="line"><span class="comment">// parallel sort took: 472 ms</span></span><br></pre></td></tr></table></figure>
<p>如你所见，所有的代码段几乎都相同，唯一的不同就是把stream()改成了parallelStream(), 结果并行排序快了50%。</p>
<h3 id="Map-2">Map</h3>
<p>正如前面已经提到的那样，map是不支持流操作的。而更新后的map现在则支持多种实用的新方法，来完成常规的任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    map.putIfAbsent(i, <span class="string">&quot;val&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map.forEach((id, val) -&gt; System.out.println(val));</span><br></pre></td></tr></table></figure>
<p>上面的代码风格是完全自解释的：putIfAbsent避免我们将null写入；forEach接受一个消费者对象，从而将操作实施到每一个map中的值上。</p>
<p>下面的这个例子展示了如何使用函数来计算map的编码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.computeIfPresent(<span class="number">3</span>, (num, val) -&gt; val + num);</span><br><span class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></span><br><span class="line"></span><br><span class="line">map.computeIfPresent(<span class="number">9</span>, (num, val) -&gt; <span class="literal">null</span>);</span><br><span class="line">map.containsKey(<span class="number">9</span>);     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">map.computeIfAbsent(<span class="number">23</span>, num -&gt; <span class="string">&quot;val&quot;</span> + num);</span><br><span class="line">map.containsKey(<span class="number">23</span>);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">map.computeIfAbsent(<span class="number">3</span>, num -&gt; <span class="string">&quot;bam&quot;</span>);</span><br><span class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></span><br></pre></td></tr></table></figure>
<p>接下来，我们将学习，当给定一个key值时，如何把一个实例从对应的key中移除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.remove(<span class="number">3</span>, <span class="string">&quot;val3&quot;</span>);</span><br><span class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></span><br><span class="line"></span><br><span class="line">map.remove(<span class="number">3</span>, <span class="string">&quot;val33&quot;</span>);</span><br><span class="line">map.get(<span class="number">3</span>);             <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>另一个有用的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.getOrDefault(<span class="number">42</span>, <span class="string">&quot;not found&quot;</span>);  <span class="comment">// not found</span></span><br></pre></td></tr></table></figure>
<p>将map中的实例合并也是非常容易的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.merge(<span class="number">9</span>, <span class="string">&quot;val9&quot;</span>, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(<span class="number">9</span>);             <span class="comment">// val9</span></span><br><span class="line"></span><br><span class="line">map.merge(<span class="number">9</span>, <span class="string">&quot;concat&quot;</span>, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(<span class="number">9</span>);             <span class="comment">// val9concat</span></span><br></pre></td></tr></table></figure>
<p>合并操作先看map中是否没有特定的key/value存在，如果是，则把key/value存入map，否则merging函数就会被调用，对现有的数值进行修改。</p>
<h3 id="时间日期API">时间日期API</h3>
<p>Java 8 包含了全新的时间日期API，这些功能都放在了java.time包下。新的时间日期API是基于Joda-Time库开发的，但是也不尽相同。下面的例子就涵盖了大多数新的API的重要部分。</p>
<h4 id="Clock">Clock</h4>
<p>Clock提供了对当前时间和日期的访问功能。Clock是对当前时区敏感的，并可用于替代System.currentTimeMillis()方法来获取当前的毫秒时间。当前时间线上的时刻可以用Instance类来表示。Instance也能够用于创建原先的java.util.Date对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Clock</span> <span class="variable">clock</span> <span class="operator">=</span> Clock.systemDefaultZone();</span><br><span class="line"><span class="type">long</span> <span class="variable">millis</span> <span class="operator">=</span> clock.millis();</span><br><span class="line"></span><br><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> clock.instant();</span><br><span class="line"><span class="type">Date</span> <span class="variable">legacyDate</span> <span class="operator">=</span> Date.from(instant);   <span class="comment">// legacy java.util.Date</span></span><br></pre></td></tr></table></figure>
<h4 id="Timezones">Timezones</h4>
<p>时区类可以用一个ZoneId来表示。时区类的对象可以通过静态工厂方法方便地获取。时区类还定义了一个偏移量，用来在当前时刻或某时间与目标时区时间之间进行转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(ZoneId.getAvailableZoneIds());</span><br><span class="line"><span class="comment">// prints all available timezone ids</span></span><br><span class="line"></span><br><span class="line"><span class="type">ZoneId</span> <span class="variable">zone1</span> <span class="operator">=</span> ZoneId.of(<span class="string">&quot;Europe/Berlin&quot;</span>);</span><br><span class="line"><span class="type">ZoneId</span> <span class="variable">zone2</span> <span class="operator">=</span> ZoneId.of(<span class="string">&quot;Brazil/East&quot;</span>);</span><br><span class="line">System.out.println(zone1.getRules());</span><br><span class="line">System.out.println(zone2.getRules());</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZoneRules[currentStandardOffset=+01:00]</span></span><br><span class="line"><span class="comment">// ZoneRules[currentStandardOffset=-03:00]</span></span><br></pre></td></tr></table></figure>
<h4 id="LocalTime">LocalTime</h4>
<p>本地时间类表示一个没有指定时区的时间，例如，10 p.m.或者17：30:15，下面的例子会用上面的例子定义的时区创建两个本地时间对象。然后我们会比较两个时间，并计算它们之间的小时和分钟的不同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalTime</span> <span class="variable">now1</span> <span class="operator">=</span> LocalTime.now(zone1);</span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">now2</span> <span class="operator">=</span> LocalTime.now(zone2);</span><br><span class="line"></span><br><span class="line">System.out.println(now1.isBefore(now2));  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">hoursBetween</span> <span class="operator">=</span> ChronoUnit.HOURS.between(now1, now2);</span><br><span class="line"><span class="type">long</span> <span class="variable">minutesBetween</span> <span class="operator">=</span> ChronoUnit.MINUTES.between(now1, now2);</span><br><span class="line"></span><br><span class="line">System.out.println(hoursBetween);       <span class="comment">// -3</span></span><br><span class="line">System.out.println(minutesBetween);     <span class="comment">// -239</span></span><br></pre></td></tr></table></figure>
<p>LocalTime是由多个工厂方法组成，其目的是为了简化对时间对象实例的创建和操作，包括对时间字符串进行解析的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalTime</span> <span class="variable">late</span> <span class="operator">=</span> LocalTime.of(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line">System.out.println(late);       <span class="comment">// 23:59:59</span></span><br><span class="line"></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">germanFormatter</span> <span class="operator">=</span></span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofLocalizedTime(FormatStyle.SHORT)</span><br><span class="line">        .withLocale(Locale.GERMAN);</span><br><span class="line"></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">leetTime</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;13:37&quot;</span>, germanFormatter);</span><br><span class="line">System.out.println(leetTime);   <span class="comment">// 13:37</span></span><br></pre></td></tr></table></figure>
<h4 id="LocalDate">LocalDate</h4>
<p>本地时间表示了一个独一无二的时间，例如：2014-03-11。这个时间是不可变的，与LocalTime是同源的。下面的例子演示了如何通过加减日，月，年等指标来计算新的日期。记住，每一次操作都会返回一个新的时间对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">tomorrow</span> <span class="operator">=</span> today.plus(<span class="number">1</span>, ChronoUnit.DAYS);</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">yesterday</span> <span class="operator">=</span> tomorrow.minusDays(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">independenceDay</span> <span class="operator">=</span> LocalDate.of(<span class="number">2014</span>, Month.JULY, <span class="number">4</span>);</span><br><span class="line"><span class="type">DayOfWeek</span> <span class="variable">dayOfWeek</span> <span class="operator">=</span> independenceDay.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek);    <span class="comment">// FRIDAY&lt;span style=&quot;font-family: Georgia, &#x27;Times New Roman&#x27;, &#x27;Bitstream Charter&#x27;, Times, serif; font-size: 13px; line-height: 19px;&quot;&gt;Parsing a LocalDate from a string is just as simple as parsing a LocalTime:&lt;/span&gt;</span></span><br></pre></td></tr></table></figure>
<p>解析字符串并形成LocalDate对象，这个操作和解析LocalTime一样简单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">germanFormatter</span> <span class="operator">=</span></span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofLocalizedDate(FormatStyle.MEDIUM)</span><br><span class="line">        .withLocale(Locale.GERMAN);</span><br><span class="line"></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">xmas</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;24.12.2014&quot;</span>, germanFormatter);</span><br><span class="line">System.out.println(xmas);   <span class="comment">// 2014-12-24</span></span><br></pre></td></tr></table></figure>
<h4 id="LocalDateTime">LocalDateTime</h4>
<p>LocalDateTime表示的是日期-时间。它将刚才介绍的日期对象和时间对象结合起来，形成了一个对象实例。LocalDateTime是不可变的，与LocalTime和LocalDate的工作原理相同。我们可以通过调用方法来获取日期时间对象中特定的数据域。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">sylvester</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2014</span>, Month.DECEMBER, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">DayOfWeek</span> <span class="variable">dayOfWeek</span> <span class="operator">=</span> sylvester.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek);      <span class="comment">// WEDNESDAY</span></span><br><span class="line"></span><br><span class="line"><span class="type">Month</span> <span class="variable">month</span> <span class="operator">=</span> sylvester.getMonth();</span><br><span class="line">System.out.println(month);          <span class="comment">// DECEMBER</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">minuteOfDay</span> <span class="operator">=</span> sylvester.getLong(ChronoField.MINUTE_OF_DAY);</span><br><span class="line">System.out.println(minuteOfDay);    <span class="comment">// 1439</span></span><br></pre></td></tr></table></figure>
<p>如果再加上的时区信息，LocalDateTime能够被转换成Instance实例。Instance能够被转换成以前的java.util.Date对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> sylvester</span><br><span class="line">        .atZone(ZoneId.systemDefault())</span><br><span class="line">        .toInstant();</span><br><span class="line"></span><br><span class="line"><span class="type">Date</span> <span class="variable">legacyDate</span> <span class="operator">=</span> Date.from(instant);</span><br><span class="line">System.out.println(legacyDate);     <span class="comment">// Wed Dec 31 23:59:59 CET 2014</span></span><br></pre></td></tr></table></figure>
<p>格式化日期-时间对象就和格式化日期对象或者时间对象一样。除了使用预定义的格式以外，我们还可以创建自定义的格式化对象，然后匹配我们自定义的格式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span></span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofPattern(<span class="string">&quot;MMM dd, yyyy - HH:mm&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">parsed</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;Nov 03, 2014 - 07:13&quot;</span>, formatter);</span><br><span class="line"><span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> formatter.format(parsed);</span><br><span class="line">System.out.println(string);     <span class="comment">// Nov 03, 2014 - 07:13</span></span><br></pre></td></tr></table></figure>
<p>不同于java.text.NumberFormat，新的DateTimeFormatter类是不可变的，也是线程安全的。</p>
<p>更多的细节，请看<a href="http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html">这里</a></p>
<h3 id="注解">注解</h3>
<p>Java 8中的注解是可重复的。让我们直接深入看看例子，弄明白它是什么意思。</p>
<p>首先，我们定义一个包装注解，它包括了一个实际注解的数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@interface</span> Hints &#123;</span><br><span class="line">    Hint[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repeatable(Hints.class)</span></span><br><span class="line"><span class="meta">@interface</span> Hint &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要在前面加上注解名：@Repeatable，Java 8 允许我们对同一类型使用多重注解，</p>
<p>变体1：使用注解容器（老方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Hints(&#123;@Hint(&quot;hint1&quot;), @Hint(&quot;hint2&quot;)&#125;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>变体2：使用可重复注解（新方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Hint(&quot;hint1&quot;)</span></span><br><span class="line"><span class="meta">@Hint(&quot;hint2&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>使用变体2，Java编译器能够在内部自动对@Hint进行设置。这对于通过反射来读取注解信息来说，是非常重要的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Hint</span> <span class="variable">hint</span> <span class="operator">=</span> Person.class.getAnnotation(Hint.class);</span><br><span class="line">System.out.println(hint);                   <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="type">Hints</span> <span class="variable">hints1</span> <span class="operator">=</span> Person.class.getAnnotation(Hints.class);</span><br><span class="line">System.out.println(hints1.value().length);  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);</span><br><span class="line">System.out.println(hints2.length);          <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>尽管我们绝对不会在Person类上声明@Hints注解，但是它的信息仍然可以通过getAnnotation(Hints.class)来读取。并且，getAnnotationsByType方法会更方便，因为它赋予了所有@Hints注解标注的方法直接的访问权限。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="http://winterbe.com/posts/2014/03/16/java-8-tutorial/">Java 8 Tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>使用Jieba进行中文词性标注</title>
    <url>/posts/99f1d29f.html</url>
    <content><![CDATA[<h1>词性</h1>
<p>词性指以词的特点作为划分词类的根据。现代汉语的词可以分为两类14种词性。</p>
<h1>常见词性分类</h1>
<p>词性分类又叫词性标注(Part-Of-Speech tag, POS-tag),常见的词性标准类型如下：</p>
<ol>
<li class="lvl-3">
<p>名词</p>
<ul class="lvl-2">
<li class="lvl-6">n 名词</li>
<li class="lvl-6">nr 人名</li>
<li class="lvl-6">nr1 汉语姓氏</li>
<li class="lvl-6">nr2 汉语名字</li>
<li class="lvl-6">nrj 日语人名</li>
<li class="lvl-6">nrf 音译人名</li>
<li class="lvl-6">ns 地名</li>
<li class="lvl-6">nsf 音译地名</li>
<li class="lvl-6">nt 机构团体名</li>
<li class="lvl-6">nz 其它专名</li>
<li class="lvl-6">nl 名词性惯用语</li>
<li class="lvl-6">ng 名词性语素</li>
</ul>
</li>
<li class="lvl-3">
<p>时间词</p>
<ul class="lvl-2">
<li class="lvl-6">t 时间词</li>
<li class="lvl-6">tg 时间词性语素</li>
</ul>
</li>
<li class="lvl-3">
<p>处所词</p>
<ul class="lvl-2">
<li class="lvl-6">s 处所词 (在公司，在学校)</li>
</ul>
</li>
<li class="lvl-3">
<p>方位词</p>
<ul class="lvl-2">
<li class="lvl-6">f 方位词</li>
</ul>
</li>
<li class="lvl-3">
<p>动词</p>
<ul class="lvl-2">
<li class="lvl-6">v 动词</li>
<li class="lvl-6">vd 副动词</li>
<li class="lvl-6">vn 名动词</li>
<li class="lvl-6">vshi 动词“是”</li>
<li class="lvl-6">vyou 动词“有”</li>
<li class="lvl-6">vf 趋向动词</li>
<li class="lvl-6">vx 形式动词</li>
<li class="lvl-6">vi 不及物动词（内动词）</li>
<li class="lvl-6">vl 动词性惯用语</li>
<li class="lvl-6">vg 动词性语素</li>
</ul>
</li>
<li class="lvl-3">
<p>形容词</p>
<ul class="lvl-2">
<li class="lvl-6">a 形容词</li>
<li class="lvl-6">ad 副形词</li>
<li class="lvl-6">an 名形词</li>
<li class="lvl-6">ag 形容词性语素</li>
<li class="lvl-6">al 形容词性惯用语</li>
</ul>
</li>
<li class="lvl-3">
<p>区别词</p>
<ul class="lvl-2">
<li class="lvl-6">b 区别词</li>
<li class="lvl-6">bl 区别词性惯用语</li>
</ul>
</li>
<li class="lvl-3">
<p>状态词</p>
<ul class="lvl-2">
<li class="lvl-6">z 状态词</li>
</ul>
</li>
<li class="lvl-3">
<p>代词</p>
<ul class="lvl-2">
<li class="lvl-6">r 代词</li>
<li class="lvl-6">rr 人称代词</li>
<li class="lvl-6">rz 指示代词</li>
<li class="lvl-6">rzt 时间指示代词</li>
<li class="lvl-6">rzs 处所指示代词</li>
<li class="lvl-6">rzv 谓词性指示代词</li>
<li class="lvl-6">ry 疑问代词</li>
<li class="lvl-6">ryt 时间疑问代词</li>
<li class="lvl-6">rys 处所疑问代词</li>
<li class="lvl-6">ryv 谓词性疑问代词</li>
<li class="lvl-6">rg 代词性语素</li>
</ul>
</li>
<li class="lvl-4">
<p>数词</p>
<ul class="lvl-2">
<li class="lvl-6">m 数词</li>
<li class="lvl-6">mq 数量词</li>
</ul>
</li>
<li class="lvl-4">
<p>量词</p>
<ul class="lvl-2">
<li class="lvl-6">q 量词</li>
<li class="lvl-6">qv 动量词</li>
<li class="lvl-6">qt 时量词</li>
</ul>
</li>
<li class="lvl-4">
<p>副词</p>
<ul class="lvl-2">
<li class="lvl-6">d 副词</li>
</ul>
</li>
<li class="lvl-4">
<p>介词</p>
<ul class="lvl-2">
<li class="lvl-6">p 介词</li>
<li class="lvl-6">pba 介词“把”</li>
<li class="lvl-6">pbei 介词“被”</li>
</ul>
</li>
<li class="lvl-4">
<p>连词</p>
<ul class="lvl-2">
<li class="lvl-6">c 连词</li>
<li class="lvl-6">cc 并列连词</li>
</ul>
</li>
</ol>
<h1>使用Jieba词性分类</h1>
<p>Jieba下进行词性分类非常简便。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">seg_lig = jieba.posseg.cut(text)</span><br><span class="line">for w,tag in seg_lig:</span><br><span class="line">    print &quot;%s /%s&quot; % (w,tag)</span><br></pre></td></tr></table></figure>
<p>以经典句子为例，“我爱北京天安门“，词性分类的结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我 /r</span><br><span class="line">爱 /v</span><br><span class="line">北京 /ns</span><br><span class="line">天安门 /ns</span><br></pre></td></tr></table></figure>
<p>使用一个稍微复杂的例子。</p>
<blockquote></blockquote>
<p>据半岛电视台援引叙利亚国家电视台称，叙利亚已经对美国、英国、法国的空袭进行了反击。据介绍，在叙军武器库中，对西方最具威慑力的当属各型战术地对地弹道导弹。尽管美英法是利用巡航导弹等武器发动远程空袭，但叙军要对等还击却几乎是“不可能完成的任务”。目前叙军仍能作战的战机仍是老旧的苏制米格-29、米格-23、米格-21战斗机和苏-22、苏-24轰炸机</p>
<p>由于文字较多，使用分行显示会十分乱，我们稍微修改代码，让分词后的词性标注结果紧跟着原单词。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">seg_lig = jieba.posseg.cut(text)</span><br><span class="line">print &quot; &quot;.join([&quot;%s /%s&quot; % (w,tag) for w,tag in seg_lig])</span><br></pre></td></tr></table></figure>
<p>分词的结果如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;据 /p 半岛 /n 电视台 /n 援引 /vn 叙利亚 /ns 国家 /n 电视台 /n 称 /v ， /x 叙利亚 /ns 已经 /d 对 /p 美国 /ns 、 /x 英国 /ns 、 /x 法国 /ns 的 /uj 空袭 /v 进行 /v 了 /ul 反击 /v 。 /x 据介绍 /n ， /x 在 /p 叙军 /n 武器库 /n 中 /f ， /x 对 /p 西方 /s 最 /d 具 /v 威慑力 /n 的 /uj 当属 /n 各型 /r 战术 /n 地对地 /n 弹道导弹 /n 。  </span><br><span class="line">尽管 /c 美英 /nz 法 /j 是 /v 利用 /n 巡航导弹 /n 等 /u 武器 /n 发动 /vn 远程 /n 空袭 /v ， /x 但 /c 叙军 /n 要 /v 对 /p 等 /u 还击 /v 却 /d 几乎 /d 是 /v “ /x 不 /d 可能 /v 完成 /v 的 /uj 任务 /n ” /x 。 /x 目前 /t 叙军 /n 仍 /d 能 /v 作战 /v 的 /uj 战机 /n 仍 /d 是 /v 老 /a 旧 /a 的 /uj 苏制 /n 米格 /nrt - /x 29 /m 、 /x 米格 /nrt - /x 23 /m 、 /x 米格 /nrt - /x 21 /m 战斗机 /n 和 /c 苏 /ns - /x 22 /m 、 /x 苏 /j - /x 24 /m 轰炸机 /n ， /x 它们 /r 在 /p 现代化 /vn 的 /uj 西方 /s 空军 /n 面前 /f 难 /a 有 /v 自保 /vn 之 /u 力 /n ， /x 因此 /c 叙军 /n 的 /uj 远程 /n 反击 /v 只能 /v 依靠 /v 另 /r 一个 /m 撒手锏 /n — /x — /x 地对地 /n 战术 /n 弹道导弹 /n 。</span><br></pre></td></tr></table></figure>
<h1>参考文献</h1>
<blockquote>
<p>原文：<a href="https://github.com/duoergun0729/nlp">https://github.com/duoergun0729/nlp</a></p>
</blockquote>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Word2Vec模型和Doc2Vec模型</title>
    <url>/posts/acc90b20.html</url>
    <content><![CDATA[<h2 id="Word2Vec模型">Word2Vec模型</h2>
<p>Word2Vec是Google在2013年开源的一款将词表征为实数值向量的高效工具，采用的模型有CBOW(Continuous Bag-Of-Words，即连续的词袋模型)和Skip-Gram 两种。Word2Vec通过训练，可以把对文本内容的处理简化为K维向量空间中的向量运算，而向量空间上的相似度可以用来表示文本语义上的相似度。因此，Word2Vec 输出的词向量可以被用来做很多NLP相关的工作，比如聚类、找同义词、词性分析等等。<br>
<img src="/img/picture/Word2Vec%E6%A8%A1%E5%9E%8B%E5%92%8CDoc2Vec%E6%A8%A1%E5%9E%8B-%E5%9B%BE1.png" alt="CBOW和Skip-gram原理图"></p>
<p>CBOW模型能够根据输入周围n-1个词来预测出这个词本身，而Skip-gram模型能够根据词本身来预测周围有哪些词。也就是说，CBOW模型的输入是某个词A周围的n个单词的词向量之和，输出是词A本身的词向量，而Skip-gram模型的输入是词A本身，输出是词A周围的n个单词的词向量。<br>
Word2Vec最常用的开源实现之一就是gensim，网址为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://radimrehurek.com/gensim/</span><br></pre></td></tr></table></figure>
<p>gensim的安装非常简单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install --upgrade gensim</span><br></pre></td></tr></table></figure>
<p>gensim的使用非常简洁，加载数据和训练数据可以合并，训练好模型后就可以按照单词获取对应的向量表示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sentences = [[&#x27;first&#x27;, &#x27;sentence&#x27;], [&#x27;second&#x27;, &#x27;sentence&#x27;]]</span><br><span class="line">model = gensim.models.Word2Vec(sentences, min_count=1)</span><br><span class="line">print model[&#x27;first&#x27;] </span><br></pre></td></tr></table></figure>
<p>其中Word2Vec有很多可以影响训练速度和质量的参数。第一个参数可以对字典做截断，少于min_count次数的单词会被丢弃掉, 默认值为5：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">model = Word2Vec(sentences, min_count=10)</span><br></pre></td></tr></table></figure>
<p>另外一个是神经网络的隐藏层的单元数，推荐值为几十到几百。事实上Word2Vec参数的个数也与神经网络的隐藏层的单元数相同，比如size=200，那么训练得到的Word2Vec参数个数也是200：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">model = Word2Vec(sentences, size=200)</span><br></pre></td></tr></table></figure>
<p>以处理IMDB数据集为例，初始化Word2Vec对象，设置神经网络的隐藏层的单元数为200，生成的词向量的维度也与神经网络的隐藏层的单元数相同。设置处理的窗口大小为8个单词，出现少于10次数的单词会被丢弃掉，迭代计算次数为10次，同时并发线程数与当前计算机的cpu个数相同：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">model=gensim.models.Word2Vec(size=200, window=8, min_count=10, iter=10, workers=cores)</span><br></pre></td></tr></table></figure>
<p>其中当前计算机的cpu个数可以使用multiprocessing获取：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cores=multiprocessing.cpu_count()</span><br></pre></td></tr></table></figure>
<p>创建字典并开始训练获取Word2Vec。gensim的官方文档中强调增加训练次数可以提高生成的Word2Vec的质量，可以通过设置epochs参数来提高训练次数，默认的训练次数为5：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x=x_train+x_test</span><br><span class="line">model.build_vocab(x)</span><br><span class="line">model.train(x, total_examples=model.corpus_count, epochs=model.iter)</span><br></pre></td></tr></table></figure>
<p>经过训练后，Word2Vec会以字典的形式保存在model对象中，可以使用类似字典的方式直接访问获取，比如获取单词“love”的Word2Vec就可以使用如下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">model[“love”]</span><br></pre></td></tr></table></figure>
<p>Word2Vec的维度与之前设置的神经网络的隐藏层的单元数相同为200，也就是说是一个长度为200的一维向量。通过遍历一段英文，逐次获取每个单词对应的Word2Vec，连接起来就可以获得该英文段落对应的Word2Vec：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def getVecsByWord2Vec(model, corpus, size):</span><br><span class="line">    x=[]</span><br><span class="line">    for text in corpus:</span><br><span class="line">        xx = []</span><br><span class="line">        for i, vv in enumerate(text):</span><br><span class="line">            try:</span><br><span class="line">                xx.append(model[vv].reshape((1,size)))</span><br><span class="line">            except KeyError:</span><br><span class="line">                continue</span><br><span class="line">        x = np.concatenate(xx)</span><br><span class="line">    x=np.array(x, dtype=&#x27;float&#x27;)</span><br><span class="line">    return x</span><br></pre></td></tr></table></figure>
<p>需要注意的是，出于性能的考虑，我们将出现少于10次数的单词会被丢弃掉，所以存在这种情况，就是一部分单词找不到对应的Word2Vec，所以需要捕捉这个异常，通常使用python的KeyError异常捕捉即可。基于上述的Word2Vec的方法，Quoc Le 和Tomas Mikolov又给出了Doc2Vec的训练方法。如下图所示，其原理与Word2Vec相同，分为Distributed Memory (DM) 和Distributed Bag of Words (DBOW)。</p>
<p><img src="/img/picture/NLP%E4%B9%8BWord2Vec%E6%A8%A1%E5%9E%8B%E5%92%8CDoc2Vec%E6%A8%A1%E5%9E%8B-%E5%9B%BE2.png" alt="DM和DBOW原理图"></p>
<p>以处理IMDB数据集为例，初始化Doc2Vec对象，设置神经网络的隐藏层的单元数为200，生成的词向量的维度也与神经网络的隐藏层的单元数相同。设置处理的窗口大小为8个单词，出现少于10次数的单词会被丢弃掉，迭代计算次数为10次，同时并发线程数与当前计算机的cpu个数相同：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">model=Doc2Vec(dm=0, dbow_words=1, size=max_features, window=8, min_count=10, iter=10, workers=cores)</span><br></pre></td></tr></table></figure>
<p>其中需要强调的是，dm为使用的算法，默认为1，表明使用DM算法，设置为0表明使用DBOW算法，通常使用默认配置即可，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">model = gensim.models.Doc2Vec.Doc2Vec(size=50, min_count=2, iter=10)</span><br></pre></td></tr></table></figure>
<h2 id="Doc2Vec">Doc2Vec</h2>
<p>与Word2Vec不同的地方是，Doc2Vec处理的每个英文段落，需要使用一个唯一的标识标记，并且使用一种特殊定义的数据格式保存需要处理的英文段落，这种数据格式定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SentimentDocument = namedtuple(&#x27;SentimentDocument&#x27;, &#x27;words tags&#x27;)</span><br></pre></td></tr></table></figure>
<p>其中SentimentDocument可以理解为这种格式的名称，也可以理解为这种对象的名称，words会保存英文段落，并且是以单词和符合列表的形式保存，tags就是我们说的保存的唯一标识。最简单的一种实现就是依次给每个英文段落编号，训练数据集的标记为“TRAIN_数字”，训练数据集的标记为“TEST_数字”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def labelizeReviews(reviews, label_type):</span><br><span class="line">    labelized = []</span><br><span class="line">    for i, v in enumerate(reviews):</span><br><span class="line">        label = &#x27;%s_%s&#x27; % (label_type, i)</span><br><span class="line">        labelized.append(SentimentDocument(v, [label]))</span><br><span class="line">    return labelized</span><br></pre></td></tr></table></figure>
<p>创建字典并开始训练获取Doc2Vec。与Word2Vec的情况一样，gensim的官方文档中强调增加训练次数可以提高生成的Doc2Vec的质量，可以通过设置epochs参数来提高训练次数，默认的训练次数为5：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x=x_train+x_test</span><br><span class="line">model.build_vocab(x)</span><br><span class="line">model.train(x, total_examples=model.corpus_count, epochs=model.iter)</span><br></pre></td></tr></table></figure>
<p>经过训练后，Doc2Vec会以字典的形式保存在model对象中，可以使用类似字典的方式直接访问获取，比如获取段落“I love tensorflow”的Doc2Vec就可以使用如下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">model.docvecs[”I love tensorflow”]</span><br></pre></td></tr></table></figure>
<p>一个典型的doc2ver展开为向量形式，内容如下所示，为了显示方便只展示了其中一部分维度的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array([ 0.02664499,  0.00475204, -0.03981256,  0.03796276, -0.03206162,</span><br><span class="line">        0.10963056, -0.04897128,  0.00151982, -0.03258783,  0.04711508,</span><br><span class="line">       -0.00667155, -0.08523653, -0.02975186,  0.00166316,  0.01915652,</span><br><span class="line">       -0.03415785, -0.05794788,  0.05110953,  0.01623618, -0.00512495,</span><br><span class="line">       -0.06385455, -0.0151557 ,  0.00365376,  0.03015811,  0.0229462 ,</span><br><span class="line">        0.03176891,  0.01117626, -0.00743352,  0.02030453, -0.05072152,</span><br><span class="line">       -0.00498496,  0.00151227,  0.06122205, -0.01811385, -0.01715777,</span><br><span class="line">        0.04883198,  0.03925886, -0.03568915,  0.00805744,  0.01654406,</span><br><span class="line">       -0.05160677,  0.0119908 , -0.01527433,  0.02209963, -0.10316766,</span><br><span class="line">       -0.01069367, -0.02432527,  0.00761799,  0.02763799, -0.04288232], dtype=float32)</span><br></pre></td></tr></table></figure>
<p>Doc2Vec的维度与之前设置的神经网络的隐藏层的单元数相同为200，也就是说是一个长度为200的一维向量。以英文段落为单位，通过遍历训练数据集和测试数据集，逐次获取每个英文段落对应的Doc2Vec，这里的英文段落就可以理解为数据集中针对电影的一段评价：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def getVecs(model, corpus, size):</span><br><span class="line">    vecs = [np.array(model.docvecs[z.tags[0]]).reshape((1, size)) for z in corpus]</span><br><span class="line">    return np.array(np.concatenate(vecs),dtype=&#x27;float&#x27;)</span><br></pre></td></tr></table></figure>
<p>训练Word2Vec和Doc2Vec是非常费时费力的过程，调试阶段会频繁更换分类算法以及修改分类算法参数调优，为了提高效率，可以把之前训练得到的Word2Vec和Doc2Vec模型保存成文件形式，以Doc2Vec为例，使用model.save函数把训练后的结果保存在本地硬盘上，运行程序时，在初始化Doc2Vec对象之前，可以先判断本地硬盘是否存在模型文件，如果存在就直接读取模型文件初始化Doc2Vec对象，反之则需要训练数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if os.path.exists(doc2ver_bin):</span><br><span class="line">    print &quot;Find cache file %s&quot; % doc2ver_bin</span><br><span class="line">    model=Doc2Vec.load(doc2ver_bin)</span><br><span class="line">else:</span><br><span class="line">    model=Doc2Vec(size=max_features, window=5, min_count=2, workers=cores,iter=40)</span><br><span class="line">    model.build_vocab(x))</span><br><span class="line">    model.train(x, total_examples=model.corpus_count, epochs=model.iter)</span><br><span class="line">    model.save(doc2ver_bin)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/duoergun0729/nlp">https://github.com/duoergun0729/nlp</a></p>
</blockquote>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能中的搜索算法</title>
    <url>/posts/c9036b1c.html</url>
    <content><![CDATA[<h1>人工智能中的搜索算法</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/search-algorithms-in-ai">https://www.javatpoint.com/search-algorithms-in-ai</a></p>
</blockquote>
<p>搜索算法是人工智能最重要的领域之一。本主题将解释人工智能中的所有搜索算法。</p>
<h3 id="解决问题的代理">解决问题的代理:</h3>
<p>在人工智能中，搜索技术是解决问题的通用方法。AI 中的理性智能体或问题解决智能体大多使用这些搜索策略或算法来解决特定问题并提供最佳结果。问题解决代理是基于目标的代理，使用原子表示。在这个主题中，我们将学习各种解决问题的搜索算法。</p>
<h2 id="搜索算法术语">搜索算法术语:</h2>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>搜索:</strong> 搜索是在给定的搜索空间中解决搜索问题的一个逐步过程。搜索问题可能有三个主要因素:</p>
<ol>
<li class="lvl-8"><strong>搜索空间:</strong> 搜索空间代表一组可能的解决方案，一个系统可能有。</li>
<li class="lvl-8"><strong>开始状态:</strong> 是代理开始搜索的状态。</li>
<li class="lvl-8"><strong>目标测试:</strong> 是观察当前状态，返回目标状态是否达到的功能。</li>
</ol>
</li>
<li class="lvl-4">
<p><strong>搜索树:</strong> 搜索问题的树表示称为搜索树。搜索树的根是对应于初始状态的根节点。</p>
</li>
<li class="lvl-4">
<p><strong>动作:</strong> 它向代理提供所有可用动作的描述。</p>
</li>
<li class="lvl-4">
<p><strong>过渡模型:</strong> 每个动作做什么的描述，可以表示为一个过渡模型。</p>
</li>
<li class="lvl-4">
<p><strong>路径成本:</strong> 是给每个路径分配一个数值成本的函数。</p>
</li>
<li class="lvl-4">
<p><strong>解:</strong> 是从开始节点通向目标节点的动作序列。</p>
</li>
<li class="lvl-4">
<p><strong>最优解:</strong> 如果一个解在所有解中成本最低。</p>
</li>
</ul>
<h2 id="搜索算法的属性">搜索算法的属性:</h2>
<p>以下是搜索算法的四个基本属性，用于比较这些算法的效率:</p>
<p><strong>完备性:</strong> 如果对于任意随机输入，至少有一个解存在，则保证返回一个解，则称搜索算法完备。</p>
<p><strong>最优性:</strong> 如果为一个算法找到的解保证是所有其他解中的最优解(最低路径成本)，那么这样的解被称为最优解。</p>
<p><strong>时间复杂度:</strong> 时间复杂度是算法完成任务的时间度量。</p>
<p><strong>空间复杂度:</strong> 是搜索过程中任意一点所需的最大存储空间，作为问题的复杂度。</p>
<h2 id="搜索算法的类型">搜索算法的类型</h2>
<p><strong>基于搜索问题，我们可以将搜索算法分为无信息(盲搜索)搜索和有信息搜索(启发式搜索)算法。</strong></p>
<p><img src="/img/ai/img/df6f459b84d1a0994b429493a3ba3381.png" alt="Search Algorithms in Artificial Intelligence"></p>
<h3 id="不知情-盲目搜索">不知情/盲目搜索:</h3>
<p>不知情的搜索不包含任何领域知识，如接近度、目标位置。它以一种蛮力的方式运行，因为它只包含关于如何遍历树以及如何识别叶节点和目标节点的信息。无信息搜索应用了一种搜索树的方式，不需要任何关于搜索空间的信息，如初始状态算子和目标测试，因此也称为盲搜索。它检查树的每个节点，直到它达到目标节点。</p>
<p><strong>主要分为五种类型:</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>广度优先搜索</p>
</li>
<li class="lvl-2">
<p>统一成本搜索</p>
</li>
<li class="lvl-2">
<p>深度优先搜索</p>
</li>
<li class="lvl-2">
<p>迭代深化深度优先搜索</p>
</li>
<li class="lvl-2">
<p>双向搜索</p>
</li>
</ul>
<h4 id="广度优先搜索">广度优先搜索:</h4>
<ul class="lvl-0">
<li class="lvl-4">
<p>广度优先搜索是遍历树或图时最常用的搜索策略。这种算法在树或图中横向搜索，因此称为广度优先搜索。</p>
</li>
<li class="lvl-4">
<p>BFS 算法从树的根节点开始搜索，并在移动到下一级节点之前展开当前级的所有后续节点。</p>
</li>
<li class="lvl-4">
<p>广度优先搜索算法是通用图搜索算法的一个例子。</p>
</li>
<li class="lvl-4">
<p>使用先进先出队列数据结构实现广度优先搜索。</p>
</li>
</ul>
<p><strong>优势:</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>如果有任何解决办法，BFS 将提供一个解决办法。</p>
</li>
<li class="lvl-4">
<p>如果给定问题有多个解决方案，那么 BFS 将提供需要最少步骤的最小解决方案。</p>
</li>
</ul>
<p><strong>缺点:</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>它需要大量内存，因为树的每一级都必须保存到内存中才能扩展到下一级。</p>
</li>
<li class="lvl-4">
<p>如果解决方案远离根节点，BFS 需要大量时间。</p>
</li>
</ul>
<h5 id="示例">示例:</h5>
<p>在下面的树结构中，我们展示了使用 BFS 算法从根节点 S 到目标节点 k 的树遍历。BFS 搜索算法分层遍历，因此它将遵循虚线箭头所示的路径，遍历的路径将是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">S---&gt; A---&gt;B----&gt;C---&gt;D----&gt;G---&gt;H---&gt;E----&gt;F----&gt;I----&gt;K</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/ai/img/0a47c18a38bc7476e61df1bc15ab1308.png" alt="Uninformed Search Algorithms"></p>
<p><strong>时间复杂度:</strong> BFS 算法的时间复杂度可以通过在 BFS 遍历到最浅 Node 的节点数得到。其中 d=最浅解的深度，b 是每个状态下的节点。</p>
<p><strong>T(b)= 1+b<sup>2</sup>+b<sup>3</sup>+…+ b <sup>d</sup> = O (b <sup>d</sup> )</strong></p>
<p><strong>空间复杂度:</strong> BFS 算法的空间复杂度由前沿的内存大小给出，即 O(b <sup>d</sup> )。</p>
<p><strong>完备性:</strong> BFS 是完备的，这意味着如果最浅的目标节点在某个有限的深度，那么 BFS 就会找到解。</p>
<p><strong>最优性:</strong> 如果路径成本是节点深度的非递减函数，则 BFS 最优。</p>
<h4 id="深度优先搜索">深度优先搜索</h4>
<ul class="lvl-0">
<li class="lvl-4">
<p>深度优先搜索是遍历树或图数据结构的递归算法。</p>
</li>
<li class="lvl-4">
<p>它被称为深度优先搜索，因为它从根节点开始，在移动到下一个路径之前，沿着每个路径到达其最大深度节点。</p>
</li>
<li class="lvl-4">
<p>DFS 使用堆栈数据结构来实现。</p>
</li>
<li class="lvl-4">
<p>DFS 算法的过程类似于 BFS 算法。</p>
</li>
</ul>
<blockquote>
<p>注意:回溯是一种使用递归寻找所有可能解的算法技术。</p>
</blockquote>
<p><strong>优势:</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>DFS 需要非常少的内存，因为它只需要存储从根节点到当前节点的路径上的节点堆栈。</p>
</li>
<li class="lvl-4">
<p>到达目标节点比 BFS 算法花费的时间少(如果它以正确的路径遍历)。</p>
</li>
</ul>
<p><strong>劣势:</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>许多州有可能会再次发生，而且无法保证找到解决方案。</p>
</li>
<li class="lvl-4">
<p>DFS 算法进行深入的搜索，有时可能会进入无限循环。</p>
</li>
</ul>
<h5 id="示例-2">示例:</h5>
<p>在下面的搜索树中，我们显示了深度优先搜索的流程，它将遵循以下顺序:</p>
<p>根节点-&gt;左节点-&gt;右节点。</p>
<p>它将从根节点 S 开始搜索，遍历 A，然后 B，然后 D 和 E，遍历 E 后，由于 E 没有其他后继节点，仍然没有找到目标节点，它将回溯树。在回溯之后，它将遍历节点 C，然后遍历节点 G，这里它将在找到目标节点时终止。</p>
<p><img src="/img/ai/img/ce1c9b71021ebcffd7b40ad004ad36a1.png" alt="Uninformed Search Algorithms"></p>
<p><strong>完整性:</strong> DFS 搜索算法在有限状态空间内是完整的，因为它将扩展有限搜索树内的每个节点。</p>
<p><strong>时间复杂度:</strong> DFS 的时间复杂度将相当于算法遍历的节点。它由下式给出:</p>
<p><strong>T(n)= 1+n<sup>2</sup>+n<sup>3</sup>+…+ n <sup>m</sup> =O(n <sup>m</sup> )</strong></p>
<p><strong>其中，m=任何节点的最大深度，这可以比 d(最浅解深度)</strong> 大得多</p>
<p><strong>空间复杂度:</strong> DFS 算法只需要存储从根节点开始的单条路径，因此 DFS 的空间复杂度相当于边缘集的大小，即为 <strong>O(bm)</strong> 。</p>
<p><strong>最优:</strong> DFS 搜索算法是非最优的，因为它可能会产生大量的步骤或高成本来到达目标节点。</p>
<h4 id="深度受限搜索算法">深度受限搜索算法:</h4>
<p>深度受限搜索算法类似于具有预定限制的深度优先搜索。深度受限搜索可以解决深度优先搜索中无限路径的缺点。在该算法中，深度极限处的节点将被视为没有后续节点。</p>
<p>深度受限搜索可以在两种失败情况下终止:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>标准故障值:表示问题没有任何解决方案。</p>
</li>
<li class="lvl-4">
<p>截止故障值:它定义了在给定的深度限制内没有问题的解决方案。</p>
</li>
</ul>
<p><strong>优势:</strong></p>
<p>深度受限搜索是内存高效的。</p>
<p><strong>缺点:</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>深度受限搜索也有不完整的缺点。</p>
</li>
<li class="lvl-4">
<p>如果问题有多个解决方案，这可能不是最佳方案。</p>
</li>
</ul>
<h5 id="示例-3">示例:</h5>
<p><img src="/img/ai/img/ecc66b1a2a6ff2bad25a181843dbef5f.png" alt="Uninformed Search Algorithms"></p>
<p><strong>完备性:</strong> 如果解在深度极限以上，则 DLS 搜索算法完备。</p>
<p><strong>时间复杂度:</strong> DLS 算法的时间复杂度为 <strong>O(b <sup>ℓ</sup> )</strong> 。</p>
<p><strong>空间复杂度:</strong> DLS 算法的空间复杂度为 O <strong>(bℓ)</strong> 。</p>
<p><strong>最优:</strong> 深度受限搜索可以看作是 DFS 的特例，即使ℓ &gt; d 也不是最优的。</p>
<h4 id="均匀成本搜索算法">均匀成本搜索算法:</h4>
<p>均匀成本搜索是一种用于遍历加权树或图的搜索算法。当每条边的成本不同时，这种算法就开始发挥作用。均匀成本搜索的主要目标是找到一条到达累积成本最低的目标节点的路径。均匀成本搜索根据节点形成根节点的路径成本来扩展节点。它可以用来求解任何需要最优成本的图/树。优先级队列实现了一种均匀成本搜索算法。它给予最低的累积成本最大的优先权。如果所有边的路径代价相同，则均匀代价搜索等价于 BFS 算法。</p>
<p><strong>优势:</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>均匀成本搜索是最优的，因为在每个状态下，成本最小的路径被选择。</p>
</li>
</ul>
<p><strong>缺点:</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>它不关心搜索涉及的步骤数，只关心路径开销。因此该算法可能陷入无限循环。</p>
</li>
</ul>
<h5 id="示例-4">示例:</h5>
<p><img src="/img/ai/img/8175688d894610300d580a667161b320.png" alt="Uninformed Search Algorithms"></p>
<p><strong>完整性:</strong></p>
<p>均匀成本搜索是完整的，比如如果有解决方案，UCS 会找到它。</p>
<p><strong>时间复杂度:</strong></p>
<p>设 C* <strong>为最优解</strong>的代价， <strong>ε</strong> 为每一步向目标节点靠拢。那么步数就是= C*/ε+1。这里我们取+1，从状态 0 开始，到 C*/ε结束。</p>
<p>因此，均匀成本搜索的最坏情况时间复杂度是<strong>O(b<sup>1+【C */ε】</sup>)/</strong>。</p>
<p><strong>空间复杂度:</strong></p>
<p>同样的逻辑也适用于空间复杂度，所以均匀成本搜索的最坏情况空间复杂度是<strong>O(b<sup>1+【C */ε】</sup>)</strong>。</p>
<p><strong>最优:</strong></p>
<p>均匀成本搜索总是最优的，因为它只选择路径成本最低的路径。</p>
<h4 id="迭代深度优先搜索">迭代深度优先搜索:</h4>
<p>迭代深化算法是离散傅立叶变换和 BFS 算法的结合。这种搜索算法找出最佳深度极限，并通过逐渐增加极限直到找到目标来实现。</p>
<p>该算法在一定的“深度极限”内进行深度优先搜索，每次迭代后不断增加深度极限，直到找到目标节点。</p>
<p>这种搜索算法结合了广度优先搜索的快速搜索和深度优先搜索的内存效率的优点。</p>
<p>当搜索空间较大，目标节点深度未知时，迭代搜索算法是有用的无信息搜索。</p>
<p><strong>优势:</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>它结合了 BFS 和 DFS 搜索算法在快速搜索和内存效率方面的优势。</p>
</li>
</ul>
<p><strong>缺点:</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>IDDFS 的主要缺点是它重复了前一阶段的所有工作。</p>
</li>
</ul>
<h5 id="示例-5">示例:</h5>
<p>遵循树结构显示的是迭代深化深度优先搜索。IDDFS 算法执行各种迭代，直到没有找到目标节点。算法执行的迭代如下所示:</p>
<p><img src="/img/ai/img/82b194ca909ea866d01dec77ad9860f0.png" alt="Uninformed Search Algorithms"></p>
<p>第 1 次迭代- &gt; A<br>
第 2 次迭代- &gt; A、B、C<br>
第 3 次迭代- &gt; A、B、D、E、C、F、G<br>
第 4 次迭代- &gt; A、B、D、H、I、E、C、F、K、G<br>
在第 4 次迭代中，算法会找到目标节点。</p>
<p><strong>完整性:</strong></p>
<p>如果分支因子是有限的，这个算法就是完整的。</p>
<p><strong>时间复杂度:</strong></p>
<p>假设 b 是分支因子，深度是 d，那么最坏的时间复杂度是 <strong>O(b <sup>d</sup> )</strong> 。</p>
<p><strong>空间复杂度:</strong></p>
<p>IDDFS 的空间复杂度将为 <strong>O(bd)</strong> 。</p>
<p><strong>最优:</strong></p>
<p>如果路径成本是节点深度的非递减函数，则 IDDFS 算法是最优的。</p>
<h4 id="双向搜索算法">双向搜索算法:</h4>
<p><strong>双向搜索算法运行两个同时进行的搜索，一个形成初始状态称为前向搜索，另一个来自目标节点称为后向搜索，以找到目标节点。双向搜索用两个小的子图代替一个单一的搜索图，其中一个从初始顶点开始搜索，另一个从目标顶点开始搜索。当这两幅图相交时，搜索停止。</strong></p>
<p><strong>双向搜索可以使用 BFS、DFS、DLS 等搜索技术。</strong></p>
<p><strong>优势:</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>双向搜索很快。</p>
</li>
<li class="lvl-4">
<p>双向搜索需要较少的内存</p>
</li>
</ul>
<p><strong>缺点:</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>双向搜索树的实现是困难的。</p>
</li>
<li class="lvl-4">
<p><strong>在双向搜索中，要提前知道目标状态。</strong></p>
</li>
</ul>
<h5 id="示例-6">示例:</h5>
<p>在下面的搜索树中，应用了双向搜索算法。该算法将一个图/树分成两个子图。它从节点 1 开始向前穿越，从目标节点 16 开始向后穿越。</p>
<p>该算法在两个搜索相遇的节点 9 处终止。</p>
<p><img src="/img/ai/img/833ded6362b6359f93af318ea7799993.png" alt="Uninformed Search Algorithms"></p>
<p><strong>完整性:</strong> 如果我们在两个搜索中都使用 BFS，则双向搜索完成。</p>
<p><strong>时间复杂度:</strong> 使用 BFS 双向搜索的时间复杂度为 <strong>O(b <sup>d</sup> )</strong> 。</p>
<p><strong>空间复杂度:</strong> 双向搜索的空间复杂度为 <strong>O(b <sup>d</sup> )</strong> 。</p>
<p><strong>最优:</strong> 双向搜索最优。</p>
<h3 id="知情搜索">知情搜索</h3>
<p>知情搜索算法使用领域知识。在有根据的搜索中，有问题信息可以指导搜索。有根据的搜索策略比无根据的搜索策略能更有效地找到解决方案。知情搜索也称为启发式搜索。</p>
<p>启发式是一种不一定能保证得到最佳解决方案，但能保证在合理的时间内找到好的解决方案的方法。</p>
<p>信息搜索可以解决许多用另一种方法无法解决的复杂问题。</p>
<p>知情搜索算法的一个例子是旅行推销员问题。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>最佳优先搜索算法(贪婪搜索)</p>
</li>
<li class="lvl-4">
<p>A*搜索算法</p>
</li>
</ul>
<h4 id="最佳优先搜索算法-贪婪搜索">最佳优先搜索算法(贪婪搜索):</h4>
<p>贪婪最佳优先搜索算法总是选择在那个时刻出现最好的路径。它是深度优先搜索和广度优先搜索算法的结合。它使用启发式函数和搜索。最佳优先搜索允许我们利用两种算法的优势。借助最佳优先搜索，在每一步，我们都可以选择最有希望的节点。在最佳优先搜索算法中，我们扩展最接近目标节点的节点，并通过启发式函数估计最接近的代价，即</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">f(n)= g(n). </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>wae，h(n)=从节点 n 到目标的估计成本。</p>
<p>贪婪最佳优先算法由优先级队列实现。</p>
<h5 id="最佳优先搜索算法">最佳优先搜索算法:</h5>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>步骤 1:</strong> 将起始节点放入 OPEN 列表。</p>
</li>
<li class="lvl-4">
<p><strong>步骤 2:</strong> 如果打开列表为空，则停止并返回失败。</p>
</li>
<li class="lvl-4">
<p><strong>步骤 3:</strong> 从 h(n)值最低的 OPEN 列表中删除节点 n，并将其放入 CLOSED 列表中。</p>
</li>
<li class="lvl-4">
<p><strong>步骤 4:</strong> 展开节点 n，生成节点 n 的后继节点。</p>
</li>
<li class="lvl-4">
<p><strong>步骤 5:</strong> 检查节点 n 的各个后继节点，看是否有节点是目标节点。如果任何后续节点是目标节点，则返回成功并终止搜索，否则继续步骤 6。</p>
</li>
<li class="lvl-4">
<p><strong>步骤 6:</strong> 对于每个后继节点，算法检查评估函数 f(n)，然后检查该节点是否已经在 OPEN 或 CLOSED 列表中。如果该节点不在两个列表中，则将其添加到打开列表中。</p>
</li>
<li class="lvl-4">
<p><strong>步骤 7:</strong> 返回第 2 步。</p>
</li>
</ul>
<h5 id="优点">优点:</h5>
<ul class="lvl-0">
<li class="lvl-4">
<p>最佳优先搜索可以通过获得两种算法的优点在 BFS 和 DFS 之间切换。</p>
</li>
<li class="lvl-4">
<p>该算法比 BFS 和 DFS 算法更有效。</p>
</li>
</ul>
<h5 id="缺点">缺点:</h5>
<ul class="lvl-0">
<li class="lvl-4">
<p>在最坏的情况下，它可以表现为非制导深度优先搜索。</p>
</li>
<li class="lvl-4">
<p>它会像 DFS 一样陷入循环。</p>
</li>
<li class="lvl-4">
<p>这个算法不是最优的。</p>
</li>
</ul>
<h5 id="示例-7">示例:</h5>
<p>考虑下面的搜索问题，我们将使用贪婪的最佳优先搜索来遍历它。在每次迭代中，使用评估函数 f(n)=h(n)扩展每个节点，如下表所示。</p>
<p><img src="/img/ai/img/bf4713ff7f12e31acf6764ae47a0eb14.png" alt="Informed Search Algorithms"></p>
<p>在这个搜索示例中，我们使用了两个列表，即<strong>打开</strong>和<strong>关闭</strong>列表。以下是遍历上述示例的迭代。</p>
<p><img src="/img/ai/img/106a126403bdfec22c86734f805ddca1.png" alt="Informed Search Algorithms"></p>
<p><strong>展开 S 的节点，放入 CLOSED 列表</strong></p>
<p><strong>初始化:</strong> 打开【A，B】，关闭【S】</p>
<p><strong>迭代 1:</strong> 打开[A]，关闭[S，B]</p>
<p><strong>迭代 2:</strong> 打开【E，F，A】，关闭【S，B】<br>
:打开【E，A】，关闭【S，B，F】</p>
<p><strong>迭代 3:</strong> 打开【I，G，E，A】，关闭【S，B，F】<br>
:打开【I，E，A】，关闭【S，B，F，G】</p>
<p>因此，最终的解决方案将是: <strong>S - &gt; B - &gt; F - &gt; G</strong></p>
<p><strong>时间复杂度:</strong> 贪婪最佳第一次搜索的最坏情况时间复杂度为 O(b <sup>m</sup> )。</p>
<p><strong>空间复杂度:</strong> 贪婪最佳第一搜索的最坏情况空间复杂度为 O(b <sup>m</sup> )。其中，m 是搜索空间的最大深度。</p>
<p><strong>完成:</strong> 贪婪的最佳优先搜索也是不完全的，即使给定的状态空间是有限的。</p>
<p><strong>最优:</strong> 贪婪最佳优先搜索算法不是最优的。</p>
<h4 id="A-搜索算法">A*搜索算法:</h4>
<p>A<em>搜索是最常见的最佳优先搜索形式。它使用启发式函数 h(n)和代价从起始状态 g(n)到达节点 n。它结合了 UCS 和贪婪最佳优先搜索的特点，有效地解决了这个问题。A</em>搜索算法使用启发式函数找到通过搜索空间的最短路径。这种搜索算法扩展较少的搜索树，更快地提供最优结果。A*算法除了用 g(n)+h(n)代替 g(n)之外，与 UCS 相似。</p>
<p>在 A*搜索算法中，我们使用搜索启发式以及到达节点的代价。因此，我们可以将两个成本合并如下，这个总和称为<strong>健身数</strong>。</p>
<p><img src="/img/ai/img/4da482020b09a640e1fb9652ea814902.png" alt="Informed Search Algorithms"></p>
<p>在搜索空间的每一点，只有那些 f(n)值最低的节点被展开，当找到目标节点时，算法终止。</p>
<h5 id="A-搜索的算法">A*搜索的算法:</h5>
<p><strong>步骤 1:</strong> 将起始节点放入 OPEN 列表中。</p>
<p><strong>步骤 2:</strong> 检查 OPEN 列表是否为空，如果列表为空则返回失败并停止。</p>
<p><strong>步骤 3:</strong> 从 OPEN 列表中选择评价函数值(g+h)最小的节点，如果节点 n 为目标节点则返回成功并停止，否则</p>
<p><strong>步骤 4:</strong> 展开节点 n 并生成其所有后继节点，将 n 放入封闭列表。对于每个后继 n’，检查 n’是否已经在打开或关闭列表中，如果没有，则计算 n’的评估函数，并将其放入打开列表中。</p>
<p><strong>步骤 5:</strong> 否则如果节点 n’已经处于 OPEN 和 CLOSED 状态，那么它应该被附加到反映最低 g(n’)值的后指针。</p>
<p><strong>步骤 6:</strong> 返回<strong>第二步</strong>。</p>
<h5 id="优点-2">优点:</h5>
<ul class="lvl-0">
<li class="lvl-4">
<p>A*搜索算法是比其他搜索算法更好的算法。</p>
</li>
<li class="lvl-4">
<p>A*搜索算法是最优且完整的。</p>
</li>
<li class="lvl-4">
<p>这个算法可以解决非常复杂的问题。</p>
</li>
</ul>
<h5 id="缺点-2">缺点:</h5>
<ul class="lvl-0">
<li class="lvl-4">
<p>它并不总是产生最短路径，因为它主要基于启发式和近似。</p>
</li>
<li class="lvl-4">
<p>A*搜索算法存在一些复杂性问题。</p>
</li>
<li class="lvl-4">
<p>A*的主要缺点是内存需求，因为它将所有生成的节点都保存在内存中，因此对于各种大规模问题来说并不实用。</p>
</li>
</ul>
<h5 id="示例-8">示例:</h5>
<p>In this example, we will traverse the given graph using the A* algorithm. The heuristic value of all states is given in the below table so we will calculate the f(n) of each state using the formula f(n)= g(n) + h(n), where g(n) is the cost to reach any node from start state. Here we will use OPEN and CLOSED list. <img src="/img/ai/img/a5f530cf3d4f083cedebe0e98d4e6eec.png" alt="Informed Search Algorithms"></p>
<p><strong>解决方案:</strong></p>
<p><img src="/img/ai/img/59f61b52ac0b1aae9f39a18ed09d3c7f.png" alt="Informed Search Algorithms"></p>
<p><strong>初始化:</strong> {(S，5)}</p>
<p><strong>迭代 1:</strong> {(S - &gt; A，4)，(S - &gt; G，10)}</p>
<p><strong>迭代 2:</strong> {(S - &gt; A - &gt; C，4)，(S - &gt; A - &gt; B，7)，(S - &gt; G，10)}</p>
<p><strong>迭代 3:</strong> {(S - &gt; A - &gt; C - &gt; G，6)，(S - &gt; A - &gt; C - &gt; D，11)，(S - &gt; A - &gt; B，7)，(S - &gt; G，10)}</p>
<p><strong>迭代 4</strong> 将给出最终结果，因为 <strong>S - &gt; A - &gt; C - &gt; G</strong> 它提供了成本为 6 的最优路径。</p>
<p><strong>需要记住的点:</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>A*算法返回最先出现的路径，它不搜索所有剩余的路径。</p>
</li>
<li class="lvl-4">
<p>A*算法的效率取决于启发式的质量。</p>
</li>
<li class="lvl-4">
<p>A*算法扩展所有满足条件 f(n) 的节点</p>
</li>
</ul>
<p><strong>完成:</strong> A*算法完成只要:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>分支因子是有限的。</p>
</li>
<li class="lvl-4">
<p>每次行动的成本是固定的。</p>
</li>
</ul>
<p><strong>最优:</strong> A*搜索算法在满足以下两个条件时为最优:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>容许:</strong> 最优性要求的第一个条件是 h(n)应该是 A*树搜索的容许启发式。可接受的启发本质上是乐观的。</p>
</li>
<li class="lvl-4">
<p><strong>一致性:</strong> 第二个要求的条件是一致性，仅适用于 A*图形搜索。</p>
</li>
</ul>
<p>如果启发式函数是可接受的，那么 A*树搜索将总是找到成本最小的路径。</p>
<p><strong>时间复杂度:</strong> a*搜索算法的时间复杂度取决于启发式函数，展开的节点数与解 d 的深度成指数关系，因此时间复杂度为 O(b^d)，其中 b 为分支因子。</p>
<p><strong>空间复杂度:</strong> a*搜索算法的空间复杂度为 <strong>O(b^d)</strong></p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
  </entry>
  <entry>
    <title>使用TextRank和TFIDF进行关键字提取</title>
    <url>/posts/8767b873.html</url>
    <content><![CDATA[<h1>文档关键字</h1>
<p>早期的信息检索平台并没有如今这么发达，大量的类似论坛、wiki的信息发布网站都依赖文档的关键字进行文档检索。即使是在如今的互联网世界，大量的信息检索还要依赖关键字。依靠人工归纳文章的关键字虽然相对准确，但是面对信息爆炸的互联网，这几乎成为了不可能的任务。本章将介绍如何使用TextRank和TFIDF算法自动提取文档的关键字。</p>
<h1>TextRank</h1>
<p>TextRank的思路来自于PageRank。PageRank最开始用来计算网页的重要性。整个互联网可以看作一张有向图，节点是网页。如果网页A存在到网页B的链接，那么有一条从网页A指向网页B的有向边，指向同一个网页的链接越多，该网页的重要性或者说PageRank值更大。综合考虑Title和Keywords等其它因素之后，Google通过PageRank来调整结果，使那些更重要的网页在搜索结果排名更靠前。</p>
<p><img src="/img/picture/%E4%BD%BF%E7%94%A8TextRank%E5%92%8CTFIDF%E8%BF%9B%E8%A1%8C%E6%96%87%E6%A1%A3%E5%85%B3%E9%94%AE%E5%AD%97%E8%87%AA%E5%8A%A8%E6%8F%90%E5%8F%96-%E5%9B%BE2.png" alt="使用TextRank和TFIDF进行文档关键字自动提取-图2"></p>
<p>TextRank的原理和PageRank类似，一篇文档去掉停用词以后，每个单词相当于一个网页，有时候也会指定某些词性的单词才参与计算TextRank，比如名词和动词。网页有明显的指向关系，但是文档的单词之间只有前后关系，所以要指定一个滑动的窗口大小，比如前后5个单词。在滑动窗口内的单词之间的前后关系当做网页之间的指向关系，参与TextRank的计算。<br>
<img src="/img/picture/%E4%BD%BF%E7%94%A8TextRank%E5%92%8CTFIDF%E8%BF%9B%E8%A1%8C%E6%96%87%E6%A1%A3%E5%85%B3%E9%94%AE%E5%AD%97%E8%87%AA%E5%8A%A8%E6%8F%90%E5%8F%96-%E5%9B%BE1.png" alt="使用TextRank和TFIDF进行文档关键字自动提取-图1"></p>
<h1>TFIDF</h1>
<p>TFIDF在本书中多次提到了，它同样可以用于提取关键字。TFIDF的一个基本假设是，一个单词的重要性由词频决定，如果一个单词在一句话里出现频率高，同时在其他句子里出现频率低，那么这个单词对这句话就非常重要，对于一个文档也是如此。</p>
<h1>测试数据</h1>
<p>测试数据挑选了写本章时的一条新闻，新闻内容如下：</p>
<blockquote></blockquote>
<p>据半岛电视台援引叙利亚国家电视台称，叙利亚已经对美国、英国、法国的空袭进行了反击。据介绍，在叙军武器库中，对西方最具威慑力的当属各型战术地对地弹道导弹。尽管美英法是利用巡航导弹等武器发动远程空袭，但叙军要对等还击却几乎是“不可能完成的任务”。目前叙军仍能作战的战机仍是老旧的苏制米格-29、米格-23、米格-21战斗机和苏-22、苏-24轰炸机，它们在现代化的西方空军面前难有自保之力，因此叙军的远程反击只能依靠另一个撒手锏——地对地战术弹道导弹.</p>
<h1>提取关键字</h1>
<h2 id="使用TextRank提取关键字">使用TextRank提取关键字</h2>
<p>Jieba提供了TextRank实现，直接使用默认参数就可以完成关键字的提取。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 引入TextRank关键词抽取接口</span><br><span class="line">textrank = analyse.textrank</span><br><span class="line"></span><br><span class="line"># 基于TextRank算法进行关键词抽取</span><br><span class="line">keywords = textrank(text)</span><br><span class="line"># 输出抽取出的关键词</span><br><span class="line">for keyword in keywords:</span><br><span class="line">    print keyword + &quot;/&quot;</span><br></pre></td></tr></table></figure>
<p>提取的结果如下所示,自动化提取关键字的结果差强人意，其中&quot;只能&quot;、&quot;据介绍&quot;这些完全可以省略，另外通常关键字个数需要控制在10个以内。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">叙军/</span><br><span class="line">远程/</span><br><span class="line">空袭/</span><br><span class="line">电视台/</span><br><span class="line">战术/</span><br><span class="line">反击/</span><br><span class="line">空军/</span><br><span class="line">现代化/</span><br><span class="line">叙利亚/</span><br><span class="line">地对地/</span><br><span class="line">只能/</span><br><span class="line">武器/</span><br><span class="line">发动/</span><br><span class="line">弹道导弹/</span><br><span class="line">任务/</span><br><span class="line">国家/</span><br><span class="line">据介绍/</span><br><span class="line">法国/</span><br><span class="line">进行/</span><br><span class="line">当属/</span><br></pre></td></tr></table></figure>
<p>Jieba提供了接口，设置关键字的个数以及提取的关键字的词性，比如：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>topK，指定关键字的个数</p>
</li>
<li class="lvl-2">
<p>allowPOS，指定关键字的词性，常见的词性包括：</p>
<ul class="lvl-2">
<li class="lvl-6">n 名词</li>
<li class="lvl-6">nr 人名</li>
<li class="lvl-6">ns 地名</li>
<li class="lvl-6">nz 其它专名</li>
<li class="lvl-6">t 时间词</li>
<li class="lvl-6">v 动词</li>
<li class="lvl-6">vd 副动词</li>
<li class="lvl-6">vn 名动词</li>
</ul>
</li>
</ul>
<p>我们只提取10个关键字，且只关注名词和动词以及名动词。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 基于TextRank算法进行关键词抽取</span><br><span class="line">keywords = textrank(text,topK = 10, withWeight = False, allowPOS = (&#x27;n&#x27;,&#x27;ns&#x27;,&#x27;vn&#x27;,&#x27;v&#x27;))</span><br></pre></td></tr></table></figure>
<p>生成的结果如下所示，基本满足我们的需求了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">叙军/</span><br><span class="line">远程/</span><br><span class="line">空袭/</span><br><span class="line">电视台/</span><br><span class="line">战术/</span><br><span class="line">反击/</span><br><span class="line">空军/</span><br><span class="line">现代化/</span><br><span class="line">叙利亚/</span><br><span class="line">地对地/</span><br></pre></td></tr></table></figure>
<h2 id="使用TFIDF提取关键字">使用TFIDF提取关键字</h2>
<p>使用TFIDF提取关键字的方法和TextRank类似。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># TFIDF</span><br><span class="line">keywords_tfidf = analyse.extract_tags(text,topK = 10, withWeight = False, allowPOS = (&#x27;n&#x27;,&#x27;ns&#x27;,&#x27;vn&#x27;,&#x27;v&#x27;,&#x27;nz&#x27;))</span><br><span class="line"></span><br><span class="line"># 输出抽取出的关键词</span><br><span class="line">for keyword in keywords_tfidf:</span><br><span class="line">    print keyword + &quot;/&quot;</span><br></pre></td></tr></table></figure>
<p>生成的结果如下所示，与TextRank相比差别不大。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">叙军/</span><br><span class="line">地对地/</span><br><span class="line">空袭/</span><br><span class="line">弹道导弹/</span><br><span class="line">远程/</span><br><span class="line">叙利亚/</span><br><span class="line">电视台/</span><br><span class="line">反击/</span><br><span class="line">战术/</span><br><span class="line">撒手锏/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/duoergun0729/nlp">https://github.com/duoergun0729/nlp</a></p>
</blockquote>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>使用LDA进行文档主题建模</title>
    <url>/posts/8e92b190.html</url>
    <content><![CDATA[<h1>LDA简介</h1>
<p>LDA（Latent Dirichlet Allocation）是一种文档主题模型，包含词、主题和文档三层结构。</p>
<p><img src="/img/picture/%E4%BD%BF%E7%94%A8LDA%E8%BF%9B%E8%A1%8C%E6%96%87%E6%A1%A3%E4%B8%BB%E9%A2%98%E5%BB%BA%E6%A8%A1-%E5%9B%BE1.png" alt="使用LDA进行文档主题建模-图1"></p>
<p>LDA认为一篇文档由一些主题按照一定概率组成，一个主题又由一些词语按照一定概率组成。早期人们用词袋模型对一篇文章进行建模，把一篇文档表示为若干单词的计数。无论是中文还是英文，都由大量单词组成，这就造成词袋向量的维数巨大，少则几千多则上万，在使用分类模型进行训练时，非常容易造成训练缓慢以及过拟合。LDA本质上把词袋模型进行了降维，把一篇文档以主题的形式进行了表示。主题的个数通常为几百，这就把文档使用了维数为几百的向量进行了表示，大大加快了训练速度，并且相对不容易造成过拟合。从某种程度上来说，主题是对若干词语的抽象表示。</p>
<p><img src="/img/picture/%E4%BD%BF%E7%94%A8LDA%E8%BF%9B%E8%A1%8C%E6%96%87%E6%A1%A3%E4%B8%BB%E9%A2%98%E5%BB%BA%E6%A8%A1-%E5%9B%BE3.png" alt="使用LDA进行文档主题建模-图3"></p>
<p>以最近一部电视剧《南方有乔木》为例。假设一篇文章介绍了这部电视剧的主要内容。我们可以把这篇文章表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.30*&quot;创业&quot;+0.3*&quot;三角恋&quot;+0.2*&quot;无人机&quot;</span><br></pre></td></tr></table></figure>
<p>然后我们可以把三角恋表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.4*&quot;南乔&quot;+0.3*&quot;时樾&quot;+0.3*&quot;安宁&quot;</span><br></pre></td></tr></table></figure>
<p>需要指出的是，计算出文档、主题以及词语之间的表示关系，需要基于大量的文档，这样才具有普遍的意义。LDA正是提供了这种算法，自动从训练文档中计算出这种对应关系。</p>
<h1>数据集</h1>
<p>本文演示用的数据集，依然使用搜狗新闻数据集SogouCS。我们从SogouCS中提取正文内容，每个URL对应的正文当做一篇文档，并且使用jieba进行了分词。演示期间我们提取SogouCS的前10000条数据用于计算LDA。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def load_sougou_content():</span><br><span class="line">    with open(&quot;../data/news_sohusite_content_10000.txt&quot;) as F:</span><br><span class="line">        content=F.readlines()</span><br><span class="line">        F.close()</span><br><span class="line">    return content</span><br></pre></td></tr></table></figure>
<p>计算LDA时，需要删除停用词，加载我们之前保存的停用词。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def load_stopwords():</span><br><span class="line">    with open(&quot;stopwords.txt&quot;) as F:</span><br><span class="line">        stopwords=F.readlines()</span><br><span class="line">        F.close()</span><br><span class="line">    return [word.strip() for word in stopwords]</span><br></pre></td></tr></table></figure>
<h1>计算主题</h1>
<p>我们使用gensim提供的API进行LDA计算。首先从语料中提取字典，并用该字典把预料转换成词袋。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 得到文档-单词矩阵 （直接利用统计词频得到特征）</span><br><span class="line">dictionary = corpora.Dictionary(content)</span><br><span class="line"># 将dictionary转化为一个词袋，得到文档-单词矩阵</span><br><span class="line">texts = [dictionary.doc2bow(text) for text in content]</span><br></pre></td></tr></table></figure>
<p>然后进行LDA计算,演示期间设置只计算5个主题，通常生产环境经验值为200。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num_topics=5</span><br><span class="line">lda = models.ldamodel.LdaModel(corpus=texts, id2word=dictionary, num_topics=num_topics)</span><br></pre></td></tr></table></figure>
<p>其中比较重要的几个参数含义如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>corpus，计算LDA的语料</p>
</li>
<li class="lvl-2">
<p>id2word，语料对应的字典</p>
</li>
<li class="lvl-2">
<p>num_topics，计算的主题的数量</p>
</li>
</ul>
<p>我们打印前5个主题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for index,topic in lda.print_topics(5):</span><br><span class="line">    print topic</span><br></pre></td></tr></table></figure>
<p>主题内容如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.007*&quot;月&quot; + 0.006*&quot;中&quot; + 0.005*&quot;年&quot; + 0.005*&quot;日&quot; + 0.004*&quot;公司&quot; + 0.004*&quot;时间&quot; + 0.003*&quot;北京&quot; + 0.003*&quot;比赛&quot; + 0.002*&quot;中国&quot; + 0.002*&quot;记者&quot;</span><br><span class="line"></span><br><span class="line">0.006*&quot;月&quot; + 0.006*&quot;发展&quot; + 0.005*&quot;年&quot; + 0.005*&quot;日&quot; + 0.005*&quot;中&quot; + 0.005*&quot;中国&quot; + 0.004*&quot;工作&quot; + 0.004*&quot;说&quot; + 0.003*&quot;记者&quot; + 0.003*&quot;建设&quot;</span><br><span class="line"></span><br><span class="line">0.008*&quot;月&quot; + 0.007*&quot;市场&quot; + 0.006*&quot;经济&quot; + 0.005*&quot;增长&quot; + 0.004*&quot;元&quot; + 0.004*&quot;中国&quot; + 0.004*&quot;企业&quot; + 0.004*&quot;产品&quot; + 0.004*&quot;年&quot; + 0.004*&quot;记者&quot;</span><br><span class="line"></span><br><span class="line">0.011*&quot;日&quot; + 0.011*&quot;月&quot; + 0.007*&quot;记者&quot; + 0.005*&quot;时&quot; + 0.005*&quot;年&quot; + 0.004*&quot;公司&quot; + 0.004*&quot;说&quot; + 0.004*&quot;中&quot; + 0.003*&quot;发现&quot; + 0.002*&quot;亿元&quot;</span><br><span class="line"></span><br><span class="line">0.006*&quot;ｏ&quot; + 0.006*&quot;ｉ&quot; + 0.006*&quot;月&quot; + 0.005*&quot;日&quot; + 0.005*&quot;ｅ&quot; + 0.005*&quot;说&quot; + 0.005*&quot;ｎ&quot; + 0.005*&quot;中&quot; + 0.004*&quot;中国&quot; + 0.004*&quot;ａ&quot;</span><br></pre></td></tr></table></figure>
<p>如果需要设置每个话题对应的关键字的个数，可以通过参数num_words设置，默认为10，这里的num_topics参数容易导致误解，它的含义是显示排名前几个话题，类似topN参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print_topics(num_topics=20, num_words=10)</span><br></pre></td></tr></table></figure>
<p>词袋处理后的结果，使用TFIDF算法处理后，可以进一步提升LDA的效果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 利用tf-idf来做为特征进行处理</span><br><span class="line">texts_tf_idf = models.TfidfModel(texts)[texts]</span><br><span class="line">lda = models.ldamodel.LdaModel(corpus=texts_tf_idf, id2word=dictionary, num_topics=num_topics)</span><br></pre></td></tr></table></figure>
<p>运行的效果如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.001*&quot;比赛&quot; + 0.001*&quot;联赛&quot; + 0.001*&quot;意甲&quot; + 0.001*&quot;主场&quot; + 0.001*&quot;轮&quot; + 0.001*&quot;赛季&quot; + 0.001*&quot;时间&quot; + 0.001*&quot;孩子&quot; + 0.001*&quot;北京&quot; + 0.000*&quot;航天员&quot;</span><br><span class="line"></span><br><span class="line">0.001*&quot;叙利亚&quot; + 0.001*&quot;奥运会&quot; + 0.001*&quot;伦敦&quot; + 0.000*&quot;选手&quot; + 0.000*&quot;中国&quot; + 0.000*&quot;说&quot; + 0.000*&quot;男子&quot; + 0.000*&quot;米&quot; + 0.000*&quot;北京&quot; + 0.000*&quot;日&quot;</span><br><span class="line"></span><br><span class="line">0.000*&quot;梅西&quot; + 0.000*&quot;林书豪&quot; + 0.000*&quot;鲁尼&quot; + 0.000*&quot;稀土&quot; + 0.000*&quot;钓鱼岛&quot; + 0.000*&quot;巴萨&quot; + 0.000*&quot;试用&quot; + 0.000*&quot;常规赛&quot; + 0.000*&quot;蛋黄派&quot; + 0.000*&quot;尼克斯&quot;</span><br><span class="line"></span><br><span class="line">0.002*&quot;体育&quot; + 0.001*&quot;搜狐&quot; + 0.001*&quot;北京&quot; + 0.001*&quot;ｏ&quot; + 0.001*&quot;时间&quot; + 0.001*&quot;ｎ&quot; + 0.001*&quot;ｉ&quot; + 0.001*&quot;日&quot; + 0.001*&quot;Ｃ&quot; + 0.001*&quot;ｅ&quot;</span><br><span class="line"></span><br><span class="line">0.001*&quot;市场&quot; + 0.001*&quot;经济&quot; + 0.001*&quot;增长&quot; + 0.001*&quot;投资&quot; + 0.001*&quot;亿元&quot; + 0.001*&quot;基金&quot; + 0.001*&quot;公司&quot; + 0.001*&quot;银行&quot; + 0.001*&quot;企业&quot; + 0.001*&quot;同比&quot;</span><br></pre></td></tr></table></figure>
<h1>使用LDA提取文档特征</h1>
<p>通常LDA的结果可以作为进一步文档分类、文档相似度计算以及文档聚类的依据，可以把LDA当做一种特征提取方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#获取语料对应的LDA特征</span><br><span class="line">corpus_lda = lda[texts_tf_idf]</span><br><span class="line">#打印0号文档对应的LDA值</span><br><span class="line">print corpus_lda[0]</span><br></pre></td></tr></table></figure>
<p>输出0号文档对应的LDA值如下，即把0号文档以5个话题形式表示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[(0, 0.019423252), (1, 0.019521076), (2, 0.92217809), (3, 0.01954053), (4, 0.019337002)]</span><br></pre></td></tr></table></figure>
<p>这里需要解释的是，无论是词袋模型还是LDA生成的结果，都可能存在大量的0，这会占用大量的内存空间。因此默认情况下，词袋以及LDA计算的结果都以稀疏矩阵的形式保存。稀疏矩阵的最小单元定义为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（元素所在的位置，元素的值）</span><br></pre></td></tr></table></figure>
<p>比如一个稀疏矩阵只有0号和2号元素不为0，分别为1和5，那么它的表示方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[(0,1),(2,5)]</span><br></pre></td></tr></table></figure>
<h1>使用多核计算</h1>
<p>LDA在生产环境中运行遇到的最大问题就是默认只能使用单核资源，运行速度过慢。gensim针对这一情况也提供了多核版本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lda = models.ldamulticore.LdaMulticore(corpus=texts_tf_idf, id2word=dictionary, num_topics=num_topics)</span><br></pre></td></tr></table></figure>
<p>该版本默认情况默认使用cpu_count()-1 即使用几乎全部CPU，仅保留一个CPU不参与LDA计算，也可以通过参数workers指定使用的CPU个数，这里的CPU指的物理CPU，不是超线程的CPU数。一般认为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPU总核数 = 物理CPU个数 * 每颗物理CPU的核数 </span><br><span class="line">总逻辑CPU数 = 物理CPU个数 * 每颗物理CPU的核数 * 超线程数</span><br></pre></td></tr></table></figure>
<p>可以尝试使用如下命令查看服务器的CPU信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看CPU信息（型号）</span><br><span class="line">cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</span><br><span class="line">24         Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz</span><br><span class="line"></span><br><span class="line"># 查看物理CPU个数</span><br><span class="line">cat /proc/cpuinfo| grep &quot;physical id&quot;| sort| uniq| wc -l</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line"># 查看每个物理CPU中core的个数(即核数)</span><br><span class="line">cat /proc/cpuinfo| grep &quot;cpu cores&quot;| uniq</span><br><span class="line">cpu cores    : 6</span><br><span class="line"></span><br><span class="line"># 查看逻辑CPU的个数</span><br><span class="line">cat /proc/cpuinfo| grep &quot;processor&quot;| wc -l</span><br><span class="line">24</span><br></pre></td></tr></table></figure>
<p>gensim官网上公布了一组测试数据，数据集为Wikipedia英文版数据集，该数据集有350万个文档，10万个特征，话题数设置为100的情况下运行LDA算法。硬件环境为一台拥有4个物理i7 CPU的服务器。使用单核接口需要使用3小时44分，当使用多核接口且使用3个物理CPU仅需要1小时6分钟。我们延续上面的例子，继续使用搜狗的数据集，为了要效果更加明显，我们使用SogouCS的前50000的数据进行LDA运算，话题数设置为100，并使用time.clock()获取当前时间，便于计算各个环节消耗的时间，比如计算LDA消耗的时间的方法如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#获取当前时间</span><br><span class="line">   start = time.clock()</span><br><span class="line">   #workers指定使用的CPU个数 默认使用cpu_count()-1 即使用几乎全部CPU 仅保留一个CPU不参与LDA计算</span><br><span class="line">   lda = models.ldamulticore.LdaMulticore(corpus=texts_tf_idf, id2word=dictionary, num_topics=num_topics)</span><br><span class="line">   #计算耗时</span><br><span class="line">   end = time.clock()</span><br><span class="line">   print(&#x27;[lda]Running time: %s Seconds&#x27; % (end - start))</span><br></pre></td></tr></table></figure>
<p>分别计算使用1，2，4等不同CPU的情况，统计了预处理环节、LDA环节的耗时，其中预处理环节主要进行了词袋处理和TFIDF处理，测试用的服务器一共有12个物理CPU。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;CPU数&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;预处理环节耗时（单位：秒） &lt;/td&gt;</span><br><span class="line">        &lt;td&gt;LDA环节耗时（单位：秒） &lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;默认&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;24&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;169&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;1&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;25&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;437&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;2&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;24&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;296&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;4&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;25&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;215&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;6&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;23&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;189&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;8&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;25&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;186&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;10&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;23&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;171&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;12&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;23&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;160&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;/table&gt;</span><br></pre></td></tr></table></figure>
<p>测试结果表明，使用多CPU资源可以提升LDA的计算效率，尤其对于CPU使用个数较少时，几乎成线性下降，当使用CPU个数较多时，性能改善不明显。在本例中默认参数将使用11个CPU，因此默认参数下计算速率略低于使用12个CPU。</p>
<p><img src="/img/picture/%E4%BD%BF%E7%94%A8LDA%E8%BF%9B%E8%A1%8C%E6%96%87%E6%A1%A3%E4%B8%BB%E9%A2%98%E5%BB%BA%E6%A8%A1-%E5%9B%BE4.png" alt="使用LDA进行文档主题建模-图4.png"></p>
<h1>在线学习</h1>
<p>LDA可以进行在线学习，动态更新模型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lda = LdaMulticore(corpus, num_topics=10)</span><br><span class="line">lda.update(other_corpus)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/duoergun0729/nlp">https://github.com/duoergun0729/nlp</a></p>
</blockquote>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>使用多层感知机进行文档分类</title>
    <url>/posts/f2d3361.html</url>
    <content><![CDATA[<h1>多层感知机概述</h1>
<h2 id="生活中的神经网络">生活中的神经网络</h2>
<p><img src="/img/picture/%E4%BD%BF%E7%94%A8%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA%E8%BF%9B%E8%A1%8C%E6%96%87%E6%A1%A3%E5%88%86%E7%B1%BB-%E5%9B%BE1.png" alt="使用多层感知机进行文档分类-图1"></p>
<p>人的大脑是由无数的神经元组成的复杂网络。神经元是具有长突起的细胞，它由细胞体和轴突、树突组成。</p>
<p><img src="/img/picture/%E4%BD%BF%E7%94%A8%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA%E8%BF%9B%E8%A1%8C%E6%96%87%E6%A1%A3%E5%88%86%E7%B1%BB-%E5%9B%BE2.png" alt="使用多层感知机进行文档分类-图2"></p>
<p>每个神经元可以有一或多个树突，可以接受刺激并将兴奋传入细胞体。每个神经元只有一个轴突，可以把兴奋从胞体传送到另一个神经元或其他组织，如肌肉或腺体。</p>
<p><img src="/img/picture/%E4%BD%BF%E7%94%A8%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA%E8%BF%9B%E8%A1%8C%E6%96%87%E6%A1%A3%E5%88%86%E7%B1%BB-%E5%9B%BE3.png" alt="使用多层感知机进行文档分类-图3"></p>
<h2 id="神经网络算法概述">神经网络算法概述</h2>
<p>神经网络算法就是模拟了人体神经元的工作原理，多个输入参数，分别具有各自的权重，经过激励函数的处理后，得到输出。输出可以再对接下一级的神经网络的输入，从而组成更加复杂的神经网络。</p>
<p><img src="/img/picture/%E4%BD%BF%E7%94%A8%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA%E8%BF%9B%E8%A1%8C%E6%96%87%E6%A1%A3%E5%88%86%E7%B1%BB-%E5%9B%BE4.png" alt="使用多层感知机进行文档分类-图4"><br>
大脑里的生物神经细胞和其他的神经细胞是相互连接在一起的。为了创建一个人工神经网络，人工神经细胞也要以同样方式相互连接在一起。为此可以有许多不同的连接方式，其中最容易理解并且也是最广泛地使用的，就是把神经细胞一层一层地连结在一起。这一种类型的神经网络就叫前馈网络。</p>
<p><img src="/img/picture/%E4%BD%BF%E7%94%A8%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA%E8%BF%9B%E8%A1%8C%E6%96%87%E6%A1%A3%E5%88%86%E7%B1%BB-%E5%9B%BE5.png" alt="使用多层感知机进行文档分类-图5"></p>
<p>如果对预测错误的神经元施加惩罚，从输出层开始层层向上查找预测错误的神经元，微调这些神经元对应的权重，达到修复错误的目的，这样的算法就叫做反向传播算法。Scikit-learn中的神经网络实现都是使用反向传播算法。本文重点介绍算法在安全领域的应用，神经网络的公式推导请参考其他机器学习专业书籍。本书介绍的是神经网络中最简单的一种形式，即多层感知机。</p>
<h1>数据集</h1>
<p>数据集依然使用搜狗实验室提供的&quot;搜狐新闻数据&quot;，该数据来自搜狐新闻2012年6月—7月期间国内，国际，体育，社会，娱乐等18个频道的新闻数据，提供URL和正文信息。 对应的网址为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.sogou.com/labs/resource/cs.php</span><br></pre></td></tr></table></figure>
<p>我们选择其中数量最大的三个频道的数据进行分析，数据清洗过程请参考我之前的文章《使用fasttext进行文档分类》</p>
<h1>特征提取</h1>
<h2 id="词袋-TFIDF">词袋&amp;TFIDF</h2>
<p>特征提取的方式采用词袋结合TFIDF的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#切割词袋</span><br><span class="line">vectorizer = CountVectorizer()</span><br><span class="line"># 该类会统计每个词语的tf-idf权值</span><br><span class="line">transformer = TfidfTransformer()</span><br><span class="line">x = transformer.fit_transform(vectorizer.fit_transform(x))</span><br></pre></td></tr></table></figure>
<h2 id="n-gram-TFIDF">n-gram&amp;TFIDF</h2>
<p>特征提取还可以使用词袋模型的加强版n-gram，比如最常见的2-gram，这样可以更好的提取单词前后之间的关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#切割词袋</span><br><span class="line">vectorizer = CountVectorizer(ngram_range=(2,2))</span><br><span class="line"># 该类会统计每个词语的tf-idf权值</span><br><span class="line">transformer = TfidfTransformer()</span><br><span class="line">x = transformer.fit_transform(vectorizer.fit_transform(x))</span><br></pre></td></tr></table></figure>
<h2 id="one-hot编码">one-hot编码</h2>
<p>由于这次需要区分的标签一共有三种，不能直接使用过去二分类问题的方式进行处理了。针对多分类问题，需要使用one-hot编码处理标签。所谓的one-hot编码，又称为一位有效编码，主要是采用位状态寄存器来对个状态进行编码，每个状态都由他独立的寄存器位，并且在任意时候只有一位有效。比如我们有三类标签，就可以编码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1,0,0]</span><br><span class="line">[0,1,0]</span><br><span class="line">[0,0,1]</span><br></pre></td></tr></table></figure>
<p>在keras中可以非常方便的进行转换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#转换成one hot编码</span><br><span class="line">y=to_categorical(t, num_classes=3)</span><br></pre></td></tr></table></figure>
<h1>训练与效果验证</h1>
<p>在scikit-learn中构造多层感知机的分类器非常方便，通常只需要设计神经网络的结构即可。本例中设计的隐藏层有两层，结点数分为为5和3，通常最后一层的结点数与标签类型数相同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#mlp</span><br><span class="line">clf = MLPClassifier(solver=&#x27;lbfgs&#x27;,</span><br><span class="line">                    alpha=1e-5,</span><br><span class="line">                    hidden_layer_sizes=(5, 3),</span><br><span class="line">                    random_state=1)</span><br></pre></td></tr></table></figure>
<p>其中比较重要的几个参数的含义为：</p>
<pre><code>- hidden_layer_sizes，表示隐藏层的结构
- activation，激活函数,&#123;‘identity’, ‘logistic’, ‘tanh’, ‘relu’&#125;, 默认relu
- solver，优化方式，&#123;‘lbfgs’, ‘sgd’, ‘adam’&#125;, 默认adam。lbfgs使用quasi-Newton方法的优化器，sgd使用随机梯度下降，adam也是一种随机梯度的优化器
- alpha，可选的，默认0.0001,正则化项参数    
</code></pre>
<p>效果验证使用5折交叉验证，考核的指标是f1和accuracy。使用cross_val_score函数可以非常方便的实现交叉验证的功能，其中cv参数指定交叉验证的方式，比如5代表5折交叉验证。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scores = cross_val_score(clf, x, y, cv = 5,scoring=&#x27;f1_micro&#x27;)</span><br><span class="line">  print(&quot;f1: %0.2f (+/- %0.2f)&quot; % (scores.mean(), scores.std() * 2))</span><br><span class="line"></span><br><span class="line">  scores = cross_val_score(clf, x, y, cv = 5,scoring=&#x27;accuracy&#x27;)</span><br><span class="line">  print(&quot;accuracy: %0.2f (+/- %0.2f)&quot; % (scores.mean(), scores.std() * 2))</span><br></pre></td></tr></table></figure>
<p>这里需要特别说明的是，在二分类问题中，我们考核f1即可，但是在多分类问题中，f1以微平均和宏平均两个指标的形式存在，分别为f1_micro和f1_macro。f1_micro对数据集中的每一个实例不分类别进行统计建立全局混淆矩阵，然后计算相应指标。f1_macro是先对每一个类统计指标值，然后在对所有类求算术平均值。通常使用其中任何一个即可。<br>
运行程序，当使用词袋&amp;TFIDF模型时，效果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f1: 0.98 (+/- 0.04)</span><br><span class="line">accuracy: 0.97 (+/- 0.05)</span><br></pre></td></tr></table></figure>
<p>当使用n-gram&amp;TFIDF模型的效果，有兴趣的读者可以自行验证。</p>
<blockquote>
<p>原文：<a href="https://github.com/duoergun0729/nlp">https://github.com/duoergun0729/nlp</a></p>
</blockquote>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>使用fasttext进行文档分类</title>
    <url>/posts/6cd3c2db.html</url>
    <content><![CDATA[<h1>fasttext原理</h1>
<p>fasttext提供了一种有效且快速的方式生成词向量以及进行文档分类。<br>
fasttext模型输入一个词的序列，输出这个词序列属于不同类别的概率。fasttext模型架构和Word2Vec中的CBOW模型很类似。不同之处在于，fasttext预测标签，而CBOW模型预测中间词。fasttext设计的初衷就是为了作为一个文档分类器，副产品是也生成了词向量。<br>
<img src="/img/picture/%E4%BD%BF%E7%94%A8fasttext%E8%BF%9B%E8%A1%8C%E6%96%87%E6%A1%A3%E5%88%86%E7%B1%BB-%E5%9B%BE2.png" alt="使用fasttext进行文档分类-图2"></p>
<h1>fasttext特性</h1>
<h2 id="n-gram">n-gram</h2>
<p>在词袋模型中，把单词当做独立的个体，没有考虑词前后的关系。比如&quot;我打你&quot;和“你打我“，使用词袋模型的话，这两句话是完全一样的。词袋的特征为：</p>
<pre><code>[&quot;我&quot;,“打“,”你”]
</code></pre>
<p>&quot;我打你&quot;和“你打我“对应的特征向量均为：</p>
<pre><code>[1,1,1]
</code></pre>
<p>n-gram是对词袋模型的一种改善，它会关注一个单词的前后关系，比如n-gram中最常见的2-gram，就关注单词的前一个词，比如&quot;我打你&quot;,就可以拆分为&quot;我打&quot;和&quot;打你&quot;。这两句话一起建模的话，2-gram对应的特征为：</p>
<pre><code>[&quot;我打&quot;，&quot;打你&quot;，&quot;你打&quot;，&quot;打我&quot;]
</code></pre>
<p>&quot;我打你&quot;对应的特征向量为：</p>
<pre><code>[1,1,0,0]
</code></pre>
<p>&quot;你打我&quot;对应的特征向量为：</p>
<pre><code>[0,0,1,1]
</code></pre>
<p>与Word2Vec使用词袋模型不同，fasttext使用了n-gram模型，因此fasttext可以更有效的表达词前后的之间的关系。</p>
<h2 id="高效率">高效率</h2>
<p>fasttext在使用标准多核CPU的情况下10分钟内处理超过10亿个词汇，特别是与深度模型对比，fastText能将训练时间由数天缩短到几秒钟。使用一个标准多核CPU，得到了在10分钟内训练完超过10亿词汇量模型的结果。</p>
<h1>安装fasttext</h1>
<p>fasttext的安装非常简便，直接从github上同步最新的代码并进行安装即可。</p>
<pre><code>$ git clone https://github.com/facebookresearch/fastText.git
$ cd fastText
$ pip install .
</code></pre>
<h1>预训练模型</h1>
<p>facebook已经基于其收集的海量语料，训练好了fasttext的词向量模型，目前已经支持了150多种语言。有需要的读者可以直接下载并使用，对应的链接为：</p>
<pre><code>https://github.com/facebookresearch/fastText/blob/master/docs/crawl-vectors.md
</code></pre>
<p><img src="/img/picture/%E4%BD%BF%E7%94%A8fasttext%E8%BF%9B%E8%A1%8C%E6%96%87%E6%A1%A3%E5%88%86%E7%B1%BB-%E5%9B%BE1.png" alt="使用fasttext进行文档分类"></p>
<h1>数据集</h1>
<p>数据集依然使用搜狗实验室提供的&quot;搜狐新闻数据&quot;，该数据来自搜狐新闻2012年6月—7月期间国内，国际，体育，社会，娱乐等18个频道的新闻数据，提供URL和正文信息。对应的网址为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.sogou.com/labs/resource/cs.php</span><br></pre></td></tr></table></figure>
<p>数据文件的格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   &lt;doc&gt;</span><br><span class="line"></span><br><span class="line">&lt;url&gt;页面URL&lt;/url&gt;</span><br><span class="line"></span><br><span class="line">&lt;docno&gt;页面ID&lt;/docno&gt;</span><br><span class="line"></span><br><span class="line">&lt;contenttitle&gt;页面标题&lt;/contenttitle&gt;</span><br><span class="line"></span><br><span class="line">&lt;content&gt;页面内容&lt;/content&gt;</span><br><span class="line"></span><br><span class="line">&lt;/doc&gt;</span><br></pre></td></tr></table></figure>
<p>我们可以看到数据文件中并没有标记页面内容属于哪个频道，如果需要做文档分类，搜狗提供了页面URL和频道之间的映射关系。</p>
<p><img src="/img/picture/%E4%BD%BF%E7%94%A8fasttext%E8%BF%9B%E8%A1%8C%E6%96%87%E6%A1%A3%E5%88%86%E7%B1%BB-%E5%9B%BE3.png" alt="使用fasttext进行文档分类-图3"></p>
<p>下载SogouTCE文件，可以看到具体的映射关系举例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.xinhuanet.com/auto/	汽车</span><br><span class="line">http://www.xinhuanet.com/fortune	财经</span><br><span class="line">http://www.xinhuanet.com/internet/	IT</span><br><span class="line">http://www.xinhuanet.com/health/	健康</span><br><span class="line">http://www.xinhuanet.com/sports	体育</span><br><span class="line">http://www.xinhuanet.com/travel	旅游</span><br><span class="line">http://www.xinhuanet.com/edu	教育</span><br><span class="line">http://www.xinhuanet.com/employment	招聘</span><br><span class="line">http://www.xinhuanet.com/life	文化</span><br><span class="line">http://www.xinhuanet.com/mil	军事</span><br><span class="line">http://www.xinhuanet.com/olympics/	奥运</span><br><span class="line">http://www.xinhuanet.com/society	社会</span><br></pre></td></tr></table></figure>
<h1>数据清洗</h1>
<p>搜狐新闻数据的文件默认编码格式为gb18030，因此解压缩后要线转换成utf-8格式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf news_sohusite_xml.full.tar.gz</span><br><span class="line">cat news_sohusite_xml.dat | iconv -f gb18030 -t utf-8 &gt; news_sohusite_xml-utf8.txt</span><br></pre></td></tr></table></figure>
<p>转换完格式后查看文件内容，文件以xml形式记录，举例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;doc&gt;</span><br><span class="line">&lt;url&gt;http://gongyi.sohu.com/s2008/sourceoflife/&lt;/url&gt;</span><br><span class="line">&lt;docno&gt;f2467af22cd2f0ea-34913306c0bb3300&lt;/docno&gt;</span><br><span class="line">&lt;contenttitle&gt;中国西部是地球上主要干旱带之一，妇女是当地劳动力．．．&lt;/contenttitle&gt;</span><br><span class="line">&lt;content&gt;同心县地处宁夏中部干旱带的核心区，　冬寒长，春暖迟，夏热短，秋凉早，干旱少雨，蒸发强烈，风大沙多。主要自然灾害有沙尘暴、干热风、霜冻、冰雹等，其中以干旱危害最为严重。由于生态环境的极度恶劣，导致农村经济发展缓慢，人民群众生产、生活水平低下，靠天吃饭的被动局</span><br><span class="line">面依然存在，同心，又是国家级老、少、边、穷县之一…［详细］&lt;/content&gt;</span><br><span class="line">&lt;/doc&gt;</span><br></pre></td></tr></table></figure>
<p>但是数据文件并不是标准的xml格式，如下所示，该文件相对标准的xml格式缺少了根元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;doc&gt;</span><br><span class="line">    &lt;url&gt;&lt;/url&gt;</span><br><span class="line">    &lt;docno&gt;&lt;/docno&gt;</span><br><span class="line">    &lt;contenttitle&gt;&lt;/contenttitle&gt;</span><br><span class="line">    &lt;content&gt;&lt;/content&gt;</span><br><span class="line">&lt;/doc&gt;</span><br><span class="line">&lt;doc&gt;</span><br><span class="line">    &lt;url&gt;&lt;/url&gt;</span><br><span class="line">    &lt;docno&gt;&lt;/docno&gt;</span><br><span class="line">    &lt;contenttitle&gt;&lt;/contenttitle&gt;</span><br><span class="line">    &lt;content&gt;&lt;/content&gt;</span><br><span class="line">&lt;/doc&gt;</span><br></pre></td></tr></table></figure>
<p>所有的doc节点都直接是最顶层，没有根节点。因此要添加根节点使该文本文件符合xml文件的规范，最简单的一种形式就是在文件的开始和结尾添加根元素标签。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;docs&gt;</span><br><span class="line">	&lt;doc&gt;</span><br><span class="line">	    &lt;url&gt;&lt;/url&gt;</span><br><span class="line">	    &lt;docno&gt;&lt;/docno&gt;</span><br><span class="line">	    &lt;contenttitle&gt;&lt;/contenttitle&gt;</span><br><span class="line">	    &lt;content&gt;&lt;/content&gt;</span><br><span class="line">	&lt;/doc&gt;</span><br><span class="line">	&lt;doc&gt;</span><br><span class="line">	    &lt;url&gt;&lt;/url&gt;</span><br><span class="line">	    &lt;docno&gt;&lt;/docno&gt;</span><br><span class="line">	    &lt;contenttitle&gt;&lt;/contenttitle&gt;</span><br><span class="line">	    &lt;content&gt;&lt;/content&gt;</span><br><span class="line">	&lt;/doc&gt;</span><br><span class="line">&lt;/docs&gt;</span><br></pre></td></tr></table></figure>
<p>可以直接使用文本编辑工具在数据文件的开始和结尾进行修改，但是这有可能导致你的终端因为内存使用过大而崩溃。一种比较稳妥的做法是使用程序完成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def make_xml():</span><br><span class="line">	print &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&quot;</span><br><span class="line">    print &quot;&lt;docs&gt;&quot;</span><br><span class="line">    with open(&quot;data/news_sohusite_xml-utf8.txt&quot;) as F:</span><br><span class="line">        for line in F:</span><br><span class="line">            print line</span><br><span class="line">        F.close()</span><br><span class="line">    print &quot;&lt;/docs&gt;&quot;</span><br></pre></td></tr></table></figure>
<p>在终端执行该程序，并将标准输出的结果保存即可，剩下的操作只要解析xml文件即可。下面我们介绍另一种方法，观察可以发现，url和content是成对出现的，并且一一对应。我们可以过滤这两个字段的内容，分别保存成content文件和url文件。首先过滤出url字段的内容，并且删除掉url标签。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat news_sohusite_xml-utf8.txt | grep &#x27;&lt;url&gt;&#x27; | sed  &#x27;s/&lt;url&gt;//g&#x27; | sed  &#x27;s/&lt;\/url&gt;//g&#x27; &gt; news_sohusite_url.txt</span><br></pre></td></tr></table></figure>
<p>然后过滤出content字段的内容，并且删除掉content标签。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat news_sohusite_xml-utf8.txt | grep &#x27;&lt;content&gt;&#x27; | sed  &#x27;s/&lt;content&gt;//g&#x27; | sed  &#x27;s/&lt;\/content&gt;//g&#x27; &gt; news_sohusite_content.txt</span><br></pre></td></tr></table></figure>
<p>content是中文内容，需要使用jieba进行切词，可以把切词的动作也放到上面的命令里面。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat news_sohusite_xml-utf8.txt | grep &#x27;&lt;content&gt;&#x27; | sed  &#x27;s/&lt;content&gt;//g&#x27; | sed  &#x27;s/&lt;\/content&gt;//g&#x27; | python -m jieba -d &#x27; &#x27;  &gt; news_sohusite_content.txt</span><br></pre></td></tr></table></figure>
<p>加载url和对应领域的映射关系的文件，以哈希的形式保存对应的映射关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def load_SogouTCE():</span><br><span class="line">    SogouTCE=[]</span><br><span class="line">    SogouTCE_kv = &#123;&#125;</span><br><span class="line">    with open(&quot;../data/SogouTCE.txt&quot;) as F:</span><br><span class="line">        for line in F:</span><br><span class="line">            (url,channel)=line.split()</span><br><span class="line">            SogouTCE.append(url)</span><br><span class="line">        F.close()</span><br><span class="line">    for index,url in enumerate(SogouTCE):</span><br><span class="line">        #删除http前缀</span><br><span class="line">        url=re.sub(&#x27;http://&#x27;,&#x27;&#x27;,url)</span><br><span class="line">        print &quot;k:%s v:%d&quot; % (url,index)</span><br><span class="line">        SogouTCE_kv[url]=index</span><br><span class="line">    return  SogouTCE_kv</span><br></pre></td></tr></table></figure>
<p>我们分析下各个领域的数据分布情况，把匹配上的url对应的标记打印出来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def load_url(SogouTCE_kv):</span><br><span class="line">    labels=[]</span><br><span class="line">    with open(&quot;../data/news_sohusite_url.txt&quot;) as F:</span><br><span class="line">        for line in F:</span><br><span class="line">            for k,v in SogouTCE_kv.items():</span><br><span class="line">                if re.search(k,line,re.IGNORECASE):</span><br><span class="line">                    #print &quot;x:%s y:%d&quot; % (line,v)</span><br><span class="line">                    print v</span><br><span class="line">                    labels.append(v)</span><br><span class="line">        F.close()</span><br><span class="line">    return  labels</span><br></pre></td></tr></table></figure>
<p>运行程序，分析各个领域对应的url数量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python fasttext.py &gt; v.txt</span><br><span class="line">cat v.txt | sort -n | uniq -c</span><br></pre></td></tr></table></figure>
<p>每行的第一个字段是数量，第二个字段是对应的领域的id，结果表明搜狐新闻数据集中在某几个领域，并且分布不均匀。为了避免样本不均衡导致的误判，我们选择数量上占前三的领域作为后继分析的数据，id分别为81，79和91。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">138576 79</span><br><span class="line">27489 80</span><br><span class="line">199871 81</span><br><span class="line">23409 82</span><br><span class="line">44537 83</span><br><span class="line">2179 84</span><br><span class="line">13012 85</span><br><span class="line">1924 87</span><br><span class="line">3294 88</span><br><span class="line"> 842 89</span><br><span class="line">50138 91</span><br><span class="line">5882 92</span><br></pre></td></tr></table></figure>
<p>反查对应的url为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kit.sohu.com/ id:81</span><br><span class="line">auto.sohu.com/ id:79</span><br><span class="line">yule.sohu.com/ id:91</span><br></pre></td></tr></table></figure>
<p>过滤我们关注的领域的内容，将content保存在x列表里，对应的领域的id保存在y列表里，作为标签使用，至此我们完成了数据清洗的工作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def load_selecteddata(SogouTCE_kv):</span><br><span class="line">    x=[]</span><br><span class="line">    y=[]</span><br><span class="line"></span><br><span class="line">    #加载content列表</span><br><span class="line">    with open(&quot;../data/news_sohusite_content.txt&quot;) as F:</span><br><span class="line">        content=F.readlines()</span><br><span class="line">        F.close()</span><br><span class="line"></span><br><span class="line">    # 加载url列表</span><br><span class="line">    with open(&quot;../data/news_sohusite_url.txt&quot;) as F:</span><br><span class="line">        url = F.readlines()</span><br><span class="line">        F.close()</span><br><span class="line"></span><br><span class="line">    for index,u in  enumerate(url):</span><br><span class="line">        for k, v in SogouTCE_kv.items():</span><br><span class="line">            # 只加载id为81，79和91的数据</span><br><span class="line">            if re.search(k, u, re.IGNORECASE) and v in (81, 79, 91):</span><br><span class="line">                #保存url对应的content内容</span><br><span class="line">                x.append(content[index])</span><br><span class="line">                y.append(v)</span><br><span class="line"></span><br><span class="line">    return x,y</span><br></pre></td></tr></table></figure>
<h2 id="删除停用词">删除停用词</h2>
<p>在处理中文语料时，需要删除停用词。所谓停用词就是对理解中文含义没有明显作用的哪些单词，常见的停用词举例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一一  </span><br><span class="line">一下  </span><br><span class="line">一个  </span><br><span class="line">一些  </span><br><span class="line">一何  </span><br><span class="line">一切  </span><br><span class="line">一则  </span><br><span class="line">一则通过  </span><br><span class="line">一天  </span><br><span class="line">一定  </span><br><span class="line">一方面  </span><br><span class="line">一旦  </span><br><span class="line">一时 </span><br></pre></td></tr></table></figure>
<p>另外所有的字母和数字还有标点符号也可以作为停用词。我们把停用词保存在一个文本文件里面便于配置使用。定义加载停用词的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def load_stopwords():</span><br><span class="line">    with open(&quot;stopwords.txt&quot;) as F:</span><br><span class="line">        stopwords=F.readlines()</span><br><span class="line">        F.close()</span><br><span class="line">    return [word.strip() for word in stopwords]</span><br></pre></td></tr></table></figure>
<p>使用停用词过滤之前提取的文本内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stopwords=load_stopwords()</span><br><span class="line"></span><br><span class="line">#切割token</span><br><span class="line">x=[  [word for word in line.split() if word not in stopwords]   for line in x]</span><br></pre></td></tr></table></figure>
<h1>文档分类</h1>
<h2 id="数据文件格式">数据文件格式</h2>
<p>fasttext对训练和测试的数据格式有一定的要求，数据文件和标签文件要合并到一个文件里面。文件中的每一行代表一条记录，同时每条记录的最后标记对应的标签。默认情况下标签要以__label__开头,比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是一条测试数据	__label__1</span><br></pre></td></tr></table></figure>
<p>python下实现合并数据文件和标签文件的功能非常简单。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def dump_file(x,y,filename):</span><br><span class="line">    with open(filename, &#x27;w&#x27;) as f:</span><br><span class="line">        for i,v in enumerate(x):</span><br><span class="line">            line=&quot;%s __label__%d\n&quot; % (v,y[i])</span><br><span class="line">            f.write(line)</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure>
<p>加载数据清洗后的数据和标签，随机划分成训练数据和测试数据，其中测试数据占20%。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SogouTCE_kv=load_SogouTCE()</span><br><span class="line">x,y=load_selecteddata(SogouTCE_kv)</span><br><span class="line"># 分割训练集和测试集</span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2)</span><br></pre></td></tr></table></figure>
<p>按照fasttext的格式要求保存成训练数据和测试数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#按照fasttest的要求生成训练数据和测试数据</span><br><span class="line">dump_file(x_train,y_train,&quot;../data/sougou_train.txt&quot;)</span><br><span class="line">dump_file(x_test, y_test, &quot;../data/sougou_test.txt&quot;)</span><br></pre></td></tr></table></figure>
<p>查看训练数据文件的内容，举例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">２ ０ １ ２ 款 长安 标致 雪铁龙 Ｄ Ｓ ４ ／ Ｄ Ｓ ５ 九寨沟 试驾 __label__79</span><br></pre></td></tr></table></figure>
<h2 id="训练模型">训练模型</h2>
<p>下面开始训练fasttext模型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># train_supervised uses the same arguments and defaults as the fastText cli</span><br><span class="line">model = train_supervised(</span><br><span class="line">        input=&quot;../data/sougou_train.txt&quot;, epoch=25, lr=0.6, wordNgrams=2, verbose=2, minCount=1</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>其中比较重要的几个参数的含义为：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>input；表示训练数据文件的路径</p>
</li>
<li class="lvl-2">
<p>epoch：表示训练的次数</p>
</li>
<li class="lvl-2">
<p>lr：表示初始的学习速率</p>
</li>
<li class="lvl-2">
<p>wordNgrams：表示n-gram的值，一般使用2，表示2-gram</p>
</li>
<li class="lvl-2">
<p>minCount：表示参与计算的单词的最小出现次数。</p>
</li>
</ul>
<h2 id="验证效果">验证效果</h2>
<p>fasttext默认情况下会计算对应的准确率和召回率。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def print_results(N, p, r):</span><br><span class="line">    print(&quot;N\t&quot; + str(N))</span><br><span class="line">    print(&quot;P@&#123;&#125;\t&#123;:.3f&#125;&quot;.format(1, p))</span><br><span class="line">    print(&quot;R@&#123;&#125;\t&#123;:.3f&#125;&quot;.format(1, r))</span><br></pre></td></tr></table></figure>
<p>使用测试数据文件进行校验。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print_results(*model.test(&quot;../data/sougou_test.txt&quot;))</span><br></pre></td></tr></table></figure>
<p>运行程序，显示加载了36M的单词，其中包含288770的单词组合，标记类型一共3种。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Read 36M words</span><br><span class="line">Number of words:  288770</span><br><span class="line">Number of labels: 3</span><br></pre></td></tr></table></figure>
<p>验证效果如下所示，准确率为99.0%，召回率为99.0%，对应的F1计算为99.0%，效果非常不错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Progress: 100.0% words/sec/thread:  626183 lr:  0.000000 loss:  0.005640 ETA:   0h 0m </span><br><span class="line">N	71107</span><br><span class="line">P@1	0.990</span><br><span class="line">R@1	0.990</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/duoergun0729/nlp">https://github.com/duoergun0729/nlp</a></p>
</blockquote>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>如何衡量模型好坏</title>
    <url>/posts/566bb055.html</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>在NLP中我们经常需要使用机器学习的分类器。如何衡量一个分类器的好坏呢？最常见的指标包括准确率与召回率,准确度与F1-Score以及ROC与AUC。</p>
<h2 id="测试数据">测试数据</h2>
<p>我们以Scikit-Learn环境介绍常见的性能衡量指标。为了演示方便，我们创建测试数据，测试数据一共1000条记录，每条记录100个特征，内容随机生成。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">x, y = datasets.make_classification(n_samples=<span class="number">1000</span>, n_features=<span class="number">100</span>,</span><br><span class="line">					n_redundant=<span class="number">0</span>, random_state = <span class="number">1</span>)</span><br><span class="line">把数据集随机划分成训练集和测试集，其中测试集占<span class="number">40</span>%。</span><br><span class="line">train_X, test_X, train_y, test_y = train_test_split(x,y,test_size=<span class="number">0.2</span>,random_state=<span class="number">66</span>)</span><br></pre></td></tr></table></figure>
<p>使用KNN算法进行训练和预测。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">knn = KNeighborsClassifier(n_neighbors=<span class="number">5</span>)</span><br><span class="line">knn.fit(train_X, train_Y)</span><br><span class="line">pred_Y = knn.predict(test_X)</span><br></pre></td></tr></table></figure>
<h2 id="混淆矩阵">混淆矩阵</h2>
<p>混淆矩阵，即Confusion Matrix，是将分类问题按照真实情况与判别情况两个维度进行归类的一个矩阵，在二分类问题中，可以用一个2乘以2的矩阵表示。如图1-1 所示，TP表示实际为真预测为真，TN表示实际为假预测为假，FN表示实际为真预测为假，通俗讲就是漏报了，FP表示实际为假预测为真，通俗讲就是误报了。</p>
<p><img src="/img/picture/%E5%A6%82%E4%BD%95%E8%A1%A1%E9%87%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%88%86%E7%B1%BB%E5%99%A8%E6%A8%A1%E5%9E%8B-%E5%9B%BE1.png" alt="如何衡量机器学习分类器模型" title="二分类问题的混淆矩阵"></p>
<p>在Scikit-Learn中，使用metrics.confusion_matrix输出混淆矩阵。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;confusion_matrix:&quot;</span></span><br><span class="line"><span class="built_in">print</span> metrics.confusion_matrix(test_Y, pred_Y)</span><br></pre></td></tr></table></figure>
<p>输出结果如下，其中漏报 36个，误报了25个。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">confusion_matrix:</span><br><span class="line">[[<span class="number">70</span> <span class="number">25</span>]</span><br><span class="line">   [<span class="number">36</span> <span class="number">69</span>]]</span><br></pre></td></tr></table></figure>
<h2 id="准确率与召回率">准确率与召回率</h2>
<p>机器学习中最基本指标是召回率(Recall Rate)和准确率(Precision Rate)，召回率也叫查全率，准确率也叫查准率。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">召回率=TP/(TP+FN)</span><br><span class="line">准确率=TP/(TP+FP)</span><br></pre></td></tr></table></figure>
<p>用一个吃货都可以理解的例子来解释这两个枯燥的概念。一个池塘有10条鱼和20只小龙虾，渔夫撒网打鱼，结果捞上来8条鱼12只小龙虾，那么准确率为8/(8+12)=40%，召回率为8/10=80%。在Scikit-Learn中，可以如下获得准确率和召回率。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;recall_score:&quot;</span></span><br><span class="line"><span class="built_in">print</span> metrics.recall_score(test_Y, pred_Y)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;precision_score:&quot;</span></span><br><span class="line"><span class="built_in">print</span> metrics.precision_score(test_Y, pred_Y)</span><br></pre></td></tr></table></figure>
<p>输出结果如下，其中召回率为65.71%，准确率为73.40%。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">recall_score:</span><br><span class="line"><span class="number">0.657142857143</span></span><br><span class="line">precision_score:</span><br><span class="line"><span class="number">0.734042553191</span></span><br></pre></td></tr></table></figure>
<h2 id="准确度与F1-Score">准确度与F1-Score</h2>
<p>准确度（Accuracy）是对检测结果一个均衡的评价，表现的是全体预测正确占全部样本的比例。F1-Score也是对准确率和召回率的一个均衡评价，国内外不少数据挖掘比赛都是重点关注F1-Score的值。在Scikit-Learn中，可以如下获得准确度和F1-Score。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;accuracy_score:&quot;</span></span><br><span class="line"><span class="built_in">print</span> metrics.accuracy_score(test_Y, pred_Y)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;f1_score:&quot;</span></span><br><span class="line"><span class="built_in">print</span> metrics.f1_score(test_Y, pred_Y)</span><br></pre></td></tr></table></figure>
<p>输出结果如下，其中准确度为69.5%和F1-Score为69.34%。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">accuracy_score:</span><br><span class="line"><span class="number">0.695</span></span><br><span class="line">f1_score:</span><br><span class="line"><span class="number">0.693467336683</span></span><br></pre></td></tr></table></figure>
<h2 id="ROC与AUC">ROC与AUC</h2>
<p>ROC（Receiver Operating Characteristic Curve）受试者工作特征曲线，以真阳性率为纵坐标，假阳性率为横坐标绘制的曲线，是反映灵敏性和特效性连续变量的综合指标。一般认为ROC越光滑说明分类算法过拟合的概率越低，越接近左上角说明分类性能越好。AUC（Area Under the Receiver Operating Characteristic Curve）就是量化衡量ROC分类性能的指标，如图1-2 所示，物理含义是ROC曲线的面积，AUC越大越好。</p>
<p><img src="/img/picture/%E5%A6%82%E4%BD%95%E8%A1%A1%E9%87%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%88%86%E7%B1%BB%E5%99%A8%E6%A8%A1%E5%9E%8B-%E5%9B%BE2.png" alt="如何衡量机器学习分类器模型-图2" title="ROC曲线示例"></p>
<p>绘制ROC曲线的方法如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">f_pos, t_pos, thresh = metrics.roc_curve(test_Y, pred_Y)</span><br><span class="line">auc_area = metrics.auc(f_pos, t_pos) plt.plot(f_pos, t_pos, <span class="string">&#x27;darkorange&#x27;</span>, lw=<span class="number">2</span>, label=<span class="string">&#x27;AUC = %.2f&#x27;</span> % auc_area)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;lower right&#x27;</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>], color=<span class="string">&#x27;navy&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;ROC&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;True Pos Rate&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;False Pos Rate&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>在Scikit-Learn中，可以如下获得AUC值。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;AUC:&quot;</span></span><br><span class="line"><span class="built_in">print</span> metrics.roc_auc_score(test_Y, pred_Y)</span><br></pre></td></tr></table></figure>
<p>计算获得的AUC值为0.70。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">AUC:</span><br><span class="line"><span class="number">0.696992481203</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/duoergun0729/nlp">https://github.com/duoergun0729/nlp</a></p>
</blockquote>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>训练word2vec模型实战</title>
    <url>/posts/d0c0ed32.html</url>
    <content><![CDATA[<h1>训练语料</h1>
<p>word2vec的算法是公开的，word2vec模型的质量完全取决于训练语料的质量。目前免费开放的预料不多，中文语料更是凤毛麟角。</p>
<p><img src="/img/picture/%E4%BD%BF%E7%94%A8%E6%90%9C%E7%8B%97%E6%96%B0%E9%97%BB%E9%A2%84%E6%96%99%E7%94%9F%E6%88%90word2vec-%E5%9B%BE1.png" alt="使用搜狗新闻预料生成word2vec-图1"></p>
<p>这里推荐使用搜狗实验室的中文语料，对应的网址为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.sogou.com/labs/resource/cs.php</span><br></pre></td></tr></table></figure>
<p>通常使用&quot;搜狐新闻数据&quot;即可，该数据来自搜狐新闻2012年6月—7月期间国内，国际，体育，社会，娱乐等18个频道的新闻数据，提供URL和正文信息。</p>
<h2 id="数据格式">数据格式</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;doc&gt;</span><br><span class="line"></span><br><span class="line">&lt;url&gt;页面URL&lt;/url&gt;</span><br><span class="line"></span><br><span class="line">&lt;docno&gt;页面ID&lt;/docno&gt;</span><br><span class="line"></span><br><span class="line">&lt;contenttitle&gt;页面标题&lt;/contenttitle&gt;</span><br><span class="line"></span><br><span class="line">&lt;content&gt;页面内容&lt;/content&gt;</span><br><span class="line"></span><br><span class="line">&lt;/doc&gt;</span><br></pre></td></tr></table></figure>
<p>注意：content字段去除了HTML标签，保存的是新闻正文文本</p>
<h2 id="数据文件">数据文件</h2>
<p>搜狐新闻数据区根据文件格式和数据规模细分为以下几种：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>迷你版(样例数据, 110KB)：tar.gz格式，zip格式</p>
</li>
<li class="lvl-2">
<p>完整版(648MB)：tar.gz格式，zip格式</p>
</li>
<li class="lvl-2">
<p>历史版本：2008版(6KB)：完整版(同时提供硬盘拷贝,65GB)：tar.gz格式</p>
</li>
</ul>
<h1>数据预处理</h1>
<h2 id="提取中文内容">提取中文内容</h2>
<p>原始数据中包含完整的html文件，所以需要提取其中的中文内容，通常提取其中<code>&lt;content&gt;</code>标签包含的内容即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf news_sohusite_xml.full.tar.gz</span><br><span class="line">cat news_sohusite_xml.dat | iconv -f gb18030 -t utf-8 | grep &quot;&lt;content&gt;&quot; &gt; news_sohusite.txt</span><br><span class="line">sed -i &quot;&quot; &#x27;s/&lt;content&gt;//g&#x27; news_sohusite.txt</span><br><span class="line">sed -i &quot;&quot; &#x27;s/&lt;\/content&gt;//g&#x27; news_sohusite.txt</span><br></pre></td></tr></table></figure>
<p>其中iconv命令的格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iconv -f encoding [-t encoding] [inputfile]... </span><br></pre></td></tr></table></figure>
<p>参数含义为：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>-f encoding :把字符从encoding编码开始转换。</p>
</li>
<li class="lvl-2">
<p>-t encoding :把字符转换到encoding编码。</p>
</li>
<li class="lvl-2">
<p>-l :列出已知的编码字符集合</p>
</li>
<li class="lvl-2">
<p>-o file :指定输出文件</p>
</li>
<li class="lvl-2">
<p>-c :忽略输出的非法字符</p>
</li>
<li class="lvl-2">
<p>-s :禁止警告信息，但不是错误信息</p>
</li>
<li class="lvl-2">
<p>–verbose :显示进度信息</p>
</li>
<li class="lvl-2">
<p>-f和-t所能指定的合法字符在-l选项的命令里面都列出来了</p>
</li>
</ul>
<h2 id="中文切词">中文切词</h2>
<p>与处理英文不同，中文没有切词，需要使用jieba进行切词处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -m jieba -d &#x27; &#x27; news_sohusite.txt &gt; news_sohusite_cutword.txt</span><br></pre></td></tr></table></figure>
<h1>训练word2vec</h1>
<p>完成预处理后，即可以利用gensim库进行训练。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def train_word2vec(filename):</span><br><span class="line">    #模型文件不存在才处理</span><br><span class="line">    if not os.path.exists(word2vec_file):</span><br><span class="line">        sentences = LineSentence(filename)</span><br><span class="line">        #sg=0 使用cbow训练, sg=1对低频词较为敏感</span><br><span class="line">        model = Word2Vec(sentences,</span><br><span class="line">                         size=n_dim, window=5, min_count=2, sg=1, workers=2)</span><br><span class="line">        model.save(word2vec_file)</span><br></pre></td></tr></table></figure>
<p>Word2Vec函数常见的几个参数含义如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>sentences表示需要处理的语料</p>
</li>
<li class="lvl-2">
<p>size表示word2vec的维数，一般50-300</p>
</li>
<li class="lvl-2">
<p>window表示处理word时的窗口长度</p>
</li>
<li class="lvl-2">
<p>min_count表示处理分析的word出现的最小次数</p>
</li>
<li class="lvl-2">
<p>sg为1表示使用skip-gram算法，为0为cbow</p>
</li>
<li class="lvl-2">
<p>workers表示计算使用的线程数</p>
</li>
<li class="lvl-2">
<p>iter表示迭代计算的次数</p>
</li>
</ul>
<h1>使用word2vec处理中文</h1>
<p>把一个中文句子使用词向量表示的方法。对于类似短信、微博、标题这些长度较短的文字，可以使用各个word的word2vec相加取平均来表示。对训练数据集创建词向量，接着进行比例缩放（scale)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def buildWordVector(imdb_w2v,text, size):</span><br><span class="line">    vec = np.zeros(size).reshape((1, size))</span><br><span class="line">    count = 0.</span><br><span class="line">    #print text</span><br><span class="line">    for word in text.split():</span><br><span class="line">        #print word</span><br><span class="line">        try:</span><br><span class="line">            vec += imdb_w2v[word].reshape((1, size))</span><br><span class="line">            count += 1.</span><br><span class="line">        except KeyError:</span><br><span class="line">            print word</span><br><span class="line">            continue</span><br><span class="line">    if count != 0:</span><br><span class="line">        vec /= count</span><br><span class="line">    return vec</span><br></pre></td></tr></table></figure>
<p>当需要把中文数据集X转换成word2vec，可以使用如下方式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#加载训练好的词向量模型</span><br><span class="line">model = Word2Vec.load(word2vec_file)</span><br><span class="line"></span><br><span class="line">x_vecs = np.concatenate([buildWordVector(model,z, n_dim) for z in x])</span><br><span class="line">x_vecs = scale(x_vecs)</span><br></pre></td></tr></table></figure>
<h1>测试效果</h1>
<p>下面我们测试生成的word2vec模型的质量。</p>
<h2 id="寻找近义词">寻找近义词</h2>
<p>寻找近义词是word2vec的一个应用场景。</p>
<h3 id="百度的近义词">百度的近义词</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print pd.Series(model.most_similar(u&#x27;百度&#x27;))</span><br><span class="line">0      (网易, 0.844283640385)</span><br><span class="line">1    (搜索引擎, 0.822018146515)</span><br><span class="line">2      (腾讯, 0.774820387363)</span><br><span class="line">3       (搜狗, 0.76777946949)</span><br><span class="line">4      (新浪, 0.760137319565)</span><br><span class="line">5      (奇虎, 0.745484173298)</span><br><span class="line">6      (文库, 0.725166857243)</span><br><span class="line">7    (手机软件, 0.717750906944)</span><br><span class="line">8       (优酷, 0.70574760437)</span><br><span class="line">9      (客户端, 0.70448333025)</span><br></pre></td></tr></table></figure>
<h3 id="微信的近义词">微信的近义词</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print pd.Series(model.most_similar(u&#x27;微信&#x27;))</span><br><span class="line">0     (摇一摇, 0.768034994602)</span><br><span class="line">1      (陌陌, 0.763847649097)</span><br><span class="line">2    (网上聊天, 0.751431167126)</span><br><span class="line">3    (聊天工具, 0.731707036495)</span><br><span class="line">4      (盗号, 0.722806692123)</span><br><span class="line">5      (飞聊, 0.715048789978)</span><br><span class="line">6      (手机, 0.706719994545)</span><br><span class="line">7     (发短信, 0.704942345619)</span><br><span class="line">8      (聊天, 0.691777765751)</span><br><span class="line">9    (账号密码, 0.679741084576)</span><br></pre></td></tr></table></figure>
<h2 id="单词运算">单词运算</h2>
<p>word2vec的一个神奇之处就是把文字转换成了数字，数字之间的加减运算，同样适用于word2vec。</p>
<h3 id="足球-明星">足球+明星</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print pd.Series(model.most_similar(positive=[u&#x27;足球&#x27;+u&#x27;明星&#x27;]))</span><br><span class="line">0      (巨星, 0.741350233555)</span><br><span class="line">1    (光芒万丈, 0.727712750435)</span><br><span class="line">2     (和亨利, 0.722848057747)</span><br><span class="line">3      (球星, 0.722578346729)</span><br><span class="line">4       (已贵, 0.71345859766)</span><br><span class="line">5     (格米利, 0.694822609425)</span><br><span class="line">6     (支斯篮, 0.690492749214)</span><br><span class="line">7      (田坛, 0.689639627934)</span><br><span class="line">8      (体坛, 0.689606904984)</span><br><span class="line">9     (竞神锋, 0.684816122055)</span><br></pre></td></tr></table></figure>
<h3 id="球星-明星">球星-明星</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print pd.Series(model.most_similar(positive=[u&#x27;球星&#x27;],negative=[u&#x27;明星&#x27;]))</span><br><span class="line">dtype: object</span><br><span class="line">0    (国际米兰, 0.492849290371)</span><br><span class="line">1      (中锋, 0.480526059866)</span><br><span class="line">2      (球员, 0.479797780514)</span><br><span class="line">3     (上赛季, 0.479528963566)</span><br><span class="line">4      (主帅, 0.479275196791)</span><br><span class="line">5      (球队, 0.477513790131)</span><br><span class="line">6     (德里奇, 0.474446773529)</span><br><span class="line">7     (热那亚, 0.472252100706)</span><br><span class="line">8      (中场, 0.459134191275)</span><br><span class="line">9       (巴萨, 0.45858669281)</span><br></pre></td></tr></table></figure>
<h2 id="比较单词的相似度">比较单词的相似度</h2>
<h3 id="比较微信和陌陌">比较微信和陌陌</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> model.wv.similarity(<span class="string">u&#x27;微信&#x27;</span>, <span class="string">u&#x27;陌陌&#x27;</span>)</span><br><span class="line"><span class="number">0.763847656891</span></span><br></pre></td></tr></table></figure>
<h3 id="比较男人和坏人">比较男人和坏人</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> model.wv.similarity(<span class="string">u&#x27;男人&#x27;</span>, <span class="string">u&#x27;坏人&#x27;</span>)</span><br><span class="line"><span class="number">0.617036796702</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/duoergun0729/nlp">https://github.com/duoergun0729/nlp</a></p>
</blockquote>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>词袋模型和TFIDF模型</title>
    <url>/posts/cadaf4df.html</url>
    <content><![CDATA[<h2 id="词袋模型">词袋模型</h2>
<p>文本特征提取有两个非常重要的模型：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>词集模型：单词构成的集合，集合自然每个元素都只有一个，也即词集中的每个单词都只有一个。</p>
</li>
<li class="lvl-2">
<p>词袋模型：在词集的基础上如果一个单词在文档中出现不止一次，统计其出现的次数（频数）。</p>
</li>
</ul>
<p>两者本质上的区别，词袋是在词集的基础上增加了频率的维度，词集只关注有和没有，词袋还要关注有几个。假设我们要对一篇文章进行特征化，最常见的方式就是词袋。导入相关的函数库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn.feature_extraction.text import CountVectorizer</span><br></pre></td></tr></table></figure>
<p>实例化分词对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; vectorizer = CountVectorizer(min_df=1)</span><br><span class="line">&gt;&gt;&gt; vectorizer                    </span><br><span class="line">CountVectorizer(analyzer=...&#x27;word&#x27;, binary=False, decode_error=...&#x27;strict&#x27;,</span><br><span class="line">        dtype=&lt;... &#x27;numpy.int64&#x27;&gt;, encoding=...&#x27;utf-8&#x27;, input=...&#x27;content&#x27;,</span><br><span class="line">        lowercase=True, max_df=1.0, max_features=None, min_df=1,</span><br><span class="line">        ngram_range=(1, 1), preprocessor=None, stop_words=None,</span><br><span class="line">        strip_accents=None, token_pattern=...&#x27;(?u)\\b\\w\\w+\\b&#x27;,</span><br><span class="line">        tokenizer=None, vocabulary=None)</span><br></pre></td></tr></table></figure>
<p>将文本进行词袋处理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; corpus = [</span><br><span class="line">...     &#x27;This is the first document.&#x27;,</span><br><span class="line">...     &#x27;This is the second second document.&#x27;,</span><br><span class="line">...     &#x27;And the third one.&#x27;,</span><br><span class="line">...     &#x27;Is this the first document?&#x27;,</span><br><span class="line">... ]</span><br><span class="line">&gt;&gt;&gt; X = vectorizer.fit_transform(corpus)</span><br><span class="line">&gt;&gt;&gt; X                             </span><br><span class="line">&lt;4x9 sparse matrix of type &#x27;&lt;... &#x27;numpy.int64&#x27;&gt;&#x27;</span><br><span class="line">    with 19 stored elements in Compressed Sparse ... format&gt;</span><br></pre></td></tr></table></figure>
<p>获取对应的特征名称：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; vectorizer.get_feature_names() == (</span><br><span class="line">...     [&#x27;and&#x27;, &#x27;document&#x27;, &#x27;first&#x27;, &#x27;is&#x27;, &#x27;one&#x27;,</span><br><span class="line">...      &#x27;second&#x27;, &#x27;the&#x27;, &#x27;third&#x27;, &#x27;this&#x27;])</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>获取词袋数据，至此我们已经完成了词袋化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; X.toarray()          </span><br><span class="line">array([[0, 1, 1, 1, 0, 0, 1, 0, 1],</span><br><span class="line">       [0, 1, 0, 1, 0, 2, 1, 0, 1],</span><br><span class="line">       [1, 0, 0, 0, 1, 0, 1, 1, 0],</span><br><span class="line">       [0, 1, 1, 1, 0, 0, 1, 0, 1]]...)</span><br></pre></td></tr></table></figure>
<p>但是如何可以使用现有的词袋的特征，对其他文本进行特征提取呢？我们定义词袋的特征空间叫做词汇表vocabulary：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vocabulary=vectorizer.vocabulary_</span><br></pre></td></tr></table></figure>
<p>针对其他文本进行词袋处理时，可以直接使用现有的词汇表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; new_vectorizer = CountVectorizer(min_df=1, vocabulary=vocabulary)</span><br></pre></td></tr></table></figure>
<p>CountVectorize函数比较重要的几个参数为：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>decode_error，处理解码失败的方式，分为‘strict’、‘ignore’、‘replace’三种方式。</p>
</li>
<li class="lvl-2">
<p>strip_accents，在预处理步骤中移除重音的方式。</p>
</li>
<li class="lvl-2">
<p>max_features，词袋特征个数的最大值。</p>
</li>
<li class="lvl-2">
<p>stop_words，判断word结束的方式。</p>
</li>
<li class="lvl-2">
<p>max_df，df最大值。</p>
</li>
<li class="lvl-2">
<p>min_df，df最小值 。</p>
</li>
<li class="lvl-2">
<p>binary，默认为False，当与TF-IDF结合使用时需要设置为True。本例中处理的数据集均为英文，所以针对解码失败直接忽略，使用ignore方式，stop_words的方式使用english，strip_accents方式为ascii方式。</p>
</li>
</ul>
<h2 id="TF-IDF模型">TF-IDF模型</h2>
<p>文本处理领域还有一种特征提取方法，叫做TF-IDF模型（term frequency–inverse document frequency，词频与逆向文件频率）。TF-IDF是一种统计方法，用以评估某一字词对于一个文件集或一个语料库的重要程度。字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。TF-IDF加权的各种形式常被搜索引擎应用，作为文件与用户查询之间相关程度的度量或评级。<br>
TF-IDF的主要思想是，如果某个词或短语在一篇文章中出现的频率TF(Term Frequency，词频)，词频高，并且在其他文章中很少出现，则认为此词或者短语具有很好的类别区分能力，适合用来分类。TF-IDF实际上是：TF * IDF。TF表示词条在文档d中出现的频率。IDF（inverse document frequency，逆向文件频率）的主要思想是：如果包含词条t的文档越少，也就是n越小，IDF越大，则说明词条t具有很好的类别区分能力。如果某一类文档C中包含词条t的文档数为m，而其他类包含t的文档总数为k，显然所有包含t的文档数n=m+k，当m大的时候，n也大，按照IDF公式得到的IDF的值会小，就说明该词条t类别区分能力不强。但是实际上，如果一个词条在一个类的文档中频繁出现，则说明该词条能够很好代表这个类的文本的特征，这样的词条应该给它们赋予较高的权重，并选来作为该类文本的特征词以区别与其他类文档。在Scikit-Learn中实现了TF-IDF算法，实例化TfidfTransformer即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn.feature_extraction.text import TfidfTransformer</span><br><span class="line">&gt;&gt;&gt; transformer = TfidfTransformer(smooth_idf=False)</span><br><span class="line">&gt;&gt;&gt; transformer    </span><br><span class="line">TfidfTransformer(norm=...&#x27;l2&#x27;, smooth_idf=False, sublinear_tf=False, use_idf=True)</span><br></pre></td></tr></table></figure>
<p>TF-IDF模型通常和词袋模型配合使用，对词袋模型生成的数组进一步处理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; counts = [[3, 0, 1],</span><br><span class="line">...           [2, 0, 0],</span><br><span class="line">...           [3, 0, 0],</span><br><span class="line">...           [4, 0, 0],</span><br><span class="line">...           [3, 2, 0],</span><br><span class="line">...           [3, 0, 2]]</span><br><span class="line">...</span><br><span class="line"> &gt;&gt;&gt; tfidf = transformer.fit_transform(counts)</span><br><span class="line">&gt;&gt;&gt; tfidf                         </span><br><span class="line">&lt;6x3 sparse matrix of type &#x27;&lt;... &#x27;numpy.float64&#x27;&gt;&#x27;     with 9 stored elements in Compressed Sparse ... format&gt; </span><br><span class="line">&gt;&gt;&gt; tfidf.toarray()                         </span><br><span class="line">array([[ 0.81940995,  0.        ,  0.57320793],       </span><br><span class="line">[ 1.        ,  0.        ,  0.        ],      </span><br><span class="line">[ 1.        ,  0.        ,  0.        ],  </span><br><span class="line">[ 1.        ,  0.        ,  0.        ],       </span><br><span class="line">[ 0.47330339,  0.88089948,  0.        ],       </span><br><span class="line">[ 0.58149261,  0.        ,  0.81355169]])</span><br></pre></td></tr></table></figure>
<h2 id="词汇表模型">词汇表模型</h2>
<p>词袋模型可以很好的表现文本由哪些单词组成，但是却无法表达出单词之间的前后关系，于是人们借鉴了词袋模型的思想，使用生成的词汇表对原有句子按照单词逐个进行编码。TensorFlow默认支持了这种模型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    tf.contrib.learn.preprocessing.VocabularyProcessor (</span><br><span class="line">                                              max_document_length,    </span><br><span class="line">                                              min_frequency=0,</span><br><span class="line">                                              vocabulary=None,</span><br><span class="line">                                              tokenizer_fn=None)</span><br><span class="line">```                                              </span><br><span class="line">其中各个参数的含义为：</span><br><span class="line"></span><br><span class="line">- max_document_length:，文档的最大长度。如果文本的长度大于最大长度，那么它会被剪切，反之则用0填充。</span><br><span class="line">- min_frequency，词频的最小值，出现次数小于最小词频则不会被收录到词表中。</span><br><span class="line">- vocabulary，CategoricalVocabulary 对象。</span><br><span class="line">- tokenizer_fn，分词函数。</span><br><span class="line"></span><br><span class="line">假设有如下句子需要处理：</span><br></pre></td></tr></table></figure>
<pre><code>x_text =[
    'i love you',
    'me too'
]
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基于以上句子生成词汇表，并对&#x27;i me too&#x27;这句话进行编码：</span><br></pre></td></tr></table></figure>
<pre><code>vocab_processor = learn.preprocessing.VocabularyProcessor(max_document_length)
vocab_processor.fit(x_text)
print next(vocab_processor.transform(['i me too'])).tolist()
x = np.array(list(vocab_processor.fit_transform(x_text)))
print x
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行程序，x_text使用词汇表编码后的数据为：</span><br></pre></td></tr></table></figure>
<p>[[1 2 3 0]<br>
[4 5 0 0]]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;i me too&#x27;这句话编码的结果为：</span><br></pre></td></tr></table></figure>
<p>[1, 4, 5, 0]</p>
<pre><code>整个过程如下图所示。

![image](/img/picture/词袋模型和TFIDF模型-图1.png)

&gt; 原文：&lt;https://github.com/duoergun0729/nlp&gt;</code></pre>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux服务器存在大量log日志,如何快速定位错误</title>
    <url>/posts/5a8eb3c9.html</url>
    <content><![CDATA[<h1>针对大量log日志快速定位错误地方</h1>
<blockquote>
<p>动态查看日志</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -f catalina.out</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从头打开日志文件</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat catalina.out</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以使用 &gt;nanjiangtest.txt 输出某个新日志去查看</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@yesky logs]# cat -n catalina.out |grep 717892466 &gt;nanjiangtest.txt</span><br></pre></td></tr></table></figure>
<h2 id="tail-head简单命令使用">tail/head简单命令使用</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@yesky logs]# tail -n number catalina.out 查询日志尾部最后number行的日志</span><br><span class="line">[root@yesky logs]# tail -n +number catalina.out 查询number行之后的所有日志</span><br><span class="line">[root@yesky logs]# head -n number catalina.out 查询日志文件中的前number行日志</span><br><span class="line">[root@yesky logs]# head -n -number catalina.out 查询日志文件除了最后number行的其他所有日志</span><br></pre></td></tr></table></figure>
<h3 id="第一种方式（根据关键字查找出行号）">第一种方式（根据关键字查找出行号）</h3>
<blockquote>
<p>用grep拿到的日志很少，我们需要查看附近的日志。我是这样做的，首先: cat -n test.log | grep “关键词” 得到关键日志的行号</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@yesky logs]# cat -n catalina.out |grep 717892466</span><br><span class="line">13230539        [11:07 17:47:11] INFO nanjiang:Edit Old Article：717892466-2020-11-07 17:47:11</span><br><span class="line">13230593        [11:07 17:47:15] INFO nanjiangSave Article ID IS：717892466</span><br><span class="line">13230595        717892466 article.getDisplayTime()1 = 2020-11-07 16:25:11</span><br><span class="line">13230596        717892466 article.getDisplayTime()2 = 2020-11-07 16:25:11</span><br><span class="line">13230601        [11:07 17:47:15] INFO 南江 10.10.10.39  edit    article 717892466       编辑文章</span><br></pre></td></tr></table></figure>
<p>「cat -n catalina.out|tail -n +13230539|head -n 10」</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>tail -n +13230539表示查询13230539行之后的日志</p>
</li>
<li class="lvl-2">
<p>head -n 10则表示在前面的查询结果里再查前10条记录</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@yesky logs]# cat -n catalina.out |tail -n +13230539|head -n 10</span><br><span class="line">13230539        [11:07 17:47:11] INFO nanjiang:Edit Old Article：717892466-2020-11-07 17:47:11</span><br><span class="line">13230540        [11:07 17:47:11] INFO Takes:2 ms class com.tmg.cms.manager.dao.article.impl.ArticleContentDaoImpl       getListByArticleId      [NzE3ODkyNDY2]       [int]</span><br><span class="line">13230541        [11:07 17:47:11] INFO Takes:1 ms class com.tmg.cms.manager.dao.resourceImage.impl.ResourceImageDaoImpl  load    </span><br><span class="line">13230542        [11:07 17:47:11] INFO Takes:0 ms class com.tmg.cms.manager.dao.resourceImage.impl.ResourceImageDaoImpl  load    </span><br><span class="line">13230543        [11:07 17:47:11] INFO Takes:1 ms class com.tmg.cms.manager.dao.resourceImage.impl.ResourceImageDaoImpl  load    </span><br><span class="line">13230544        [11:07 17:47:11] INFO article.getImage3：/uploadImages/2020/312/02/3NXCRK4U3589_2.jpg</span><br><span class="line">13230545        [11:07 17:47:11] INFO Takes:0 ms class com.tmg.cms.manager.dao.resourceImage.impl.ResourceImageDaoImpl  load   </span><br><span class="line">13230546        [11:07 17:47:11] INFO Takes:2 ms class com.tmg.cms.manager.dao.privilege.impl.UserDaoImpl       getUserByid     </span><br><span class="line">13230547        [11:07 17:47:11] INFO Takes:57 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl     selectSitemapWithoutAudit       [MQ==]  [int]</span><br><span class="line">13230548        [11:07 17:47:11] INFO Takes:5 ms class com.tmg.cms.manager.dao.forbidword.impl.ForbidwordDaoImpl        getForbidwordBysiteid   [MjI=]  [int]</span><br></pre></td></tr></table></figure>
<h3 id="第二种方式：查看指定时间段内的日志">第二种方式：查看指定时间段内的日志</h3>
<blockquote>
<p>首先要进行范围时间段内日志查询先查看是否在当前日之内存在</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &#x27;11:07 18:29:20&#x27; catalina.out</span><br><span class="line">grep &#x27;11:07 18:31:11&#x27; catalina.out</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间范围内的查询</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -n &#x27;/11:07 18:29:20/,/11:07 18:31:11/p&#x27; catalina.out </span><br><span class="line">sed -n &#x27;/11:07 18:29:/,/11:07 18:31:/p&#x27; catalina.out</span><br></pre></td></tr></table></figure>
<h3 id="第三种方式：查看日志中特定字符的匹配数目">第三种方式：查看日志中特定字符的匹配数目</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@yesky logs]# grep &#x27;1175109632&#x27; catalina.out | wc -l</span><br></pre></td></tr></table></figure>
<h3 id="第四种方式：查询最后number行，并查找关键字“结果”">第四种方式：查询最后number行，并查找关键字“结果”</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@yesky logs]# tail -n 20 catalina.out | grep &#x27;INFO Takes:1&#x27;</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.config.impl.ConfigInfoDaoImpl load </span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [NTkwOTQ5] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MzI0] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MzI3] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MzMw] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MzA5NA==] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [Mzc4Mg==] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [OTM1MA==] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MTE5MDMw] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [NTQ2MzQw] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [NTg2NzYy] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MzYyMjA=] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.configModule.impl.ConfigModuleDaoImpl getPersonMenuList</span><br></pre></td></tr></table></figure>
<h3 id="第五种方式：查询最后number行，并查找关键字“结果”并且对结果进行标红，上下扩展两行">第五种方式：查询最后number行，并查找关键字“结果”并且对结果进行标红，上下扩展两行</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@yesky logs]# tail -n 20 catalina.out | grep &#x27;INFO Takes:1&#x27; --color -a2</span><br><span class="line">[11:11 22:02:51] INFO Takes:0 ms class com.tmg.cms.manager.dao.article.impl.ArticleContentDaoImpl getArticlePageNum [NzE4MTM2ODky] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.config.impl.ConfigInfoDaoImpl load [com.tmg.cms.manager.model.config.ConfigInfo]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [NTkwOTQ5] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MzI0] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:0 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MzI1] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MzI3] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MzMw] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:0 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MzAzNg==] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MzA5NA==] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [Mzc4Mg==] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [OTM1MA==] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:0 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MTE0MjQ4] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:0 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MTE4MDc4] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MTE5MDMw] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [NTQ2MzQw] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:0 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [NTQ3MTIw] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:0 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [NTY4OTYx] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [NTg2NzYy] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.sitemap.impl.SitemapDaoImpl getSitemapTop [MzYyMjA=] [int]</span><br><span class="line">[11:11 22:02:51] INFO Takes:1 ms class com.tmg.cms.manager.dao.configModule.impl.ConfigModuleDaoImpl getPersonMenuList [com.tmg.cms.manager.model.config.ConfigPersonMenu]</span><br></pre></td></tr></table></figure>
<h3 id="第七种方式：分页查看，使用空格翻页-使用more-less">第七种方式：分页查看，使用空格翻页(使用more/less)</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@yesky logs]# tail -n 2000 catalina.out | grep &#x27;INFO Takes:1&#x27; --color -a2 | more</span><br><span class="line">[root@yesky logs]# tail -n 2000 catalina.out | grep &#x27;INFO Takes:1&#x27; --color -a2 | less</span><br></pre></td></tr></table></figure>
<h2 id="附加">附加</h2>
<h3 id="1-全屏导航">1.全屏导航</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>ctrl + F - 向前移动一屏</p>
</li>
<li class="lvl-2">
<p>ctrl + B - 向后移动一屏</p>
</li>
<li class="lvl-2">
<p>ctrl + D - 向前移动半屏</p>
</li>
<li class="lvl-2">
<p>ctrl + U - 向后移动半屏</p>
</li>
</ul>
<h3 id="2-单行导航">2.单行导航</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>j - 向前移动一行</p>
</li>
<li class="lvl-2">
<p>k - 向后移动一行</p>
</li>
</ul>
<h3 id="3-其它导航">3.其它导航</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>G - 移动到最后一行</p>
</li>
<li class="lvl-2">
<p>g - 移动到第一行</p>
</li>
<li class="lvl-2">
<p>q / ZZ - 退出 less 命令</p>
</li>
</ul>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>linux环境变量加载顺序</title>
    <url>/posts/9104f7ba.html</url>
    <content><![CDATA[<h1>01、环境变量文件描述</h1>
<p><strong>/etc/profile</strong>: 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行,并从/etc/profile.d目录的配置文件中搜集shell的设置.<br>
<strong>/etc/bashrc</strong>: 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取.</p>
<p>//用户级别的环境变量，用户可以覆盖全局变量<br>
<strong>~/.bash_profile</strong>: 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件.<br>
<strong>~/.bashrc</strong>: 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取.<br>
<strong>~/.bash_logout</strong>: 当每次退出系统(退出bash shell)时,执行该文件.</p>
<p>/etc/profile中设定的变量(全局)的可以作用于任何用户,<br>
而~/.bashrc等中设定的变量(局部)只能继承/etc/profile中的变量,他们是&quot;父子&quot;关系.</p>
<p>~/.bash_profile 是交互式、login 方式进入 bash 运行的<br>
~/.bashrc 是交互式 non-login 方式进入 bash 运行的通常二者设置大致相同，所以通常前者会调用后者</p>
<h2 id="一、系统环境变量：">一、系统环境变量：</h2>
<p><strong>/etc/profile</strong> ：这个文件预设了几个重要的变量，例如PATH, USER, LOGNAME, MAIL, INPUTRC, HOSTNAME, HISTSIZE, umask等等。</p>
<p>为系统的每个用户设置环境信息。当用户第一次登陆时，该文件执行，并从/etc/profile.d目录中的配置文件搜索shell的设置（可以用于设定针对全系统所有用户的环境变量，环境变量周期是永久的）</p>
<p><strong>/etc/bashrc</strong> ：这个文件主要预设umask以及PS1。这个PS1就是我们在敲命令时，前面那串字符了，例如 [root@localhost ~]#,当bash shell被打开时,该文件被读取</p>
<p>这个文件是针对所有用户的bash初始化文件，在此设定中的环境信息将应用与所有用户的shell中，此文件会在用户每次打开shell时执行一次。（即每次新开一个终端，都会执行/etc/bashrc）**</p>
<h2 id="二、用户环境变量：">二、用户环境变量：</h2>
<p><strong>.bash_profile</strong> ：定义了用户的个人化路径与环境变量的文件名称。每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次。（在这个文件中有执行.bashrc的脚本）</p>
<p><strong>.bashrc</strong> ：该文件包含专用于你的shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。例如你可以将用户自定义的alias或者自定义变量写到这个文件中。</p>
<p><strong>.bash_history</strong> ：记录命令历史用的。</p>
<p><strong>.bash_logout</strong> ：当退出shell时，会执行该文件。可以把一些清理的工作放到这个文件中。</p>
<p>linux加载配置项时通过下面方式首先 加载/etc/profile配置</p>
<p>然后 加载/ect/profile.d/下面的所有脚本</p>
<p>然后 加载当前用户 .bash_profile</p>
<p>然后 加载.bashrc</p>
<p>最后 加载 [/etc/bashrc]</p>
<p>/etc/profile → /etc/profile.d/*.sh → ~/.bash_profile → ~/.bashrc → [/etc/bashrc]</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>拉链表</title>
    <url>/posts/2e5ad32b.html</url>
    <content><![CDATA[<!--markdown-->
<p>历史拉链表是一种数据模型，主要是针对数据仓库设计中表存储数据的方式而定义的。所谓历史拉链表，就是指记录一个事物从开始一直到当前状态的所有变化信息。拉所有记录链表可以避免按每一天存储造成的海量存储问题，同时也是处理缓慢变化数据的一种常见方式</p>
<h2 id="一、应用场景">一、应用场景</h2>
<p>现假设有如下场景：<br>
  一个企业拥有5000万会员信息，每天有20万会员资料变更，需要在数仓中记录会员表的历史变化以备分析使用，即每天都要保留一个快照供查询，反映历史数据的情况。在此场景中，需要反映5000万会员的历史变化，如果保留快照，存储两年就需要2X365X5000W条数据存储空间，数据量为365亿，如果存储更长时间，则无法估计需要的存储空间。而利用拉链算法存储，每日只向历史表中添加新增和变化的数据，每日不过20万条，存储4年也只需要3亿存储空间。</p>
<h2 id="二、实现步骤">二、实现步骤</h2>
<p>  在拉链表中，每一条数据都有一个生效日期(effective_date)和失效日期(expire_date)。假设在一个用户表中，在2019年11月8日新增了两个用户，如下表所示，则这两条记录的生效时间为当天，由于到2019年11月8日为止,这两条就还没有被修改过，所以失效时间为一个给定的比较大的值，比如：3000-12-31。</p>
<table>
<thead>
<tr>
<th style="text-align:center">member_id</th>
<th style="text-align:center">phoneno</th>
<th style="text-align:center">create_time</th>
<th style="text-align:center">update_time</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">10001</td>
<td style="text-align:center">13300000001</td>
<td style="text-align:center">2019-11-08</td>
<td style="text-align:center">3000-12-31</td>
</tr>
<tr>
<td style="text-align:center">10002</td>
<td style="text-align:center">13500000002</td>
<td style="text-align:center">2019-11-08</td>
<td style="text-align:center">3000-12-31</td>
</tr>
</tbody>
</table>
<p>  第二天(2019-11-09)，用户10001被删除了，用户10002的电话号码被修改成13600000002.为了保留历史状态，用户10001的失效时间被修改为2019-11-09，用户10002则变成了两条记录，如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">member_id</th>
<th style="text-align:center">phoneno</th>
<th style="text-align:center">create_time</th>
<th style="text-align:center">update_time</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">10001</td>
<td style="text-align:center">13300000001</td>
<td style="text-align:center">2019-11-08</td>
<td style="text-align:center">2019-11-09</td>
</tr>
<tr>
<td style="text-align:center">10002</td>
<td style="text-align:center">13500000002</td>
<td style="text-align:center">2019-11-08</td>
<td style="text-align:center">2019-11-09</td>
</tr>
<tr>
<td style="text-align:center">10002</td>
<td style="text-align:center">13600000002</td>
<td style="text-align:center">2019-11-09</td>
<td style="text-align:center">3000-12-31</td>
</tr>
</tbody>
</table>
<p>  第三天(2019-11-10),又新增了用户10003，则用户表数据如小表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">member_id</th>
<th style="text-align:center">phoneno</th>
<th style="text-align:center">create_time</th>
<th style="text-align:center">update_time</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">10001</td>
<td style="text-align:center">13300000001</td>
<td style="text-align:center">2019-11-08</td>
<td style="text-align:center">2019-11-09</td>
</tr>
<tr>
<td style="text-align:center">10002</td>
<td style="text-align:center">13500000002</td>
<td style="text-align:center">2019-11-08</td>
<td style="text-align:center">2019-11-09</td>
</tr>
<tr>
<td style="text-align:center">10002</td>
<td style="text-align:center">13600000002</td>
<td style="text-align:center">2019-11-09</td>
<td style="text-align:center">3000-12-31</td>
</tr>
<tr>
<td style="text-align:center">10003</td>
<td style="text-align:center">13600000006</td>
<td style="text-align:center">2019-11-10</td>
<td style="text-align:center">3000-12-31</td>
</tr>
</tbody>
</table>
<p>  如果要查询最新的数据，那么只要查询失效时间为3000-12-31的数据即可，如果要查11月8号的历史数据，则筛选生效时间&lt;= 2019-11-08并且失效时间&gt;2019-11-08的数据即可。如果查询11月9号的数据，那么筛选条件则是生效时间&lt;=2019-11-09并且失效时间&gt;2019-11-09.</p>
<h2 id="三、表结构">三、表结构</h2>
<p>MySQL源member表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">member</span>(</span><br><span class="line">             member_id <span class="type">VARCHAR</span> ( <span class="number">64</span> ),</span><br><span class="line">             phoneno <span class="type">VARCHAR</span> ( <span class="number">20</span> ),</span><br><span class="line">             create_time datetime,</span><br><span class="line">             update_time datetime );</span><br></pre></td></tr></table></figure>
<p>ODS层增量表member_delta,每天一个分区:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> member_delta(</span><br><span class="line">             member_id string,</span><br><span class="line">             phoneno string,</span><br><span class="line">             create_time string,</span><br><span class="line">             update_time string)</span><br><span class="line">PARTITIONED <span class="keyword">BY</span> (<span class="keyword">DAY</span> string);</span><br></pre></td></tr></table></figure>
<p>临时表:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> member_his_tmp(</span><br><span class="line">             member_id string,</span><br><span class="line">             phoneno string,</span><br><span class="line">             effective_date <span class="type">date</span>,</span><br><span class="line">             expire_date <span class="type">date</span></span><br><span class="line">             );</span><br></pre></td></tr></table></figure>
<p>DW层历史拉链表:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> member_his(</span><br><span class="line">             member_id string,</span><br><span class="line">             phoneno string,</span><br><span class="line">             effective_date <span class="type">date</span>,</span><br><span class="line">             expire_date <span class="type">date</span>);</span><br></pre></td></tr></table></figure>
<h2 id="四、Demo数据准备">四、Demo数据准备</h2>
<p>2019-11-08的数据为：</p>
<table><tbody><tr><td>member_id</td><td>phoneno</td><td>create_time</td><td>update_time</td></tr><tr><td>10001</td><td>13500000001</td><td>2019-11-08 14:47:55</td><td>2019-11-08 14:47:55</td></tr><tr><td>10002</td><td>13500000002</td><td>2019-11-08 14:48:33</td><td>2019-11-08 14:48:33</td></tr><tr><td>10003</td><td>13500000003</td><td>2019-11-08 14:48:53</td><td>2019-11-08 14:48:53</td></tr><tr><td>10004</td><td>13500000004</td><td>2019-11-08 14:49:02</td><td>2019-11-08 14:49:02</td></tr></tbody></table>
<p>2019-11-09的数据为：其中蓝色代表新增数据，红色代表修改的数据：</p>
<table><tbody><tr><td>member_id</td><td>phoneno</td><td>create_time</td><td>update_time</td></tr><tr><td>10001</td><td>13500000001</td><td>2019-11-08 14:47:55</td><td>2019-11-08 14:47:55</td></tr><tr><td bgcolor="#DC143C">10002</td><td bgcolor="#DC143C">13600000002</td><td bgcolor="#DC143C">2019-11-08 14:48:33</td><td bgcolor="#DC143C">2019-11-09 14:48:33</td></tr><tr><td>10003</td><td>13500000003</td><td>2019-11-08 14:48:53</td><td>2019-11-08 14:48:53</td></tr><tr><td>10004</td><td>13500000004</td><td>2019-11-08 14:49:02</td><td>2019-11-08 14:49:02</td></tr><tr><td bgcolor="#6495ED">10005</td><td bgcolor="#6495ED">13500000005</td><td bgcolor="#6495ED">2019-11-09 08:54:03</td><td bgcolor="#6495ED">2019-11-09 08:54:03</td></tr><tr><td bgcolor="#6495ED">10006</td><td bgcolor="#6495ED">13500000006</td><td bgcolor="#6495ED">2019-11-09 09:54:25</td><td bgcolor="#6495ED">2019-11-09 09:54:25</td></tr></tbody></table>
<p>2019-11-10的数据：其中蓝色代表新增数据，红色代表修改的数据：</p>
<table><tbody><tr><td>member_id</td><td>phoneno</td><td>create_time</td><td>update_time</td></tr><tr><td>10001</td><td>13500000001</td><td>2019-11-08 14:47:55</td><td>2019-11-08 14:47:55</td></tr><tr><td>10002</td><td>13600000002</td><td>2019-11-08 14:48:33</td><td>2019-11-09 14:48:33</td></tr><tr><td>10003</td><td>13500000003</td><td>2019-11-08 14:48:53</td><td>2019-11-08 14:48:53</td></tr><tr><td bgcolor="#DC143C">10004</td><td bgcolor="#DC143C">13600000004</td><td bgcolor="#DC143C">2019-11-08 14:49:02</td><td bgcolor="#DC143C">2019-11-10 14:49:02</td></tr><tr><td>10005</td><td>13500000005</td><td>2019-11-09 08:54:03</td><td>2019-11-09 08:54:03</td></tr><tr><td>10006</td><td>13500000006</td><td>2019-11-09 09:54:25</td><td>2019-11-09 09:54:25</td></tr><tr><td bgcolor="#6495ED">10007</td><td bgcolor="#6495ED">13500000007</td><td bgcolor="#6495ED">2019-11-10 17:41:49</td><td bgcolor="#6495ED">2019-11-10 17:41:49</td></tr></tbody></table>
<h2 id="五、全量初始装载">五、全量初始装载</h2>
<p>在启用拉链表时，先对其进行初始装载，比如以2019-11-08为开始时间，那么将MySQL源表全量抽取到ODS层member_delta表的2018-11-08的分区中，然后初始装载DW层的拉链表member_his。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> overwrite <span class="keyword">TABLE</span> member_his </span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">   member_id,</span><br><span class="line">   phoneno,</span><br><span class="line">   to_date ( create_time ) <span class="keyword">AS</span> effective_date,</span><br><span class="line">  <span class="string">&#x27;3000-12-31&#x27;</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	member_delta </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	<span class="keyword">DAY</span> <span class="operator">=</span> <span class="string">&#x27;2019-11-08&#x27;</span></span><br></pre></td></tr></table></figure>
<p>查询初始的历史拉链表数据:<br>
<img src="https://img-blog.csdnimg.cn/img_convert/b7b2455db73f3992a2dd519d052be2ec.png" alt=""></p>
<h2 id="六、增量抽取数据">六、增量抽取数据</h2>
<p>  每天，从源系统member表中，将前一天的增量数据抽取到ODS层的增量数据表member_delta对应的分区中。这里的增量需要通过member表中的创建时间和修改时间来确定，或者使用sqoop job监控update时间来进行增联抽取。比如，本案例中2019-11-09和2019-11-10为两个分区，分别存储了2019-11-09和2019-11-10日的增量数据。<br>
2019-11-09分区的数据为:<br>
<img src="https://img-blog.csdnimg.cn/img_convert/bf52c4d3d45507868059227dff275a86.png" alt=""></p>
<p>2019-11-10分区的数据为：<br>
<img src="https://img-blog.csdnimg.cn/img_convert/ccb1deaca665346cff84cbf1c8e694af.png" alt=""></p>
<h2 id="七、增量刷新历史拉链数据">七、增量刷新历史拉链数据</h2>
<h3 id="2019-11-09增量刷新历史拉链表：">2019-11-09增量刷新历史拉链表：</h3>
<h4 id="将数据放进临时表：">将数据放进临时表：</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> overwrite <span class="keyword">TABLE</span> member_his_tmp</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  (</span><br><span class="line"><span class="comment">-- 2019-11-09增量数据，代表最新的状态，该数据的生效时间是2019-11-09，过期时间为3000-12-31</span></span><br><span class="line"><span class="comment">-- 这些增量的数据需要被全部加载到历史拉链表中</span></span><br><span class="line"><span class="keyword">SELECT</span> member_id,</span><br><span class="line">       phoneno,</span><br><span class="line">       <span class="string">&#x27;2019-11-09&#x27;</span> effective_date,</span><br><span class="line">                    <span class="string">&#x27;3000-12-31&#x27;</span> expire_date</span><br><span class="line">   <span class="keyword">FROM</span> member_delta</span><br><span class="line">   <span class="keyword">WHERE</span> <span class="keyword">DAY</span><span class="operator">=</span><span class="string">&#x27;2019-11-09&#x27;</span></span><br><span class="line">   <span class="keyword">UNION</span> <span class="keyword">ALL</span> </span><br><span class="line"><span class="comment">-- 用当前为生效状态的拉链数据，去left join 增量数据，</span></span><br><span class="line"><span class="comment">-- 如果匹配得上，则表示该数据已发生了更新，</span></span><br><span class="line"><span class="comment">-- 此时，需要将发生更新的数据的过期时间更改为当前时间.</span></span><br><span class="line"><span class="comment">-- 如果匹配不上，则表明该数据没有发生更新，此时过期时间不变</span></span><br><span class="line"><span class="keyword">SELECT</span> a.member_id,</span><br><span class="line">       a.phoneno,</span><br><span class="line">       a.effective_date,</span><br><span class="line">       if(b.member_id <span class="keyword">IS</span> <span class="keyword">NULL</span>, to_date(a.expire_date), to_date(b.day)) expire_date</span><br><span class="line">   <span class="keyword">FROM</span></span><br><span class="line">     (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">      <span class="keyword">FROM</span> member_his</span><br><span class="line">    ) a</span><br><span class="line">   <span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">     (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">      <span class="keyword">FROM</span> member_delta</span><br><span class="line">      <span class="keyword">WHERE</span> <span class="keyword">DAY</span><span class="operator">=</span><span class="string">&#x27;2019-11-09&#x27;</span>) b <span class="keyword">ON</span> a.member_id<span class="operator">=</span>b.member_id)his</span><br></pre></td></tr></table></figure>
<h4 id="将数据覆盖到历史拉链表">将数据覆盖到历史拉链表:</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> overwrite <span class="keyword">TABLE</span> member_his</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> member_his_tmp</span><br></pre></td></tr></table></figure>
<h4 id="查看历史拉链表">查看历史拉链表:</h4>
<p><img src="https://img-blog.csdnimg.cn/img_convert/cbd380e301b1096d4c404c102cd79854.png" alt=""></p>
<h3 id="2019-11-10增量刷新历史拉链表">2019-11-10增量刷新历史拉链表</h3>
<h4 id="将数据放进临时表">将数据放进临时表</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> overwrite <span class="keyword">TABLE</span> member_his_tmp</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  (</span><br><span class="line"><span class="comment">-- 2019-11-10增量数据，代表最新的状态，该数据的生效时间是2019-11-10，过期时间为3000-12-31</span></span><br><span class="line"><span class="comment">-- 这些增量的数据需要被全部加载到历史拉链表中</span></span><br><span class="line"><span class="keyword">SELECT</span> member_id,</span><br><span class="line">       phoneno,</span><br><span class="line">       <span class="string">&#x27;2019-11-10&#x27;</span> effective_date,</span><br><span class="line">                    <span class="string">&#x27;3000-12-31&#x27;</span> expire_date</span><br><span class="line">   <span class="keyword">FROM</span> member_delta</span><br><span class="line">   <span class="keyword">WHERE</span> <span class="keyword">DAY</span><span class="operator">=</span><span class="string">&#x27;2019-11-10&#x27;</span></span><br><span class="line">   <span class="keyword">UNION</span> <span class="keyword">ALL</span> </span><br><span class="line"><span class="comment">-- 用当前为生效状态的拉链数据，去left join 增量数据，</span></span><br><span class="line"><span class="comment">-- 如果匹配得上，则表示该数据已发生了更新，</span></span><br><span class="line"><span class="comment">-- 此时，需要将发生更新的数据的过期时间更改为当前时间.</span></span><br><span class="line"><span class="comment">-- 如果匹配不上，则表明该数据没有发生更新，此时过期时间不变</span></span><br><span class="line"><span class="keyword">SELECT</span> a.member_id,</span><br><span class="line">       a.phoneno,</span><br><span class="line">       a.effective_date,</span><br><span class="line">       if(b.member_id <span class="keyword">IS</span> <span class="keyword">NULL</span>, to_date(a.expire_date), to_date(b.day)) expire_date</span><br><span class="line">   <span class="keyword">FROM</span></span><br><span class="line">     (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">      <span class="keyword">FROM</span> member_his</span><br><span class="line">    ) a</span><br><span class="line">   <span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">     (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">      <span class="keyword">FROM</span> member_delta</span><br><span class="line">      <span class="keyword">WHERE</span> <span class="keyword">DAY</span><span class="operator">=</span><span class="string">&#x27;2019-11-10&#x27;</span>) b <span class="keyword">ON</span> a.member_id<span class="operator">=</span>b.member_id)his</span><br></pre></td></tr></table></figure>
<h4 id="查看历史拉链表-2">查看历史拉链表:</h4>
<p><img src="https://pic.downk.cc/item/5ff6ab7d3ffa7d37b311909b.png" alt=""></p>
<h4 id="将以上脚本封装成shell调度的脚本">将以上脚本封装成shell调度的脚本:</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">如果是输入的日期按照取输入日期；如果没输入日期取当前时间的前一天</span></span><br><span class="line">if [ -n &quot;$1&quot; ] ;then</span><br><span class="line">	do_date=$1</span><br><span class="line">else </span><br><span class="line">	do_date=`date -d &quot;-1 day&quot; +%F`  </span><br><span class="line">fi </span><br><span class="line"></span><br><span class="line">sql=&quot;</span><br><span class="line"></span><br><span class="line">INSERT overwrite TABLE member_his_tmp</span><br><span class="line">SELECT *</span><br><span class="line">FROM</span><br><span class="line">  (</span><br><span class="line">-- 2019-11-10增量数据，代表最新的状态，该数据的生效时间是2019-11-10，过期时间为3000-12-31</span><br><span class="line">-- 这些增量的数据需要被全部加载到历史拉链表中</span><br><span class="line">SELECT member_id,</span><br><span class="line">       phoneno,</span><br><span class="line">       &#x27;$do_date&#x27; effective_date,</span><br><span class="line">       &#x27;3000-12-31&#x27; expire_date</span><br><span class="line">   FROM member_delta</span><br><span class="line">   WHERE DAY=&#x27;$do_date&#x27;</span><br><span class="line">   UNION ALL </span><br><span class="line">-- 用当前为生效状态的拉链数据，去left join 增量数据，</span><br><span class="line">-- 如果匹配得上，则表示该数据已发生了更新，</span><br><span class="line">-- 此时，需要将发生更新的数据的过期时间更改为当前时间.</span><br><span class="line">-- 如果匹配不上，则表明该数据没有发生更新，此时过期时间不变</span><br><span class="line">SELECT a.member_id,</span><br><span class="line">       a.phoneno,</span><br><span class="line">       a.effective_date,</span><br><span class="line">       if(b.member_id IS NULL, to_date(a.expire_date), to_date(b.day)) expire_date</span><br><span class="line">   FROM</span><br><span class="line">     (SELECT *</span><br><span class="line">      FROM member_his</span><br><span class="line"> ) a</span><br><span class="line">   LEFT JOIN</span><br><span class="line">     (SELECT *</span><br><span class="line">      FROM member_delta</span><br><span class="line">      WHERE DAY=&#x27;$do_date&#x27;) b ON a.member_id=b.member_id)his;</span><br><span class="line">&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">hive -e <span class="string">&quot;<span class="variable">$sql</span>&quot;</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据仓库</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Python OOP概念</title>
    <url>/posts/39d0c80e.html</url>
    <content><![CDATA[<h1>Python OOP 概念</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-oops-concepts">https://www.javatpoint.com/python-oops-concepts</a></p>
</blockquote>
<p>像其他通用编程语言一样，Python 从一开始就是一种面向对象的语言。它允许我们使用面向对象的方法开发应用。在 <a href="https://www.javatpoint.com/python-tutorial">Python</a> 中，我们可以轻松创建和使用类和对象。</p>
<p>面向对象的范例是使用类和对象来设计程序。对象与真实单词实体相关，如书、房子、铅笔等。oops 概念侧重于编写可重用的代码。通过创建对象来解决问题是一种普遍的技术。</p>
<p>面向对象编程系统的主要原理如下。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>类</p>
</li>
<li class="lvl-4">
<p>对象</p>
</li>
<li class="lvl-4">
<p>方法</p>
</li>
<li class="lvl-4">
<p>继承</p>
</li>
<li class="lvl-4">
<p>多态性</p>
</li>
<li class="lvl-4">
<p>数据抽象</p>
</li>
<li class="lvl-4">
<p>封装</p>
</li>
</ul>
<h2 id="班级">班级</h2>
<p>该类可以定义为对象的集合。它是一个逻辑实体，具有一些特定的属性和方法。例如:如果您有一个雇员类，那么它应该包含一个属性和方法，即电子邮件 id、姓名、年龄、工资等。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>:   </span><br><span class="line">        &lt;statement-<span class="number">1</span>&gt;   </span><br><span class="line">        .   </span><br><span class="line">        .    </span><br><span class="line">        &lt;statement-N&gt;   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="目标">目标</h2>
<p>对象是具有状态和行为的实体。它可以是任何真实世界的物体，如鼠标、键盘、椅子、桌子、笔等。</p>
<p>Python 中的一切都是对象，几乎一切都有属性和方法。所有函数都有一个内置属性 <strong>doc</strong>，它返回函数源代码中定义的 docstring。</p>
<p>当我们定义一个类时，它需要创建一个对象来分配内存。考虑下面的例子。</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">car</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,modelname, year</span>):</span><br><span class="line">        self.modelname = modelname</span><br><span class="line">        self.year = year</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.modelname,self.year)</span><br><span class="line"></span><br><span class="line">c1 = car(<span class="string">&quot;Toyota&quot;</span>, <span class="number">2016</span>)</span><br><span class="line">c1.display()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Toyota <span class="number">2016</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们已经创建了名为 car 的类，它有两个属性 modelname 和 year。我们已经创建了一个 c1 对象来访问类属性。c1 对象将为这些值分配内存。我们将在下一个教程中学习更多关于类和对象的知识。</p>
<h2 id="方法">方法</h2>
<p>方法是与对象关联的函数。在 Python 中，方法不是类实例独有的。任何对象类型都可以有方法。</p>
<h2 id="继承">继承</h2>
<p>继承是面向对象编程最重要的方面，它模拟了现实世界中的继承概念。它指定子对象获取父对象的所有属性和行为。</p>
<p>通过使用继承，我们可以创建一个使用另一个类的所有属性和行为的类。新类称为派生类或子类，而获取其属性的类称为基类或父类。</p>
<p>它提供了代码的重用性。</p>
<h2 id="多态性">多态性</h2>
<p>多态性包含两个词“聚”和“形”。多边形意味着很多，变形意味着形状。通过多态性，我们理解一个任务可以用不同的方式执行。比如——你有一个类动物，所有的动物都会说话。但是他们说话不同。在这里，“说话”行为在某种意义上是多态的，并且取决于动物。所以，抽象的“动物”概念实际上并不“说话”，而是具体的动物(如狗和猫)有一个具体实施的动作“说话”。</p>
<h2 id="封装">封装</h2>
<p>封装也是面向对象编程的一个重要方面。它用于限制对方法和变量的访问。在封装中，代码和数据被包装在一个单元中，不会被意外修改。</p>
<h2 id="数据抽象">数据抽象</h2>
<p>数据抽象和封装都经常被用作同义词。两者几乎是同义词，因为数据抽象是通过封装实现的。</p>
<p>抽象用于隐藏内部细节，只显示功能。抽象事物意味着给事物命名，这样名字就抓住了一个函数或整个程序的核心。</p>
<h2 id="面向对象和面向过程的编程语言">面向对象和面向过程的编程语言</h2>
<p>面向对象和面向过程编程的区别如下:</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>面向对象编程</th>
<th>面向过程编程</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.</td>
<td>面向对象编程是解决问题的方法，用于通过使用对象完成计算的地方。</td>
<td>过程编程使用一系列指令来逐步进行计算。</td>
</tr>
<tr>
<td>2.</td>
<td>它使开发和维护更加容易。</td>
<td>在过程编程中，当项目变得冗长时，维护代码并不容易。</td>
</tr>
<tr>
<td>3.</td>
<td>它模拟真实世界的实体。因此，现实世界的问题可以通过 oops 轻松解决。</td>
<td>它没有模拟真实世界。它对被分成称为函数的小部分的逐步指令起作用。</td>
</tr>
<tr>
<td>4.</td>
<td>它提供数据隐藏。所以它比过程语言更安全。您不能从任何地方访问私人数据。</td>
<td>过程语言没有为数据绑定提供任何合适的方式，因此不太安全。</td>
</tr>
<tr>
<td>5.</td>
<td>面向对象编程语言的例子是 C++、Java、。Net、Python、C#等。</td>
<td>过程语言例子有:C，Fortran，Pascal，VB 等。</td>
</tr>
</tbody>
</table>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-OOP</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 中的抽象</title>
    <url>/posts/4bd79900.html</url>
    <content><![CDATA[<h1>Python 中的抽象</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/abstraction-in-python">https://www.javatpoint.com/abstraction-in-python</a></p>
</blockquote>
<p>抽象用于向用户隐藏函数的内部功能。用户只与功能的基本实现交互，但内部工作是隐藏的。用户熟悉**“什么功能”<strong>但是不知道</strong>“它是怎么做的。”**</p>
<p>简单地说，我们都使用智能手机，并且非常熟悉它的功能，如摄像头、录音机、拨号等。，但我们不知道这些操作是如何在后台发生的。我们再举一个例子——当我们使用电视遥控器增加音量时。我们不知道按一个键如何增加电视的音量。我们只知道按“+”按钮来增加音量。</p>
<p>这正是在<a href="https://www.javatpoint.com/python-oops-concepts">面向对象概念</a>中工作的抽象。</p>
<h2 id="为什么抽象很重要？">为什么抽象很重要？</h2>
<p>在 Python 中，抽象用于隐藏不相关的数据/类，以降低复杂性。也提高了应用效率。接下来，我们将学习如何使用 <a href="https://www.javatpoint.com/python-programs">Python 程序</a>实现抽象。</p>
<h2 id="Python-中的抽象类">Python 中的抽象类</h2>
<p>在 <a href="https://www.javatpoint.com/python-tutorial">Python</a> 中，抽象可以通过使用抽象类和接口来实现。</p>
<p>由一个或多个抽象方法组成的类称为抽象类。抽象方法不包含它们的实现。抽象类可以被子类继承，抽象方法在子类中得到定义。抽象类是另一个类的蓝图。当我们设计大型函数时，抽象类可能很有用。抽象类也有助于为组件的不同实现提供标准接口。Python 提供了 <strong>abc</strong> 模块来使用 Python 程序中的抽象。让我们看看下面的语法。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们从 <strong>abc</strong> 模块导入 ABC 类。</p>
<h2 id="抽象基类">抽象基类</h2>
<p>抽象基类是一组子类接口的通用应用。它可以被第三方使用，第三方将提供诸如插件的实现。当我们使用大型代码库来努力记住所有的类时，这也是有益的。</p>
<h2 id="抽象类的工作">抽象类的工作</h2>
<p>与其他高级语言不同，Python 本身不提供抽象类。我们需要导入 abc 模块，它为定义抽象基类提供了基础。ABC 的工作原理是将基类的方法装饰成抽象的。它将具体的类注册为抽象基的实现。我们使用***@ abstract method】***装饰器来定义一个抽象方法，或者如果我们不为该方法提供定义，它会自动成为抽象方法。让我们理解下面的例子。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Python program demonstrate</span></span><br><span class="line"><span class="comment"># abstract base class work </span></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>(<span class="title class_ inherited__">ABC</span>): </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">mileage</span>(<span class="params">self</span>): </span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tesla</span>(<span class="title class_ inherited__">Car</span>): </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">mileage</span>(<span class="params">self</span>): </span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;The mileage is 30kmph&quot;</span>) </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Suzuki</span>(<span class="title class_ inherited__">Car</span>): </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">mileage</span>(<span class="params">self</span>): </span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;The mileage is 25kmph &quot;</span>) </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Duster</span>(<span class="title class_ inherited__">Car</span>): </span><br><span class="line">	 <span class="keyword">def</span> <span class="title function_">mileage</span>(<span class="params">self</span>): </span><br><span class="line">		  <span class="built_in">print</span>(<span class="string">&quot;The mileage is 24kmph &quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Renault</span>(<span class="title class_ inherited__">Car</span>): </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mileage</span>(<span class="params">self</span>): </span><br><span class="line">		    <span class="built_in">print</span>(<span class="string">&quot;The mileage is 27kmph &quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Driver code </span></span><br><span class="line">t= Tesla () </span><br><span class="line">t.mileage() </span><br><span class="line"></span><br><span class="line">r = Renault() </span><br><span class="line">r.mileage() </span><br><span class="line"></span><br><span class="line">s = Suzuki() </span><br><span class="line">s.mileage() </span><br><span class="line">d = Duster() </span><br><span class="line">d.mileage()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The mileage <span class="keyword">is</span> 30kmph</span><br><span class="line">The mileage <span class="keyword">is</span> 27kmph </span><br><span class="line">The mileage <span class="keyword">is</span> 25kmph </span><br><span class="line">The mileage <span class="keyword">is</span> 24kmph</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>解释-</strong></p>
<p>在上面的代码中，我们已经导入了 <strong>abc 模块</strong>来创建抽象基类。我们创建了继承了 ABC 类的 Car 类，并定义了一个名为里程()的抽象方法。然后，我们从三个不同的子类继承了基类，并以不同的方式实现了抽象方法。我们创建了对象来调用抽象方法。</p>
<p>让我们理解另一个例子。</p>
<p>让我们理解另一个例子。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Python program to define </span></span><br><span class="line"><span class="comment"># abstract class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Polygon</span>(<span class="title class_ inherited__">ABC</span>): </span><br><span class="line"></span><br><span class="line">   <span class="comment"># abstract method </span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">sides</span>(<span class="params">self</span>): </span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span>(<span class="title class_ inherited__">Polygon</span>): </span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">sides</span>(<span class="params">self</span>): </span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Triangle has 3 sides&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pentagon</span>(<span class="title class_ inherited__">Polygon</span>): </span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">sides</span>(<span class="params">self</span>): </span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Pentagon has 5 sides&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hexagon</span>(<span class="title class_ inherited__">Polygon</span>): </span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">sides</span>(<span class="params">self</span>): </span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Hexagon has 6 sides&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">square</span>(<span class="title class_ inherited__">Polygon</span>): </span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">sides</span>(<span class="params">self</span>): </span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;I have 4 sides&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Driver code </span></span><br><span class="line">t = Triangle() </span><br><span class="line">t.sides() </span><br><span class="line"></span><br><span class="line">s = square() </span><br><span class="line">s.sides() </span><br><span class="line"></span><br><span class="line">p = Pentagon() </span><br><span class="line">p.sides() </span><br><span class="line"></span><br><span class="line">k = Hexagon() </span><br><span class="line">K.sides() </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Triangle has <span class="number">3</span> sides</span><br><span class="line">Square has <span class="number">4</span> sides</span><br><span class="line">Pentagon has <span class="number">5</span> sides</span><br><span class="line">Hexagon has <span class="number">6</span> sides</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>解释-</strong></p>
<p>在上面的代码中，我们定义了名为 Polygon 的抽象基类，并定义了抽象方法。这个基类由不同的子类继承。我们在每个子类中实现了抽象方法。我们创建了子类的对象，并调用了 <strong>sides()</strong> 方法。每个子类中的**边()**方法的隐藏实现开始发挥作用。抽象类中定义的抽象方法 <strong>sides()</strong> 方法从未被调用。</p>
<h2 id="需要记住的要点">需要记住的要点</h2>
<p>下面是我们应该记住的关于 Python 中抽象基类的几点。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>抽象类可以包含普通方法和抽象方法。</p>
</li>
<li class="lvl-4">
<p>无法实例化抽象；我们不能为抽象类创建对象。</p>
</li>
</ul>
<p>抽象对于向用户隐藏核心功能至关重要。我们已经介绍了 Python 中抽象的所有基本概念。</p>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-OOP</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 构造器</title>
    <url>/posts/f1d84d54.html</url>
    <content><![CDATA[<h1>Python 构造器</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-constructors">https://www.javatpoint.com/python-constructors</a></p>
</blockquote>
<p>构造器是一种特殊类型的方法(函数)，用于初始化类的实例成员。</p>
<p>在 C++或 Java 中，构造器与其类同名，但在 Python 中它对构造器的处理不同。它用于创建对象。</p>
<p>构造器可以有两种类型。</p>
<ol>
<li class="lvl-4">
<p>参数化构造器</p>
</li>
<li class="lvl-4">
<p>非参数化构造器</p>
</li>
</ol>
<p>构造器定义是在我们创建这个类的对象时执行的。构造器还验证对象是否有足够的资源来执行任何启动任务。</p>
<h2 id="用-python-创建构造器">用 python 创建构造器</h2>
<p>在 Python 中，方法 <strong><strong>init</strong>()</strong> 模拟类的构造器。当类实例化时调用此方法。它接受<strong>self</strong>-关键字作为允许访问类的属性或方法的第一个参数。</p>
<p>我们可以在创建类对象时传递任意数量的参数，这取决于 <strong><strong>init</strong>()</strong> 的定义。它主要用于初始化类属性。每个类都必须有一个构造器，即使它只是依赖于默认的构造器。</p>
<p>考虑下面的例子来初始化<strong>雇员</strong>类属性。</p>
<h3 id="例子">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, <span class="built_in">id</span></span>):</span><br><span class="line">        self.<span class="built_in">id</span> = <span class="built_in">id</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ID: %d \nName: %s&quot;</span> % (self.<span class="built_in">id</span>, self.name))</span><br><span class="line"></span><br><span class="line">emp1 = Employee(<span class="string">&quot;John&quot;</span>, <span class="number">101</span>)</span><br><span class="line">emp2 = Employee(<span class="string">&quot;David&quot;</span>, <span class="number">102</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># accessing display() method to print employee 1 information</span></span><br><span class="line"></span><br><span class="line">emp1.display()</span><br><span class="line"></span><br><span class="line"><span class="comment"># accessing display() method to print employee 2 information</span></span><br><span class="line">emp2.display()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ID: <span class="number">101</span> </span><br><span class="line">Name: John</span><br><span class="line">ID: <span class="number">102</span> </span><br><span class="line">Name: David</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="计算一个类的对象数">计算一个类的对象数</h3>
<p>当我们创建类的对象时，会自动调用构造器。考虑下面的例子。</p>
<h3 id="例子-2">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:  </span><br><span class="line">    count = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):  </span><br><span class="line">        Student.count = Student.count + <span class="number">1</span>  </span><br><span class="line">s1=Student()  </span><br><span class="line">s2=Student()  </span><br><span class="line">s3=Student()  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The number of students:&quot;</span>,Student.count)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The number of students: <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Python-非参数化构造器">Python 非参数化构造器</h2>
<p>当我们不想操作只有 self 作为参数的值或构造器时，使用非参数化构造器。考虑下面的例子。</p>
<h3 id="例子-3">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="comment"># Constructor - non parameterized</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This is non parametrized constructor&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">self,name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>,name)</span><br><span class="line">student = Student()</span><br><span class="line">student.show(<span class="string">&quot;John&quot;</span>)    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Python-参数化构造器">Python 参数化构造器</h2>
<p>参数化构造器有多个参数以及<strong>自身</strong>。考虑下面的例子。</p>
<h3 id="例子-4">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="comment"># Constructor - parameterized</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This is parametrized constructor&quot;</span>)</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>,self.name)</span><br><span class="line">student = Student(<span class="string">&quot;John&quot;</span>)</span><br><span class="line">student.show()  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">This <span class="keyword">is</span> parametrized constructor</span><br><span class="line">Hello John</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Python-默认构造器">Python 默认构造器</h2>
<p>当我们没有在类中包含构造器或者忘记声明它时，那么它就变成了默认的构造器。它不执行任何任务，但初始化对象。考虑下面的例子。</p>
<h3 id="例子-5">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    roll_num = <span class="number">101</span></span><br><span class="line">    name = <span class="string">&quot;Joseph&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.roll_num,self.name)</span><br><span class="line"></span><br><span class="line">st = Student()</span><br><span class="line">st.display()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">101</span> Joseph</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="一个类中有多个构造器">一个类中有多个构造器</h2>
<p>让我们看看另一个场景，如果我们在类中声明两个相同的构造器会发生什么。</p>
<h3 id="例子-6">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The First Constructor&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The second contructor&quot;</span>)</span><br><span class="line"></span><br><span class="line">st = Student()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The Second Constructor</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，对象 <strong>st</strong> 调用了第二个构造器，而两者具有相同的配置。第一种方法不能被 <strong>st</strong> 对象访问。在内部，如果类有多个构造器，该类的对象将总是调用最后一个构造器。</p>
<h4 id="注意-Python-中不允许构造器重载。">注意:Python 中不允许构造器重载。</h4>
<h2 id="Python-内置的类函数">Python 内置的类函数</h2>
<p>下表描述了类中定义的内置函数。</p>
<p>| 序号 | 功能 | 描述 |<br>
| one | getattr（obj，name，default） | 它用于访问对象的属性。 |<br>
| Two | setattr(obj、name、value) | 它用于为对象的特定属性设置特定值。 |<br>
| three | delaattr(obj，name) | 它用于删除特定属性。 |<br>
| four | hasattr(obj，name) | 如果对象包含某些特定属性，则返回 true。 |</p>
<h3 id="例子-7">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, <span class="built_in">id</span>, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.<span class="built_in">id</span> = <span class="built_in">id</span></span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># creates the object of the class Student</span></span><br><span class="line">s = Student(<span class="string">&quot;John&quot;</span>, <span class="number">101</span>, <span class="number">22</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># prints the attribute name of the object s</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(s, <span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># reset the value of attribute age to 23</span></span><br><span class="line"><span class="built_in">setattr</span>(s, <span class="string">&quot;age&quot;</span>, <span class="number">23</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># prints the modified value of age</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(s, <span class="string">&#x27;age&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># prints true if the student contains the attribute with name id</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(s, <span class="string">&#x27;id&#x27;</span>))</span><br><span class="line"><span class="comment"># deletes the attribute age</span></span><br><span class="line"><span class="built_in">delattr</span>(s, <span class="string">&#x27;age&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># this will give an error since the attribute age has been deleted</span></span><br><span class="line"><span class="built_in">print</span>(s.age)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">John</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line">AttributeError: <span class="string">&#x27;Student&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;age&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="内置类属性">内置类属性</h2>
<p>除了其他属性，Python 类还包含一些内置的类属性，这些属性提供了关于该类的信息。</p>
<p>下表给出了内置的类属性。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>one</td>
<td><strong>dict</strong></td>
<td>它提供了包含类命名空间信息的字典。</td>
</tr>
<tr>
<td>Two</td>
<td><strong>doc</strong></td>
<td>它包含一个包含类文档的字符串</td>
</tr>
<tr>
<td>three</td>
<td><strong>name</strong></td>
<td>它用于访问类名。</td>
</tr>
<tr>
<td>four</td>
<td><strong>moudle</strong></td>
<td>它用于访问定义该类的模块。</td>
</tr>
<tr>
<td>five</td>
<td><strong>base</strong></td>
<td>它包含一个包含所有基类的元组。</td>
</tr>
</tbody>
</table>
<h3 id="例子-8">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,<span class="built_in">id</span>,age</span>):  </span><br><span class="line">        self.name = name;  </span><br><span class="line">        self.<span class="built_in">id</span> = <span class="built_in">id</span>;  </span><br><span class="line">        self.age = age  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display_details</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Name:%s, ID:%d, age:%d&quot;</span>%(self.name,self.<span class="built_in">id</span>))  </span><br><span class="line">s = Student(<span class="string">&quot;John&quot;</span>,<span class="number">101</span>,<span class="number">22</span>)  </span><br><span class="line"><span class="built_in">print</span>(s.__doc__)  </span><br><span class="line"><span class="built_in">print</span>(s.__dict__)  </span><br><span class="line"><span class="built_in">print</span>(s.__module__)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">None</span></span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;id&#x27;</span>: <span class="number">101</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">22</span>&#125;</span><br><span class="line">__main__</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-OOP</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 类和对象</title>
    <url>/posts/a39fbc03.html</url>
    <content><![CDATA[<h1>Python 类和对象</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-objects-classes">https://www.javatpoint.com/python-objects-classes</a></p>
</blockquote>
<p>我们在之前的教程中已经讨论过，类是一个虚拟实体，可以看作是一个对象的蓝图。该类在实例化时就存在了。我们举个例子来理解一下。</p>
<p>假设一个类是一个建筑的原型。一栋建筑包含了所有关于楼层、房间、门、窗等的细节。基于这些细节，我们可以建造任意多的建筑。因此，建筑可以被看作一个类，我们可以创建尽可能多的这个类的对象。</p>
<p>另一方面，对象是类的实例。创建对象的过程可以称为实例化。</p>
<p>在教程的这一部分，我们将讨论用 Python 创建类和对象。我们还将讨论如何使用对象访问类属性。</p>
<h2 id="用-Python-创建类">用 Python 创建类</h2>
<p>在 Python 中，可以通过使用关键字 class，后跟类名来创建一个类。下面给出了创建类的语法。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>:  </span><br><span class="line">    <span class="comment">#statement_suite   </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>In Python, we must notice that each class is associated with a documentation string which can be accessed by using <strong><class-name>.<strong>doc</strong>.</strong> A class contains a statement suite including fields, constructor, function, etc. definition.</p>
<p>考虑下面的例子来创建一个类 <strong>Employee</strong> ，它包含两个字段作为 Employee id 和 name。</p>
<p>该类还包含一个功能<strong>显示()</strong>，用于显示<strong>员工的信息。</strong></p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>:  </span><br><span class="line">    <span class="built_in">id</span> = <span class="number">10</span> </span><br><span class="line">    name = <span class="string">&quot;Devansh&quot;</span>  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span> (self):  </span><br><span class="line">        <span class="built_in">print</span>(self.<span class="built_in">id</span>,self.name)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里 <strong>self</strong> 作为引用变量，引用当前类对象。它总是函数定义中的第一个参数。但是，在函数调用中，使用 <strong>self</strong> 是可选的。</p>
<h3 id="自参数">自参数</h3>
<p>self 参数引用类的当前实例并访问类变量。我们可以用任何东西代替自我，但它必须是属于类的任何函数的第一个参数。</p>
<h2 id="创建类的实例">创建类的实例</h2>
<p>如果我们想在另一个类或方法中使用类属性，就需要实例化一个类。可以通过使用类名调用类来实例化类。</p>
<p>下面给出了创建类实例的语法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;<span class="built_in">object</span>-name&gt; = &lt;<span class="keyword">class</span>-name&gt;(&lt;arguments&gt;)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面的示例创建在上面的示例中定义的雇员类的实例。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>:  </span><br><span class="line">    <span class="built_in">id</span> = <span class="number">10</span> </span><br><span class="line">    name = <span class="string">&quot;John&quot;</span>  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span> (self):  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ID: %d \nName: %s&quot;</span>%(self.<span class="built_in">id</span>,self.name))  </span><br><span class="line"><span class="comment"># Creating a emp instance of Employee class</span></span><br><span class="line">emp = Employee()  </span><br><span class="line">emp.display()  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ID: <span class="number">10</span> </span><br><span class="line">Name: John</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们创建了 Employee 类，它有两个名为 id 和 name 的属性，并为它们赋值。我们可以观察到我们在显示功能中通过了自我作为参数。它用于引用同一个类属性。</p>
<p>我们创建了一个名为 **emp 的新实例对象。**通过使用它，我们可以访问类的属性。</p>
<h2 id="删除对象">删除对象</h2>
<p>我们可以使用 del 关键字删除对象或对象本身的属性。考虑下面的例子。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>:</span><br><span class="line">    <span class="built_in">id</span> = <span class="number">10</span></span><br><span class="line">    name = <span class="string">&quot;John&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ID: %d \nName: %s&quot;</span> % (self.<span class="built_in">id</span>, self.name))</span><br><span class="line">    <span class="comment"># Creating a emp instance of Employee class</span></span><br><span class="line"></span><br><span class="line">emp = Employee()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Deleting the property of object</span></span><br><span class="line"><span class="keyword">del</span> emp.<span class="built_in">id</span></span><br><span class="line"><span class="comment"># Deleting the object itself</span></span><br><span class="line"><span class="keyword">del</span> emp</span><br><span class="line">emp.display()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它将通过属性错误，因为我们已经删除了对象 <strong>emp</strong> 。</p>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-OOP</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 继承</title>
    <url>/posts/1aca788d.html</url>
    <content><![CDATA[<h1>Python 继承</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/inheritance-in-python">https://www.javatpoint.com/inheritance-in-python</a></p>
</blockquote>
<p>继承是面向对象范例的一个重要方面。继承为程序提供了代码可重用性，因为我们可以使用现有的类来创建新的类，而不是从头开始创建。</p>
<p>在继承中，子类获取属性，并且可以访问父类中定义的所有数据成员和函数。子类也可以向父类的函数提供其特定的实现。在教程的这一部分，我们将详细讨论继承。</p>
<p>在 python 中，派生类只需在派生类名称后面的括号中提到基类，就可以继承基类。考虑以下语法将基类继承到派生类中。</p>
<h3 id="句法">句法</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span>-<span class="keyword">class</span>(base <span class="keyword">class</span>):</span><br><span class="line">	&lt;<span class="keyword">class</span>-suite&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一个类可以通过在括号内提及所有类来继承多个类。请考虑以下语法。</p>
<h3 id="句法-2">句法</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derive</span>-<span class="keyword">class</span>(&lt;base <span class="keyword">class</span> <span class="number">1</span>&gt;, &lt;base <span class="keyword">class</span> <span class="number">2</span>&gt;, ..... &lt;base <span class="keyword">class</span> <span class="title class_">n</span>&gt;):</span><br><span class="line">	&lt;<span class="keyword">class</span> - suite&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例-1">例 1</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Animal Speaking&quot;</span>)</span><br><span class="line"><span class="comment">#child class Dog inherits the base class Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bark</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;dog barking&quot;</span>)</span><br><span class="line">d = Dog()</span><br><span class="line">d.bark()</span><br><span class="line">d.speak()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">dog barking</span><br><span class="line">Animal Speaking</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-多级继承">Python 多级继承</h2>
<p>像其他面向对象语言一样，python 中的多级继承是可能的。当一个派生类继承另一个派生类时，多级继承被存档。在 python 中，多级继承的存档级别不限。</p>
<p>下面给出了多级继承的语法。</p>
<h3 id="句法-3">句法</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">class1</span>:</span><br><span class="line">	&lt;<span class="keyword">class</span>-suite&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">class2</span>(<span class="title class_ inherited__">class1</span>):</span><br><span class="line">	&lt;<span class="keyword">class</span> <span class="title class_">suite</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">class3</span>(<span class="title class_ inherited__">class2</span>):</span><br><span class="line">	&lt;<span class="keyword">class</span> <span class="title class_">suite</span>&gt;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例子-9">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Animal Speaking&quot;</span>)</span><br><span class="line"><span class="comment">#The child class Dog inherits the base class Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bark</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;dog barking&quot;</span>)</span><br><span class="line"><span class="comment">#The child class Dogchild inherits another child class Dog</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogChild</span>(<span class="title class_ inherited__">Dog</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Eating bread...&quot;</span>)</span><br><span class="line">d = DogChild()</span><br><span class="line">d.bark()</span><br><span class="line">d.speak()</span><br><span class="line">d.eat()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">dog barking</span><br><span class="line">Animal Speaking</span><br><span class="line">Eating bread...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-多重继承">Python 多重继承</h2>
<p>Python 为我们提供了在子类中继承多个基类的灵活性。</p>
<p>下面给出了执行多重继承的语法。</p>
<h3 id="句法-4">句法</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span>:</span><br><span class="line">	&lt;<span class="keyword">class</span>-suite&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span>:</span><br><span class="line">	&lt;<span class="keyword">class</span>-suite&gt;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseN</span>:</span><br><span class="line">	&lt;<span class="keyword">class</span>-suite&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>(Base1, Base2, ...... BaseN):</span><br><span class="line">	&lt;<span class="keyword">class</span>-suite&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例子-10">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculation1</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Summation</span>(<span class="params">self,a,b</span>):</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculation2</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Multiplication</span>(<span class="params">self,a,b</span>):</span><br><span class="line">        <span class="keyword">return</span> a*b;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>(Calculation1,Calculation2):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Divide</span>(<span class="params">self,a,b</span>):</span><br><span class="line">        <span class="keyword">return</span> a/b;</span><br><span class="line">d = Derived()</span><br><span class="line"><span class="built_in">print</span>(d.Summation(<span class="number">10</span>,<span class="number">20</span>))</span><br><span class="line"><span class="built_in">print</span>(d.Multiplication(<span class="number">10</span>,<span class="number">20</span>))</span><br><span class="line"><span class="built_in">print</span>(d.Divide(<span class="number">10</span>,<span class="number">20</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">200</span></span><br><span class="line"><span class="number">0.5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="issubclass-sub，sup-方法">issubclass(sub，sup)方法</h2>
<p>issubclass(sub，sup)方法用于检查指定类之间的关系。如果第一个类是第二个类的子类，则返回 true，否则返回 false。</p>
<p>考虑下面的例子。</p>
<h3 id="例子-11">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculation1</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Summation</span>(<span class="params">self,a,b</span>):</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculation2</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Multiplication</span>(<span class="params">self,a,b</span>):</span><br><span class="line">        <span class="keyword">return</span> a*b;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>(Calculation1,Calculation2):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Divide</span>(<span class="params">self,a,b</span>):</span><br><span class="line">        <span class="keyword">return</span> a/b;</span><br><span class="line">d = Derived()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(Derived,Calculation2))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(Calculation1,Calculation2))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="isinstance-obj，class-方法">isinstance (obj，class)方法</h2>
<p>isinstance()方法用于检查对象和类之间的关系。如果第一个参数(即 obj)是第二个参数(即类)的实例，则返回 true。</p>
<p>考虑下面的例子。</p>
<h3 id="例子-12">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculation1</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Summation</span>(<span class="params">self,a,b</span>):</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculation2</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Multiplication</span>(<span class="params">self,a,b</span>):</span><br><span class="line">        <span class="keyword">return</span> a*b;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>(Calculation1,Calculation2):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Divide</span>(<span class="params">self,a,b</span>):</span><br><span class="line">        <span class="keyword">return</span> a/b;</span><br><span class="line">d = Derived()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(d,Derived))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="方法重写">方法重写</h2>
<p>我们可以在子类中提供父类方法的一些具体实现。当父类方法在子类中用一些特定的实现来定义时，这个概念被称为方法重写。在子类中需要父类方法的不同定义的情况下，我们可能需要执行方法重写。</p>
<p>考虑下面的例子，在 python 中执行方法重写。</p>
<h3 id="例子-13">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;speaking&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Barking&quot;</span>)</span><br><span class="line">d = Dog()</span><br><span class="line">d.speak()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Barking</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="方法重写的真实例子">方法重写的真实例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">getroi</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SBI</span>(<span class="title class_ inherited__">Bank</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getroi</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ICICI</span>(<span class="title class_ inherited__">Bank</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getroi</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">b1 = Bank()</span><br><span class="line">b2 = SBI()</span><br><span class="line">b3 = ICICI()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Bank Rate of interest:&quot;</span>,b1.getroi());</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;SBI Rate of interest:&quot;</span>,b2.getroi());</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ICICI Rate of interest:&quot;</span>,b3.getroi());</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Bank Rate of interest: <span class="number">10</span></span><br><span class="line">SBI Rate of interest: <span class="number">7</span></span><br><span class="line">ICICI Rate of interest: <span class="number">8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="python-中的数据抽象">python 中的数据抽象</h2>
<p>抽象是面向对象编程的一个重要方面。在 python 中，我们还可以通过向要隐藏的属性添加双下划线(___)作为前缀来执行数据隐藏。此后，通过对象，该属性在类外部将不可见。</p>
<p>考虑下面的例子。</p>
<h3 id="例子-14">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>:</span><br><span class="line">    __count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        Employee.__count = Employee.__count+<span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The number of employees&quot;</span>,Employee.__count)</span><br><span class="line">emp = Employee()</span><br><span class="line">emp2 = Employee()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(emp.__count)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    emp.display()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The number of employees <span class="number">2</span></span><br><span class="line">AttributeError: <span class="string">&#x27;Employee&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;__count&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-OOP</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python MongoDB</title>
    <url>/posts/5870e75d.html</url>
    <content><![CDATA[<h1>Python MongoDB 连接</h1>
<p>为了在 Python 编程语言和 MongoDB 数据库之间建立连接，我们需要首先安装 <strong>pymongo</strong> 驱动程序。这里，我们正在创建一个连接到数据库并执行基本数据库操作的示例。</p>
<p>该示例包括以下步骤:</p>
<h3 id="1-安装驱动程序">1)安装驱动程序</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">$ pip install pymongo</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/6b67e4a354285a2a5a1097efc1a195dc.png" alt="MongoDB Python mongodb connectivity 1"></p>
<h3 id="2-创建-Python-文件">2)创建 Python 文件</h3>
<p><strong>// <a href="http://connect.py">connect.py</a></strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient <span class="comment"># import mongo client to connect</span></span><br><span class="line"><span class="keyword">import</span> pprint</span><br><span class="line"><span class="comment"># Creating instance of mongoclient</span></span><br><span class="line">client = MongoClient()</span><br><span class="line"><span class="comment"># Creating database</span></span><br><span class="line">db = client.javatpoint</span><br><span class="line">employee = &#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;101&quot;</span>,</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;Peter&quot;</span>,</span><br><span class="line"><span class="string">&quot;profession&quot;</span>: <span class="string">&quot;Software Engineer&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># Creating document</span></span><br><span class="line">employees = db.employees</span><br><span class="line"><span class="comment"># Inserting data</span></span><br><span class="line">employees.insert_one(employee)</span><br><span class="line"><span class="comment"># Fetching data</span></span><br><span class="line">pprint.pprint(employees.find_one())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-执行-Python-脚本">3)执行 Python 脚本</h3>
<p>该脚本在控制台上打印插入的记录。</p>
<p><img src="/img/7b25a0abd092d4bab6723be1029166cd.png" alt="MongoDB Python mongodb connectivity 2"></p>
<h3 id="4-进入蒙古-Shell">4)进入蒙古 Shell</h3>
<p>现在，进入 MongoDB 数据库 Shell，查看创建的数据库和集合。</p>
<p>我们可以使用以下命令进入数据库。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">$ mongo</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/9c4889d684147a1d4bbf6bd06bec2fc5.png" alt="MongoDB Python mongodb connectivity 3"></p>
<h3 id="5-检查数据库">5)检查数据库</h3>
<p>以下命令用于显示可用的数据库。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&gt; show dbs</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/a8c731ad5cf838b756f0f59a5b6b4392.png" alt="MongoDB Python mongodb connectivity 4"></p>
<h3 id="6-支票收款">6)支票收款</h3>
<p>以下命令用于显示数据库中的可用集合。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&gt; show collections</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/2c688704f1aec56132f9441cdf58f666.png" alt="MongoDB Python mongodb connectivity 5"></p>
<h3 id="7-访问记录">7)访问记录</h3>
<p>我们可以看到特定集合中存储的记录。以下命令用于显示记录。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&gt; db.employees.find()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/cd7e15a6c5e300e5c97f358f36da7f2d.png" alt="MongoDB Python mongodb connectivity 6"></p>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-数据库</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python MySQL</title>
    <url>/posts/b52f47b.html</url>
    <content><![CDATA[<h1>Python Mysql</h1>
<h2 id="安装-mysql-connector">安装 mysql.connector</h2>
<p>要将 python 应用与 MySQL 数据库连接起来，我们必须在程序中导入 mysql.connector 模块。</p>
<p>mysql.connector 不是 python 安装附带的内置模块。我们需要安装它让它工作。</p>
<p>执行以下命令，使用 pip 安装程序安装它。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;  python -m pip install mysql-connector</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>或者按照以下步骤操作。</strong></p>
<p>1.点击链接:</p>
<p><a href="https://files.pythonhosted.org/packages/8f/6d/fb8ebcbbaee68b172ce3dfd08c7b8660d09f91d8d5411298bcacbd309f96/mysql-connector-python-8.0.13.tar.gz">https://files . python hosted . org/packages/8f/6d/fb8 ebcbaee 68 b 172 C3 DFD 08 c7b 8660d 09 f 91 d8d 5411298 bcacbd 309 f 96/MySQL-connector-python-8 . 0 . 13 . tar . gz</a>下载源代码。</p>
<p>2.提取存档文件。</p>
<p>3.打开终端(windows 的 CMD)，将当前工作目录改为源代码目录。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$  cd mysql-connector-python-<span class="number">8.0</span><span class="number">.13</span>/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4.使用参数 build 运行名为 <a href="http://setup.py">setup.py</a> 的文件。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ python setup.py build</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>5.运行以下命令来安装 mysql 连接器。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ python setup.py install</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为 python 安装 mysql 连接器需要一点时间。一旦这个过程结束，我们可以通过在 python shell 上导入 mysql 连接器来验证安装。</p>
<p><img src="/img/083f0797ba9ceb12c3ede098c2b9fb57.png" alt="Environment Setup"></p>
<p>因此，我们已经成功地在系统上安装了 python 的 mysql 连接器。</p>
<h2 id="数据库连接">数据库连接</h2>
<p>将 python 应用连接到我们的数据库有以下步骤。</p>
<ol>
<li class="lvl-4">
<p>导入 mysql.connector 模块</p>
</li>
<li class="lvl-4">
<p>创建连接对象。</p>
</li>
<li class="lvl-4">
<p>创建光标对象</p>
</li>
<li class="lvl-4">
<p>执行查询</p>
</li>
</ol>
<hr>
<h3 id="创建连接">创建连接</h3>
<p>为了在 MySQL 数据库和 python 应用之间创建连接，使用了 mysql.connector 模块的 connect()方法。</p>
<p>在方法调用中传递数据库详细信息，如主机名、用户名和数据库密码。方法返回连接对象。</p>
<p>使用 connect()的语法如下。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Connection-Object= mysql.connector.connect(host = &lt;host-name&gt; , user = &lt;username&gt; , passwd = &lt;password&gt; )</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>考虑下面的例子。</p>
<h4 id="例子-15">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#printing the connection object </span></span><br><span class="line"><span class="built_in">print</span>(myconn)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;mysql.connector.connection.MySQLConnection <span class="built_in">object</span> at <span class="number">0x7fb142edd780</span>&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，我们必须注意，如果我们想要连接到特定的数据库，我们可以在 connect()方法中指定数据库名称。</p>
<h4 id="例子-16">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>, database = <span class="string">&quot;mydb&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#printing the connection object </span></span><br><span class="line"><span class="built_in">print</span>(myconn) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;mysql.connector.connection.MySQLConnection <span class="built_in">object</span> at <span class="number">0x7ff64aa3d7b8</span>&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="创建光标对象">创建光标对象</h3>
<p>光标对象可以被定义为 Python 数据库 API 2.0 中指定的抽象。它通过与数据库的相同连接，方便我们拥有多个独立的工作环境。我们可以通过调用连接对象的“cursor”函数来创建 cursor 对象。游标对象是对数据库执行查询的一个重要方面。</p>
<p>下面给出了创建光标对象的语法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;my_cur&gt;  = conn.cursor()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="例子-17">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>, database = <span class="string">&quot;mydb&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#printing the connection object </span></span><br><span class="line"><span class="built_in">print</span>(myconn) </span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cur)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;mysql.connector.connection.MySQLConnection <span class="built_in">object</span> at <span class="number">0x7faa17a15748</span>&gt; </span><br><span class="line">MySQLCursor: (Nothing executed yet)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="创建新数据库">创建新数据库</h2>
<h3 id="获取现有数据库的列表">获取现有数据库的列表</h3>
<p>我们可以通过使用下面的 MySQL 查询获得所有数据库的列表。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;  show databases;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="例子-18">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    dbs = cur.execute(<span class="string">&quot;show databases&quot;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> cur:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;EmployeeDB&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;Test&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;TestDB&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;information_schema&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;javatpoint&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;javatpoint1&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;mydb&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;mysql&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;performance_schema&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;testDB&#x27;</span>,)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="创建新数据库-2">创建新数据库</h3>
<p>可以使用以下 SQL 查询创建新数据库。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;  create database &lt;database-name&gt;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="例子-19">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#creating a new database</span></span><br><span class="line">    cur.execute(<span class="string">&quot;create database PythonDB2&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#getting the list of all the databases which will now include the new database PythonDB</span></span><br><span class="line">    dbs = cur.execute(<span class="string">&quot;show databases&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> cur:</span><br><span class="line">        <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;EmployeeDB&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;PythonDB&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;Test&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;TestDB&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;anshika&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;information_schema&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;javatpoint&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;javatpoint1&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;mydb&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;mydb1&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;mysql&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;performance_schema&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;testDB&#x27;</span>,)</span><br></pre></td></tr></table></figure>
<h2 id="创建表">创建表</h2>
<p>在教程的这一部分中，我们将创建新的表 Employee。我们必须在建立连接对象时提到数据库名称。</p>
<p>我们可以使用 SQL 的 CREATE TABLE 语句来创建新表。在我们的数据库 PythonDB 中，Employee 表最初将有四列，即姓名、id、工资和 department_id。</p>
<p>以下查询用于创建新表“员工”。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;  create table Employee (name varchar(<span class="number">20</span>) <span class="keyword">not</span> null, <span class="built_in">id</span> <span class="built_in">int</span> primary key, salary <span class="built_in">float</span> <span class="keyword">not</span> null, Dept_Id <span class="built_in">int</span> <span class="keyword">not</span> null)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例子-20">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#Creating a table with name Employee having four columns i.e., name, id, salary, and department id</span></span><br><span class="line">    dbs = cur.execute(<span class="string">&quot;create table Employee(name varchar(20) not null, id int(20) not null primary key, salary float not null, Dept_id int not null)&quot;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/c30547e8ba0cf5d1e626271c47116e06.png" alt="Creating table"></p>
<p>现在，我们可以检查数据库中是否存在雇员表。</p>
<h3 id="更改表">更改表</h3>
<p>有时，我们可能会忘记创建一些列，或者我们可能需要更新表模式。如果需要，alter 语句用于更改表架构。在这里，我们将把列 branch_name 添加到表 Employee 中。以下 SQL 查询用于此目的。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">alter table Employee add branch_name varchar(<span class="number">20</span>) <span class="keyword">not</span> null</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>考虑下面的例子。</p>
<h4 id="例子-21">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#adding a column branch name to the table Employee</span></span><br><span class="line">    cur.execute(<span class="string">&quot;alter table Employee add branch_name varchar(20) not null&quot;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/d8598d4a08bc5c8a614636f212cfaa4c.png" alt="Creating the table"></p>
<h2 id="插入操作">插入操作</h2>
<h3 id="向表中添加记录">向表中添加记录</h3>
<p><strong>INSERT INTO</strong> 语句用于向表中添加一条记录。在 python 中，我们可以用格式说明符(%s)代替值。</p>
<p>我们在游标的 execute()方法中以元组的形式提供实际值。</p>
<p>考虑下面的例子。</p>
<h4 id="例子-22">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line">sql = <span class="string">&quot;insert into Employee(name, id, salary, dept_id, branch_name) values (%s, %s, %s, %s, %s)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#The row values are provided in the form of tuple </span></span><br><span class="line">val = (<span class="string">&quot;John&quot;</span>, <span class="number">110</span>, <span class="number">25000.00</span>, <span class="number">201</span>, <span class="string">&quot;Newyork&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#inserting the values into the table</span></span><br><span class="line">    cur.execute(sql,val)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#commit the transaction </span></span><br><span class="line">    myconn.commit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cur.rowcount,<span class="string">&quot;record inserted!&quot;</span>)</span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> record inserted!</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/b8ab14d98505f34fba8b08b3be886acd.png" alt="Insert Operation"></p>
<hr>
<h3 id="插入多行">插入多行</h3>
<p>我们还可以使用 python 脚本一次插入多行。多行被称为各种元组的列表。</p>
<p>列表的每个元素被视为一个特定的行，而元组的每个元素被视为一个特定的列值(属性)。</p>
<p>考虑下面的例子。</p>
<h4 id="例子-23">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line">sql = <span class="string">&quot;insert into Employee(name, id, salary, dept_id, branch_name) values (%s, %s, %s, %s, %s)&quot;</span></span><br><span class="line">val = [(<span class="string">&quot;John&quot;</span>, <span class="number">102</span>, <span class="number">25000.00</span>, <span class="number">201</span>, <span class="string">&quot;Newyork&quot;</span>),(<span class="string">&quot;David&quot;</span>,<span class="number">103</span>,<span class="number">25000.00</span>,<span class="number">202</span>,<span class="string">&quot;Port of spain&quot;</span>),(<span class="string">&quot;Nick&quot;</span>,<span class="number">104</span>,<span class="number">90000.00</span>,<span class="number">201</span>,<span class="string">&quot;Newyork&quot;</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#inserting the values into the table</span></span><br><span class="line">    cur.executemany(sql,val)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#commit the transaction </span></span><br><span class="line">    myconn.commit()</span><br><span class="line">    <span class="built_in">print</span>(cur.rowcount,<span class="string">&quot;records inserted!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> records inserted! </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/785a85c85699bfe41b9ba3818386cfc0.png" alt="Insert Operation"></p>
<hr>
<h3 id="行标识">行标识</h3>
<p>在 SQL 中，一个特定的行由一个插入 id 来表示，该 id 被称为行 id。我们可以通过使用 cursor 对象的属性 lastrowid 来获取最后插入的行 id。</p>
<p>考虑下面的例子。</p>
<h4 id="例子-24">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line">sql = <span class="string">&quot;insert into Employee(name, id, salary, dept_id, branch_name) values (%s, %s, %s, %s, %s)&quot;</span></span><br><span class="line"></span><br><span class="line">val = (<span class="string">&quot;Mike&quot;</span>,<span class="number">105</span>,<span class="number">28000</span>,<span class="number">202</span>,<span class="string">&quot;Guyana&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#inserting the values into the table</span></span><br><span class="line">    cur.execute(sql,val)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#commit the transaction </span></span><br><span class="line">    myconn.commit()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#getting rowid</span></span><br><span class="line">    <span class="built_in">print</span>(cur.rowcount,<span class="string">&quot;record inserted! id:&quot;</span>,cur.lastrowid)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> record inserted! Id: <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="读取操作">读取操作</h2>
<p>SELECT 语句用于从数据库中读取值。我们可以通过在 SQL 中使用各种子句来限制选择查询的输出，如 where、limit 等。</p>
<p>Python 提供的 fetchall()方法以行的形式返回存储在表中的数据。我们可以迭代结果来获得单个行。</p>
<p>在教程的这一部分，我们将使用 python 脚本从数据库中提取数据。我们还将格式化输出，将其打印在控制台上。</p>
<h3 id="例子-25">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#Reading the Employee data    </span></span><br><span class="line">    cur.execute(<span class="string">&quot;select * from Employee&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#fetching the rows from the cursor object</span></span><br><span class="line">    result = cur.fetchall()</span><br><span class="line">    <span class="comment">#printing the result</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> result:</span><br><span class="line">        <span class="built_in">print</span>(x);</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;John&#x27;</span>, <span class="number">101</span>, <span class="number">25000.0</span>, <span class="number">201</span>, <span class="string">&#x27;Newyork&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;John&#x27;</span>, <span class="number">102</span>, <span class="number">25000.0</span>, <span class="number">201</span>, <span class="string">&#x27;Newyork&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;David&#x27;</span>, <span class="number">103</span>, <span class="number">25000.0</span>, <span class="number">202</span>, <span class="string">&#x27;Port of spain&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;Nick&#x27;</span>, <span class="number">104</span>, <span class="number">90000.0</span>, <span class="number">201</span>, <span class="string">&#x27;Newyork&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;Mike&#x27;</span>, <span class="number">105</span>, <span class="number">28000.0</span>, <span class="number">202</span>, <span class="string">&#x27;Guyana&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="读取特定列">读取特定列</h3>
<p>我们可以通过提及特定列的名称来阅读它们，而不是使用星号(*)。</p>
<p>在下面的示例中，我们将从 Employee 表中读取姓名、id 和工资，并将其打印在控制台上。</p>
<h4 id="例子-26">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#Reading the Employee data    </span></span><br><span class="line">    cur.execute(<span class="string">&quot;select name, id, salary from Employee&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#fetching the rows from the cursor object</span></span><br><span class="line">    result = cur.fetchall()</span><br><span class="line">    <span class="comment">#printing the result</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> result:</span><br><span class="line">        <span class="built_in">print</span>(x);</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;John&#x27;</span>, <span class="number">101</span>, <span class="number">25000.0</span>)</span><br><span class="line">(<span class="string">&#x27;John&#x27;</span>, <span class="number">102</span>, <span class="number">25000.0</span>)</span><br><span class="line">(<span class="string">&#x27;David&#x27;</span>, <span class="number">103</span>, <span class="number">25000.0</span>)</span><br><span class="line">(<span class="string">&#x27;Nick&#x27;</span>, <span class="number">104</span>, <span class="number">90000.0</span>)</span><br><span class="line">(<span class="string">&#x27;Mike&#x27;</span>, <span class="number">105</span>, <span class="number">28000.0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="fetchone-方法">fetchone()方法</h3>
<p>fetchone()方法仅用于从表中获取一行。fetchone()方法返回结果集的下一行。</p>
<p>考虑下面的例子。</p>
<h4 id="例子-27">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#Reading the Employee data    </span></span><br><span class="line">    cur.execute(<span class="string">&quot;select name, id, salary from Employee&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#fetching the first row from the cursor object</span></span><br><span class="line">    result = cur.fetchone()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#printing the result</span></span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;John&#x27;</span>, <span class="number">101</span>, <span class="number">25000.0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="格式化结果">格式化结果</h3>
<p>我们可以通过迭代游标对象的 fetchall()或 fetchone()方法产生的结果来格式化结果，因为结果作为不可读的元组对象存在。</p>
<p>考虑下面的例子。</p>
<h4 id="例子-28">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">#Reading the Employee data    </span></span><br><span class="line">    cur.execute(<span class="string">&quot;select name, id, salary from Employee&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#fetching the rows from the cursor object</span></span><br><span class="line">    result = cur.fetchall()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Name    id    Salary&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> result:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s    %d    %d&quot;</span>%(row[<span class="number">0</span>],row[<span class="number">1</span>],row[<span class="number">2</span>]))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Name    <span class="built_in">id</span>    Salary</span><br><span class="line">John    <span class="number">101</span>    <span class="number">25000</span></span><br><span class="line">John    <span class="number">102</span>    <span class="number">25000</span></span><br><span class="line">David    <span class="number">103</span>    <span class="number">25000</span></span><br><span class="line">Nick    <span class="number">104</span>    <span class="number">90000</span></span><br><span class="line">Mike    <span class="number">105</span>    <span class="number">28000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="使用-where-子句">使用 where 子句</h3>
<p>我们可以使用 where 子句来限制 select 语句产生的结果。这将只提取那些满足 where 条件的列。</p>
<p>考虑下面的例子。</p>
<h4 id="示例-打印以-j-开头的名称">示例:打印以 j 开头的名称</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#Reading the Employee data    </span></span><br><span class="line">    cur.execute(<span class="string">&quot;select name, id, salary from Employee where name like &#x27;J%&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#fetching the rows from the cursor object</span></span><br><span class="line">    result = cur.fetchall()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Name    id    Salary&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> result:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s    %d    %d&quot;</span>%(row[<span class="number">0</span>],row[<span class="number">1</span>],row[<span class="number">2</span>]))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Name    <span class="built_in">id</span>    Salary</span><br><span class="line">John    <span class="number">101</span>    <span class="number">25000</span></span><br><span class="line">John    <span class="number">102</span>    <span class="number">25000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="示例-打印-id-101、102-和-103-的名称">示例:打印 id = 101、102 和 103 的名称</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#Reading the Employee data    </span></span><br><span class="line">    cur.execute(<span class="string">&quot;select name, id, salary from Employee where id in (101,102,103)&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#fetching the rows from the cursor object</span></span><br><span class="line">    result = cur.fetchall()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Name    id    Salary&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> result:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s    %d    %d&quot;</span>%(row[<span class="number">0</span>],row[<span class="number">1</span>],row[<span class="number">2</span>]))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Name    <span class="built_in">id</span>    Salary</span><br><span class="line">John    <span class="number">101</span>    <span class="number">25000</span></span><br><span class="line">John    <span class="number">102</span>    <span class="number">25000</span></span><br><span class="line">David    <span class="number">103</span>    <span class="number">2500</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="排序结果">排序结果</h3>
<p>ORDER BY 子句用于排序结果。考虑下面的例子。</p>
<h4 id="例子-29">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#Reading the Employee data    </span></span><br><span class="line">    cur.execute(<span class="string">&quot;select name, id, salary from Employee order by name&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#fetching the rows from the cursor object</span></span><br><span class="line">    result = cur.fetchall()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Name    id    Salary&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> result:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s    %d    %d&quot;</span>%(row[<span class="number">0</span>],row[<span class="number">1</span>],row[<span class="number">2</span>]))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Name    <span class="built_in">id</span>    Salary</span><br><span class="line">David   <span class="number">103</span>    <span class="number">25000</span></span><br><span class="line">John    <span class="number">101</span>    <span class="number">25000</span></span><br><span class="line">John    <span class="number">102</span>    <span class="number">25000</span></span><br><span class="line">Mike    <span class="number">105</span>    <span class="number">28000</span></span><br><span class="line">Nick    <span class="number">104</span>    <span class="number">90000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="DESC-的命令">DESC 的命令</h3>
<p>这将按特定列的降序排序结果。</p>
<h4 id="例子-30">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#Reading the Employee data    </span></span><br><span class="line">    cur.execute(<span class="string">&quot;select name, id, salary from Employee order by name desc&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#fetching the rows from the cursor object</span></span><br><span class="line">    result = cur.fetchall()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#printing the result</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Name    id    Salary&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> result:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s    %d    %d&quot;</span>%(row[<span class="number">0</span>],row[<span class="number">1</span>],row[<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Name    <span class="built_in">id</span>    Salary</span><br><span class="line">Nick    <span class="number">104</span>    <span class="number">90000</span></span><br><span class="line">Mike    <span class="number">105</span>    <span class="number">28000</span></span><br><span class="line">John    <span class="number">101</span>    <span class="number">25000</span></span><br><span class="line">John    <span class="number">102</span>    <span class="number">25000</span></span><br><span class="line">David    <span class="number">103</span>    <span class="number">25000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="更新操作">更新操作</h2>
<p>UPDATE-SET 语句用于更新表中的任何列。以下 SQL 查询用于更新列。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;  update Employee <span class="built_in">set</span> name = <span class="string">&#x27;alex&#x27;</span> where <span class="built_in">id</span> = <span class="number">110</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>考虑下面的例子。</p>
<h3 id="例子-31">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#updating the name of the employee whose id is 110</span></span><br><span class="line">    cur.execute(<span class="string">&quot;update Employee set name = &#x27;alex&#x27; where id = 110&quot;</span>)</span><br><span class="line">    myconn.commit()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"></span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/c643f3f52fdcfd1ba2dfb5ab0df49823.png" alt="Update Operation"></p>
<hr>
<h3 id="删除操作">删除操作</h3>
<p>DELETE FROM 语句用于从表中删除特定记录。这里，我们必须使用 WHERE 子句强加一个条件，否则表中的所有记录都将被删除。</p>
<p>以下 SQL 查询用于从表中删除 id 为 110 的员工详细信息。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;  delete <span class="keyword">from</span> Employee where <span class="built_in">id</span> = <span class="number">110</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>考虑下面的例子。</p>
<h4 id="例子-32">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#Deleting the employee details whose id is 110</span></span><br><span class="line">    cur.execute(<span class="string">&quot;delete from Employee where id = 110&quot;</span>)</span><br><span class="line">    myconn.commit()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"></span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="连接操作">连接操作</h2>
<p>我们可以通过使用 join 语句在两个或多个表中使用一些公共列来组合它们。</p>
<p>我们的数据库中只有一个表，让我们用两列 department _ id 和 department_name 再创建一个 Departments 表。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">create table Departments (Dept_id <span class="built_in">int</span>(<span class="number">20</span>) primary key <span class="keyword">not</span> null, Dept_Name varchar(<span class="number">20</span>) <span class="keyword">not</span> null);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/5f85a3be9e4f39b417a671195807d75d.png" alt="Join Operation"></p>
<p>因为我们已经创建了一个新的表 Departments，如上图所示。然而，我们还没有在其中插入任何值。</p>
<p>让我们插入一些部门 id 和部门名称，以便将其映射到我们的员工表。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">insert into Departments values (<span class="number">201</span>, <span class="string">&quot;CS&quot;</span>);</span><br><span class="line">insert into Departments values (<span class="number">202</span>, <span class="string">&quot;IT&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>让我们看看每个表中插入的值。请看下图。</p>
<p><img src="/img/ae533e74525b952342ab1660ca5c6af1.png" alt="Join Operation"></p>
<p>现在，让我们创建一个 python 脚本，将公共列(即 dept_id)上的两个表连接起来。</p>
<h3 id="例子-33">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#joining the two tables on departments_id</span></span><br><span class="line">    cur.execute(<span class="string">&quot;select Employee.id, Employee.name, Employee.salary, Departments.Dept_id, Departments.Dept_Name from Departments join Employee on Departments.Dept_id = Employee.Dept_id&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ID    Name    Salary    Dept_Id    Dept_Name&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> cur:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%d    %s    %d    %d    %s&quot;</span>%(row[<span class="number">0</span>], row[<span class="number">1</span>],row[<span class="number">2</span>],row[<span class="number">3</span>],row[<span class="number">4</span>]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ID    Name    Salary    Dept_Id    Dept_Name</span><br><span class="line"><span class="number">101</span>   John    <span class="number">25000</span>    	<span class="number">201</span>    		CS</span><br><span class="line"><span class="number">102</span>   John    <span class="number">25000</span>    	<span class="number">201</span>    		CS</span><br><span class="line"><span class="number">103</span>   David   <span class="number">25000</span>       <span class="number">202</span>    		IT</span><br><span class="line"><span class="number">104</span>   Nick    <span class="number">90000</span>   	<span class="number">201</span>    		CS</span><br><span class="line"><span class="number">105</span>   Mike    <span class="number">28000</span>   	<span class="number">202</span>   		IT</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="右连接">右连接</h3>
<p>右连接显示右侧表的所有列，因为我们在数据库 PythonDB 中有两个表，即 Departments 和 Employee。表中没有任何员工不在任何部门工作(部门标识为空的员工)。然而，为了理解右连接的概念，让我们创建一个。</p>
<p>在 MySQL 服务器上执行以下查询。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">insert into Employee(name, <span class="built_in">id</span>, salary, branch_name) values (<span class="string">&quot;Alex&quot;</span>,<span class="number">108</span>,<span class="number">29900</span>,<span class="string">&quot;Mumbai&quot;</span>); </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这将插入一个不在任何部门工作的员工 Alex(部门 id 为空)。</p>
<p>现在，我们在“员工”表中有一名员工，其部门 id 不在“部门”表中。现在让我们在两个表上执行正确的连接。</p>
<h4 id="例子-34">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#joining the two tables on departments_id</span></span><br><span class="line">    result = cur.execute(<span class="string">&quot;select Employee.id, Employee.name, Employee.salary, Departments.Dept_id, Departments.Dept_Name from Departments right join Employee on Departments.Dept_id = Employee.Dept_id&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;ID    Name    Salary    Dept_Id    Dept_Name&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> row <span class="keyword">in</span> cur:</span><br><span class="line">        <span class="built_in">print</span>(row[<span class="number">0</span>],<span class="string">&quot;    &quot;</span>, row[<span class="number">1</span>],<span class="string">&quot;    &quot;</span>,row[<span class="number">2</span>],<span class="string">&quot;    &quot;</span>,row[<span class="number">3</span>],<span class="string">&quot;    &quot;</span>,row[<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ID    Name    Salary    Dept_Id    Dept_Name</span><br><span class="line"><span class="number">101</span>      John      <span class="number">25000.0</span>      <span class="number">201</span>      CS</span><br><span class="line"><span class="number">102</span>      John      <span class="number">25000.0</span>      <span class="number">201</span>      CS</span><br><span class="line"><span class="number">103</span>      David      <span class="number">25000.0</span>      <span class="number">202</span>      IT</span><br><span class="line"><span class="number">104</span>      Nick      <span class="number">90000.0</span>      <span class="number">201</span>      CS</span><br><span class="line"><span class="number">105</span>      Mike      <span class="number">28000.0</span>      <span class="number">202</span>      IT</span><br><span class="line"><span class="number">108</span>      Alex      <span class="number">29900.0</span>      <span class="literal">None</span>      <span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="左连接">左连接</h3>
<p>左连接包含左侧表中的所有数据。它对右连接的效果正好相反。考虑下面的例子。</p>
<h4 id="例子-35">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#joining the two tables on departments_id</span></span><br><span class="line">    result = cur.execute(<span class="string">&quot;select Employee.id, Employee.name, Employee.salary, Departments.Dept_id, Departments.Dept_Name from Departments left join Employee on Departments.Dept_id = Employee.Dept_id&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ID    Name    Salary    Dept_Id    Dept_Name&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> cur:</span><br><span class="line">        <span class="built_in">print</span>(row[<span class="number">0</span>],<span class="string">&quot;    &quot;</span>, row[<span class="number">1</span>],<span class="string">&quot;    &quot;</span>,row[<span class="number">2</span>],<span class="string">&quot;    &quot;</span>,row[<span class="number">3</span>],<span class="string">&quot;    &quot;</span>,row[<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ID    Name    Salary    Dept_Id    Dept_Name</span><br><span class="line"><span class="number">101</span>      John      <span class="number">25000.0</span>      <span class="number">201</span>      CS</span><br><span class="line"><span class="number">102</span>      John      <span class="number">25000.0</span>      <span class="number">201</span>      CS</span><br><span class="line"><span class="number">103</span>      David      <span class="number">25000.0</span>      <span class="number">202</span>      IT</span><br><span class="line"><span class="number">104</span>      Nick      <span class="number">90000.0</span>      <span class="number">201</span>      CS</span><br><span class="line"><span class="number">105</span>      Mike      <span class="number">28000.0</span>      <span class="number">202</span>      IT</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="执行事务">执行事务</h2>
<p>事务确保数据库的数据一致性。我们必须确保在执行数据库操作时，不能有多个应用修改记录。这些事务具有以下属性。</p>
<ol>
<li class="lvl-4">
<p><strong>原子性</strong><br>
要么事务完成，要么什么都没发生。如果一个事务包含 4 个查询，那么所有这些查询都必须执行，或者都不执行。</p>
</li>
<li class="lvl-4">
<p><strong>一致性</strong><br>
事务开始前数据库必须一致，事务完成后数据库也必须一致。</p>
</li>
<li class="lvl-4">
<p><strong>隔离</strong><br>
事务的中间结果在当前事务之外不可见。</p>
</li>
<li class="lvl-4">
<p><strong>持久性</strong><br>
一旦事务被提交，即使在系统故障后，其影响也是持久的。</p>
</li>
</ol>
<hr>
<h3 id="Python-commit-方法">Python commit()方法</h3>
<p>Python 提供了 commit()方法，确保对</p>
<p>数据库不断地发生变化。</p>
<p>下面给出了使用 commit()方法的语法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">conn.commit() <span class="comment">#conn is the connection object </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在调用 commit()之前，修改数据库记录的所有操作都不会发生。</p>
<hr>
<h3 id="Python-rollback-方法">Python rollback()方法</h3>
<p>rollback()方法用于恢复对数据库所做的更改。这种方法很有用，因为如果在数据库操作过程中发生了一些错误，我们可以回滚该事务以保持数据库的一致性。</p>
<p>使用 rollback()的语法如下。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Conn.rollback()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="关闭连接">关闭连接</h3>
<p>一旦我们完成了所有关于数据库的操作，我们就需要关闭数据库连接。Python 提供了 close()方法。下面给出了使用 close()方法的语法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">conn.close() </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在下面的示例中，我们删除了所有在 CS 部门工作的员工。</p>
<h4 id="例子-36">例子</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create the connection object </span></span><br><span class="line">myconn = mysql.connector.connect(host = <span class="string">&quot;localhost&quot;</span>, user = <span class="string">&quot;root&quot;</span>,passwd = <span class="string">&quot;google&quot;</span>,database = <span class="string">&quot;PythonDB&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#creating the cursor object</span></span><br><span class="line">cur = myconn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cur.execute(<span class="string">&quot;delete from Employee where Dept_id = 201&quot;</span>)</span><br><span class="line">    myconn.commit()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Deleted !&quot;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Can&#x27;t delete !&quot;</span>)</span><br><span class="line">    myconn.rollback()</span><br><span class="line"></span><br><span class="line">myconn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Deleted !</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
        <category>python-数据库</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python SQLite</title>
    <url>/posts/d5f6c82e.html</url>
    <content><![CDATA[<h1>Python SQLite 连接</h1>
<p>首先，您必须在系统上安装 python 和 sqlite。</p>
<h2 id="安装-Python">安装 Python</h2>
<p>使用以下代码:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade python</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/98ddb8f0a2d623e271691c9e6f46a3e1.png" alt="SQLite Connect sqlite with python 1"></p>
<p>按 y，安装将在几秒钟内完成。</p>
<h2 id="安装-SQLite">安装 SQLite</h2>
<p><strong>安装步骤</strong></p>
<p>键入以下命令:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">sudo apt-get install sqlite3 libsqlite3-dev</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>安装后检查安装，sqlite 终端会给你提示和版本信息？</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">sqlite3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>转到所需文件夹并创建数据库:</p>
<p>sqlite3 数据库. db</p>
<p>它将在您发出命令的文件夹中创建 database.db。</p>
<p>要检查数据库是否已创建，请在 sqlite3 终端中使用以下命令:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">.databases</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="注意-要使用-Python-连接-SQLite，您不需要单独安装连接模块，因为默认情况下，它是与-Python-2-5-x-版一起发货的。">注意:要使用 Python 连接 SQLite，您不需要单独安装连接模块，因为默认情况下，它是与 Python 2.5 . x 版一起发货的。</h4>
<hr>
<h2 id="使用-Python-的-SQLite">使用 Python 的 SQLite</h2>
<p>创建一个 python 文件“<a href="http://connect.py">connect.py</a>”，包含以下代码:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">conn = sqlite3.connect(<span class="string">&#x27;javatpoint.db&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Opened database successfully&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>在命令提示符下执行以下语句:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">python connect.py</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/39d1342661f43a70acd451c3accf2bd6.png" alt="SQLite Connect sqlite with python 2"></p>
<p>现在已经创建了与 javatpoint 数据库的连接。现在，您可以创建一个表。</p>
<h2 id="创建表-2">创建表</h2>
<p>在数据库“javatpoint”中创建一个表“Employees”。</p>
<p>创建一个 python 文件“<a href="http://createtable.py">createtable.py</a>”，包含以下代码:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">conn = sqlite3.connect(<span class="string">&#x27;javatpoint.db&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Opened database successfully&quot;</span>;</span><br><span class="line"></span><br><span class="line">conn.execute(<span class="string">&#x27;&#x27;&#x27;CREATE TABLE Employees</span></span><br><span class="line"><span class="string">       (ID INT PRIMARY KEY     NOT NULL,</span></span><br><span class="line"><span class="string">       NAME           TEXT    NOT NULL,</span></span><br><span class="line"><span class="string">       AGE            INT     NOT NULL,</span></span><br><span class="line"><span class="string">       ADDRESS        CHAR(50),</span></span><br><span class="line"><span class="string">       SALARY         REAL);&#x27;&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Table created successfully&quot;</span>;</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在命令提示符下执行以下语句:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">python createtable.py</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/34a96bf81fb97cd19581923a0abaf526.png" alt="SQLite Connect sqlite with python 3"></p>
<p>在“javatpoint”数据库中创建了一个表“Employees”。</p>
<h2 id="插入记录">插入记录</h2>
<p>在“员工”表中插入一些记录。</p>
<p>创建一个 python 文件“<a href="http://connection.py">connection.py</a>”，包含以下代码:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">conn = sqlite3.connect(<span class="string">&#x27;javatpoint.db&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Opened database successfully&quot;</span>;</span><br><span class="line"></span><br><span class="line">conn.execute(<span class="string">&quot;INSERT INTO Employees (ID,NAME,AGE,ADDRESS,SALARY) \</span></span><br><span class="line"><span class="string">      VALUES (1, &#x27;Ajeet&#x27;, 27, &#x27;Delhi&#x27;, 20000.00 )&quot;</span>);</span><br><span class="line"></span><br><span class="line">conn.execute(<span class="string">&quot;INSERT INTO Employees (ID,NAME,AGE,ADDRESS,SALARY) \</span></span><br><span class="line"><span class="string">      VALUES (2, &#x27;Allen&#x27;, 22, &#x27;London&#x27;, 25000.00 )&quot;</span>);</span><br><span class="line"></span><br><span class="line">conn.execute(<span class="string">&quot;INSERT INTO Employees (ID,NAME,AGE,ADDRESS,SALARY) \</span></span><br><span class="line"><span class="string">      VALUES (3, &#x27;Mark&#x27;, 29, &#x27;CA&#x27;, 200000.00 )&quot;</span>);</span><br><span class="line"></span><br><span class="line">conn.execute(<span class="string">&quot;INSERT INTO Employees (ID,NAME,AGE,ADDRESS,SALARY) \</span></span><br><span class="line"><span class="string">      VALUES (4, &#x27;Kanchan&#x27;, 22, &#x27;Ghaziabad &#x27;, 65000.00 )&quot;</span>);</span><br><span class="line"></span><br><span class="line">conn.commit()</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Records inserted successfully&quot;</span>;</span><br><span class="line">conn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>在命令提示符下执行以下语句:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">python connection.py</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/7ba1b156540a9f1a241f221e4591a53a.png" alt="SQLite Connect sqlite with python 4"></p>
<p>记录插入成功。</p>
<h2 id="选择记录">选择记录</h2>
<p>现在，您可以使用 SELECT 语句从“雇员”表中获取并显示您的记录。</p>
<p>创建一个 python 文件“<a href="http://select.py">select.py</a>”，包含以下代码:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">conn = sqlite3.connect(<span class="string">&#x27;javatpoint.db&#x27;</span>)</span><br><span class="line"></span><br><span class="line">data = conn.execute(<span class="string">&quot;select * from Employees&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> data:</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;ID = &quot;</span>, row[<span class="number">0</span>]</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;NAME = &quot;</span>, row[<span class="number">1</span>]</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;ADDRESS = &quot;</span>, row[<span class="number">2</span>]</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;SALARY = &quot;</span>, row[<span class="number">3</span>], <span class="string">&quot;\n&quot;</span></span><br><span class="line"></span><br><span class="line">conn.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在命令提示符下执行以下语句:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">python select.py </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/1b56a244bc056f0a2efd7eb0cb1e2d87.png" alt="SQLite Connect sqlite with python 5"></p>
<p>查看您之前插入的所有记录。</p>
<p>通过同样的过程，您可以使用 Python 更新和删除 SQLite 数据库中的表。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-数据库</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python `If-else`语句</title>
    <url>/posts/394067ff.html</url>
    <content><![CDATA[<h1>Python <code>If-else</code>语句</h1>
<p>决策是几乎所有编程语言中最重要的方面。顾名思义，决策允许我们为特定的决策运行特定的代码块。在这里，决策是根据特定条件的有效性做出的。条件检查是决策的支柱。</p>
<p>在 python 中，决策由以下语句执行。</p>
<table>
<thead>
<tr>
<th>声明</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>if 语句</td>
<td><code>if</code>语句用于测试特定条件。如果条件为真，将执行一个代码块(if-block)。</td>
</tr>
<tr>
<td>If - else 语句</td>
<td><code>If-else</code>语句类似于 <code>if</code>语句，除了它还为要检查的条件的 false 情况提供代码块。如果 <code>if</code>语句中提供的条件为 false，则将执行 else 语句。</td>
</tr>
<tr>
<td>嵌套 <code>if</code>语句</td>
<td>嵌套的 <code>if</code>语句使我们能够使用 if。外部 <code>if</code>语句中的 else 语句。</td>
</tr>
</tbody>
</table>
<h2 id="Python-中的缩进">Python 中的缩进</h2>
<p>为了便于编程和实现简单性，python 不允许在块级代码中使用括号。在 Python 中，缩进用于声明一个块。如果两个语句处于相同的缩进级别，那么它们就是同一个块的一部分。</p>
<p>一般来说，四个空格用来缩进语句，这是 python 中典型的缩进量。</p>
<p>缩进是 python 语言中最常用的部分，因为它声明了代码块。一个块的所有语句都位于同一缩进级别。我们将在 python 中看到实际的缩进是如何在决策和其他事情中发生的。</p>
<h2 id="if语句"><code>if</code>语句</h2>
<p><code>if</code>语句用于测试特定条件，如果条件为真，它将执行一个称为 if-block 的代码块。<code>if</code>语句的条件可以是任何有效的逻辑表达式，可以计算为真或假。</p>
<p><img src="/img/c88f3d683a3ad3e73025fdf2899a8ab6.png" alt="Python If-else statements"></p>
<p><code>if</code>语句的语法如下。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> expression:</span><br><span class="line">	statement</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例-1-2">例 1</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;enter the number?&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> num%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Number is even&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">enter the number?<span class="number">10</span></span><br><span class="line">Number <span class="keyword">is</span> even</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="示例-2-打印三个数字中最大的一个的程序。">示例 2:打印三个数字中最大的一个的程序。</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter a? &quot;</span>));</span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter b? &quot;</span>));</span><br><span class="line">c = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter c? &quot;</span>));</span><br><span class="line"><span class="keyword">if</span> a&gt;b <span class="keyword">and</span> a&gt;c:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a is largest&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> b&gt;a <span class="keyword">and</span> b&gt;c:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b is largest&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> c&gt;a <span class="keyword">and</span> c&gt;b:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;c is largest&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter a? <span class="number">100</span></span><br><span class="line">Enter b? <span class="number">120</span></span><br><span class="line">Enter c? <span class="number">130</span></span><br><span class="line">c <span class="keyword">is</span> largest</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="If-else语句"><code>If-else</code>语句</h2>
<p><code>If-else</code>语句提供了一个与 <code>if</code>语句相结合的 else 块，它在条件为 false 的情况下执行。</p>
<p>如果条件为真，则执行 If 块。否则，执行 else 块。</p>
<p><img src="/img/c4c6b7641a9d7ad8960edd358c3c066a.png" alt="Python If-else statements"></p>
<p><code>If-else</code>语句的语法如下。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition:</span><br><span class="line">	<span class="comment">#block of statements </span></span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line">	<span class="comment">#another block of statements (else-block) </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例-1-检查一个人是否有资格投票的程序。">例 1:检查一个人是否有资格投票的程序。</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">age = <span class="built_in">int</span> (<span class="built_in">input</span>(<span class="string">&quot;Enter your age? &quot;</span>))</span><br><span class="line"><span class="keyword">if</span> age&gt;=<span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You are eligible to vote !!&quot;</span>);</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Sorry! you have to wait !!&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter your age? <span class="number">90</span></span><br><span class="line">You are eligible to vote !!</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例-2-检查一个数是否为偶数的程序。">例 2:检查一个数是否为偶数的程序。</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;enter the number?&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> num%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Number is even...&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Number is odd...&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">enter the number?<span class="number">10</span></span><br><span class="line">Number <span class="keyword">is</span> even</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="elif-声明">elif 声明</h2>
<p><code>elif</code>语句使我们能够检查多个条件，并根据其中的真实条件执行特定的语句块。根据我们的需要，我们的程序中可以有任意数量的 <code>elif</code>语句。但是，使用 elif 是可选的。</p>
<p><code>elif</code>语句的工作方式类似于 c 语言中的 if-else-if 梯形语句。它必须由 <code>if</code>语句继承。</p>
<p><code>elif</code>语句的语法如下。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> expression <span class="number">1</span>: </span><br><span class="line">	<span class="comment"># block of statements </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> expression <span class="number">2</span>: </span><br><span class="line">	<span class="comment"># block of statements </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> expression <span class="number">3</span>: </span><br><span class="line">	<span class="comment"># block of statements </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line">	<span class="comment"># block of statements</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/5c831a224686421d7ac32b490ce81407.png" alt="Python If-else statements"></p>
<h3 id="例-1-3">例 1</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">number = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the number?&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> number==<span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;number is equals to 10&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> number==<span class="number">50</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;number is equal to 50&quot;</span>);</span><br><span class="line"><span class="keyword">elif</span> number==<span class="number">100</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;number is equal to 100&quot;</span>);</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;number is not equal to 10, 50 or 100&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the number?<span class="number">15</span></span><br><span class="line">number <span class="keyword">is</span> <span class="keyword">not</span> equal to <span class="number">10</span>, <span class="number">50</span> <span class="keyword">or</span> <span class="number">100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例-2">例 2</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"> marks = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the marks? &quot;</span>))</span><br><span class="line"><span class="keyword">if</span> marks &gt; <span class="number">85</span> <span class="keyword">and</span> marks &lt;= <span class="number">100</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Congrats ! you scored grade A ...&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> marks &gt; <span class="number">60</span> <span class="keyword">and</span> marks &lt;= <span class="number">85</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You scored grade B + ...&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> marks &gt; <span class="number">40</span> <span class="keyword">and</span> marks &lt;= <span class="number">60</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You scored grade B ...&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> (marks &gt; <span class="number">30</span> <span class="keyword">and</span> marks &lt;= <span class="number">40</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You scored grade C ...&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Sorry you are fail ?&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-if-else">https://www.javatpoint.com/python-if-else</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python JSON</title>
    <url>/posts/45338182.html</url>
    <content><![CDATA[<h1>Python JSON</h1>
<p>JSON 代表 <strong>JavaScript 对象符号</strong>，这是一种广泛用于网络数据交换的数据格式。JSON 是在客户机和服务器之间组织数据的理想格式。它的语法类似于 JavaScript 编程语言。JSON 的主要目标是在客户端和网络服务器之间传输数据。这很容易学习，也是交换数据最有效的方法。可以和**<a href="https://www.javatpoint.com/perl-tutorial">Perl</a><a href="https://www.javatpoint.com/java-tutorial">Java</a>**等各种编程语言配合使用。</p>
<p><a href="https://www.javatpoint.com/json-tutorial">JSON</a> 主要支持 6 种数据类型在 <a href="https://www.javatpoint.com/javascript-tutorial">JavaScript</a> 中:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>String</p>
</li>
<li class="lvl-2">
<p>Number</p>
</li>
<li class="lvl-2">
<p>Boolean</p>
</li>
<li class="lvl-2">
<p>Null</p>
</li>
<li class="lvl-2">
<p>Object</p>
</li>
<li class="lvl-2">
<p>Array</p>
</li>
</ul>
<p>JSON 建立在两种结构之上:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>它将数据存储在名称/值对中。它被视为<strong>对象、记录、字典、哈希表、键控列表</strong>。</p>
</li>
<li class="lvl-4">
<p>值的有序列表被视为数组、向量、列表或序列。</p>
</li>
</ul>
<p>JSON 数据表示类似于 Python 字典。下面是一个 JSON 数据的例子:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;book&quot;</span>: [</span><br><span class="line">  &#123; </span><br><span class="line">       <span class="string">&quot;id&quot;</span>: 01,</span><br><span class="line"><span class="string">&quot;language&quot;</span>: <span class="string">&quot;English&quot;</span>,</span><br><span class="line"><span class="string">&quot;edition&quot;</span>: <span class="string">&quot;Second&quot;</span>,</span><br><span class="line"><span class="string">&quot;author&quot;</span>: <span class="string">&quot;Derrick Mwiti&quot;</span> </span><br><span class="line">],</span><br><span class="line">   &#123;</span><br><span class="line">  &#123; </span><br><span class="line">	<span class="string">&quot;id&quot;</span>: 02,</span><br><span class="line"><span class="string">&quot;language&quot;</span>: <span class="string">&quot;French&quot;</span>,</span><br><span class="line"><span class="string">&quot;edition&quot;</span>: <span class="string">&quot;Third&quot;</span>,</span><br><span class="line"><span class="string">&quot;author&quot;</span>: <span class="string">&quot;Vladimir&quot;</span> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="使用-Python-JSON">使用 Python JSON</h2>
<p>Python 提供了一个名为 <strong>json</strong> 的模块。Python 支持标准库封送和 <code>pickle</code>模块，JSON API 的行为与这些库类似。Python 本身支持 JSON 特性。</p>
<p>JSON 数据的编码称为<strong>序列化</strong>。序列化是一种技术，其中数据在<strong>字节序列</strong>中转换，并通过网络传输。</p>
<p>反序列化是对转换为 JSON 格式的数据进行解码的反向过程。</p>
<p>该模块包括许多内置功能。</p>
<p>让我们来看看这些功能:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(json))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;JSONDecodeError&#x27;</span>, <span class="string">&#x27;JSONDecoder&#x27;</span>, <span class="string">&#x27;JSONEncoder&#x27;</span>, <span class="string">&#x27;__all__&#x27;</span>, <span class="string">&#x27;__author__&#x27;</span>, <span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;__cached__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__file__&#x27;</span>, <span class="string">&#x27;__loader__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;__path__&#x27;</span>, <span class="string">&#x27;__spec__&#x27;</span>, <span class="string">&#x27;__version__&#x27;</span>, <span class="string">&#x27;_default_decoder&#x27;</span>, <span class="string">&#x27;_default_encoder&#x27;</span>, <span class="string">&#x27;codecs&#x27;</span>, <span class="string">&#x27;decoder&#x27;</span>, <span class="string">&#x27;detect_encoding&#x27;</span>, <span class="string">&#x27;dump&#x27;</span>, <span class="string">&#x27;dumps&#x27;</span>, <span class="string">&#x27;encoder&#x27;</span>, <span class="string">&#x27;load&#x27;</span>, <span class="string">&#x27;loads&#x27;</span>, <span class="string">&#x27;scanner&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在本节中，我们将学习以下方法:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>load()</strong></p>
</li>
<li class="lvl-4">
<p><strong>loads()</strong></p>
</li>
<li class="lvl-4">
<p><strong>dump()</strong></p>
</li>
<li class="lvl-4">
<p><strong>dumps()</strong></p>
</li>
</ul>
<h2 id="序列化-JSON">序列化 JSON</h2>
<p>序列化是将 Python 对象转换为 JSON 的技术。有时，计算机需要处理大量的信息，因此将这些信息存储到文件中是很好的。我们可以使用 JSON 函数将 JSON 数据存储到文件中。json 模块提供了用于转换 Python 对象的 <strong>dump()</strong> 和**dump()**方法。</p>
<p>Python 对象被转换为以下 JSON 对象。清单如下:</p>
<table>
<thead>
<tr>
<th>Python 对象</th>
<th>数据</th>
</tr>
</thead>
<tbody>
<tr>
<td>Dict</td>
<td>Object</td>
</tr>
<tr>
<td>list, tuple</td>
<td>Array</td>
</tr>
<tr>
<td>Str</td>
<td>String</td>
</tr>
<tr>
<td>int，float</td>
<td>Number</td>
</tr>
<tr>
<td>True</td>
<td>true</td>
</tr>
<tr>
<td>False</td>
<td>false</td>
</tr>
<tr>
<td>None</td>
<td>null</td>
</tr>
</tbody>
</table>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>dump()功能</strong></p>
</li>
</ul>
<p><strong>将 JSON 数据写入文件</strong></p>
<p>Python 提供了 <strong>dump()</strong> 功能，以 JSON 格式传输(编码)数据。它接受两个位置参数，第一个是要序列化的数据对象，第二个是需要写入字节的类似文件的对象。</p>
<p>让我们考虑简单的序列化示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Import json</span><br><span class="line"><span class="comment"># Key:value mapping</span></span><br><span class="line">student  = &#123;</span><br><span class="line"><span class="string">&quot;Name&quot;</span> : <span class="string">&quot;Peter&quot;</span>,</span><br><span class="line"><span class="string">&quot;Roll_no&quot;</span> : <span class="string">&quot;0090014&quot;</span>,</span><br><span class="line"><span class="string">&quot;Grade&quot;</span> : <span class="string">&quot;A&quot;</span>,</span><br><span class="line"><span class="string">&quot;Age&quot;</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">&quot;Subject&quot;</span>: [<span class="string">&quot;Computer Graphics&quot;</span>, <span class="string">&quot;Discrete Mathematics&quot;</span>, <span class="string">&quot;Data Structure&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.json&quot;</span>,<span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> write_file:</span><br><span class="line">    json.dump(student,write_file)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;Name&quot;</span> : <span class="string">&quot;Peter&quot;</span>, <span class="string">&quot;Roll_no&quot;</span> : <span class="string">&quot;0090014&quot;</span> , <span class="string">&quot;Grade&quot;</span> : <span class="string">&quot;A&quot;</span>,  <span class="string">&quot;Age&quot;</span> : <span class="number">20</span>, <span class="string">&quot;Subject&quot;</span> : [<span class="string">&quot;Computer Graphics&quot;</span>, <span class="string">&quot;Discrete Mathematics&quot;</span>, <span class="string">&quot;Data Structure&quot;</span>] &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的程序中，我们已经在写入模式下打开了一个名为 <strong>data.json</strong> 的文件。我们以写入模式打开了该文件，因为如果该文件不存在，它将被创建。 <strong>json.dump()</strong> 方法将字典转换为 json 字符串。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>dumps()功能</strong></p>
</li>
</ul>
<p>**dumps()**函数用于将序列化数据存储在 Python 文件中。它只接受一个参数，即用于序列化的 Python 数据。没有使用类似文件的参数，因为我们没有将数据写入磁盘。让我们考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment"># Key:value mapping</span></span><br><span class="line">student  = &#123;</span><br><span class="line"><span class="string">&quot;Name&quot;</span> : <span class="string">&quot;Peter&quot;</span>,</span><br><span class="line"><span class="string">&quot;Roll_no&quot;</span> : <span class="string">&quot;0090014&quot;</span>,</span><br><span class="line"><span class="string">&quot;Grade&quot;</span> : <span class="string">&quot;A&quot;</span>,</span><br><span class="line"><span class="string">&quot;Age&quot;</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">b = json.dumps(student)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;Peter&quot;</span>, <span class="string">&quot;Roll_no&quot;</span>: <span class="string">&quot;0090014&quot;</span>, <span class="string">&quot;Grade&quot;</span>: <span class="string">&quot;A&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">20</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JSON 支持原始数据类型，如字符串和数字，以及嵌套列表、元组和对象。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment">#Python  list conversion to JSON  Array </span></span><br><span class="line"><span class="built_in">print</span>(json.dumps([<span class="string">&#x27;Welcome&#x27;</span>, <span class="string">&quot;to&quot;</span>, <span class="string">&quot;javaTpoint&quot;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment">#Python  tuple conversion to JSON Array </span></span><br><span class="line"><span class="built_in">print</span>(json.dumps((<span class="string">&quot;Welcome&quot;</span>, <span class="string">&quot;to&quot;</span>, <span class="string">&quot;javaTpoint&quot;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python string conversion to JSON String </span></span><br><span class="line"><span class="built_in">print</span>(json.dumps(<span class="string">&quot;Hello&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python int conversion to JSON Number </span></span><br><span class="line"><span class="built_in">print</span>(json.dumps(<span class="number">1234</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python float conversion to JSON Number </span></span><br><span class="line"><span class="built_in">print</span>(json.dumps(<span class="number">23.572</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Boolean conversion to their respective values </span></span><br><span class="line"><span class="built_in">print</span>(json.dumps(<span class="literal">True</span>))</span><br><span class="line"><span class="built_in">print</span>(json.dumps(<span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># None value to null </span></span><br><span class="line"><span class="built_in">print</span>(json.dumps(<span class="literal">None</span>)) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&quot;Welcome&quot;</span>, <span class="string">&quot;to&quot;</span>, <span class="string">&quot;javaTpoint&quot;</span>]</span><br><span class="line">[<span class="string">&quot;Welcome&quot;</span>, <span class="string">&quot;to&quot;</span>, <span class="string">&quot;javaTpoint&quot;</span>]</span><br><span class="line"><span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="number">1234</span></span><br><span class="line"><span class="number">23.572</span></span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">null</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="反序列化-JSON">反序列化 JSON</h3>
<p>反序列化是将 JSON 数据解码成 Python 对象的过程。json 模块提供了 <strong>load()</strong> 和**loads()**两种方法，用于将 JSON 数据转换为实际的 Python 对象形式。清单如下:</p>
<table>
<thead>
<tr>
<th>json</th>
<th>Python</th>
</tr>
</thead>
<tbody>
<tr>
<td>Object</td>
<td>dict</td>
</tr>
<tr>
<td>Array</td>
<td>list</td>
</tr>
<tr>
<td>String</td>
<td>str</td>
</tr>
<tr>
<td>number(int)</td>
<td>int</td>
</tr>
<tr>
<td>true</td>
<td>True</td>
</tr>
<tr>
<td>false</td>
<td>False</td>
</tr>
<tr>
<td>null</td>
<td>None</td>
</tr>
</tbody>
</table>
<p>上表显示了序列化表的逆表，但从技术上讲，它不是 JSON 数据的完美转换。这意味着，如果我们对对象进行编码，并在一段时间后再次解码；我们可能拿不回同样的东西。</p>
<p>让我们举一个现实生活中的例子，一个人把一些东西翻译成中文，另一个人把它翻译回英文，这可能不完全是翻译。考虑一个简单的例子:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">a = (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line">b = json.dumps(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(json.loads(b)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>load()功能</strong></p>
</li>
</ul>
<p><strong>load()</strong> 函数用于将 JSON 数据从文件反序列化为 Python 对象。考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment"># Key:value mapping</span></span><br><span class="line">student  = &#123;</span><br><span class="line"><span class="string">&quot;Name&quot;</span> : <span class="string">&quot;Peter&quot;</span>,</span><br><span class="line"><span class="string">&quot;Roll_no&quot;</span> : <span class="string">&quot;0090014&quot;</span>,</span><br><span class="line"><span class="string">&quot;Grade&quot;</span> : <span class="string">&quot;A&quot;</span>,</span><br><span class="line"><span class="string">&quot;Age&quot;</span>: <span class="number">20</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.json&quot;</span>,<span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> write_file:</span><br><span class="line">    json.dump(student,write_file)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.json&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> read_file:</span><br><span class="line">    b = json.load(read_file)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Peter&#x27;</span>, <span class="string">&#x27;Roll_no&#x27;</span>: <span class="string">&#x27;0090014&#x27;</span>, <span class="string">&#x27;Grade&#x27;</span>: <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">20</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的程序中，我们已经使用 <strong>dump()</strong> 函数对文件中的 Python 对象进行了编码。之后我们使用 <strong>load()</strong> 函数读取 JSON 文件，这里我们已经传递了 <strong>read_file</strong> 作为参数。</p>
<p>json 模块还提供了 <strong>loads()</strong> 函数，用于将 JSON 数据转换为 Python 对象。这与**load()**功能非常相似。考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Import json</span><br><span class="line">a = [<span class="string">&quot;Mathew&quot;</span>,<span class="string">&quot;Peter&quot;</span>,(<span class="number">10</span>,<span class="number">32.9</span>,<span class="number">80</span>),&#123;<span class="string">&quot;Name&quot;</span> : <span class="string">&quot;Tokyo&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python object into JSON </span></span><br><span class="line">b = json.dumps(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># JSON into Python Object</span></span><br><span class="line">c = json.loads(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;Mathew&#x27;</span>, <span class="string">&#x27;Peter&#x27;</span>, [<span class="number">10</span>, <span class="number">32.9</span>, <span class="number">80</span>], &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Tokyo&#x27;</span>&#125;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="json-load-与-json-loads">json.load()与 json.loads()</h3>
<p><strong>json.load()</strong> 函数用于加载 json 文件，而 <strong>json.loads()</strong> 函数用于加载字符串。</p>
<h3 id="json-dump-与-JSON-dumps">json.dump()与 JSON.dumps()</h3>
<p>当我们想要将 Python 对象序列化为 json 文件时，使用 <strong>json.dump()</strong> 函数，使用**JSON . dump()**函数将 JSON 数据转换为字符串进行解析和打印。</p>
<h2 id="Python-漂亮打印-JSON">Python 漂亮打印 JSON</h2>
<p>有时我们需要分析和调试大量的 JSON 数据。这可以通过在 json.dump()和 JSON.dump()方法中传递额外的参数 indent 和 sort_keys 来实现。</p>
<h4 id="注意-dump-和-dumps-函数都接受缩进和短键参数。">注意:dump()和 dumps()函数都接受缩进和短键参数。</h4>
<p>考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">person = <span class="string">&#x27;&#123;&quot;Name&quot;: &quot;Andrew&quot;,&quot;City&quot;:&quot;English&quot;, &quot;Number&quot;:90014, &quot;Age&quot;: 23,&quot;Subject&quot;: [&quot;Data Structure&quot;,&quot;Computer Graphics&quot;, &quot;Discrete mathematics&quot;]&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">per_dict = json.loads(person)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(json.dumps(per_dict, indent = <span class="number">5</span>, sort_keys= <span class="literal">True</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;Age&quot;</span>: <span class="number">23</span>,</span><br><span class="line">    <span class="string">&quot;City&quot;</span>: <span class="string">&quot;English&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;Andrew&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Number&quot;</span>: <span class="number">90014</span>,</span><br><span class="line">    <span class="string">&quot;Subject&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;Data Structure&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Computer Graphics&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Discrete mathematics&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们为缩进参数提供了 5 个空格，并且键是按升序排序的。缩进的默认值为<strong>False</strong>，** Sort_key<strong>的默认值为</strong>False**。</p>
<h2 id="编码和解码">编码和解码</h2>
<p>编码是将文本或值转换成加密形式的技术。加密数据只能由首选用户通过解码来使用。编码也称为<strong>序列化</strong>，解码也称为<strong>反序列化</strong>。对 JSON(对象)格式进行编码和解码。Python 为此类操作提供了一个流行的包。我们可以通过以下命令在 Windows 上安装它:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install demjson</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>编码</strong>-demjson 包提供了 <strong>encode()</strong> 函数，用于将 Python 对象转换为 json 字符串表示。语法如下:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">demjson.encode(self,obj,nest_level = <span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例:1 -使用 demjson 包进行编码</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> demjson</span><br><span class="line">a = [&#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&#x27;Peter&#x27;</span>,<span class="string">&quot;Age&quot;</span>:<span class="number">20</span>, <span class="string">&quot;Subject&quot;</span>:<span class="string">&quot;Electronics&quot;</span>&#125;]</span><br><span class="line"><span class="built_in">print</span>(demjson.encode(a))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="string">&quot;Age&quot;</span>:<span class="number">20</span>,<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;Peter&quot;</span>,<span class="string">&quot;Subject&quot;</span>:<span class="string">&quot;Electronics&quot;</span>&#125;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>解码</strong>-<strong>demjson</strong>模块提供**解码()**功能，用于将 json 对象转换为 Python 格式类型。语法如下:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Import demjson</span><br><span class="line">a = <span class="string">&quot;[&#x27;Peter&#x27;, &#x27;Smith&#x27;, &#x27;Ricky&#x27;, &#x27;Hayden&#x27;]&quot;</span></span><br><span class="line"><span class="built_in">print</span>(demjson.decode(a))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;Peter&#x27;</span>, <span class="string">&#x27;Smith&#x27;</span>, <span class="string">&#x27;Ricky&#x27;</span>, <span class="string">&#x27;Hayden&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在本教程中，我们已经了解了 Python JSON。JSON 是客户端和 web 服务器之间传输数据最有效的方式。</p>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-json">https://www.javatpoint.com/python-json</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Lambda函数</title>
    <url>/posts/41f913f0.html</url>
    <content><![CDATA[<h1>Python Lambda函数</h1>
<p>Python Lambda 函数被称为匿名函数，它是在没有名称的情况下定义的。Python 允许我们不以标准方式声明函数，即使用 <strong>def</strong> 关键字。相反，匿名函数是通过使用<strong>λ</strong>关键字声明的。但是，Lambda 函数可以接受任意数量的参数，但是它们只能以表达式的形式返回一个值。</p>
<p>匿名函数包含一小段代码。它模拟 C 和 C++的内联函数，但并不完全是内联函数。</p>
<p>下面给出了定义匿名函数的语法。</p>
<h3 id="句法-5">句法</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> arguments: expression     </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它可以接受任意数量的参数，并且只有一个表达式。当需要函数对象时，它很有用。</p>
<p>考虑以下 lambda 函数的例子。</p>
<h3 id="例-1-4">例 1</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a is an argument and a+10 is an expression which got evaluated and returned.  </span></span><br><span class="line">x = <span class="keyword">lambda</span> a:a+<span class="number">10</span> </span><br><span class="line"><span class="comment"># Here we are printing the function object</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sum = &quot;</span>,x(<span class="number">20</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;function &lt;<span class="keyword">lambda</span>&gt; at <span class="number">0x0000019E285D16A8</span>&gt;</span><br><span class="line"><span class="built_in">sum</span> =  <span class="number">30</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们定义了<strong>λa:a+10</strong>匿名函数，其中 <strong>a</strong> 是一个参数， <strong>a+10</strong> 是一个表达式。给定的表达式被求值并返回结果。上述 lambda 函数与普通函数相同。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">x</span>(<span class="params">a</span>):</span><br><span class="line">	<span class="keyword">return</span> a+<span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span> = x(<span class="number">10</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例-2-2">例 2</h3>
<p>Lambda 函数的多个参数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a and b are the arguments and a*b is the expression which gets evaluated and returned.  </span></span><br><span class="line">x = <span class="keyword">lambda</span> a,b: a*b</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mul = &quot;</span>, x(<span class="number">20</span>,<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">mul =  <span class="number">200</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为什么要用 lambda 函数？当我们在另一个函数中匿名使用 lambda 函数时，在场景中可以更好地描述 lambda 函数的主要作用。在 Python 中，lambda 函数可以用作<strong>高阶函数</strong>的参数，后者接受其他函数作为参数。考虑以下示例:<br>
例 1:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#the function table(n) prints the table of n  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">table</span>(<span class="params">n</span>):  </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">lambda</span> a:a*n <span class="comment"># a will contain the iteration variable i and a multiple of n is returned at each function call  </span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the number:&quot;</span>))  </span><br><span class="line">b = table(n) <span class="comment">#the entered number is passed into the function table. b will contain a lambda function which is called again and again with the iteration variable i  </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>):  </span><br><span class="line"><span class="built_in">print</span>(n,<span class="string">&quot;X&quot;</span>,i,<span class="string">&quot;=&quot;</span>,b(i)) <span class="comment">#the lambda function b is called with the iteration variable i</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the number:<span class="number">10</span></span><br><span class="line"><span class="number">10</span> X <span class="number">1</span> = <span class="number">10</span></span><br><span class="line"><span class="number">10</span> X <span class="number">2</span> = <span class="number">20</span></span><br><span class="line"><span class="number">10</span> X <span class="number">3</span> = <span class="number">30</span></span><br><span class="line"><span class="number">10</span> X <span class="number">4</span> = <span class="number">40</span></span><br><span class="line"><span class="number">10</span> X <span class="number">5</span> = <span class="number">50</span></span><br><span class="line"><span class="number">10</span> X <span class="number">6</span> = <span class="number">60</span></span><br><span class="line"><span class="number">10</span> X <span class="number">7</span> = <span class="number">70</span></span><br><span class="line"><span class="number">10</span> X <span class="number">8</span> = <span class="number">80</span></span><br><span class="line"><span class="number">10</span> X <span class="number">9</span> = <span class="number">90</span></span><br><span class="line"><span class="number">10</span> X <span class="number">10</span> = <span class="number">100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>lambda 函数常用 Python 内置函数 <strong>filter()</strong> 函数和 <strong>map()</strong> 函数。将 lambda 函数与过滤器一起使用()<br>
Python 内置的 <strong>filter()函数</strong>接受一个函数和一个列表作为参数。它提供了一种有效的方法来过滤掉序列中的所有元素。它返回新的序列，在该序列中，函数评估为<strong>true</strong>。考虑下面的例子，我们从给定的列表中过滤出唯一的奇数。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#program to filter out the tuple which contains odd numbers  </span></span><br><span class="line">lst = (<span class="number">10</span>,<span class="number">22</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">100</span>,<span class="number">123</span>,<span class="number">29</span>)</span><br><span class="line">oddlist = <span class="built_in">tuple</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x:(x%<span class="number">3</span> == <span class="number">0</span>),lst)) <span class="comment"># the tuple contains all the items of the tuple for which the lambda function evaluates to true  </span></span><br><span class="line"><span class="built_in">print</span>(oddlist)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="number">37</span>, <span class="number">41</span>, <span class="number">123</span>, <span class="number">29</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用 lambda 函数和 map()<br>
Python 中的 <strong>map()函数</strong>接受一个函数和一个列表。它给出了一个新的列表，其中包含了函数为每个项目返回的所有修改过的项目。考虑以下 <strong>map()</strong> 函数的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#program to filter out the list which contains odd numbers  </span></span><br><span class="line">lst = (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>)</span><br><span class="line">square_list = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x**<span class="number">2</span>,lst)) <span class="comment"># the tuple contains all the items of the list for which the lambda function evaluates to true  </span></span><br><span class="line"><span class="built_in">print</span>(square_tuple)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="number">100</span>, <span class="number">400</span>, <span class="number">900</span>, <span class="number">1600</span>, <span class="number">2500</span>, <span class="number">3600</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python OpenCV对象检测</title>
    <url>/posts/828582a3.html</url>
    <content><![CDATA[<h1>Python OpenCV 对象检测</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-opencv-object-detection">https://www.javatpoint.com/python-opencv-object-detection</a></p>
</blockquote>
<p>OpenCV 是用于图像处理、机器学习和计算机视觉的巨大开源库。它在实时操作中也发挥着重要作用。在 OpenCV 库的帮助下，我们可以轻松地处理图像和视频，以识别文件中的对象、人脸甚至笔迹。在本教程中，我们将只关注使用 OpenCV 从图像中检测对象。我们将学习如何使用 Python 程序使用 OpenCV 从给定的图像中进行对象检测。</p>
<h2 id="对象检测">对象检测</h2>
<p>基本上，对象检测是与图像处理、深度学习和计算机视觉相关的现代计算机技术，以检测图像文件中存在的对象。对象检测技术中使用的所有技术(正如我们前面提到的)都处理检测图像或视频中对象的实例。</p>
<h2 id="基于-OpenCV-的对象检测">基于 OpenCV 的对象检测</h2>
<p>我们在上一节中已经学习了对象检测，在这一节中，我们将学习如何使用 OpenCV 库在图像或视频中进行对象检测。我们将首先在 Python 程序中导入 OpenCV 库，然后我们将使用函数对给我们的图像文件执行对象检测。但是，在使用和导入库函数之前，让我们先安装使用对象检测技术的要求。</p>
<p>在本教程中，我们将使用哈尔级联技术来进行对象检测。让我们先简单了解一下哈尔级联技术。</p>
<h3 id="Haar级联技术">Haar级联技术:</h3>
<p>基本上，哈尔级联技术是一种基于机器学习的方法，其中我们使用大量正图像和负图像来训练分类器以在图像之间进行分类。哈尔级联分类器被认为是利用 OpenCV 库进行对象检测的有效方法。现在，让我们理解前面讨论过的正面和负面形象的概念:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>**Positive images:**这些图像包含我们希望从分类器中识别的对象。</p>
</li>
<li class="lvl-4">
<p>**Negative Images:**这些是不包含任何我们希望被分类器检测到的物体的图像，这些可以是其他一切的图像。</p>
</li>
</ul>
<h3 id="使用-Python-OpenCV-进行对象检测的要求">使用 Python OpenCV 进行对象检测的要求:</h3>
<p>我们必须首先在系统中安装一些重要的库，因为这是执行对象检测任务的重要要求。作为执行对象检测的要求，我们必须在系统中安装以下库:</p>
<h3 id="1-OpenCV-库的安装">1.OpenCV 库的安装:</h3>
<p>首先，使用 OpenCV 库执行对象检测的要求是 OpenCV 库应该存在于我们的设备中，以便我们可以将其导入 Python 程序并使用其对象检测功能。如果这个库不在我们的系统中，我们可以使用命令提示符终端中的以下命令来安装它:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install opencv-python</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/9a65f0ac64d7a8bce92e8185698aa66f.png" alt="Python OpenCV object detection"></p>
<p>当我们在终端写完这个命令后按回车键，命令提示符下的 pip 安装程序会开始将 OpenCV 库安装到我们的系统中。</p>
<p><img src="/img/31354ca5b16ba2d9e7d4a477f755c2d6.png" alt="Python OpenCV object detection"></p>
<p>我们可以看到，OpenCV 库已经成功安装在我们的系统中，现在我们可以将其导入到 Python 程序中使用它的功能。</p>
<h3 id="2-matplotlib-库的安装">2.matplotlib 库的安装:</h3>
<p>Matplotlib 在开篇、结尾、阅读等方面很有帮助。，Python 程序中的图像，这就是为什么安装这个用于对象检测的库成为一项重要要求的原因。如果 matplotlib 库不在我们的系统中，我们必须在命令提示符终端中使用以下命令来安装它:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install matplotlib</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/17047dfe9fa3301d5bafd3951330b44a.png" alt="Python OpenCV object detection"></p>
<p>当我们在终端中写完这个命令后按回车键，命令提示符中的 pip 安装程序将开始将其安装到我们的系统中。</p>
<p><img src="/img/adec4c14adfb1ace475b0b858085cb7f.png" alt="Python OpenCV object detection"></p>
<p>我们可以看到，matplotlib 库已经成功安装在我们的系统中，现在我们可以将其导入到 Python 程序中，使用其功能进行打开、读取等。，图像。</p>
<p>我们已经安装了执行对象检测所需的所有库，现在我们可以继续这个任务的实现部分了。</p>
<h3 id="对象检测在-Python-中的实现；">对象检测在 Python 中的实现；</h3>
<p>在这一部分，我们将编写 Python 程序来进行对象检测，并了解它的实现。我们将在 Python 程序中使用以下图像对其执行对象检测:</p>
<p><img src="/img/375d017fa4d2c447c521a96cb2840059.png" alt="Python OpenCV object detection"></p>
<h3 id="打开图像">打开图像</h3>
<p>我们将首先打开上面给出的图像，并创建图片的环境以在输出中显示它。我们先看一个示例程序来了解实现，然后再看解释部分。</p>
<p><strong>示例 1:</strong> 在 Python 程序中使用 OpenCV 和 matplotlib 库打开图像:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Import OpenCV module</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="comment"># Import pyplot from matplotlib as pltd</span></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> pltd</span><br><span class="line"><span class="comment"># Opening the image from files</span></span><br><span class="line">imaging = cv2.imread(<span class="string">&quot;opencv-od.png&quot;</span>)</span><br><span class="line"><span class="comment"># Altering properties of image with cv2</span></span><br><span class="line">/img_gray = cv2.cvtColor(imaging, cv2.COLOR_BGR2GRAY)</span><br><span class="line">imaging_rgb = cv2.cvtColor(imaging, cv2.COLOR_BGR2RGB)</span><br><span class="line"><span class="comment"># Plotting image with subplot() from plt</span></span><br><span class="line">pltd.subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># Displaying image in the output</span></span><br><span class="line">pltd.imshow(imaging_rgb)</span><br><span class="line">pltd.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<p><img src="/img/1f5765a01cb18ba3596d311e651e9cdc.png" alt="Python OpenCV object detection"></p>
<p><strong>说明:</strong></p>
<p>首先，我们将 OpenCV(作为 cv2)和 matplotlib(作为 plt)库导入到程序中，以便在代码中使用它们的功能。之后，我们使用 cv2 的 imread()函数打开了图像文件。</p>
<p>然后，我们使用 cv2 函数定义了在程序中打开的图像的属性。然后，我们使用 plt 的子图()函数对图像进行子图，并在其中给出参数。最后，我们使用了 plt 模块的 imshow()和 show()函数来显示输出中的图像。</p>
<p>正如我们在输出中看到的，图像是作为程序的结果显示的，并且它的边界已经被细分。</p>
<h3 id="图像中的识别或物体检测">图像中的识别或物体检测</h3>
<p>现在，我们将使用程序中的检测多尺度()来检测图像中存在的对象。下面是在代码中使用 detectMultiScale()函数的语法:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">found = xml_data.detectMultiScale(/img_gray, </span><br><span class="line">                                   minSize = (<span class="number">30</span>, <span class="number">30</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们将在程序中使用带有此功能的条件语句来检查是否检测到图像中的任何对象，并突出显示检测到的部分。让我们通过一个示例程序来了解图像中对象检测的实现。</p>
<p><strong>示例 2:</strong> 使用以下 Python 程序中的检测多尺度()在图像中检测对象:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Import OpenCV module</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="comment"># Import pyplot from matplotlib as plt</span></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> pltd</span><br><span class="line"><span class="comment"># Opening the image from files</span></span><br><span class="line">imaging = cv2.imread(<span class="string">&quot;opencv-od.png&quot;</span>)</span><br><span class="line"><span class="comment"># Altering properties of image with cv2</span></span><br><span class="line">imaging_gray = cv2.cvtColor(imaging, cv2.COLOR_BGR2GRAY)</span><br><span class="line">imaging_rgb = cv2.cvtColor(imaging, cv2.COLOR_BGR2RGB)</span><br><span class="line"><span class="comment"># Importing Haar cascade classifier xml data</span></span><br><span class="line">xml_data = cv2.CascadeClassifier(<span class="string">&#x27;XML-data.xml&#x27;</span>)</span><br><span class="line"><span class="comment"># Detecting object in the image with Haar cascade classifier </span></span><br><span class="line">detecting = xml_data.detectMultiScale(imaging_gray, </span><br><span class="line">                                   minSize = (<span class="number">30</span>, <span class="number">30</span>))</span><br><span class="line"><span class="comment"># Amount of object detected</span></span><br><span class="line">amountDetecting = <span class="built_in">len</span>(detecting)</span><br><span class="line"><span class="comment"># Using if condition to highlight the object detected</span></span><br><span class="line"><span class="keyword">if</span> amountDetecting != <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">for</span> (a, b, width, height) <span class="keyword">in</span> detecting:</span><br><span class="line">        cv2.rectangle(imaging_rgb, (a, b), <span class="comment"># Highlighting detected object with rectangle</span></span><br><span class="line">                      (a + height, b + width), </span><br><span class="line">                      (<span class="number">0</span>, <span class="number">275</span>, <span class="number">0</span>), <span class="number">9</span>)</span><br><span class="line"><span class="comment"># Plotting image with subplot() from plt</span></span><br><span class="line">pltd.subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># Displaying image in the output</span></span><br><span class="line">pltd.imshow(imaging_rgb)</span><br><span class="line">pltd.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<p><img src="/img/bfd4406c2ac6114374d1941c78640745.png" alt="Python OpenCV object detection"></p>
<p><strong>说明:</strong></p>
<p>在程序中打开图像后，我们已经将级联分类器 XML 文件导入到程序中。然后，我们使用导入的级联文件的**检测多尺度()**功能来检测图像中是否存在对象。</p>
<p>我们在程序中使用 if 条件来检查对象是否被检测到，如果对象被检测到，我们已经使用 <code>for</code>循环和 cv2 函数高亮显示了检测到的对象部分。高亮显示图像中检测到的物体部分后，我们使用 plt <strong>show()</strong> 和 <strong>imshow()</strong> 功能显示处理后的图像。</p>
<p>正如我们在输出中所看到的，当我们运行程序时，带有突出显示的对象检测部分的图像会显示给我们。</p>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python SMTP发送电子邮件</title>
    <url>/posts/14808f99.html</url>
    <content><![CDATA[<h1>Python 使用 SMTP 发送电子邮件</h1>
<p>简单邮件传输协议(SMTP)被用作使用 Python 处理电子邮件传输的协议。它用于在电子邮件服务器之间路由电子邮件。它是一个应用层协议，允许用户向另一个用户发送邮件。接收者使用协议 **POP(邮局协议)**和 **IMAP(互联网消息访问协议)**检索电子邮件。</p>
<p><img src="/img/6dbdbeeafac53cfcf36f471474dcb304.png" alt="Python Sending Email using SMTP"></p>
<p>当服务器侦听来自客户端的 TCP 连接时，它会在端口 587 上启动连接。</p>
<p>Python 提供了一个 <strong>smtplib</strong> 模块，该模块定义了一个用于向互联网机器发送电子邮件的 SMTP 客户端会话对象。为此，我们必须使用 import 语句导入 <strong>smtplib</strong> 模块。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ <span class="keyword">import</span> smtplib</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>SMTP 对象用于电子邮件传输。以下语法用于创建 smtplib 对象。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> smtplib   </span><br><span class="line">smtpObj = smtplib.SMTP(host, port, local_hostname)    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它接受以下参数。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>**主机:**是运行您的 SMTP 服务器的机器的主机名。在这里，我们可以指定服务器的 IP 地址，如(<a href="https://www.javatpoint.com/">https://www.javatpoint.com</a>)或本地主机。这是一个可选参数。</p>
</li>
<li class="lvl-4">
<p>**端口:**是主机监听 SMTP 连接的端口号。默认为 25。</p>
</li>
<li class="lvl-4">
<p><strong>local_hostname:</strong> 如果 SMTP 服务器在你的本地机器上运行，我们可以提到本地机器的主机名。</p>
</li>
</ul>
<p>SMTP 对象的 sendmail()方法用于将邮件发送到所需的计算机。语法如下。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">smtpObj.sendmail(sender, receiver, message)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/python3  </span></span><br><span class="line"><span class="keyword">import</span> smtplib  </span><br><span class="line">sender_mail = <span class="string">&#x27;sender@fromdomain.com&#x27;</span>  </span><br><span class="line">receivers_mail = [<span class="string">&#x27;reciever@todomain.com&#x27;</span>]  </span><br><span class="line">message = <span class="string">&quot;&quot;&quot;From: From Person %s </span></span><br><span class="line"><span class="string">To: To Person %s </span></span><br><span class="line"><span class="string">Subject: Sending SMTP e-mail  </span></span><br><span class="line"><span class="string">This is a test e-mail message. </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>%(sender_mail,receivers_mail)  </span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">   smtpObj = smtplib.SMTP(<span class="string">&#x27;localhost&#x27;</span>)  </span><br><span class="line">   smtpObj.sendmail(sender_mail, receivers_mail, message)  </span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Successfully sent email&quot;</span>)  </span><br><span class="line"><span class="keyword">except</span> Exception:  </span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Error: unable to send email&quot;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="从-gmail-发送电子邮件">从 gmail 发送电子邮件</h2>
<p>有些情况下，电子邮件是使用 Gmail SMTP 服务器发送的。在这种情况下，我们可以将 Gmail 作为 SMTP 服务器传递，而不是使用端口为 587 的 localhost。</p>
<p>使用以下语法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ smtpObj = smtplib.SMTP(<span class="string">&quot;gmail.com&quot;</span>, <span class="number">587</span>)   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这里，我们需要使用 Gmail 用户名和密码登录 Gmail 账户。为此，smtplib 提供了 login()方法，该方法接受发送者的用户名和密码。</p>
<p>如果你正在使用 Gmail，这可能会让你的 Gmail 要求你访问不太安全的应用。您需要暂时打开此功能才能正常工作。</p>
<p><img src="/img/521bc9056eb7c8a53c5fe64f042469c3.png" alt="Python Sending Email using SMTP"></p>
<p>考虑下面的例子。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/python3  </span></span><br><span class="line"><span class="keyword">import</span> smtplib  </span><br><span class="line">sender_mail = <span class="string">&#x27;sender@gmail.com&#x27;</span>  </span><br><span class="line">receivers_mail = [<span class="string">&#x27;reciever@gmail.com&#x27;</span>]  </span><br><span class="line">message = <span class="string">&quot;&quot;&quot;From: From Person %s </span></span><br><span class="line"><span class="string">To: To Person %s </span></span><br><span class="line"><span class="string">Subject: Sending SMTP e-mail  </span></span><br><span class="line"><span class="string">This is a test e-mail message. </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>%(sender_mail,receivers_mail)  </span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">   password = <span class="built_in">input</span>(<span class="string">&#x27;Enter the password&#x27;</span>);  </span><br><span class="line">   smtpObj = smtplib.SMTP(<span class="string">&#x27;gmail.com&#x27;</span>,<span class="number">587</span>)  </span><br><span class="line">   smtpobj.login(sender_mail,password)  </span><br><span class="line">   smtpObj.sendmail(sender_mail, receivers_mail, message)  </span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Successfully sent email&quot;</span>)  </span><br><span class="line"><span class="keyword">except</span> Exception:  </span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Error: unable to send email&quot;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="通过电子邮件发送-HTML">通过电子邮件发送 HTML</h2>
<p>我们可以通过指定发送 HTML 的 MIME 版本、内容类型和字符集来格式化消息中的 HTML。</p>
<p>考虑下面的例子。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/python3  </span></span><br><span class="line"><span class="keyword">import</span> smtplib  </span><br><span class="line">sender_mail = <span class="string">&#x27;sender@fromdomain.com&#x27;</span>  </span><br><span class="line">receivers_mail = [<span class="string">&#x27;reciever@todomain.com&#x27;</span>]  </span><br><span class="line">message = <span class="string">&quot;&quot;&quot;From: From Person %s </span></span><br><span class="line"><span class="string">To: To Person %s </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">MIME-Version:1.0 </span></span><br><span class="line"><span class="string">Content-type:text/html </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Subject: Sending SMTP e-mail  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;h3&gt;Python SMTP&lt;/h3&gt; </span></span><br><span class="line"><span class="string">&lt;strong&gt;This is a test e-mail message.&lt;/strong&gt; </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>%(sender_mail,receivers_mail)  </span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">   smtpObj = smtplib.SMTP(<span class="string">&#x27;localhost&#x27;</span>)  </span><br><span class="line">   smtpObj.sendmail(sender_mail, receivers_mail, message)  </span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Successfully sent email&quot;</span>)  </span><br><span class="line"><span class="keyword">except</span> Exception:  </span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Error: unable to send email&quot;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-sending-email">https://www.javatpoint.com/python-sending-email</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python `While`循环</title>
    <url>/posts/52a29154.html</url>
    <content><![CDATA[<h1>Python <code>While</code>循环</h1>
<p>Python <code>While</code>循环允许执行部分代码，直到给定条件返回 false。它也被称为预测试环路。</p>
<p>它可以被看作是一个重复的 <code>if</code>语句。当我们不知道迭代次数时，<code>While</code>循环是最有效的。</p>
<p>语法如下。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> expression:  </span><br><span class="line">    statements  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，语句可以是单个语句或一组语句。表达式应该是任何导致真或假的有效 Python 表达式。true 是任何非零值，false 是 0。</p>
<h3 id="当循环流程图">当循环流程图</h3>
<p><img src="/img/942f6f9df8960493f3c336b2683713e1.png" alt="Python While loop"></p>
<h2 id="循环控制语句">循环控制语句</h2>
<p>我们可以在使用循环控制语句执行循环时改变<strong>的正常顺序。当 <code>While</code>循环执行完成时，该范围内定义的所有自动对象都将被拆除。Python 提供了以下控制语句在 <code>While</code>循环中使用。</strong></p>
<p><strong>1.<code>continue</code>语句-</strong></p>
<p>当遇到 <code>continue</code>语句时，控制转移到循环的开始。让我们理解下面的例子。</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># prints all letters except &#x27;a&#x27; and &#x27;t&#x27; </span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">str1 = <span class="string">&#x27;javatpoint&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">len</span>(str1): </span><br><span class="line">	<span class="keyword">if</span> str1[i] == <span class="string">&#x27;a&#x27;</span> <span class="keyword">or</span> str1[i] == <span class="string">&#x27;t&#x27;</span>: </span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Current Letter :&#x27;</span>, a[i]) </span><br><span class="line">	i += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Current Letter : j</span><br><span class="line">Current Letter : v</span><br><span class="line">Current Letter : p</span><br><span class="line">Current Letter : o</span><br><span class="line">Current Letter : i</span><br><span class="line">Current Letter : n</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>2.<code>break</code>语句-</strong></p>
<p>当遇到 <code>break</code>语句时，它会将控制带出循环。</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The control transfer is transfered</span></span><br><span class="line"><span class="comment"># when break statement soon it sees t</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">str1 = <span class="string">&#x27;javatpoint&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">len</span>(str1): </span><br><span class="line">	<span class="keyword">if</span> str1[i] == <span class="string">&#x27;t&#x27;</span>: </span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Current Letter :&#x27;</span>, str1[i]) </span><br><span class="line">	i += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Current Letter : j</span><br><span class="line">Current Letter : a</span><br><span class="line">Current Letter : v</span><br><span class="line">Current Letter : a</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>3.<code>pass</code>语句-</strong></p>
<p><code>pass</code>语句用于声明空循环。它也用于定义空类、函数和控制语句。让我们理解下面的例子。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># An empty loop </span></span><br><span class="line">str1 = <span class="string">&#x27;javatpoint&#x27;</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">len</span>(str1): </span><br><span class="line">	i += <span class="number">1</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Value of i :&#x27;</span>, i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Value of i : <span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="示例-1">示例-1:</h3>
<p>使用 <code>While</code>循环打印 1 到 10 的程序</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">i=<span class="number">1</span></span><br><span class="line"><span class="comment">#The while loop will iterate until condition becomes false.</span></span><br><span class="line">While(i&lt;=<span class="number">10</span>):  </span><br><span class="line">    <span class="built_in">print</span>(i) </span><br><span class="line">    i=i+<span class="number">1</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="示例-2">示例 2:</h3>
<p>打印给定数字表的程序。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">i=<span class="number">1</span>  </span><br><span class="line">number=<span class="number">0</span>  </span><br><span class="line">b=<span class="number">9</span>  </span><br><span class="line">number = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the number:&quot;</span>))  </span><br><span class="line"><span class="keyword">while</span> i&lt;=<span class="number">10</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d X %d = %d \n&quot;</span>%(number,i,number*i))  </span><br><span class="line">    i = i+<span class="number">1</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the number:<span class="number">10</span></span><br><span class="line"><span class="number">10</span> X <span class="number">1</span> = <span class="number">10</span> </span><br><span class="line"></span><br><span class="line"><span class="number">10</span> X <span class="number">2</span> = <span class="number">20</span> </span><br><span class="line"></span><br><span class="line"><span class="number">10</span> X <span class="number">3</span> = <span class="number">30</span> </span><br><span class="line"></span><br><span class="line"><span class="number">10</span> X <span class="number">4</span> = <span class="number">40</span> </span><br><span class="line"></span><br><span class="line"><span class="number">10</span> X <span class="number">5</span> = <span class="number">50</span> </span><br><span class="line"></span><br><span class="line"><span class="number">10</span> X <span class="number">6</span> = <span class="number">60</span> </span><br><span class="line"></span><br><span class="line"><span class="number">10</span> X <span class="number">7</span> = <span class="number">70</span> </span><br><span class="line"></span><br><span class="line"><span class="number">10</span> X <span class="number">8</span> = <span class="number">80</span> </span><br><span class="line"></span><br><span class="line"><span class="number">10</span> X <span class="number">9</span> = <span class="number">90</span> </span><br><span class="line"></span><br><span class="line"><span class="number">10</span> X <span class="number">10</span> = <span class="number">100</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="无限-While循环">无限 <code>While</code>循环</h2>
<p>如果 <code>While</code>循环中给出的条件永远不会变为假，那么 <code>While</code>循环永远不会终止，变成<strong>无限 <code>While</code>循环。</strong></p>
<p><code>While</code>循环中的任何<strong>非零</strong>值表示<strong>始终为真</strong>条件，而零表示始终为假条件。如果我们希望我们的程序在没有任何干扰的情况下连续运行，这种方法是有用的。</p>
<h3 id="例-1-5">例 1</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>):  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hi! we are inside the infinite while loop&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Hi! we are inside the infinite <span class="keyword">while</span> loop</span><br><span class="line">Hi! we are inside the infinite <span class="keyword">while</span> loop</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例-2-3">例 2</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">var = <span class="number">1</span>  </span><br><span class="line"><span class="keyword">while</span>(var != <span class="number">2</span>):  </span><br><span class="line">    i = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the number:&quot;</span>))  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Entered value is %d&quot;</span>%(i))  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the number:<span class="number">10</span></span><br><span class="line">Entered value <span class="keyword">is</span> <span class="number">10</span></span><br><span class="line">Enter the number:<span class="number">10</span></span><br><span class="line">Entered value <span class="keyword">is</span> <span class="number">10</span></span><br><span class="line">Enter the number:<span class="number">10</span></span><br><span class="line">Entered value <span class="keyword">is</span> <span class="number">10</span></span><br><span class="line">Infinite time</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="将-else-与-While循环一起使用">将 else 与 <code>While</code>循环一起使用</h2>
<p>Python 允许我们在 <code>While</code>循环中使用 else 语句。当 while 语句中给出的条件变为 false 时，执行 else 块。就像循环一样，如果 <code>While</code>循环使用 <code>break</code>语句中断，那么 else 块将不会被执行，而 else 块之后的语句将被执行。else 语句可以选择与 <code>While</code>循环一起使用。考虑下面的例子。</p>
<h3 id="例-1-6">例 1</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">i=<span class="number">1</span> </span><br><span class="line"><span class="keyword">while</span>(i&lt;=<span class="number">5</span>):  </span><br><span class="line">    <span class="built_in">print</span>(i)  </span><br><span class="line">    i=i+<span class="number">1</span>  </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The while loop exhausted&quot;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例-2-4">例 2</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">i=<span class="number">1</span>  </span><br><span class="line"><span class="keyword">while</span>(i&lt;=<span class="number">5</span>):  </span><br><span class="line">    <span class="built_in">print</span>(i)  </span><br><span class="line">    i=i+<span class="number">1</span>  </span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">3</span>):  </span><br><span class="line">        <span class="keyword">break</span> </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The while loop exhausted&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，当遇到 <code>break</code>语句时，<code>While</code>循环停止执行并跳过 else 语句。</p>
<h3 id="示例-3">示例-3</h3>
<p>打印斐波那契数列到给定极限的程序</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">terms = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the terms &quot;</span>))</span><br><span class="line"><span class="comment"># first two intial terms</span></span><br><span class="line">a = <span class="number">0</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># check if the number of terms is Zero or negative</span></span><br><span class="line"><span class="keyword">if</span> (terms &lt;= <span class="number">0</span>):</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Please enter a valid integer&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> (terms == <span class="number">1</span>):</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Fibonacci sequence upto&quot;</span>,limit,<span class="string">&quot;:&quot;</span>)</span><br><span class="line">   <span class="built_in">print</span>(a)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Fibonacci sequence:&quot;</span>)</span><br><span class="line">   <span class="keyword">while</span> (count &lt; terms) :</span><br><span class="line">       <span class="built_in">print</span>(a, end = <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">       c = a + b</span><br><span class="line">       <span class="comment"># updateing values</span></span><br><span class="line">       a = b</span><br><span class="line">       b = c</span><br><span class="line"></span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the terms <span class="number">10</span></span><br><span class="line">Fibonacci sequence:</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-while-loop">https://www.javatpoint.com/python-while-loop</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python `assert`关键字</title>
    <url>/posts/5eb69ff5.html</url>
    <content><![CDATA[<h1>Python <code>assert</code>关键字</h1>
<p>Python <code>assert</code>关键字被定义为测试条件的调试工具。断言主要是在程序中断言或陈述一个事实的假设。例如，在编写除法函数时，除数不应该为零，您断言除数不等于零。</p>
<p>它只是一个布尔表达式，有一个条件或表达式检查条件是否返回真或假。如果它是真的，程序什么也不做，它移动到下一行代码。但是如果它为假，它会引发一个带有可选错误消息的 <strong>AssertionError</strong> 异常。</p>
<p>断言的主要任务是通知开发人员程序中不可恢复的错误，如“找不到文件”，说断言是程序的内部自检是正确的。它对于任何应用开发领域的测试或质量保证都是最重要的。<code>assert</code>关键字的语法如下。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> condition, error_message(optional)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="为什么使用断言">为什么使用断言</h2>
<p>它是一个调试工具，主要任务是检查条件。如果它发现条件为真，它将移动到下一行代码，如果不是，则停止所有操作并引发错误。它指出了代码中的错误。</p>
<h2 id="Python-中的断言在哪里使用">Python 中的断言在哪里使用</h2>
<ul class="lvl-0">
<li class="lvl-4">
<p>检查功能的输出。</p>
</li>
<li class="lvl-4">
<p>用于测试代码。</p>
</li>
<li class="lvl-4">
<p>在检查参数值时。检查有效输入。</p>
</li>
</ul>
<h3 id="示例-1-2">示例 1</h3>
<p>此示例显示了使用错误消息处理断言。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">avg</span>(<span class="params">scores</span>):  </span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(scores) != <span class="number">0</span>,<span class="string">&quot;The List is empty.&quot;</span>  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(scores)/<span class="built_in">len</span>(scores)  </span><br><span class="line"></span><br><span class="line">scores2 = [<span class="number">67</span>,<span class="number">59</span>,<span class="number">86</span>,<span class="number">75</span>,<span class="number">92</span>]  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The Average of scores2:&quot;</span>,avg(scores2))  </span><br><span class="line"></span><br><span class="line">scores1 = []  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The Average of scores1:&quot;</span>,avg(scores1))  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The Average of scores2: <span class="number">75.8</span></span><br><span class="line">AssertionError: The <span class="type">List</span> <span class="keyword">is</span> empty.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:<strong>在上例中，我们将一个非空列表</strong>scores2</strong> 和一个空列表<strong>scores1</strong> 传递给了 <strong>avg()</strong> 函数。我们成功接收到<strong>scores2</strong> 列表的输出，但在此之后，我们收到一个错误<strong>评估错误:列表为空</strong>。断言条件由<strong>scores2</strong> 列表满足，并允许程序继续运行。但是，<strong>scores1</strong> 不满足条件，给出一个 AssertionError。</p>
<h3 id="示例-2-2">示例 2:</h3>
<p>此示例显示了控制台中的“Divide by 0 error”。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># initializing number   </span></span><br><span class="line">x = <span class="number">7</span>  </span><br><span class="line">y = <span class="number">0</span>  </span><br><span class="line"><span class="comment"># It uses assert to check for 0   </span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;x / y value is : &quot;</span>)   </span><br><span class="line"><span class="keyword">assert</span> y != <span class="number">0</span>, <span class="string">&quot;Divide by 0 error&quot;</span>  </span><br><span class="line"><span class="built_in">print</span> (x / y)   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<p>x / y 值为:</p>
<h3 id="运行时异常">运行时异常:</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):  </span><br><span class="line">  File <span class="string">&quot;main.py&quot;</span>, line <span class="number">6</span>, <span class="keyword">in</span> &lt;module&gt;  </span><br><span class="line">    <span class="keyword">assert</span> y != <span class="number">0</span>, <span class="string">&quot;Divide by 0 error&quot;</span>  </span><br><span class="line">AssertionError: Divide by <span class="number">0</span> error  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的例子中，我们已经初始化了一个整数变量，即 x=7，y=0，并尝试打印 x/y 的值作为输出。Python 解释器生成了一个运行时异常，因为 <code>assert</code>关键字发现除数为零，然后在控制台中显示 <strong>“Divide by 0 error误”</strong>。</p>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-assert-keyword">https://www.javatpoint.com/python-assert-keyword</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python `break`语句</title>
    <url>/posts/ea0bc080.html</url>
    <content><![CDATA[<h1>Python <code>break</code>语句</h1>
<p>break 是 python 中的一个关键字，用于将程序控制带出循环。<code>break</code>语句逐个中断循环，即在嵌套循环的情况下，它首先中断内部循环，然后继续到外部循环。换句话说，我们可以说 break 用于中止程序的当前执行，控制转到循环后的下一行。</p>
<p>中断通常用于我们需要为给定条件中断循环的情况。</p>
<p>中断的语法如下。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#loop statements</span></span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="例-1-7">例 1</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">4</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;item matched&quot;</span>)</span><br><span class="line">        count = count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;found at&quot;</span>,count,<span class="string">&quot;location&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">item matched</span><br><span class="line">found at <span class="number">2</span> location</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="例-2-5">例 2</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;python&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(i);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">p</span><br><span class="line">y</span><br><span class="line">t</span><br><span class="line">h</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="示例-3-使用-While循环break语句">示例 3:使用 <code>While</code>循环<code>break</code>语句</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(i,<span class="string">&quot; &quot;</span>,end=<span class="string">&quot;&quot;</span>),</span><br><span class="line">    i=i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;came out of while loop&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  came out of <span class="keyword">while</span> loop</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="例-3">例 3</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">n=<span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> i&lt;=<span class="number">10</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%d X %d = %d\n&quot;</span>%(n,i,n*i));</span><br><span class="line">        i = i+<span class="number">1</span>;</span><br><span class="line">    choice = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Do you want to continue printing the table, press 0 for no?&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> choice == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span>;    </span><br><span class="line">    n=n+<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> X <span class="number">1</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> X <span class="number">2</span> = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> X <span class="number">3</span> = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> X <span class="number">4</span> = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> X <span class="number">5</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> X <span class="number">6</span> = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> X <span class="number">7</span> = <span class="number">14</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> X <span class="number">8</span> = <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> X <span class="number">9</span> = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> X <span class="number">10</span> = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">Do you want to <span class="keyword">continue</span> printing the table, press <span class="number">0</span> <span class="keyword">for</span> no?<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> X <span class="number">1</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> X <span class="number">2</span> = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> X <span class="number">3</span> = <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> X <span class="number">4</span> = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> X <span class="number">5</span> = <span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> X <span class="number">6</span> = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> X <span class="number">7</span> = <span class="number">21</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> X <span class="number">8</span> = <span class="number">24</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> X <span class="number">9</span> = <span class="number">27</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> X <span class="number">10</span> = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">Do you want to <span class="keyword">continue</span> printing the table, press <span class="number">0</span> <span class="keyword">for</span> no?<span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-break">https://www.javatpoint.com/python-break</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python `collections`模块</title>
    <url>/posts/76d82c1f.html</url>
    <content><![CDATA[<h1>Python <code>collections</code>模块</h1>
<p>Python <code>collections</code>模块被定义为用于存储数据集合的容器，例如列表、字典、集合和元组等。引入它是为了改进内置收集容器的功能。</p>
<p>Python <code>collections</code>模块最早是在其 2.4 版本中引入的。</p>
<p>有以下不同类型的<code>collections</code>模块:</p>
<h2 id="namedtuple">namedtuple()</h2>
<p>Python <strong>namedtuple()</strong> 函数返回一个类似元组的对象，并为元组中的每个位置指定名称。它用于消除普通元组中记住元组对象的每个字段的索引的问题。</p>
<p><strong>示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pranshu = (<span class="string">&#x27;James&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;M&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(pranshu)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;James&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;M&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="OrderedDict">OrderedDict()</h2>
<p>Python OrderedDict()类似于字典对象，其中键保持插入顺序。如果我们再次尝试插入密钥，该密钥的前一个值将被覆盖。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> collections  </span><br><span class="line">d1=collections.OrderedDict()  </span><br><span class="line">d1[<span class="string">&#x27;A&#x27;</span>]=<span class="number">10</span>  </span><br><span class="line">d1[<span class="string">&#x27;C&#x27;</span>]=<span class="number">12</span>  </span><br><span class="line">d1[<span class="string">&#x27;B&#x27;</span>]=<span class="number">11</span>  </span><br><span class="line">d1[<span class="string">&#x27;D&#x27;</span>]=<span class="number">13</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> d1.items():  </span><br><span class="line">    <span class="built_in">print</span> (k,v)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">A <span class="number">10</span></span><br><span class="line">C <span class="number">12</span></span><br><span class="line">B <span class="number">11</span></span><br><span class="line">D <span class="number">13</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="defaultdict">defaultdict()</h2>
<p>Python defaultdict()被定义为类似字典的对象。它是内置 dict 类的子类。它提供字典提供的所有方法，但将第一个参数作为默认数据类型。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict    </span><br><span class="line">number = defaultdict(<span class="built_in">int</span>)    </span><br><span class="line">number[<span class="string">&#x27;one&#x27;</span>] = <span class="number">1</span>    </span><br><span class="line">number[<span class="string">&#x27;two&#x27;</span>] = <span class="number">2</span>    </span><br><span class="line"><span class="built_in">print</span>(number[<span class="string">&#x27;three&#x27;</span>])  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Counter">Counter()</h2>
<p>Python Counter是字典对象的一个子类，它有助于对哈希对象进行计数。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter    </span><br><span class="line">c = Counter()  </span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">10</span>]    </span><br><span class="line">Counter(<span class="built_in">list</span>)  </span><br><span class="line">Counter(&#123;<span class="number">1</span>:<span class="number">5</span>,<span class="number">2</span>:<span class="number">4</span>&#125;)    </span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">1</span>]    </span><br><span class="line">c = Counter(<span class="built_in">list</span>)    </span><br><span class="line"><span class="built_in">print</span>(c[<span class="number">1</span>])   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="deque">deque()</h2>
<p>Python <strong>deque()</strong> 是一个双端队列，允许我们从两端添加和移除元素。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque  </span><br><span class="line"><span class="built_in">list</span> = [<span class="string">&quot;x&quot;</span>,<span class="string">&quot;y&quot;</span>,<span class="string">&quot;z&quot;</span>]  </span><br><span class="line">deq = deque(<span class="built_in">list</span>)  </span><br><span class="line"><span class="built_in">print</span>(deq)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">deque([<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="ChainMap">ChainMap</h2>
<p>一个<strong>ChainMap</strong>类用于将多个字典组合在一起以创建一个列表。链接字典存储在列表中，并且是公共的，可以通过地图属性进行访问。考虑下面的例子。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> ChainMap</span><br><span class="line">baseline = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Peter&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="string">&#x27;14&#x27;</span>&#125;</span><br><span class="line">adjustments = &#123;<span class="string">&#x27;Age&#x27;</span>: <span class="string">&#x27;14&#x27;</span>, <span class="string">&#x27;Roll_no&#x27;</span>: <span class="string">&#x27;0012&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(ChainMap(adjustments, baseline)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Roll_no&#x27;</span> ]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="用户字典对象">用户字典对象</h2>
<p>用户字典充当字典对象的包装器。字典可以通过使用<strong>用户字典</strong>对象作为属性来访问。它使使用字典变得容易。</p>
<p>它提供以下属性。</p>
<p><strong>数据</strong> -一个用来存储 UserDict 类内容的真实字典。</p>
<h2 id="用户列表对象">用户列表对象</h2>
<p>用户列表表现为列表对象的包装类。当我们想要向列表添加新功能时，它非常有用。它使使用字典变得容易。</p>
<p>它提供以下属性。</p>
<p><strong>数据</strong> -真实列表用于存储 User 类的内容。</p>
<h2 id="UserString对象"><code>UserString</code>对象</h2>
<p><strong>用户列表</strong>表现为列表对象的包装类。字典可以通过使用**<code>UserString</code>**对象作为属性来访问。它使使用字典变得容易。</p>
<p>它提供以下属性。</p>
<p><strong>数据</strong> -一个真实的<strong>字符串</strong>对象用于存储<code>UserString</code>类的内容。</p>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-collection-module">https://www.javatpoint.com/python-collection-module</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python `continue`语句</title>
    <url>/posts/6f2b221c.html</url>
    <content><![CDATA[<h1>Python <code>continue</code>语句</h1>
<p>Python 中的 <code>continue</code>语句用于将程序控制带到循环的开始。<code>continue</code>语句跳过循环中剩余的代码行，并从下一次迭代开始。它主要用于循环中的特定条件，以便我们可以跳过特定条件的某些特定代码。Python 中的 <code>continue</code>语句用于将程序控制带到循环的开始。<code>continue</code>语句跳过循环中剩余的代码行，并从下一次迭代开始。它主要用于循环中的特定条件，以便我们可以跳过特定条件的某些特定代码。</p>
<h3 id="句法-6">句法</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#loop statements  </span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="comment">#the code to be skipped   </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="流程图">流程图</h3>
<p><img src="/img/e71573a4080d25e950bab5a4a05a5a91.png" alt="Python continue Statement"></p>
<p>考虑下面的例子。</p>
<h3 id="例-1-8">例 1</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span>                   </span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">10</span>):              </span><br><span class="line">   i = i+<span class="number">1</span></span><br><span class="line">   <span class="keyword">if</span>(i == <span class="number">5</span>):</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">   <span class="built_in">print</span>(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>观察上述代码的输出，值 5 被跳过，因为我们在 <code>While</code>循环中提供了使用 <strong><code>continue</code>语句</strong>的 <strong>if 条件</strong>。当它与给定的条件匹配时，控制转移到 <code>While</code>循环的开始，并跳过代码中的值 5。</p>
<p>让我们看另一个例子:</p>
<h3 id="例-2-6">例 2</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;JavaTpoint&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="string">&#x27;T&#x27;</span>):</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">J</span><br><span class="line">a</span><br><span class="line">v</span><br><span class="line">a</span><br><span class="line">p</span><br><span class="line">o</span><br><span class="line">i</span><br><span class="line">n</span><br><span class="line">t</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="通过声明">通过声明</h2>
<p><code>pass</code>语句是一个空操作，因为当它被执行时什么都不会发生。它用于在语法上需要一条语句，但我们不想在它的位置使用任何可执行语句的情况。</p>
<p>例如，它可以在子类中重写父类方法时使用，但不想在子类中给出它的具体实现。</p>
<p>Pass 也用于代码将被写入某处但尚未写入程序文件的地方。考虑下面的例子。</p>
<h3 id="例子-37">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]  </span><br><span class="line">flag = <span class="number">0</span>  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Current element:&quot;</span>,i,end=<span class="string">&quot; &quot;</span>);  </span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">3</span>:  </span><br><span class="line">        <span class="keyword">pass</span>  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\nWe are inside pass block\n&quot;</span>);  </span><br><span class="line">        flag = <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">if</span> flag==<span class="number">1</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\nCame out of pass\n&quot;</span>);  </span><br><span class="line">        flag=<span class="number">0</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Current element: <span class="number">1</span> Current element: <span class="number">2</span> Current element: <span class="number">3</span> </span><br><span class="line">We are inside <span class="keyword">pass</span> block</span><br><span class="line"></span><br><span class="line">Came out of <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">Current element: <span class="number">4</span> Current element: <span class="number">5</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们将在下一个教程中了解有关 <code>pass</code>语句的更多信息。</p>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-continue">https://www.javatpoint.com/python-continue</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python `for`循环</title>
    <url>/posts/a8e29766.html</url>
    <content><![CDATA[<h1>Python <code>for</code>循环</h1>
<p>Python 中的 for <strong>循环</strong>用于多次迭代语句或程序的一部分。它经常用于遍历数据结构，如列表、元组或字典。</p>
<p>下面给出了 python 中 <code>for</code>循环的语法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> iterating_var <span class="keyword">in</span> sequence:  </span><br><span class="line">    statement(s)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="for循环流程图"><code>for</code>循环流程图</h3>
<p><img src="/img/ee800e9141cde35a9a5db492f878e2b5.png" alt="Python for loop"></p>
<h3 id="对于使用序列的循环">对于使用序列的循环</h3>
<p><strong>示例-1:迭代用于循环的字符串</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;Python&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">P</span><br><span class="line">y</span><br><span class="line">t</span><br><span class="line">h</span><br><span class="line">o</span><br><span class="line">n</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例- 2:打印给定编号表格的程序。</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">n = <span class="number">5</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">    c = n*i</span><br><span class="line">    <span class="built_in">print</span>(c)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">35</span></span><br><span class="line"><span class="number">40</span></span><br><span class="line"><span class="number">45</span></span><br><span class="line">50s</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例-4:打印给定列表总和的程序。</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">10</span>,<span class="number">30</span>,<span class="number">23</span>,<span class="number">43</span>,<span class="number">65</span>,<span class="number">12</span>]</span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">    <span class="built_in">sum</span> = <span class="built_in">sum</span>+i</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The sum is:&quot;</span>,<span class="built_in">sum</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The <span class="built_in">sum</span> <span class="keyword">is</span>: <span class="number">183</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="对于使用范围-函数的循环">对于使用范围()函数的循环</h3>
<p><strong>范围()功能</strong></p>
<p>**范围()**功能用于生成数字序列。如果我们通过范围(10)，它将生成从 0 到 9 的数字。range()函数的语法如下。</p>
<p><strong>语法:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">range</span>(start,stop,step size)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p>开始代表迭代的开始。</p>
</li>
<li class="lvl-4">
<p>stop 表示循环将迭代到 stop-1。<strong>范围(1，5)</strong> 将生成 1 到 4 次迭代。它是可选的。</p>
</li>
<li class="lvl-4">
<p>步长用于跳过迭代中的特定数字。可以选择使用。默认情况下，步长为 1。它是可选的。</p>
</li>
</ul>
<p>请考虑以下示例:</p>
<p><strong>示例-1:按顺序打印数字的程序。</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(i,end = <span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例- 2:打印给定编号表格的程序。</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the number &quot;</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">    c = n*i</span><br><span class="line">    <span class="built_in">print</span>(n,<span class="string">&quot;*&quot;</span>,i,<span class="string">&quot;=&quot;</span>,c)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the number <span class="number">10</span></span><br><span class="line"><span class="number">10</span> * <span class="number">1</span> = <span class="number">10</span></span><br><span class="line"><span class="number">10</span> * <span class="number">2</span> = <span class="number">20</span></span><br><span class="line"><span class="number">10</span> * <span class="number">3</span> = <span class="number">30</span></span><br><span class="line"><span class="number">10</span> * <span class="number">4</span> = <span class="number">40</span></span><br><span class="line"><span class="number">10</span> * <span class="number">5</span> = <span class="number">50</span></span><br><span class="line"><span class="number">10</span> * <span class="number">6</span> = <span class="number">60</span></span><br><span class="line"><span class="number">10</span> * <span class="number">7</span> = <span class="number">70</span></span><br><span class="line"><span class="number">10</span> * <span class="number">8</span> = <span class="number">80</span></span><br><span class="line"><span class="number">10</span> * <span class="number">9</span> = <span class="number">90</span></span><br><span class="line"><span class="number">10</span> * <span class="number">10</span> = <span class="number">100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例-3:使用步长范围()打印偶数的程序。</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the number &quot;</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n,<span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the number <span class="number">20</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们也可以使用带有数字序列的 <strong>range()</strong> 函数。 <strong>len()</strong> 函数与 range()函数相结合，后者使用索引遍历序列。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;Peter&#x27;</span>,<span class="string">&#x27;Joseph&#x27;</span>,<span class="string">&#x27;Ricky&#x27;</span>,<span class="string">&#x27;Devansh&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">list</span>)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>,<span class="built_in">list</span>[i])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Hello Peter</span><br><span class="line">Hello Joseph</span><br><span class="line">Hello Ricky</span><br><span class="line">Hello Devansh</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="python-中的嵌套-for循环">python 中的嵌套 <code>for</code>循环</h2>
<p>Python 允许我们将任意数量的 <code>for</code>循环嵌套在 <strong>for</strong> 循环中。对于外部循环的每次迭代，内部循环被执行 n 次。语法如下。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> iterating_var1 <span class="keyword">in</span> sequence:  <span class="comment">#outer loop</span></span><br><span class="line">    <span class="keyword">for</span> iterating_var2 <span class="keyword">in</span> sequence:  <span class="comment">#inner loop</span></span><br><span class="line">        <span class="comment">#block of statements   </span></span><br><span class="line"><span class="comment">#Other statements  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="示例-1-循环嵌套">示例- 1:循环嵌套</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># User input for number of rows</span></span><br><span class="line">rows = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the rows:&quot;</span>))</span><br><span class="line"><span class="comment"># Outer loop will print number of rows</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,rows+<span class="number">1</span>):</span><br><span class="line"><span class="comment"># Inner loop will print number of Astrisk</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>,end = <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the rows:<span class="number">5</span></span><br><span class="line">*</span><br><span class="line">**</span><br><span class="line">***</span><br><span class="line">****</span><br><span class="line">*****</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="示例-2-数字金字塔程序。">示例-2:数字金字塔程序。</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">rows = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the rows&quot;</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,rows+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">        <span class="built_in">print</span>(i,end = <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">333</span></span><br><span class="line"><span class="number">4444</span></span><br><span class="line"><span class="number">55555</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="将-else-语句与-for循环一起使用">将 else 语句与 <code>for</code>循环一起使用</h2>
<p>与 C、C++或 Java 等其他语言不同，Python 允许我们将 else 语句与 <code>for</code>循环一起使用，该循环只能在所有迭代都用尽时执行。这里，我们必须注意到，如果循环包含任何 <code>break</code>语句，那么 else 语句将不会被执行。</p>
<h2 id="例-1-9">例 1</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">5</span>):  </span><br><span class="line">    <span class="built_in">print</span>(i)  </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;for loop completely exhausted, since there is no break.&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="keyword">for</span> loop completely exhausted, since there <span class="keyword">is</span> no <span class="keyword">break</span>.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>for</code>循环完全耗尽，因为没有中断。</p>
<h2 id="例-2-7">例 2</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">5</span>):  </span><br><span class="line">    <span class="built_in">print</span>(i)  </span><br><span class="line">    <span class="keyword">break</span>;  </span><br><span class="line"><span class="keyword">else</span>:<span class="built_in">print</span>(<span class="string">&quot;for loop is exhausted&quot;</span>);  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The loop is broken due to break statement...came out of the loop&quot;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，循环由于 <code>break</code>语句而中断；因此，else 语句不会被执行。将执行紧挨着 else 块的语句。</p>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于 <code>break</code>语句，循环中断…脱离了循环。我们将在下一个教程中了解更多关于 <code>break</code>语句的信息。</p>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-for-loop">https://www.javatpoint.com/python-for-loop</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python `itertools`</title>
    <url>/posts/95d69c19.html</url>
    <content><![CDATA[<h1>Python <code>itertools</code></h1>
<p>Itertool 是最令人惊叹的 Python 3 标准库之一。这个库有非常酷的功能，可以说它是 Python 编程语言的瑰宝。Python 提供了 itertools 的优秀文档，但是在本教程中，我们将讨论几个重要且有用的 itertools 函数或迭代器。</p>
<p>itertools 的关键之处在于，这个库的功能用于生成内存高效且精确的代码。</p>
<p>在学习 Python itertools 之前，您应该了解 Python 迭代器和生成器。在本文中，我们将描述面向初学者和专业人士的 itertools。</p>
<h2 id="介绍">介绍</h2>
<p>根据 itertools 的官方定义，“<strong>这个模块实现了许多迭代器构建块，灵感来自 APL、Haskell 和 SML</strong> ”简而言之，迭代器的数量可以一起创建“迭代器代数”，这使得完成复杂的任务成为可能。itertools 中的函数用于生成更复杂的迭代器。让我们举个例子: <a href="https://www.javatpoint.com/python-zip-function">Python 内置的 zip()函数</a>接受任意数量的可迭代参数。它迭代元组并返回它们对应的元素。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b= [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">c = <span class="built_in">zip</span>(a,b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们传递了两个列表[1，2，3]和[‘a ‘，’ b ‘，’ c’]作为可在 <strong>zip()</strong> 函数<strong>中迭代的列表。<strong>这些列表一次返回一个元素。在 <a href="https://www.javatpoint.com/python-tutorial">Python</a> 中，实现</strong>的元素。<strong>iter</strong>()</strong> 或**。<strong>getitem</strong>()** 方法称为 iterable。</p>
<p><a href="https://www.javatpoint.com/python-iter-function">Python iter()函数</a>用于调用 iterable 并返回 iterable 的迭代器对象。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a = <span class="built_in">iter</span>(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;str_iterator <span class="built_in">object</span> at <span class="number">0x01505FA0</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://www.javatpoint.com/python-zip-function">Python zip()函数</a>在其每个参数上调用 <strong>iter()</strong> ，然后通过将结果组合成元组来调用 <strong>next()</strong> 。</p>
<h4 id="注意-如果您正在使用-zip-函数和-map-函数，这意味着您已经在使用-itertools。你不需要清楚地导入它。">注意:如果您正在使用 zip()函数和 map()函数，这意味着您已经在使用 itertools。你不需要清楚地导入它。</h4>
<h2 id="迭代器的类型">迭代器的类型</h2>
<p>itertools 模块中有各种类型的迭代器。清单如下:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>无限迭代器</p>
</li>
<li class="lvl-4">
<p>组合迭代器</p>
</li>
<li class="lvl-4">
<p>终止迭代器</p>
</li>
</ul>
<h3 id="无限迭代器">无限迭代器</h3>
<p>在 Python 中，任何可以为循环实现<strong>的对象都被称为迭代器。列表、元组、集合、字典、字符串是迭代器的例子，但是迭代器也可以是无限的，这种类型的迭代器被称为</strong>无限迭代器**。**</p>
<p><img src="/img/WX20230718-171737@2x.png" alt="无限迭代器"></p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>count(start, stop)</strong>:从开始值打印到无穷大。步骤参数是可选的，如果该值被提供给<strong>step</strong>，那么步数将被跳过。考虑以下示例:</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.count(<span class="number">10</span>,<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">50</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(i,end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">15</span> <span class="number">20</span> <span class="number">25</span> <span class="number">30</span> <span class="number">35</span> <span class="number">40</span> <span class="number">45</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>cycle(iterable):</strong>:这个迭代器从传递的参数开始按顺序打印所有值。它以循环方式打印值。考虑以下示例:</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">temp = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.cycle(<span class="string">&quot;123&quot;</span>):</span><br><span class="line">    <span class="keyword">if</span> temp &gt; <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(i,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        temp = temp+<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例- 2:使用 next()功能</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">val = [<span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;Point&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">iter</span> = itertools.cycle(val)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    <span class="comment"># Using next function</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(<span class="built_in">iter</span>), end = <span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Java T Point Java T Point</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>repeat(val,num)</strong> :顾名思义，它无限次重复打印传递的值。 <strong>num</strong> 参数是可选的。考虑以下示例:</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Printing the number repeadtly:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(itertools.repeat(<span class="number">40</span>,<span class="number">15</span>)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>**组合迭代器:**复杂的组合构造被递归生成器简化。排列、组合和笛卡尔乘积是组合构造的例子。</p>
<p>在 Python 中，有四种组合迭代器:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Product() -</strong> 用于计算可迭代输入的笛卡尔乘积。在这个函数中，我们使用可选的 <strong>repeat</strong> 关键字参数来计算可迭代函数与其自身的乘积。<strong>重复</strong>关键词代表重复次数。它以排序元组的形式返回输出。考虑以下示例:</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;We are computing cartesian product using repeat Keyword Argument:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(product([<span class="number">1</span>, <span class="number">2</span>], repeat=<span class="number">2</span>)))</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;We are computing cartesian product of the containers:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(product([<span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;point&#x27;</span>], <span class="string">&#x27;5&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;We are computing product of the containers:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(product(<span class="string">&#x27;CD&#x27;</span>, [<span class="number">4</span>, <span class="number">5</span>])))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Computing cartesian product using repeat Keyword Argument:</span><br><span class="line">[(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>)]</span><br><span class="line"></span><br><span class="line">Computing cartesian product of the containers:</span><br><span class="line">[(<span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;5&#x27;</span>), (<span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;5&#x27;</span>), (<span class="string">&#x27;point&#x27;</span>, <span class="string">&#x27;5&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">Computing product of the containers:</span><br><span class="line">[(<span class="string">&#x27;C&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;C&#x27;</span>, <span class="number">5</span>), (<span class="string">&#x27;D&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;D&#x27;</span>, <span class="number">5</span>)] </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Permutations()</strong>:用于生成可迭代表的所有可能的置换。每个元素的唯一性取决于它们的位置而不是值。它接受两个论点<strong>可重复</strong>和<strong>group_size</strong>。如果 group_size 的值为 <strong>none</strong> 或未指定，那么 group_size 将转换为可迭代的长度。</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Computing all permutation of the following list&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(permutations([<span class="number">3</span>,<span class="string">&quot;Python&quot;</span>],<span class="number">2</span>)))</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Permutations of following string&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(permutations(<span class="string">&#x27;AB&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Permutation of the given container is:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(permutations(<span class="built_in">range</span>(<span class="number">4</span>),<span class="number">2</span>)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Computing <span class="built_in">all</span> permutation of the following <span class="built_in">list</span></span><br><span class="line">[(<span class="number">3</span>, <span class="string">&#x27;Python&#x27;</span>), (<span class="string">&#x27;Python&#x27;</span>, <span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line">Permutations of following string</span><br><span class="line">[(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>), (<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;A&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">Permutation of the given container <span class="keyword">is</span>:</span><br><span class="line">[(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">2</span>), (<span class="number">0</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">0</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">0</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">2</span>)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Combinations()</strong>:用于按排序顺序打印指定组大小中作为参数传递的容器的所有可能组合(不替换)。</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Combination of list in sorted order(without replacement)&quot;</span>,<span class="built_in">list</span>(combinations([<span class="string">&#x27;B&#x27;</span>,<span class="number">3</span>],<span class="number">2</span>)))</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Combination of string in sorted order&quot;</span>,<span class="built_in">list</span>(combinations(<span class="string">&quot;ZX&quot;</span>,<span class="number">2</span>)))</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Combination of list in sorted order&quot;</span>,<span class="built_in">list</span>(combinations(<span class="built_in">range</span>(<span class="number">20</span>),<span class="number">1</span>)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Combination of <span class="built_in">list</span> <span class="keyword">in</span> <span class="built_in">sorted</span> order(without replacement) [(<span class="string">&#x27;B&#x27;</span>, <span class="number">3</span>)]</span><br><span class="line">Combination of string <span class="keyword">in</span> <span class="built_in">sorted</span> order [(<span class="string">&#x27;Z&#x27;</span>, <span class="string">&#x27;X&#x27;</span>)]</span><br><span class="line">Combination of <span class="built_in">list</span> <span class="keyword">in</span> <span class="built_in">sorted</span> order [(<span class="number">0</span>,), (<span class="number">1</span>,), (<span class="number">2</span>,), (<span class="number">3</span>,), (<span class="number">4</span>,), (<span class="number">5</span>,), (<span class="number">6</span>,), (<span class="number">7</span>,), (<span class="number">8</span>,), (<span class="number">9</span>,)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Combination_with_replacement()</strong>:它接受两个参数，第一个参数是 r 长度的元组，第二个参数是 repeat。它从可迭代的元素中返回长度为 n 的子序列，并重复相同的过程。单独的元素可以在<strong>组合中重复出现</strong></p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations_with_replacement</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Combination of string in sorted order(with replacement) is:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(combinations_with_replacement(<span class="string">&quot;XY&quot;</span>, <span class="number">3</span>)))</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Combination of list in sorted order(with replacement) is:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(combinations_with_replacement([<span class="number">4</span>, <span class="number">2</span>], <span class="number">3</span>)))</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Combination of container in sorted order(with replacement) is:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(combinations_with_replacement(<span class="built_in">range</span>(<span class="number">3</span>), <span class="number">2</span>)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Combination of string <span class="keyword">in</span> <span class="built_in">sorted</span> order(<span class="keyword">with</span> replacement) <span class="keyword">is</span>:</span><br><span class="line">[(<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;X&#x27;</span>), (<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>), (<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>), (<span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">Combination of <span class="built_in">list</span> <span class="keyword">in</span> <span class="built_in">sorted</span> order(<span class="keyword">with</span> replacement) <span class="keyword">is</span>:</span><br><span class="line">[(<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>), (<span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>), (<span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>)]</span><br><span class="line"></span><br><span class="line">Combination of container <span class="keyword">in</span> <span class="built_in">sorted</span> order(<span class="keyword">with</span> replacement) <span class="keyword">is</span>:</span><br><span class="line">[(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">2</span>)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="终止迭代器">终止迭代器</h3>
<p>终结迭代器通常用于处理小的输入序列，并根据迭代器中使用的方法的功能生成输出。</p>
<p>有不同类型的终止迭代器:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>accumulate(iter, func)</strong> :它需要两个参数，第一个参数是可迭代的，第二个参数是一个函数，在每次迭代可迭代的值时都会遵循这个函数。如果函数没有在**累加()**迭代器中定义，默认情况下会发生加法。输出变量取决于输入变量；如果输入 iterable 不包含任何值，则输出 iterable 也将为空。</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line"><span class="comment"># initializing list 1</span></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># using accumulate() that will prints the successive summation of elements</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The sum is : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(itertools.accumulate(list1)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># using accumulate() that will prints the successive multiplication of elements</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The product is : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(itertools.accumulate(list1, operator.mul)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># using accumulate() that will prints the successive summation of elements</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The sum is : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(itertools.accumulate(list1)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># using accumulate() that will prints the successive multiplication of elements</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The product is : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(itertools.accumulate(list1, operator.mul)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The <span class="built_in">sum</span> <span class="keyword">is</span> : [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">17</span>, <span class="number">26</span>, <span class="number">37</span>]</span><br><span class="line">The product <span class="keyword">is</span> : [<span class="number">1</span>, <span class="number">4</span>, <span class="number">20</span>, <span class="number">140</span>, <span class="number">1260</span>, <span class="number">13860</span>]</span><br><span class="line">The <span class="built_in">sum</span> <span class="keyword">is</span> : [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">17</span>, <span class="number">26</span>, <span class="number">37</span>]</span><br><span class="line">The product <span class="keyword">is</span> : [<span class="number">1</span>, <span class="number">4</span>, <span class="number">20</span>, <span class="number">140</span>, <span class="number">1260</span>, <span class="number">13860</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>chain(iter1，iter2)</strong> -用于打印 iterable 中以 chain 形式传递并在参数中声明的所有值。考虑以下示例:</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># declaring list 1</span></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># declaring list 2</span></span><br><span class="line">list2 = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># declaring list 3</span></span><br><span class="line">list3 = [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># using chain() function that will to print all elements of lists</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The output is : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(itertools.chain(list1, list2, list3)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The output <span class="keyword">is</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>dropwhile(func，seq)</strong> -仅在 <strong>func</strong> 之后开始打印字符。考虑以下论点:</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="comment"># initializing list</span></span><br><span class="line">list1 = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="comment"># using dropwhile() iterator that will print start displaying after condition is false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The output is : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(itertools.dropwhile(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, list1)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The output <span class="keyword">is</span>  : [<span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>filterfalse(func，seq)</strong> -我们可以通过它的名称来假设它，因为这个迭代器只打印那些为传递的函数返回 false 的值。考虑以下示例:</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># declaring list</span></span><br><span class="line">list1 = [<span class="number">12</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">27</span>, <span class="number">28</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># using filterfalse() iterator that will print false values</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The Output is: &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(itertools.filterfalse(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, list1)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The Output <span class="keyword">is</span> : [<span class="number">15</span>, <span class="number">27</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>islice(iterable,start,stop,step)</strong> -它根据给定的位置对给定的可重复进行切片。它分别接受四个参数，它们是可迭代的、容器的、起始位置的。，结束位置和步骤(可选)。</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="comment"># Declaring list</span></span><br><span class="line">list1 = [<span class="number">12</span>, <span class="number">34</span>, <span class="number">65</span>, <span class="number">73</span>, <span class="number">80</span>, <span class="number">19</span>, <span class="number">20</span>]</span><br><span class="line"><span class="comment"># using islice() iterator that will slice the list acc. to given argument</span></span><br><span class="line"><span class="comment"># starts printing from 3nd index till 8th skipping 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The sliced list values are : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(itertools.islice(list1, <span class="number">2</span>, <span class="number">8</span>, <span class="number">2</span>)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The sliced <span class="built_in">list</span> values are : [<span class="number">34</span>, <span class="number">73</span>, <span class="number">19</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>starmap(func, tuple list)</strong> -需要两个参数；第一个参数是函数，第二个参数是由元组形式的元素组成的列表。考虑下面的例子。</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># Declaring list that contain tuple as element</span></span><br><span class="line">list1 = [(<span class="number">10</span>, <span class="number">20</span>, <span class="number">15</span>), (<span class="number">18</span>, <span class="number">40</span>, <span class="number">19</span>), (<span class="number">53</span>, <span class="number">42</span>, <span class="number">90</span>), (<span class="number">16</span>, <span class="number">12</span>, <span class="number">27</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># using starmap() iterator for selection value acc. to function</span></span><br><span class="line"><span class="comment"># selects max of all tuple values</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The values acc. to function are : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(itertools.starmap(<span class="built_in">max</span>, list1)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The values acc. to function are : [<span class="number">20</span>, <span class="number">40</span>, <span class="number">90</span>, <span class="number">27</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>takewhile(func，iterable)</strong> -这是 **dropwhile()的反方向。**将打印数值，直到返回假状态。考虑以下示例:</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># Defining a list</span></span><br><span class="line">list1 = [<span class="number">20</span>, <span class="number">42</span>, <span class="number">64</span>, <span class="number">77</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># takewhile() iterator is used  to print values till condition return false.</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Print until 1st false value returned : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(itertools.takewhile(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, list1)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The <span class="built_in">list</span> values until false value <span class="keyword">return</span> : [<span class="number">20</span>, <span class="number">42</span>, <span class="number">64</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>tee(iterator, count)</strong> -它将容器分成多个迭代器，这些迭代器在参数中定义。考虑以下示例:</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># Declaring list</span></span><br><span class="line">li = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># storing list in iterator</span></span><br><span class="line">iti = <span class="built_in">iter</span>(li)</span><br><span class="line"><span class="comment"># using tee() iterator to create a list of iterators</span></span><br><span class="line"><span class="comment"># Creating list of 3 iterators having similar values.</span></span><br><span class="line">it = itertools.tee(iti, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># It will print object of iterator</span></span><br><span class="line"><span class="built_in">print</span>(it)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The iterators are : &quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">list</span>(it[i]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(&lt;itertools._tee <span class="built_in">object</span> at <span class="number">0x01B88D88</span>&gt;, &lt;itertools._tee <span class="built_in">object</span> at <span class="number">0x01B88DA8</span>&gt;, &lt;itertools._tee <span class="built_in">object</span> at <span class="number">0x01B88BA8</span>&gt;)</span><br><span class="line">The iterators are : </span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>zip_longest(iterable1, iterable2, fillval)</strong> -它按顺序交替打印 iterable 的值。如果其中一个可重复打印所有值，剩余的值将由分配给填充值的值填充。</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; The combined value of iterrables is :&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(*(itertools.zip_longest(<span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;Tpoint&#x27;</span>, fillvalue=<span class="string">&#x27;_&#x27;</span>)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The combined value of iterables <span class="keyword">is</span> :</span><br><span class="line">(<span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;T&#x27;</span>) (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;p&#x27;</span>) (<span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;o&#x27;</span>) (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;i&#x27;</span>) (<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;n&#x27;</span>) (<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;t&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在本教程中，我们讨论了几个有用的迭代器和 itertools。</p>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-itertools">https://www.javatpoint.com/python-itertools</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python `os`模块</title>
    <url>/posts/57598349.html</url>
    <content><![CDATA[<h1>Python <code>os</code>模块</h1>
<p>Python <code>os</code>模块提供了在用户和操作系统之间建立交互的工具。它提供了许多有用的操作系统功能，用于执行基于操作系统的任务和获取操作系统的相关信息。</p>
<p>该操作系统属于 Python 的标准实用程序模块。该模块提供了一种使用操作系统相关功能的可移植方式。</p>
<p>Python <code>os</code>模块允许我们处理文件和目录。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">To work <span class="keyword">with</span> the OS module, we need to <span class="keyword">import</span> the OS module.</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>os</code>模块中有一些功能如下:</p>
<h2 id="os-name（）"><a href="http://os.name">os.name</a>（）</h2>
<p>此函数提供它导入的<code>os</code>模块的名称。</p>
<p>目前，它注册了’ posix ‘，’ nt ‘，’ os2 ‘，’ ce ‘，’ java ‘和’ riscos '。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="built_in">print</span>(os.name) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">nt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="os-mkdir">os.mkdir()</h2>
<p><strong>os.mkdir()</strong> 功能用于新建目录。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.mkdir(<span class="string">&quot;d:\\newdir&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它将在名为 newdir 的 D 驱动器中创建函数字符串参数路径的新目录。</p>
<h2 id="os-getcwd">os . getcwd()</h2>
<p>它返回文件的当前工作目录(CWD)。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os   </span><br><span class="line"><span class="built_in">print</span>(os.getcwd())   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">C:\Users\Python\Desktop\ModuleOS</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="if-chdir（）">if.chdir（）</h2>
<p><strong>os</strong> 模块提供 <strong>chdir()</strong> 功能，用于更改当前工作目录。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.chdir(<span class="string">&quot;d:\\&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">d:\\</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="OS-rmr">OS . rmr()</h2>
<p><strong>rmdir()</strong> 函数删除具有绝对或相关路径的指定目录。首先，我们必须更改当前的工作目录并删除文件夹。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># It will throw a Permission error; that&#x27;s why we have to change the current working directory.</span></span><br><span class="line">os.rmdir(<span class="string">&quot;d:\\newdir&quot;</span>)</span><br><span class="line">os.chdir(<span class="string">&quot;..&quot;</span>)</span><br><span class="line">os.rmdir(<span class="string">&quot;newdir&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="os-error">os.error()</h2>
<p>函数的作用是:定义操作系统级错误。在文件名和路径无效或不可访问的情况下，它会引发错误。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># If file does not exist,</span></span><br><span class="line">    <span class="comment"># then it throw an IOError</span></span><br><span class="line">    filename = <span class="string">&#x27;Python.txt&#x27;</span></span><br><span class="line">    f = <span class="built_in">open</span>(filename, <span class="string">&#x27;rU&#x27;</span>)</span><br><span class="line">    text = f.read()</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># The Control jumps directly to here if</span></span><br><span class="line"><span class="comment"># any lines throws IOError.</span></span><br><span class="line"><span class="keyword">except</span> IOError:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(os.error) will &lt;class &#x27;OSError&#x27;&gt;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Problem reading: &#x27;</span> + filename)   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Problem reading: Python.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="os-popen">os.popen()</h2>
<p>此函数打开一个文件或从指定的命令，它返回一个连接到管道的文件对象。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os   </span><br><span class="line">fd = <span class="string">&quot;python.txt&quot;</span>    </span><br><span class="line"></span><br><span class="line"><span class="comment"># popen() is similar to open()   </span></span><br><span class="line">file = <span class="built_in">open</span>(fd, <span class="string">&#x27;w&#x27;</span>)   </span><br><span class="line">file.write(<span class="string">&quot;This is awesome&quot;</span>)   </span><br><span class="line">file.close()   </span><br><span class="line">file = <span class="built_in">open</span>(fd, <span class="string">&#x27;r&#x27;</span>)   </span><br><span class="line">text = file.read()   </span><br><span class="line"><span class="built_in">print</span>(text)   </span><br><span class="line"></span><br><span class="line"><span class="comment"># popen() provides gateway and accesses the file directly   </span></span><br><span class="line">file = os.popen(fd, <span class="string">&#x27;w&#x27;</span>)   </span><br><span class="line">file.write(<span class="string">&quot;This is awesome&quot;</span>)   </span><br><span class="line"><span class="comment"># File not closed, shown in next function.    </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">This <span class="keyword">is</span> awesome</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="os-close">os.close()</h2>
<p>该功能关闭描述符为 <strong>fr</strong> 的关联文件。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os   </span><br><span class="line">fr = <span class="string">&quot;Python1.txt&quot;</span>  </span><br><span class="line">file = <span class="built_in">open</span>(fr, <span class="string">&#x27;r&#x27;</span>)   </span><br><span class="line">text = file.read()   </span><br><span class="line"><span class="built_in">print</span>(text)   </span><br><span class="line">os.close(file)     </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;main.py&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> </span><br><span class="line">    file = <span class="built_in">open</span>(fr, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">FileNotFoundError: [Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">&#x27;Python1.txt&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="os-rename">os.rename()</h2>
<p>可以使用 <strong>os.rename()</strong> 函数重命名文件或目录。如果用户有权更改文件，则可以重命名该文件。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os   </span><br><span class="line">fd = <span class="string">&quot;python.txt&quot;</span>  </span><br><span class="line">os.rename(fd,<span class="string">&#x27;Python1.txt&#x27;</span>)   </span><br><span class="line">os.rename(fd,<span class="string">&#x27;Python1.txt&#x27;</span>)   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;main.py&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> </span><br><span class="line">    os.rename(fd,<span class="string">&#x27;Python1.txt&#x27;</span>)</span><br><span class="line">FileNotFoundError: [Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">&#x27;python.txt&#x27;</span> -&gt; <span class="string">&#x27;Python1.txt&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="os-access">os.access()</h2>
<p>该函数使用真实的 <strong>uid/gid</strong> 来测试调用用户是否可以访问路径。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os   </span><br><span class="line"><span class="keyword">import</span> sys  </span><br><span class="line"></span><br><span class="line">path1 = os.access(<span class="string">&quot;Python.txt&quot;</span>, os.F_OK)   </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Exist path:&quot;</span>, path1)   </span><br><span class="line"></span><br><span class="line"><span class="comment"># Checking access with os.R_OK   </span></span><br><span class="line">path2 = os.access(<span class="string">&quot;Python.txt&quot;</span>, os.R_OK)   </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;It access to read the file:&quot;</span>, path2)   </span><br><span class="line"></span><br><span class="line"><span class="comment"># Checking access with os.W_OK   </span></span><br><span class="line">path3 = os.access(<span class="string">&quot;Python.txt&quot;</span>, os.W_OK)   </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;It access to write the file:&quot;</span>, path3)   </span><br><span class="line"></span><br><span class="line"><span class="comment"># Checking access with os.X_OK   </span></span><br><span class="line">path4 = os.access(<span class="string">&quot;Python.txt&quot;</span>, os.X_OK)   </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Check if path can be executed:&quot;</span>, path4)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Exist path: <span class="literal">False</span></span><br><span class="line">It access to read the file: <span class="literal">False</span></span><br><span class="line">It access to write the file: <span class="literal">False</span></span><br><span class="line">Check <span class="keyword">if</span> path can be executed: <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-os-module">https://www.javatpoint.com/python-os-module</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python `math`模块</title>
    <url>/posts/d2b971a6.html</url>
    <content><![CDATA[<h1>Python <code>math</code>模块</h1>
<p>Python <code>math</code>模块被定义为最著名的数学函数，包括三角函数、表示函数、对数函数等。此外，它还定义了两个数学常数，即派和欧拉数等。</p>
<p><strong>Pie (n):</strong> 它是一个众所周知的数学常数，定义为环境与圆直径之比。它的值是 3.141592653589793。</p>
<p><strong>欧拉数(e):</strong> 定义为自然对数的底数，其值为 2.718282849045</p>
<p>下面给出了不同的<code>math</code>模块:</p>
<h3 id="math-log">math.log()</h3>
<p>此方法返回给定数字的自然对数。它是按照基数 e 计算的。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> math  </span><br><span class="line">number = <span class="number">2e-7</span>  <span class="comment"># small value of of x  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;log(fabs(x), base) is :&#x27;</span>, math.log(math.fabs(number), <span class="number">10</span>))  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">log(fabs(x), base) <span class="keyword">is</span> : -<span class="number">6.698970004336019</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&lt;</p>
<h3 id="math-log10">math.log10()</h3>
<p>此方法返回给定数字的以 10 为底的对数，称为标准对数。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> math  </span><br><span class="line">x=<span class="number">13</span>  <span class="comment"># small value of of x  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;log10(x) is :&#x27;</span>, math.log10(x))  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">log10(x) <span class="keyword">is</span> : <span class="number">1.1139433523068367</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="math-exp">math.exp()</h3>
<p>此方法在将 e 提升到给定数字后返回一个浮点数。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> math  </span><br><span class="line">number = <span class="number">5e-2</span>  <span class="comment"># small value of of x  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The given number (x) is :&#x27;</span>, number)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;e^x (using exp() function) is :&#x27;</span>, math.exp(number)-<span class="number">1</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The given number (x) <span class="keyword">is</span> : <span class="number">0.05</span></span><br><span class="line">e^x (using exp() function) <span class="keyword">is</span> : <span class="number">0.05127109637602412</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="math-pow-x，y">math.pow(x，y)</h3>
<p>此方法返回 x 的幂对应于 y 的值。如果 x 的值为负值或 y 不是整数值，则会引发值错误。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">number = math.<span class="built_in">pow</span>(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The power of number:&quot;</span>,number)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The power of number: <span class="number">100.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="math-floor-x">math.floor(x)</h3>
<p>此方法返回 x 的底值。它返回小于或等于 x 的值</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">number = math.floor(<span class="number">10.25201</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The floor value is:&quot;</span>,number)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The floor value <span class="keyword">is</span>: <span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="math-ceil-x">math.ceil(x)</h3>
<p>此方法返回 x 的上限值。它返回大于或等于 x 的值</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">number = math.ceil(<span class="number">10.25201</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The floor value is:&quot;</span>,number)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The floor value <span class="keyword">is</span>: <span class="number">11</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="math-fabs-x">math.fabs(x)</h3>
<p>这个方法返回 x 的绝对值。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">number = math.fabs(<span class="number">10.001</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The floor absolute is:&quot;</span>,number)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The absolute value <span class="keyword">is</span>: <span class="number">10.001</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="math-factorial">math.factorial()</h3>
<p>此方法返回给定数字 x 的阶乘。如果 x 不是整数，它将引发<strong>值错误</strong>。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">number = math.factorial(<span class="number">7</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The factorial of number:&quot;</span>,number)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The factorial of number: <span class="number">5040</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="math-modf-x">math.modf(x)</h3>
<p>这个方法返回 x 的小数部分和整数部分。它带有 x 是浮点数的符号。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">number = math.modf(<span class="number">44.5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The modf of number:&quot;</span>,number)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The modf of number: (<span class="number">0.5</span>, <span class="number">44.0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Python 提供了几个<code>math</code>模块，可以用单行代码执行复杂的任务。在本教程中，我们讨论了几个重要的<code>math</code>模块。</p>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-math-module">https://www.javatpoint.com/python-math-module</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python `random`模块</title>
    <url>/posts/80bcbda7.html</url>
    <content><![CDATA[<h1>Python <code>random</code>模块</h1>
<p>Python <code>random</code>模块函数依赖于伪随机数生成器函数 random()，该函数生成 0.0 到 1.0 之间的浮点数。</p>
<p><code>random</code>模块中使用了不同类型的函数，如下所示:</p>
<h3 id="random-random">random.random()</h3>
<p>该函数生成 0.0 到 1.0 之间的随机浮点数。</p>
<h3 id="random-randint">random.randint()</h3>
<p>此函数返回指定整数之间的随机整数。</p>
<h3 id="random-choice">random.choice()</h3>
<p>该函数从非空序列中返回随机选择的元素。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># importing &quot;random&quot;  module.</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment"># We are using the choice() function to generate a random number from</span></span><br><span class="line"><span class="comment"># the given list of numbers.</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;The random number from list is : &quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> (random.choice([<span class="number">50</span>, <span class="number">41</span>, <span class="number">84</span>, <span class="number">40</span>, <span class="number">31</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The random number <span class="keyword">from</span> <span class="built_in">list</span> <span class="keyword">is</span> : <span class="number">84</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="random-shuffle">random.shuffle()</h3>
<p>这个函数随机地重新排序列表中的元素。</p>
<h3 id="random-randrange-求、结束、步">random.randrange(求、结束、步)</h3>
<p>此函数用于生成一个在其参数中指定的范围内的数字。它接受三个参数，开始数字、最后数字和步长，用于跳过范围内的数字。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># We are using randrange() function to generate in range from 100</span></span><br><span class="line"><span class="comment"># to 500\. The last parameter 10 is step size to skip</span></span><br><span class="line"><span class="comment"># ten numbers when selecting.</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;A random number from range is : &quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> (random.randrange(<span class="number">100</span>, <span class="number">500</span>, <span class="number">10</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">A random number <span class="keyword">from</span> <span class="built_in">range</span> <span class="keyword">is</span> : <span class="number">290</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="random-seed">random.seed()</h3>
<p>此函数用于应用带有种子参数的特定随机数。它返回映射器值。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># importing &quot;random&quot; module.</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment"># using random() to generate a random number</span></span><br><span class="line"><span class="comment"># between 0 and 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The random number between 0 and 1 is : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(random.random())</span><br><span class="line"></span><br><span class="line"><span class="comment"># using seed() to seed a random number</span></span><br><span class="line">random.seed(<span class="number">4</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The random number between <span class="number">0</span> <span class="keyword">and</span> <span class="number">1</span> <span class="keyword">is</span> : <span class="number">0.4405576668981033</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-random-module">https://www.javatpoint.com/python-random-module</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python `pass`</title>
    <url>/posts/d77b8894.html</url>
    <content><![CDATA[<h1>Python <code>pass</code></h1>
<p>在 Python 中，<code>pass</code>关键字用于不执行任何内容；这意味着，当我们不想执行代码时，可以使用 pass 来执行 empty。它和名字所指的一样。它只是让控件在不执行任何代码的情况下通过。如果我们想绕过任何代码，可以使用 <code>pass</code>语句。</p>
<p>当一条语句在语法上是必需的时，这是有益的，但是我们希望我们不希望以后执行它。注释和 pass 的区别在于，注释完全被 Python 解释器忽略，而 <code>pass</code>语句没有被忽略。</p>
<p>假设我们有一个循环，我们现在不想执行，但我们将在未来执行。这里我们可以使用通行证。</p>
<p>考虑下面的例子。</p>
<p><strong>示例-通过声明</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pass is just a placeholder for</span></span><br><span class="line"><span class="comment"># we will adde functionality later.</span></span><br><span class="line">values = &#123;<span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;n&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> values:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例- 2:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]: </span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This is pass block&quot;</span>,i)</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">This <span class="keyword">is</span> <span class="keyword">pass</span> block <span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以使用 <code>pass</code>语句创建空的类或函数。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Empty Function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function_name</span>(<span class="params">args</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment">#Empty Class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-pass">https://www.javatpoint.com/python-pass</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python `sklearn.impute`模块</title>
    <url>/posts/475a55ae.html</url>
    <content><![CDATA[<h1>Python <code>sklearn.impute</code>模块</h1>
<p>在本教程中，我们将学习 Sklearn 库的 simple Current 模块，它以前被称为 Current 模块，但在 Sklearn 库的最新版本中进行了更新。我们将讨论 SimpleImputer 类，以及如何使用它来处理数据集中缺失的数据，并使用 Python 程序替换数据集中缺失的值。</p>
<h2 id="simpleinputer-类">simpleinputer 类</h2>
<p>我们可以用来处理预测模型数据集中缺失值的 scikit-learn 类称为 simple Current 类。在这个类的帮助下，我们可以用指定的占位符替换数据集中的 NaN(缺失值)值。我们可以通过在程序中使用 simpleCurrent()方法来实现和使用这个模块类。</p>
<h3 id="SimpleImputer-方法的语法">SimpleImputer()方法的语法:</h3>
<p>要在 Python 程序中实现 SimpleCurrent()类方法，我们必须使用以下语法:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">SimpleImputer(missingValues, strategy)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>**参数:**以下是使用简单估算()方法时必须定义的参数:</p>
<ol>
<li class="lvl-4">
<p><strong>missingValues:</strong> 是 SimpleImputer()方法中的缺失值占位符，必须在执行过程中进行估算，缺省情况下，缺失值占位符的值为 NaN。</p>
</li>
<li class="lvl-4">
<p><strong>strategy</strong>:是要替换数据集中缺失值(NaN 值)的数据，默认情况下，这个参数的取值方法是‘Mean’。简单估算()方法的策略参数可以采用“平均值”、“模式”、“中位数”(中心趋势测量方法)和“常数”值输入。</p>
</li>
<li class="lvl-4">
<p><strong>fillValue:</strong> 如果我们给出‘常量’作为替代值的方法，这个参数只在策略参数中使用。我们必须为策略参数定义常数值，它将替换数据集中的 NaN 值。</p>
</li>
</ol>
<p>SimpleImputer 类是 Sklearn 库的模块类，要使用这个类，首先我们必须在系统中安装 Sklearn 库，如果它还不存在的话。</p>
<h3 id="Sklearn-库的安装">Sklearn 库的安装:</h3>
<p>我们可以通过在系统的命令终端提示符下使用以下命令来安装 Sklearn:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install sklearn</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>按下回车键后，sklearn 模块将开始在我们的设备中安装，如下所示:</p>
<p><img src="/img/e2c586b8d07713fbfc826a1261ed9e87.png" alt="Python SimpleImputer module"></p>
<p>现在，我们的系统中安装了 Sklearn 模块，我们可以继续使用 simple Current 类函数。</p>
<h3 id="用-simple-Current-类处理数据集中的-NaN-值">用 simple Current 类处理数据集中的 NaN 值</h3>
<p>现在，我们将在 Python 程序中使用 SimpleImputer 类来处理数据集中缺少的值(我们将在程序中使用)。我们将在示例程序中定义一个数据集，同时给出其中一些缺失的值，然后我们使用 SimpleImputer 类方法通过定义数据集的参数来处理这些值。让我们通过一个示例 Python 程序来理解这一点的实现。</p>
<p><strong>示例 1:</strong> 看看下面的 Python 程序，其中定义了一个数据集，其中定义了 NaN 值:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Import numpy module as nmp</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> nmp</span><br><span class="line"><span class="comment"># Importing SimpleImputer class from sklearn impute module</span></span><br><span class="line"><span class="keyword">from</span> sklearn.impute <span class="keyword">import</span> SimpleImputer</span><br><span class="line"><span class="comment"># Setting up imputer function variable</span></span><br><span class="line">imputerFunc = SimpleImputer(missing_values = nmp.nan, strategy =<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line"><span class="comment"># Defining a dataset</span></span><br><span class="line">dataSet = [[<span class="number">32</span>, nmp.nan, <span class="number">34</span>, <span class="number">47</span>], [<span class="number">17</span>, nmp.nan, <span class="number">71</span>, <span class="number">53</span>], [<span class="number">19</span>, <span class="number">29</span>, nmp.nan, <span class="number">79</span>], [nmp.nan, <span class="number">31</span>, <span class="number">23</span>, <span class="number">37</span>], [<span class="number">19</span>, nmp.nan, <span class="number">79</span>, <span class="number">53</span>]]</span><br><span class="line"><span class="comment"># Print original dataset</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The Original Dataset we defined in the program: \n&quot;</span>, dataSet)</span><br><span class="line"><span class="comment"># Imputing dataset by replacing missing values</span></span><br><span class="line">imputerFunc = imputerFunc.fit(dataSet)</span><br><span class="line">dataSet2 = imputerFunc.transform(dataSet)</span><br><span class="line"><span class="comment"># Printing imputed dataset</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The imputed dataset after replacing missing values from it: \n&quot;</span>, dataSet2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The Original Dataset we defined <span class="keyword">in</span> the program: </span><br><span class="line"> [[<span class="number">32</span>, nan, <span class="number">34</span>, <span class="number">47</span>], [<span class="number">17</span>, nan, <span class="number">71</span>, <span class="number">53</span>], [<span class="number">19</span>, <span class="number">29</span>, nan, <span class="number">79</span>], [nan, <span class="number">31</span>, <span class="number">23</span>, <span class="number">37</span>], [<span class="number">19</span>, nan, <span class="number">79</span>, <span class="number">53</span>]]</span><br><span class="line">The imputed dataset after replacing missing values <span class="keyword">from</span> it: </span><br><span class="line"> [[<span class="number">32</span>\.   <span class="number">30</span>\.   <span class="number">34</span>\.   <span class="number">47</span>\.  ]</span><br><span class="line"> [<span class="number">17</span>\.   <span class="number">30</span>\.   <span class="number">71</span>\.   <span class="number">53</span>\.  ]</span><br><span class="line"> [<span class="number">19</span>\.   <span class="number">29</span>\.   <span class="number">51.75</span> <span class="number">79</span>\.  ]</span><br><span class="line"> [<span class="number">21.75</span> <span class="number">31</span>\.   <span class="number">23</span>\.   <span class="number">37</span>\.  ]</span><br><span class="line"> [<span class="number">19</span>\.   <span class="number">30</span>\.   <span class="number">79</span>\.   <span class="number">53</span>\.  ]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>我们首先将 numpy 模块(用于定义数据集)和 sklearn 模块(用于使用 SimpleImputer 类方法)导入到程序中。然后，我们使用简单估算器类方法定义估算器来处理缺失值，并使用“平均”策略来替换数据集中的缺失值。之后，我们在程序中使用 numpy 模块函数定义了一个数据集，并给出了数据集中的一些缺失值(NaN 值)。然后，我们在输出中打印原始数据集。之后，我们对数据集中缺失的值进行了估算，并用我们之前在简单估算类的程序中定义的估算值进行了替换。在输入数据集并替换其中缺失的值后，我们打印了新的数据集。</p>
<p>正如我们在输出中所看到的，估算值数据集在缺少值的地方有平均值，这就是我们如何使用 simple Current 模块类来处理数据集中的 NaN 值。</p>
<h2 id="结论-3">结论</h2>
<p>我们已经阅读了该方法中的 simple Current 类方法，并了解了如何使用它来处理数据集中存在的 NaN 值。我们了解了策略值参数，我们使用它来定义替换数据集的 NaN 值的方法。我们还了解了 Sklearn 库的安装，最后，我们在一个示例中使用了 simple Current 类方法来估算数据集。</p>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python `statistics`模块</title>
    <url>/posts/ead347d8.html</url>
    <content><![CDATA[<h1>Python <code>statistics</code>模块</h1>
<p>Python <code>statistics</code>模块提供了对数值数据进行数理统计的功能。本模块中定义了一些流行的统计函数。</p>
<h2 id="mean-函数">mean()函数</h2>
<p>mean()函数用于计算列表中数字的算术平均值。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> statistics  </span><br><span class="line"><span class="comment"># list of positive integer numbers </span></span><br><span class="line">datasets = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>]   </span><br><span class="line">x = statistics.mean(datasets)   </span><br><span class="line"><span class="comment"># Printing the mean </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Mean is :&quot;</span>, x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Mean <span class="keyword">is</span> : <span class="number">4.857142857142857</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="median-函数">median()函数</h2>
<p>median()函数用于返回列表中数值数据的中间值。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> statistics   </span><br><span class="line">datasets = [<span class="number">4</span>, -<span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">5</span>, -<span class="number">2</span>]    </span><br><span class="line"><span class="comment"># Printing median of the </span></span><br><span class="line"><span class="comment"># random data-set </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Median of data-set is : % s &quot;</span></span><br><span class="line">        % (statistics.median(datasets)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Median of data-<span class="built_in">set</span> <span class="keyword">is</span> : <span class="number">4.5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="mode-函数">mode()函数</h2>
<p>mode()函数返回列表中最常见的数据。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> statistics   </span><br><span class="line"><span class="comment"># declaring a simple data-set consisting of real valued positive integers. </span></span><br><span class="line">dataset =[<span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">8</span>]   </span><br><span class="line"><span class="comment"># Printing out the mode of given data-set </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Calculated Mode % s&quot;</span> % (statistics.mode(dataset)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Calculated Mode <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="stdev-函数">stdev()函数</h2>
<p>stdev()函数用于计算给定样本的标准偏差，该样本以列表形式提供。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> statistics   </span><br><span class="line"><span class="comment"># creating a simple data - set </span></span><br><span class="line">sample = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]   </span><br><span class="line"><span class="comment"># Prints standard deviation </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Standard Deviation of sample is % s &quot;</span> </span><br><span class="line">                % (statistics.stdev(sample))) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Standard Deviation of sample <span class="keyword">is</span> <span class="number">1.5811388300841898</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="median-low">median_low()</h2>
<p>median_low函数用于返回列表中数值数据的低中值。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> statistics   </span><br><span class="line"><span class="comment"># simple list of a set of integers </span></span><br><span class="line">set1 = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>]   </span><br><span class="line"><span class="comment"># Note: low median will always be a member of the data-set.   </span></span><br><span class="line"><span class="comment"># Print low median of the data-set </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Low median of data-set is % s &quot;</span> </span><br><span class="line">        % (statistics.median_low(set1)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Low median of the data-<span class="built_in">set</span> <span class="keyword">is</span> <span class="number">5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="median-high">median_high()</h2>
<p>median_high函数用于返回列表中数值数据的高中值。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> statistics   </span><br><span class="line"><span class="comment"># list of set of the integers </span></span><br><span class="line">dataset = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>]   </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;High median of data-set is %s &quot;</span> </span><br><span class="line">        % (statistics.median_high(dataset)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">High median of the data-<span class="built_in">set</span> <span class="keyword">is</span> <span class="number">6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-statistics-module">https://www.javatpoint.com/python-statistics-module</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python `sys`模块</title>
    <url>/posts/8e495c40.html</url>
    <content><![CDATA[<h1>Python <code>sys</code>模块</h1>
<p>python <code>sys</code>模块提供了用于操作 python 运行时环境不同部分的函数和变量。它允许我们访问系统特定的参数和功能。</p>
<p><strong>导入系统</strong></p>
<p>首先，在运行任何函数之前，我们必须在程序中导入 <code>sys</code>模块。</p>
<p><strong><code>sys</code>模块</strong></p>
<p>该函数提供已导入的现有 python 模块的名称。</p>
<p><strong>sys.argv</strong></p>
<p>该函数返回传递给 Python 脚本的命令行参数列表。脚本的名称始终是索引 0 处的项，其余的参数存储在后续的索引中。</p>
<p><strong>sys.base_exec_prefix</strong></p>
<p>该函数提供了一种有效的方法来获得与 exec_prefix 相同的值。如果不运行虚拟环境，该值将保持不变。</p>
<p><strong>sys.base_prefix</strong></p>
<p>它在 Python 启动期间，在 <a href="http://site.py">site.py</a> 运行之前被设置为与前缀相同的值。</p>
<p><strong>sys.byteorder</strong></p>
<p>这是本机 byteorder 的一个指示，它提供了一种有效的方式来做某事。</p>
<p><strong>sys.maxsize</strong></p>
<p>此函数返回变量的最大整数。</p>
<p><strong>sys.path</strong></p>
<p>该函数显示当前系统中的 PYTHONPATH 集。它是一个环境变量，是所有 python 模块的搜索路径。</p>
<p><strong>sys.stdin</strong></p>
<p>它是一个对象，在程序开始时包含 stdin 的原始值，并在结束时使用。它可以恢复文件。</p>
<p><strong>sys.getrefcount</strong></p>
<p>此函数返回对象的引用计数。</p>
<p><strong>sys.exit</strong></p>
<p>该函数用于从 Python 控制台或命令提示符退出，也用于在出现异常时退出程序。</p>
<p><strong>sys.executable</strong></p>
<p>这个函数的值是 Python 解释器的绝对路径。了解 python 在其他机器上的安装位置非常有用。</p>
<p><strong>sys.platform</strong></p>
<p>该函数的这个值用于标识我们工作的平台。</p>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-sys-module">https://www.javatpoint.com/python-sys-module</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 中的第二大数字</title>
    <url>/posts/66b1a133.html</url>
    <content><![CDATA[<h1>Python 中的第二大数字</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/second-largest-number-in-python">https://www.javatpoint.com/second-largest-number-in-python</a></p>
</blockquote>
<p>当我们的列表中有很多元素时，我们会想到找到最高或最低的元素，Python 让我们变得更加容易。</p>
<p>在本文中，我们将讨论如何从列表中找到 Python 中的第二大数字。</p>
<ol>
<li class="lvl-4">
<p>排序列表，然后打印倒数第二个数字。</p>
</li>
<li class="lvl-4">
<p>移除最大元素。</p>
</li>
<li class="lvl-4">
<p>寻找最大元素。</p>
</li>
<li class="lvl-4">
<p>遍历列表。</p>
</li>
</ol>
<p>让我们看看第一种方法-</p>
<h2 id="排序列表，然后打印倒数第二个数字">排序列表，然后打印倒数第二个数字</h2>
<p>下面的程序说明了我们如何用 Python 实现它</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#program to find the second largest number of list</span></span><br><span class="line"><span class="comment"># declaring the list</span></span><br><span class="line">list_val = [<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">25</span>, <span class="number">10</span>]</span><br><span class="line"><span class="comment"># sorting the list</span></span><br><span class="line">list_val.sort()</span><br><span class="line"><span class="comment">#displaying the second last element of the list</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The second largest element of the list is:&quot;</span>, list_val[-<span class="number">2</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The second largest element of the <span class="built_in">list</span> <span class="keyword">is</span>: <span class="number">30</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>是时候解释一下了-</p>
<ol>
<li class="lvl-4">
<p>我们已经声明了要从中取出倒数第二个元素的列表。</p>
</li>
<li class="lvl-4">
<p>在此之后，我们使用了排序方法，以便列表中的所有元素都按升序排列。</p>
</li>
<li class="lvl-4">
<p>现在我们使用负索引，因为第二大数字将出现在倒数第二的位置。</p>
</li>
</ol>
<p>第二种方法是通过移除最大元素来获得列表的第二大元素。</p>
<p>让我们看看我们能怎么做。</p>
<h2 id="移除最大元素">移除最大元素</h2>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#program to find the second largest number of list</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># declaring the list</span></span><br><span class="line">list_val = [<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">25</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># new_list is a set of list1</span></span><br><span class="line">res_list = <span class="built_in">set</span>(list_val)</span><br><span class="line"></span><br><span class="line"><span class="comment">#removing the maximum element</span></span><br><span class="line">res_list.remove(<span class="built_in">max</span>(res_list))</span><br><span class="line"></span><br><span class="line"><span class="comment">#printing the second largest element </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(res_list))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">30</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>解释-</strong></p>
<p>让我们了解我们在上面的程序中做了什么-</p>
<ol>
<li class="lvl-4">
<p>我们已经声明了要从中取出倒数第二个元素的列表。</p>
</li>
<li class="lvl-4">
<p>在此之后，我们使用 set 方法获取列表中所有唯一的元素。</p>
</li>
<li class="lvl-4">
<p>现在我们使用 max()从列表中获取最大值，然后删除它。</p>
</li>
<li class="lvl-4">
<p>之后，我们打印结果列表的最大值，这将给出第二大的数字。</p>
</li>
</ol>
<p>在第三种方法中，我们将使用 <code>for</code>循环并从列表中找到第二大数字。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># declaring empty list</span></span><br><span class="line">list_val = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># user provides the number of elements to be added in the list</span></span><br><span class="line">num_list = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter number of elements in list: &quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, num_list + <span class="number">1</span>):</span><br><span class="line">	element = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the elements: &quot;</span>))</span><br><span class="line">	list_val.append(element)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sort the list</span></span><br><span class="line">list_val.sort()</span><br><span class="line"></span><br><span class="line"><span class="comment"># print second largest element</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Second largest element is:&quot;</span>, list_val[-<span class="number">2</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter number of elements <span class="keyword">in</span> <span class="built_in">list</span>: <span class="number">5</span></span><br><span class="line"></span><br><span class="line">Enter the elements: <span class="number">10</span></span><br><span class="line"></span><br><span class="line">Enter the elements: <span class="number">20</span></span><br><span class="line"></span><br><span class="line">Enter the elements: <span class="number">30</span></span><br><span class="line"></span><br><span class="line">Enter the elements: <span class="number">40</span></span><br><span class="line"></span><br><span class="line">Enter the elements: <span class="number">50</span></span><br><span class="line">The second largest element <span class="keyword">is</span>: <span class="number">40</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>解释-</strong></p>
<p>让我们看看我们在这里做了什么-</p>
<ol>
<li class="lvl-4">
<p>我们已经声明了一个空列表，我们将在其中插入元素。</p>
</li>
<li class="lvl-4">
<p>之后，我们要求用户提供我们想要添加到列表中的元素数量。</p>
</li>
<li class="lvl-4">
<p>在此之后，我们使用排序方法，以便列表中的所有元素都按升序排列。</p>
</li>
<li class="lvl-4">
<p>现在我们使用负索引，因为第二大数字将出现在倒数第二的位置。</p>
</li>
</ol>
<h2 id="遍历列表">遍历列表</h2>
<p>在最后一个程序中，我们将遍历列表找出最大的数字，然后利用条件语句从列表中找到第二大的数字。</p>
<p>下面的程序说明了同样的情况-</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc_largest</span>(<span class="params">arr</span>):</span><br><span class="line">	second_largest = arr[<span class="number">0</span>]</span><br><span class="line">	largest_val = arr[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">		<span class="keyword">if</span> arr[i] &gt; largest_val:</span><br><span class="line">			largest_val = arr[i]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">		<span class="keyword">if</span> arr[i] &gt; second_largest <span class="keyword">and</span> arr[i] != largest_val:</span><br><span class="line">			second_largest = arr[i]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> second_largest</span><br><span class="line"><span class="built_in">print</span>(calc_largest([<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">25</span>, <span class="number">10</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">30</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>解释-</strong></p>
<p>让我们了解我们在上面的程序中做了什么-</p>
<ol>
<li class="lvl-4">
<p>第一步是创建一个函数，通过遍历来检查列表中最大的数字。</p>
</li>
<li class="lvl-4">
<p>在下一个 <code>for</code>循环中，我们再次遍历列表以找到最高的数字，但这次不包括前一个，因为这里我们的目标是找到第二大函数。</p>
</li>
<li class="lvl-4">
<p>最后，我们在函数中传递我们的列表。</p>
</li>
</ol>
<p>因此，在本文中，我们有机会跳出框框思考，并发现一些新的方法来开发在 Python 中寻找第二大数字的逻辑。</p>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 元组</title>
    <url>/posts/3bfa306a.html</url>
    <content><![CDATA[<h1>Python 元组</h1>
<p>Python Tuple 用于存储不可变 Python 对象的序列。元组类似于列表，因为存储在列表中的项目的值可以改变，而元组是不可变的，并且存储在元组中的项目的值不能改变。</p>
<h2 id="创建元组">创建元组</h2>
<p>元组可以写成逗号分隔(,)值的集合，用小括号()括起来。圆括号是可选的，但使用它是一种好的做法。元组可以定义如下。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">T1 = (<span class="number">101</span>, <span class="string">&quot;Peter&quot;</span>, <span class="number">22</span>)  </span><br><span class="line">T2 = (<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>)   </span><br><span class="line">T3 = <span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(T1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(T2))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(T3))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="注意-不用括号创建的元组也称为元组打包。">注意:不用括号创建的元组也称为元组打包。</h4>
<p>可以如下创建一个空元组。</p>
<p>T4 = ()</p>
<p>用单个元素创建元组略有不同。我们需要在元素后面放一个逗号来声明元组。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="string">&quot;JavaTpoint&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(tup1))</span><br><span class="line"><span class="comment">#Creating a tuple with single element </span></span><br><span class="line">tup2 = (<span class="string">&quot;JavaTpoint&quot;</span>,)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(tup2))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>元组的索引方式与列表相同。元组中的项可以通过使用它们特定的索引值来访问。</p>
<p>考虑以下元组示例:</p>
<h3 id="示例-1-3">示例- 1</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tuple1 = (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>)  </span><br><span class="line"><span class="built_in">print</span>(tuple1)  </span><br><span class="line">count = <span class="number">0</span>  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tuple1:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;tuple1[%d] = %d&quot;</span>%(count, i)) </span><br><span class="line">    count = count+<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>)</span><br><span class="line">tuple1[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">tuple1[<span class="number">1</span>] = <span class="number">20</span></span><br><span class="line">tuple1[<span class="number">2</span>] = <span class="number">30</span></span><br><span class="line">tuple1[<span class="number">3</span>] = <span class="number">40</span></span><br><span class="line">tuple1[<span class="number">4</span>] = <span class="number">50</span></span><br><span class="line">tuple1[<span class="number">5</span>] = <span class="number">60</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="示例-2-3">示例- 2</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tuple1 = <span class="built_in">tuple</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the tuple elements ...&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(tuple1)  </span><br><span class="line">count = <span class="number">0</span>  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tuple1:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;tuple1[%d] = %s&quot;</span>%(count, i)) </span><br><span class="line">    count = count+<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the <span class="built_in">tuple</span> elements ..<span class="number">.123456</span></span><br><span class="line">(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">tuple1[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">tuple1[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">tuple1[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">tuple1[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line">tuple1[<span class="number">4</span>] = <span class="number">5</span></span><br><span class="line">tuple1[<span class="number">5</span>] = <span class="number">6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>元组的索引方式与列表相同。元组中的项可以通过使用它们特定的索引值来访问。</p>
<p>我们将在教程的这一部分看到 tuple 的所有这些方面。</p>
<h2 id="元组索引和切片">元组索引和切片</h2>
<p>元组中的索引和切片类似于列表。元组中的索引从 0 开始，到长度(元组)- 1。</p>
<p>元组中的项可以通过使用 index []运算符来访问。Python 还允许我们使用冒号运算符来访问元组中的多个项目。</p>
<p>请参考下图，详细了解索引和切片。</p>
<p><img src="/img/ba543fe02b5f3d6b398ff50d3b4a7b01.png" alt="Python Tuple"></p>
<p>考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tup = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line"><span class="built_in">print</span>(tup[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(tup[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(tup[<span class="number">2</span>])</span><br><span class="line"><span class="comment"># It will give the IndexError</span></span><br><span class="line"><span class="built_in">print</span>(tup[<span class="number">8</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="built_in">tuple</span> index out of <span class="built_in">range</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，元组有 7 个元素，表示 0 到 6。我们试图访问元组外部的一个元素，该元素引发了<strong>索引错误</strong>。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tuple</span> = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line"><span class="comment">#element 1 to end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>[<span class="number">1</span>:])</span><br><span class="line"><span class="comment">#element 0 to 3 element </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>[:<span class="number">4</span>])</span><br><span class="line"><span class="comment">#element 1 to 4 element</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>[<span class="number">1</span>:<span class="number">5</span>]) </span><br><span class="line"><span class="comment"># element 0 to 6 and take step of 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>[<span class="number">0</span>:<span class="number">6</span>:<span class="number">2</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="负索引">负索引</h2>
<p>元组元素也可以通过使用负索引来访问。索引-1 表示最右边的元素，索引-2 表示倒数第二个元素，依此类推。</p>
<p>使用负索引从左到右遍历元素。考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tuple1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)  </span><br><span class="line"><span class="built_in">print</span>(tuple1[-<span class="number">1</span>])  </span><br><span class="line"><span class="built_in">print</span>(tuple1[-<span class="number">4</span>])  </span><br><span class="line"><span class="built_in">print</span>(tuple1[-<span class="number">3</span>:-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(tuple1[:-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(tuple1[-<span class="number">2</span>:])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="删除元组">删除元组</h2>
<p>与列表不同，元组项不能通过使用 <strong>del</strong> 关键字删除，因为元组是不可变的。要删除整个元组，我们可以在元组名称中使用 <strong>del</strong> 关键字。</p>
<p>考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tuple1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)  </span><br><span class="line"><span class="built_in">print</span>(tuple1)  </span><br><span class="line"><span class="keyword">del</span> tuple1[<span class="number">0</span>]  </span><br><span class="line"><span class="built_in">print</span>(tuple1)  </span><br><span class="line"><span class="keyword">del</span> tuple1  </span><br><span class="line"><span class="built_in">print</span>(tuple1)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;tuple.py&quot;</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span>(tuple1)</span><br><span class="line">NameError: name <span class="string">&#x27;tuple1&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="基本元组操作">基本元组操作</h2>
<p>像连接(+)、重复(*)、成员资格(in)这样的运算符的工作方式与它们处理列表的方式相同。有关更多详细信息，请参考下表。</p>
<p>假设声明了 Tuple t = (1，2，3，4，5)和 Tuple t1 = (6，7，8，9)。</p>
<h3 id="重复">重复</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">T1*<span class="number">2</span> = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<h3 id="串联">串联</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">T1+T2 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br></pre></td></tr></table></figure>
<h3 id="是否为成员">是否为成员</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> (<span class="number">2</span> <span class="keyword">in</span> T1) </span><br><span class="line">prints <span class="literal">True</span>.</span><br></pre></td></tr></table></figure>
<h3 id="遍历">遍历</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> T1: </span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<h3 id="len">len()</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>(T1) = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h3 id="count">count()</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creating tuples  </span></span><br><span class="line">T1 = (<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>)  </span><br><span class="line">T2 = (<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;Tpoint&#x27;</span>, <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;java&#x27;</span>)  </span><br><span class="line"><span class="comment"># counting the appearance of 3  </span></span><br><span class="line">res = T1.count(<span class="number">2</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Count of 2 in T1 is:&#x27;</span>, res)  </span><br><span class="line"><span class="comment"># counting the appearance of java  </span></span><br><span class="line">res = T2.count(<span class="string">&#x27;java&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Count of Java in T2 is:&#x27;</span>, res)  </span><br></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Count of <span class="number">2</span> <span class="keyword">in</span> T1 <span class="keyword">is</span>: <span class="number">5</span></span><br><span class="line">Count of java <span class="keyword">in</span> T2 <span class="keyword">is</span>: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="index">index()</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creating tuples  </span></span><br><span class="line">Tuple_data = (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>)  </span><br><span class="line"><span class="comment"># getting the index of 3  </span></span><br><span class="line">res = Tuple_data.index(<span class="number">3</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;First occurrence of 1 is&#x27;</span>, res)  </span><br><span class="line"><span class="comment"># getting the index of 3 after 4th  </span></span><br><span class="line"><span class="comment"># index  </span></span><br><span class="line">res = Tuple_data.index(<span class="number">3</span>, <span class="number">4</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;First occurrence of 1 after 4th index is:&#x27;</span>, res)  </span><br></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">First occurrence of <span class="number">1</span> <span class="keyword">is</span> <span class="number">2</span></span><br><span class="line">First occurrence of <span class="number">1</span> after 4th index <span class="keyword">is</span>: <span class="number">6</span></span><br></pre></td></tr></table></figure>
<h2 id="Python-元组内置函数">Python 元组内置函数</h2>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>len(tuple)</td>
<td>它计算元组的长度。</td>
</tr>
<tr>
<td>max(tuple)</td>
<td>它返回元组的最大元素</td>
</tr>
<tr>
<td>min(tuple)</td>
<td>它返回元组的最小元素。</td>
</tr>
<tr>
<td>tuple(iterable)</td>
<td>它将指定的序列转换为元组。</td>
</tr>
</tbody>
</table>
<h2 id="在哪里使用元组？">在哪里使用元组？</h2>
<p>在以下场景中使用元组代替列表。</p>
<p>1.使用 tuple 代替 list 让我们清楚地知道 tuple 数据是不变的，不能改变。</p>
<p>2.Tuple 可以模拟没有键的字典。考虑下面的嵌套结构，它可以用作字典。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[(<span class="number">101</span>, <span class="string">&quot;John&quot;</span>, <span class="number">22</span>), (<span class="number">102</span>, <span class="string">&quot;Mike&quot;</span>, <span class="number">28</span>),  (<span class="number">103</span>, <span class="string">&quot;Dustin&quot;</span>, <span class="number">30</span>)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="列表与元组">列表与元组</h2>
<p>| 序号 | 列表 | 元组 |<br>
| one | 列表的字面值语法由[]显示。 | 元组的字面语法由()表示。 |<br>
| Two | 列表是可变的。 | 元组是不可变的。 |<br>
| three | 列表的长度是可变的。 | 元组具有固定长度。 |<br>
| four | 该列表提供了比元组更多的功能。 | 元组提供的功能比列表少。|<br>
| five | 该列表用于我们需要存储没有约束的简单集合的场景，其中项目的值可以更改。 | 元组用于我们需要存储只读集合的情况，即项目的值不能更改。它可以作为字典里面的钥匙。|<br>
| six | 列表的内存效率不如元组。 | 元组因其不变性而更具内存效率。 |</p>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-tuples">https://www.javatpoint.com/python-tuples</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 内置函数</title>
    <url>/posts/8158a18d.html</url>
    <content><![CDATA[<h1>Python 内置函数</h1>
<p>Python 内置函数被定义为其功能在 Python 中预定义的函数。python 解释器有几个一直存在的功能。这些功能被称为内置功能。Python 中有几个内置函数，如下所示:</p>
<h2 id="Python-abs">Python abs()</h2>
<p>python <strong>abs()</strong> 函数用于返回一个数字的绝对值。它只需要一个参数，一个要返回绝对值的数字。参数可以是整数和浮点数。如果参数是一个复数，那么，abs()返回它的大小。</p>
<p><strong>Python abs()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  integer number	</span></span><br><span class="line">integer = -<span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Absolute value of -40 is:&#x27;</span>, <span class="built_in">abs</span>(integer))</span><br><span class="line"></span><br><span class="line"><span class="comment">#  floating number</span></span><br><span class="line">floating = -<span class="number">20.83</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Absolute value of -40.83 is:&#x27;</span>, <span class="built_in">abs</span>(floating))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Absolute value of -<span class="number">20</span> <span class="keyword">is</span>: <span class="number">20</span></span><br><span class="line">Absolute value of -<span class="number">20.83</span> <span class="keyword">is</span>: <span class="number">20.83</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-all">Python all()</h2>
<p>python <strong>all()</strong> 函数接受一个可迭代对象(如列表、字典等),如果传递的 iterable 中的所有项都为真，则返回 true。否则，它返回 False。如果可迭代对象为空，all()函数将返回 True。</p>
<p><strong>Python all()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># all values true</span></span><br><span class="line">k = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">all</span>(k))</span><br><span class="line"></span><br><span class="line"><span class="comment"># all values false</span></span><br><span class="line">k = [<span class="number">0</span>, <span class="literal">False</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">all</span>(k))</span><br><span class="line"></span><br><span class="line"><span class="comment"># one false value</span></span><br><span class="line">k = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">all</span>(k))</span><br><span class="line"></span><br><span class="line"><span class="comment"># one true value</span></span><br><span class="line">k = [<span class="number">0</span>, <span class="literal">False</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">all</span>(k))</span><br><span class="line"></span><br><span class="line"><span class="comment"># empty iterable</span></span><br><span class="line">k = []</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">all</span>(k))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-bin">Python bin()</h2>
<p>python <strong>bin()</strong> 函数用于返回指定整数的二进制表示。结果总是以前缀 0b 开头。</p>
<p><strong>Python bin()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">x =  <span class="number">10</span></span><br><span class="line">y =  <span class="built_in">bin</span>(x)</span><br><span class="line"><span class="built_in">print</span> (y)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">0b1010</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-bool（）">Python bool（）</h2>
<p>python <strong>bool()</strong> 使用标准的真值测试过程将一个值转换为布尔值(真或假)。</p>
<p><strong>Python bool()示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">test1 = []</span><br><span class="line"><span class="built_in">print</span>(test1,<span class="string">&#x27;is&#x27;</span>,<span class="built_in">bool</span>(test1))</span><br><span class="line">test1 = [<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(test1,<span class="string">&#x27;is&#x27;</span>,<span class="built_in">bool</span>(test1))</span><br><span class="line">test1 = <span class="number">0.0</span></span><br><span class="line"><span class="built_in">print</span>(test1,<span class="string">&#x27;is&#x27;</span>,<span class="built_in">bool</span>(test1))</span><br><span class="line">test1 = <span class="literal">None</span></span><br><span class="line"><span class="built_in">print</span>(test1,<span class="string">&#x27;is&#x27;</span>,<span class="built_in">bool</span>(test1))</span><br><span class="line">test1 = <span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span>(test1,<span class="string">&#x27;is&#x27;</span>,<span class="built_in">bool</span>(test1))</span><br><span class="line">test1 = <span class="string">&#x27;Easy string&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(test1,<span class="string">&#x27;is&#x27;</span>,<span class="built_in">bool</span>(test1))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[] <span class="keyword">is</span> <span class="literal">False</span></span><br><span class="line">[<span class="number">0</span>] <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line"><span class="number">0.0</span> <span class="keyword">is</span> <span class="literal">False</span></span><br><span class="line"><span class="literal">None</span> <span class="keyword">is</span> <span class="literal">False</span></span><br><span class="line"><span class="literal">True</span> <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line">Easy string <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-bytes">Python bytes()</h2>
<p>python 中的 python <strong>bytes()<strong>用于返回一个</strong>字节</strong>对象。它是 bytearray()函数的不可变版本。</p>
<p>它可以创建指定大小的空字节对象。</p>
<p><strong>Python bytes()示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">string = <span class="string">&quot;Hello World.&quot;</span></span><br><span class="line">array = <span class="built_in">bytes</span>(string, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">b <span class="string">&#x27; Hello World.&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-callable">Python callable()</h2>
<p>python 中的一个 python **callable()**函数是可以调用的。如果传递的对象看起来是可调用的，这个内置函数检查并返回 true，否则返回 false。</p>
<p><strong>Python callable()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">x = <span class="number">8</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">callable</span>(x))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-compile">Python compile()</h2>
<p>python <strong>compile()</strong> 函数以源代码为输入，返回一个代码对象，稍后可以由 exec()函数执行。</p>
<p><strong>Python compile()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># compile string source to code</span></span><br><span class="line">code_str = <span class="string">&#x27;x=5\ny=10\nprint(&quot;sum =&quot;,x+y)&#x27;</span></span><br><span class="line">code = <span class="built_in">compile</span>(code_str, <span class="string">&#x27;sum.py&#x27;</span>, <span class="string">&#x27;exec&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(code))</span><br><span class="line"><span class="built_in">exec</span>(code)</span><br><span class="line"><span class="built_in">exec</span>(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;code&#x27;</span>&gt;</span><br><span class="line"><span class="built_in">sum</span> = <span class="number">15</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-exec">Python exec()</h2>
<p>python <strong>exec()</strong> 函数用于动态执行 python 程序，该程序可以是字符串或目标代码，并且它接受大块代码，这与只接受单个表达式的 eval()函数不同。</p>
<p><strong>Python exec()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">x = <span class="number">8</span></span><br><span class="line"><span class="built_in">exec</span>(<span class="string">&#x27;print(x==8)&#x27;</span>)</span><br><span class="line"><span class="built_in">exec</span>(<span class="string">&#x27;print(x+4)&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-sum">Python sum()</h2>
<p>顾名思义，python <strong>sum()</strong> 函数用于获取一个可迭代的，即列表的数字之和。</p>
<p><strong>Python sum()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">s = <span class="built_in">sum</span>([<span class="number">1</span>, <span class="number">2</span>,<span class="number">4</span> ])</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line">s = <span class="built_in">sum</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>], <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-any">Python any()</h2>
<p>如果 iterable 中的任何项目为真，python <strong>any()</strong> 函数将返回真。否则，它返回 False。</p>
<p><strong>Python any()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>]                            </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">any</span>(l))                                 </span><br><span class="line"></span><br><span class="line">l = [<span class="number">0</span>, <span class="literal">False</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">any</span>(l))</span><br><span class="line"></span><br><span class="line">l = [<span class="number">0</span>, <span class="literal">False</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">any</span>(l))</span><br><span class="line"></span><br><span class="line">l = []</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">any</span>(l))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-ascii">Python ascii()</h2>
<p>python <strong>ascii()</strong> 函数返回一个包含对象的可打印表示的字符串，并使用\x，\u 或\U 转义来转义字符串中的非 ascii 字符。</p>
<p><strong>Python ascii()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">normalText = <span class="string">&#x27;Python is interesting&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ascii</span>(normalText))</span><br><span class="line"></span><br><span class="line">otherText = <span class="string">&#x27;Pythn is interesting&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ascii</span>(otherText))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Pyth\xf6n is interesting&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;Python is interesting&#x27;</span></span><br><span class="line"><span class="string">&#x27;Pyth\xf6n is interesting&#x27;</span></span><br><span class="line">Pythn <span class="keyword">is</span> interesting</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-bytearray">Python bytearray()</h2>
<p>python <strong>bytearray()</strong> 返回一个 bytearray 对象，可以将对象转换成 bytearray 对象，或者创建一个指定大小的空 bytearray 对象。</p>
<p><strong>Python bytearray()示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">string = <span class="string">&quot;Python is a programming language.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># string with encoding &#x27;utf-8&#x27;</span></span><br><span class="line">arr = <span class="built_in">bytearray</span>(string, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bytearray</span>(<span class="string">b&#x27;Python is a programming language.&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-eval">Python eval()</h2>
<p>python <strong>eval()</strong> 函数解析传递给它的表达式，并在程序中运行 python 表达式(代码)。</p>
<p><strong>Python eval()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">x = <span class="number">8</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&#x27;x + 1&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-float">Python float()</h2>
<p>python <strong>float()</strong> 函数从数字或字符串中返回一个浮点数。</p>
<p><strong>Python float()示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># for integers</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">float</span>(<span class="number">9</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># for floats</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">float</span>(<span class="number">8.19</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># for string floats</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">float</span>(<span class="string">&quot;-24.27&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># for string floats with whitespaces</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">float</span>(<span class="string">&quot;     -17.19\n&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># string float error</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">float</span>(<span class="string">&quot;xyz&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">9.0</span></span><br><span class="line"><span class="number">8.19</span></span><br><span class="line">-<span class="number">24.27</span></span><br><span class="line">-<span class="number">17.19</span></span><br><span class="line">ValueError: could <span class="keyword">not</span> convert string to <span class="built_in">float</span>: <span class="string">&#x27;xyz&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-format">Python format()</h2>
<p>python <strong>format()</strong> 函数返回给定值的格式化表示。</p>
<p><strong>Python format()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># d, f and b are a type</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># integer</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">format</span>(<span class="number">123</span>, <span class="string">&quot;d&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># float arguments</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">format</span>(<span class="number">123.4567898</span>, <span class="string">&quot;f&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># binary format</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">format</span>(<span class="number">12</span>, <span class="string">&quot;b&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">123.456790</span></span><br><span class="line"><span class="number">1100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-frozenset">Python frozenset()</h2>
<p>python <strong>frozenset()</strong> 函数返回一个不可变的 frozenset 对象，该对象用给定 iterable 中的元素初始化。</p>
<p><strong>Python frozenset()示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tuple of letters</span></span><br><span class="line">letters = (<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;s&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fSet = <span class="built_in">frozenset</span>(letters)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Frozen set is:&#x27;</span>, fSet)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Empty frozen set is:&#x27;</span>, <span class="built_in">frozenset</span>())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Frozen <span class="built_in">set</span> <span class="keyword">is</span>: <span class="built_in">frozenset</span>(&#123;<span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;t&#x27;</span>&#125;)</span><br><span class="line">Empty frozen <span class="built_in">set</span> <span class="keyword">is</span>: <span class="built_in">frozenset</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-getattr">Python getattr()</h2>
<p>python <strong>getattr()</strong> 函数返回对象的命名属性的值。如果找不到，它将返回默认值。</p>
<p><strong>Python getattr()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Details</span>:</span><br><span class="line">    age = <span class="number">22</span></span><br><span class="line">    name = <span class="string">&quot;Phill&quot;</span></span><br><span class="line"></span><br><span class="line">details = Details()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The age is:&#x27;</span>, <span class="built_in">getattr</span>(details, <span class="string">&quot;age&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The age is:&#x27;</span>, details.age)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The age <span class="keyword">is</span>: <span class="number">22</span></span><br><span class="line">The age <span class="keyword">is</span>: <span class="number">22</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-globals">Python globals()</h2>
<p>python <strong>globals()</strong> 函数返回当前全局符号表的字典。</p>
<p>一个<strong>符号表</strong>被定义为一个数据结构，它包含了关于程序的所有必要信息。它包括变量名、方法、类等。</p>
<p><strong>Python globals()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">age = <span class="number">22</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">globals</span>()[<span class="string">&#x27;age&#x27;</span>] = <span class="number">22</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The age is:&#x27;</span>, age)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The age <span class="keyword">is</span>: <span class="number">22</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-any-2">Python any()</h2>
<p>python <strong>any()</strong> 函数如果 iterable 中的任何项目为真，则返回真，否则返回假。</p>
<p><strong>Python any()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>]                            </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">any</span>(l))                                 </span><br><span class="line"></span><br><span class="line">l = [<span class="number">0</span>, <span class="literal">False</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">any</span>(l))</span><br><span class="line"></span><br><span class="line">l = [<span class="number">0</span>, <span class="literal">False</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">any</span>(l))</span><br><span class="line"></span><br><span class="line">l = []</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">any</span>(l))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-iter">Python iter()</h2>
<p>python <strong>iter()</strong> 函数用于返回迭代器对象。它创建一个可以一次迭代一个元素的对象。</p>
<p><strong>Python iter()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># list of numbers</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">listIter = <span class="built_in">iter</span>(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># prints &#x27;1&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(listIter))</span><br><span class="line"></span><br><span class="line"><span class="comment"># prints &#x27;2&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(listIter))</span><br><span class="line"></span><br><span class="line"><span class="comment"># prints &#x27;3&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(listIter))</span><br><span class="line"></span><br><span class="line"><span class="comment"># prints &#x27;4&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(listIter))</span><br><span class="line"></span><br><span class="line"><span class="comment"># prints &#x27;5&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(listIter))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-len">Python len()</h2>
<p>python <strong>len()</strong> 函数用于返回对象的长度(项数)。</p>
<p><strong>Python len()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">strA = <span class="string">&#x27;Python&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(strA))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Python-list">Python list()</h2>
<p>python <strong>list()</strong> 用 python 创建一个列表。</p>
<p><strong>Python list()示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># empty list</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment"># string</span></span><br><span class="line">String = <span class="string">&#x27;abcde&#x27;</span>     </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(String))</span><br><span class="line"></span><br><span class="line"><span class="comment"># tuple</span></span><br><span class="line"><span class="type">Tuple</span> = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="type">Tuple</span>))</span><br><span class="line"><span class="comment"># list</span></span><br><span class="line"><span class="type">List</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="type">List</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[]</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-locals">Python locals()</h2>
<p>python <strong>locals()</strong> 方法更新并返回当前本地符号表的字典。</p>
<p>一个<strong>符号表</strong>被定义为一个数据结构，它包含了关于程序的所有必要信息。它包括变量名、方法、类等。</p>
<p><strong>Python locals()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">localsAbsent</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">locals</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">localsPresent</span>():</span><br><span class="line">    present = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">locals</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;localsNotPresent:&#x27;</span>, localsAbsent())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;localsPresent:&#x27;</span>, localsPresent())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">localsAbsent: &#123;&#125;</span><br><span class="line">localsPresent: &#123;<span class="string">&#x27;present&#x27;</span>: <span class="literal">True</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-map">Python map()</h2>
<p>python <strong>map()</strong> 函数用于将给定的函数应用于 iterable(列表、元组等)的每个项目后，返回结果列表。).</p>
<p><strong>Python map()功能示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calculateAddition</span>(<span class="params">n</span>):</span><br><span class="line">  <span class="keyword">return</span> n+n</span><br><span class="line"></span><br><span class="line">numbers = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">result = <span class="built_in">map</span>(calculateAddition, numbers)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># converting map object to set</span></span><br><span class="line">numbersAddition = <span class="built_in">set</span>(result)</span><br><span class="line"><span class="built_in">print</span>(numbersAddition)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">map</span> <span class="built_in">object</span> at <span class="number">0x7fb04a6bec18</span>&gt;</span><br><span class="line">&#123;<span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-memoryview">Python memoryview()</h2>
<p>python <strong>memoryview()</strong> 函数返回给定参数的 memoryview 对象。</p>
<p><strong>Python memoryview()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#A random bytearray</span></span><br><span class="line">randomByteArray = <span class="built_in">bytearray</span>(<span class="string">&#x27;ABC&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">mv = <span class="built_in">memoryview</span>(randomByteArray)</span><br><span class="line"></span><br><span class="line"><span class="comment"># access the memory view&#x27;s zeroth index</span></span><br><span class="line"><span class="built_in">print</span>(mv[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># It create byte from memory view</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bytes</span>(mv[<span class="number">0</span>:<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># It create list from memory view</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(mv[<span class="number">0</span>:<span class="number">3</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">65</span></span><br><span class="line"><span class="string">b&#x27;AB&#x27;</span></span><br><span class="line">[<span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-object">Python object()</h2>
<p>python **object()**返回一个空对象。它是所有类的基础，保存所有类默认的内置属性和方法。</p>
<p><strong>Python object()示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">python = <span class="built_in">object</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(python))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(python))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;object&#x27;</span>&gt;</span><br><span class="line">[<span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-open">Python open()</h2>
<p>python <strong>open()</strong> 函数打开文件并返回相应的文件对象。</p>
<p><strong>Python open()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># opens python.text file of the current directory</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;python.txt&quot;</span>)</span><br><span class="line"><span class="comment"># specifying full path</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;C:/Python33/README.txt&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Since the mode <span class="keyword">is</span> omitted, the file <span class="keyword">is</span> opened <span class="keyword">in</span> <span class="string">&#x27;r&#x27;</span> mode; opens <span class="keyword">for</span> reading.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-chr">Python chr()</h2>
<p>Python <strong>chr()</strong> 函数用于获取一个字符串，该字符串表示一个指向 Unicode 代码整数的字符。例如，chr(97)返回字符串“a”。此函数接受整数参数，如果超出指定范围，将引发错误。参数的标准范围是从 0 到 1，114，111。</p>
<p><strong>Python chr()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">result = <span class="built_in">chr</span>(<span class="number">102</span>) <span class="comment"># It returns string representation of a char</span></span><br><span class="line">result2 = <span class="built_in">chr</span>(<span class="number">112</span>)</span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(result2)</span><br><span class="line"><span class="comment"># Verify, is it string type?</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;is it string type:&quot;</span>, <span class="built_in">type</span>(result) <span class="keyword">is</span> <span class="built_in">str</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ValueError: <span class="built_in">chr</span>() arg <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x110000</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-complex">Python complex()</h2>
<p>Python <strong>complex()</strong> 函数用于将数字或字符串转换为复数。此方法接受两个可选参数并返回一个复数。第一个参数称为实部，第二个称为虚部。</p>
<p><strong>Python complex()示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python complex() function example</span></span><br><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">a = <span class="built_in">complex</span>(<span class="number">1</span>) <span class="comment"># Passing single parameter</span></span><br><span class="line">b = <span class="built_in">complex</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="comment"># Passing both parameters</span></span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="number">1.5</span>+<span class="number">0j</span>)</span><br><span class="line">(<span class="number">1.5</span>+<span class="number">2.2j</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-delattr">Python delattr()</h2>
<p>Python <strong>delattr()</strong> 函数用于从类中删除一个属性。它需要两个参数，第一个是类的对象，第二个是我们想要删除的属性。删除属性后，它在类中不再可用，如果尝试使用类对象调用它，将引发错误。</p>
<p><strong>Python delattr()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="built_in">id</span> = <span class="number">101</span></span><br><span class="line">    name = <span class="string">&quot;Pranshu&quot;</span></span><br><span class="line">    email = <span class="string">&quot;pranshu@abc.com&quot;</span></span><br><span class="line"><span class="comment"># Declaring function</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getinfo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.<span class="built_in">id</span>, self.name, self.email)</span><br><span class="line">s = Student()</span><br><span class="line">s.getinfo()</span><br><span class="line"><span class="built_in">delattr</span>(Student,<span class="string">&#x27;course&#x27;</span>) <span class="comment"># Removing attribute which is not available</span></span><br><span class="line">s.getinfo() <span class="comment"># error: throws an error</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">101</span> Pranshu [email protected]</span><br><span class="line">AttributeError: course</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-dir">Python dir()</h2>
<p>Python <strong>dir()</strong> 函数返回当前局部范围内的名称列表。如果调用方法的对象有一个名为 <strong>dir</strong>()的方法，将调用该方法，并且必须返回属性列表。它只接受一个对象类型参数。</p>
<p><strong>Python dir()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">att = <span class="built_in">dir</span>()</span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(att)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;__annotations__&#x27;</span>, <span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;__cached__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__file__&#x27;</span>, <span class="string">&#x27;__loader__&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;__spec__&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-divmod">Python divmod()</h2>
<p>Python <strong>divmod()</strong> 函数用来求两个数的余数和商。这个函数接受两个数字参数并返回一个元组。两个参数都是必需的，并且都是数字</p>
<p><strong>Python divmod()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python divmod() function example</span></span><br><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">result = <span class="built_in">divmod</span>(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="number">5</span>, <span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-enumerate">Python enumerate()</h2>
<p>Python <strong>enumerate()</strong> 函数返回一个枚举对象。它需要两个参数，第一个是元素序列，第二个是序列的起始索引。我们可以通过循环或 next()方法按顺序获取元素。</p>
<p><strong>Python enumerate()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">result = <span class="built_in">enumerate</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(result))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">enumerate</span> <span class="built_in">object</span> at <span class="number">0x7ff641093d80</span>&gt;</span><br><span class="line">[(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-dict">Python dict()</h2>
<p>Python <strong>dict()</strong> 函数是一个创建字典的构造器。Python 字典提供了三种不同的构造器来创建字典:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>如果没有传递参数，它将创建一个空字典。</p>
</li>
<li class="lvl-4">
<p>如果给定了位置参数，将使用相同的键值对创建字典。否则，传递一个可迭代对象。</p>
</li>
<li class="lvl-4">
<p>如果给定了关键字参数，关键字参数及其值将被添加到根据位置参数创建的字典中。</p>
</li>
</ul>
<p><strong>Python dict()示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">result = <span class="built_in">dict</span>() <span class="comment"># returns an empty dictionary</span></span><br><span class="line">result2 = <span class="built_in">dict</span>(a=<span class="number">1</span>,b=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(result2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;&#125;</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-filter">Python filter()</h2>
<p>Python <strong>filter()</strong> 函数用于获取过滤后的元素。这个函数有两个参数，第一个是函数，第二个是可迭代的。过滤器函数返回可迭代对象的那些元素的序列，对于这些元素，函数返回<strong>真值</strong>。</p>
<p>第一个参数可以是 <strong>none</strong> ，如果函数不可用并且只返回 <strong>true</strong> 的元素。</p>
<p><strong>Python filter()功能示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python filter() function example</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">filterdata</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> x&gt;<span class="number">5</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">result = <span class="built_in">filter</span>(filterdata,(<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>))</span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(result))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="number">6</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-hash">Python hash()</h2>
<p>Python <strong>hash()</strong> 函数用于获取一个对象的哈希值。Python 使用哈希算法计算哈希值。哈希值是整数，用于在字典查找过程中比较字典键。我们只能哈希下面给出的类型:</p>
<p><strong>Hassable 类型:</strong>* bool * int * long * float * string * Unicode * tuple * code 对象。</p>
<p><strong>Python hash()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">result = <span class="built_in">hash</span>(<span class="number">21</span>) <span class="comment"># integer value</span></span><br><span class="line">result2 = <span class="built_in">hash</span>(<span class="number">22.2</span>) <span class="comment"># decimal value</span></span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(result2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">461168601842737174</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-help">Python help()</h2>
<p>Python <strong>help()</strong> 函数用于获取调用过程中传递的对象相关的帮助。它接受一个可选参数并返回帮助信息。如果没有给出参数，它会显示 Python 帮助控制台。它在内部调用 python 的帮助函数。</p>
<p><strong>Python help()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">info = <span class="built_in">help</span>() <span class="comment"># No argument</span></span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(info)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Welcome to Python <span class="number">3.5</span><span class="string">&#x27;s help utility!</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-min">Python min()</h2>
<p>Python <strong>min()</strong> 函数用于从集合中获取最小的元素。这个函数接受两个参数，第一个是元素的集合，第二个是 key，并返回集合中最小的元素。</p>
<p><strong>Python min()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">small = <span class="built_in">min</span>(<span class="number">2225</span>,<span class="number">325</span>,<span class="number">2025</span>) <span class="comment"># returns smallest element</span></span><br><span class="line">small2 = <span class="built_in">min</span>(<span class="number">1000.25</span>,<span class="number">2025.35</span>,<span class="number">5625.36</span>,<span class="number">10052.50</span>)</span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(small)</span><br><span class="line"><span class="built_in">print</span>(small2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">325</span></span><br><span class="line"><span class="number">1000.25</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-set">Python set()</h2>
<p>在 python 中，集合是一个内置类，这个函数是这个类的构造器。它用于使用调用期间传递的元素创建新的集合。它将一个可迭代对象作为参数，并返回一个新的 set 对象。</p>
<p><strong>Python set()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">result = <span class="built_in">set</span>() <span class="comment"># empty set</span></span><br><span class="line">result2 = <span class="built_in">set</span>(<span class="string">&#x27;12&#x27;</span>)</span><br><span class="line">result3 = <span class="built_in">set</span>(<span class="string">&#x27;javatpoint&#x27;</span>)</span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(result2)</span><br><span class="line"><span class="built_in">print</span>(result3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>()</span><br><span class="line">&#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-hex">Python hex()</h2>
<p>Python <strong>hex()</strong> 函数用于生成一个整数参数的 hex 值。它接受一个整数参数，并返回一个转换为十六进制字符串的整数。在这种情况下，我们希望得到一个浮点的十六进制值，然后使用 float.hex()函数。</p>
<p><strong>Python hex()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">result = <span class="built_in">hex</span>(<span class="number">1</span>) </span><br><span class="line"><span class="comment"># integer value</span></span><br><span class="line">result2 = <span class="built_in">hex</span>(<span class="number">342</span>) </span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(result2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">0x1</span></span><br><span class="line"><span class="number">0x156</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-id">Python id()</h2>
<p>Python <strong>id()</strong> 函数返回一个对象的标识。这是一个整数，保证是唯一的。该函数将一个参数作为一个对象，并返回一个代表身份的唯一整数。具有非重叠生存期的两个对象可能具有相同的 id()值。</p>
<p><strong>Python id()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">val = <span class="built_in">id</span>(<span class="string">&quot;Javatpoint&quot;</span>) <span class="comment"># string object</span></span><br><span class="line">val2 = <span class="built_in">id</span>(<span class="number">1200</span>) <span class="comment"># integer object</span></span><br><span class="line">val3 = <span class="built_in">id</span>([<span class="number">25</span>,<span class="number">336</span>,<span class="number">95</span>,<span class="number">236</span>,<span class="number">92</span>,<span class="number">3225</span>]) <span class="comment"># List object</span></span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(val)</span><br><span class="line"><span class="built_in">print</span>(val2)</span><br><span class="line"><span class="built_in">print</span>(val3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">139963782059696</span></span><br><span class="line"><span class="number">139963805666864</span></span><br><span class="line"><span class="number">139963781994504</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-setattr">Python setattr()</h2>
<p>Python <strong>setattr()</strong> 函数用于为对象的属性设置一个值。它接受三个参数，即一个对象、一个字符串和一个任意值，并且不返回任何值。当我们想给一个对象添加一个新的属性并给它设置一个值时，这是很有帮助的。</p>
<p><strong>Python setattr()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="built_in">id</span> = <span class="number">0</span></span><br><span class="line">    name = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">id</span>, name</span>):</span><br><span class="line">        self.<span class="built_in">id</span> = <span class="built_in">id</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">student = Student(<span class="number">102</span>,<span class="string">&quot;Sohan&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(student.<span class="built_in">id</span>)</span><br><span class="line"><span class="built_in">print</span>(student.name)</span><br><span class="line"><span class="comment">#print(student.email) product error</span></span><br><span class="line"><span class="built_in">setattr</span>(student, <span class="string">&#x27;email&#x27;</span>,<span class="string">&#x27;sohan@abc.com&#x27;</span>) <span class="comment"># adding new attribute</span></span><br><span class="line"><span class="built_in">print</span>(student.email)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">102</span></span><br><span class="line">Sohan</span><br><span class="line">[email protected]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-slice">Python slice()</h2>
<p>Python <strong>slice()</strong> 函数用于从元素集合中获取元素的切片。Python 提供了两个重载切片函数。第一个函数接受单个参数，而第二个函数接受三个参数并返回一个 slice 对象。这个切片对象可以用来获取集合的一个子部分。</p>
<p><strong>Python slice()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">result = <span class="built_in">slice</span>(<span class="number">5</span>) <span class="comment"># returns slice object</span></span><br><span class="line">result2 = <span class="built_in">slice</span>(<span class="number">0</span>,<span class="number">5</span>,<span class="number">3</span>) <span class="comment"># returns slice object</span></span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(result2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">slice</span>(<span class="literal">None</span>, <span class="number">5</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="built_in">slice</span>(<span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-sorted">Python sorted()</h2>
<p>Python <strong>sorted()</strong> 函数用于排序元素。默认情况下，它按升序排序元素，但也可以按降序进行排序。它接受四个参数，并按排序顺序返回一个集合。就字典而言，它只排序键，而不排序值。</p>
<p><strong>Python sorted()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;javatpoint&quot;</span> <span class="comment"># declaring string</span></span><br><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">sorted1 = <span class="built_in">sorted</span>(<span class="built_in">str</span>) <span class="comment"># sorting string</span></span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(sorted1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;v&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-next">Python next()</h2>
<p>Python <strong>next()</strong> 函数用于从集合中获取下一项。它接受两个参数，即迭代器和默认值，并返回一个元素。</p>
<p>这个方法调用迭代器，如果没有项目，就会抛出一个错误。为了避免错误，我们可以设置一个默认值。</p>
<p><strong>Python next()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">number = <span class="built_in">iter</span>([<span class="number">256</span>, <span class="number">32</span>, <span class="number">82</span>]) <span class="comment"># Creating iterator</span></span><br><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">item = <span class="built_in">next</span>(number) </span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(item)</span><br><span class="line"><span class="comment"># second item</span></span><br><span class="line">item = <span class="built_in">next</span>(number)</span><br><span class="line"><span class="built_in">print</span>(item)</span><br><span class="line"><span class="comment"># third item</span></span><br><span class="line">item = <span class="built_in">next</span>(number)</span><br><span class="line"><span class="built_in">print</span>(item)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">256</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">82</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-input">Python input()</h2>
<p>Python <strong>input()</strong> 函数用于获取用户的输入。它提示用户输入并读取一行。读取数据后，它将其转换为字符串并返回。如果读取电渗流，它会抛出一个错误 <strong>EOFError</strong> 。</p>
<p><strong>Python input()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">val = <span class="built_in">input</span>(<span class="string">&quot;Enter a value: &quot;</span>)</span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;You entered:&quot;</span>,val)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter a value: <span class="number">45</span></span><br><span class="line">You entered: <span class="number">45</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-int">Python int()</h2>
<p>Python <strong>int()</strong> 函数用于获取整数值。它返回一个转换成整数的表达式。如果参数是浮点型的，转换会截断数字。如果参数在整数范围之外，则它会将数字转换为长类型。</p>
<p>如果数字不是数字或者给定了基数，则该数字必须是字符串。</p>
<p><strong>Python int()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">val = <span class="built_in">int</span>(<span class="number">10</span>) <span class="comment"># integer value</span></span><br><span class="line">val2 = <span class="built_in">int</span>(<span class="number">10.52</span>) <span class="comment"># float value</span></span><br><span class="line">val3 = <span class="built_in">int</span>(<span class="string">&#x27;10&#x27;</span>) <span class="comment"># string value</span></span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;integer values :&quot;</span>,val, val2, val3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">integer values : <span class="number">10</span> <span class="number">10</span> <span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-isinstance">Python isinstance()</h2>
<p>Python <strong>isinstance()</strong> 函数用于检查给定的对象是否是该类的实例。如果对象属于该类，它将返回 true。否则返回假。如果类是子类，它也会返回 true。</p>
<p><strong>isinstance()</strong> 函数接受两个参数，即对象和 classinfo，然后返回 True 或 False。</p>
<p><strong>Python isinstance()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="built_in">id</span> = <span class="number">101</span></span><br><span class="line">    name = <span class="string">&quot;John&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">id</span>, name</span>):</span><br><span class="line">        self.<span class="built_in">id</span>=<span class="built_in">id</span></span><br><span class="line">        self.name=name</span><br><span class="line"></span><br><span class="line">student = Student(<span class="number">1010</span>,<span class="string">&quot;John&quot;</span>)</span><br><span class="line">lst = [<span class="number">12</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">767</span>]</span><br><span class="line"><span class="comment"># Calling function </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(student, Student)) <span class="comment"># isinstance of Student class</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(lst, Student))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-oct">Python oct()</h2>
<p>Python <strong>oct()</strong> 函数用于获取一个整数的八进制值。此方法接受一个参数，并返回一个转换为八进制字符串的整数。如果参数类型不是整数，它会抛出一个错误<strong>类型错误</strong>。</p>
<p><strong>Python oct()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Calling function</span></span><br><span class="line">val = <span class="built_in">oct</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># Displaying result</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Octal value of 10:&quot;</span>,val)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Octal value of <span class="number">10</span>: <span class="number">0o12</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-order">Python order()</h2>
<p>python**order()**函数返回一个整数，代表给定 Unicode 字符的 Unicode 代码点。</p>
<p><strong>Python order()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Code point of an integer</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&#x27;8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Code point of an alphabet </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&#x27;R&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Code point of a character</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&#x27;&amp;&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">56</span></span><br><span class="line"><span class="number">82</span></span><br><span class="line"><span class="number">38</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-pow">Python pow()</h2>
<p>python <strong>pow()</strong> 函数用于计算一个数的幂。它返回 x 的 y 次方，如果给定第三个自变量(z)，它返回 x 的 y 模 z 次方，即(x，y) % z。</p>
<p><strong>Python pow()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># positive x, positive y (x**y)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">pow</span>(<span class="number">4</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># negative x, positive y</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">pow</span>(-<span class="number">4</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># positive x, negative y (x**-y)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">pow</span>(<span class="number">4</span>, -<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># negative x, negative y</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">pow</span>(-<span class="number">4</span>, -<span class="number">2</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">0.0625</span></span><br><span class="line"><span class="number">0.0625</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-print">Python print()</h2>
<p>python <strong>print()</strong> 函数将给定对象打印到屏幕或其他标准输出设备上。</p>
<p><strong>Python print()功能示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Python is programming language.&quot;</span>)</span><br><span class="line"></span><br><span class="line">x = <span class="number">7</span></span><br><span class="line"><span class="comment"># Two objects passed</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x =&quot;</span>, x)</span><br><span class="line"></span><br><span class="line">y = x</span><br><span class="line"><span class="comment"># Three objects passed</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x =&#x27;</span>, x, <span class="string">&#x27;= y&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Python <span class="keyword">is</span> programming language.</span><br><span class="line">x = <span class="number">7</span></span><br><span class="line">x = <span class="number">7</span> = y</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-range">Python range()</h2>
<p>python <strong>range()</strong> 函数返回一个不可变的数字序列，默认情况下从 0 开始，递增 1(默认情况下)，以指定的数字结束。</p>
<p><strong>Python range()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># empty range</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># using the range(stop)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">4</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># using the range(start, stop)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">7</span> )))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-reversed">Python reversed()</h2>
<p>python <strong>reversed()</strong> 函数返回给定序列的反向迭代器。</p>
<p><strong>Python reversed()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># for string</span></span><br><span class="line">String = <span class="string">&#x27;Java&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">reversed</span>(String)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># for tuple</span></span><br><span class="line"><span class="type">Tuple</span> = (<span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">reversed</span>(<span class="type">Tuple</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># for range</span></span><br><span class="line">Range = <span class="built_in">range</span>(<span class="number">8</span>, <span class="number">12</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">reversed</span>(Range)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># for list</span></span><br><span class="line"><span class="type">List</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">reversed</span>(<span class="type">List</span>)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;J&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;J&#x27;</span>]</span><br><span class="line">[<span class="number">11</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-round">Python round()</h2>
<p>python <strong>round()</strong> 函数对一个数字的数字进行舍入，并返回浮点数。</p>
<p><strong>Python round()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  for integers</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#  for floating point</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(<span class="number">10.8</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#  even choice</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(<span class="number">6.6</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-issubclass">Python issubclass()</h2>
<p>如果对象参数(第一个参数)是第二个类(第二个参数)的子类，python <strong>issubclass()</strong> 函数返回 true。</p>
<p><strong>Python issubclass()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">rectangleType</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Rectangle is a &#x27;</span>, rectangleType)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span>(<span class="title class_ inherited__">Rectangle</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    Rectangle.__init__(<span class="string">&#x27;square&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(Square, Rectangle))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(Square, <span class="built_in">list</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(Square, (<span class="built_in">list</span>, Rectangle)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(Rectangle, (<span class="built_in">list</span>, Rectangle)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-str">Python str()</h2>
<p>python <strong>str()</strong> 将指定的值转换为字符串。</p>
<p><strong>Python str()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;4&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Python-tuple">Python tuple()</h2>
<p>python <strong>tuple()</strong> 函数用于创建 tuple 对象。</p>
<p><strong>Python tuple()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">t1 = <span class="built_in">tuple</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;t1=&#x27;</span>, t1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># creating a tuple from a list</span></span><br><span class="line">t2 = <span class="built_in">tuple</span>([<span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;t2=&#x27;</span>, t2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># creating a tuple from a string</span></span><br><span class="line">t1 = <span class="built_in">tuple</span>(<span class="string">&#x27;Java&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;t1=&#x27;</span>,t1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># creating a tuple from a dictionary</span></span><br><span class="line">t1 = <span class="built_in">tuple</span>(&#123;<span class="number">4</span>: <span class="string">&#x27;four&#x27;</span>, <span class="number">5</span>: <span class="string">&#x27;five&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;t1=&#x27;</span>,t1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">t1= ()</span><br><span class="line">t2= (<span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>)</span><br><span class="line">t1= (<span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">t1= (<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-type">Python type()</h2>
<p>python **type()**返回指定对象的类型，如果单个参数被传递给内置函数的类型()。如果传递了三个参数，那么它将返回一个新的类型对象。</p>
<p><strong>Python type()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> = [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="type">List</span>))</span><br><span class="line"></span><br><span class="line"><span class="type">Dict</span> = &#123;<span class="number">4</span>: <span class="string">&#x27;four&#x27;</span>, <span class="number">5</span>: <span class="string">&#x27;five&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="type">Dict</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span>:</span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">InstanceOfPython = Python()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(InstanceOfPython))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Python&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-vars">Python vars()</h2>
<p>python <strong>vars()</strong> 函数返回给定对象的 <strong>dict</strong> 属性。</p>
<p><strong>Python vars()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x = <span class="number">7</span>, y = <span class="number">9</span></span>):</span><br><span class="line">    self.x = x</span><br><span class="line">    self.y = y</span><br><span class="line"></span><br><span class="line">InstanceOfPython = Python()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">vars</span>(InstanceOfPython))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;y&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;x&#x27;</span>: <span class="number">7</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-zip">Python zip()</h2>
<p>python <strong>zip()</strong> 函数返回一个 zip 对象，该对象映射多个容器的相似索引。它接受 iterables(可以为零或更多)，使其成为迭代器，根据传递的 iterables 聚合元素，并返回元组的迭代器。</p>
<p><strong>Python zip()函数示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">numList = [<span class="number">4</span>,<span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">strList = [<span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;five&#x27;</span>, <span class="string">&#x27;six&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># No iterables are passed</span></span><br><span class="line">result = <span class="built_in">zip</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Converting itertor to list</span></span><br><span class="line">resultList = <span class="built_in">list</span>(result)</span><br><span class="line"><span class="built_in">print</span>(resultList)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Two iterables are passed</span></span><br><span class="line">result = <span class="built_in">zip</span>(numList, strList)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Converting itertor to set</span></span><br><span class="line">resultSet = <span class="built_in">set</span>(result)</span><br><span class="line"><span class="built_in">print</span>(resultSet)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[]</span><br><span class="line">&#123;(<span class="number">5</span>, <span class="string">&#x27;five&#x27;</span>), (<span class="number">4</span>, <span class="string">&#x27;four&#x27;</span>), (<span class="number">6</span>, <span class="string">&#x27;six&#x27;</span>)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-built-in-functions">https://www.javatpoint.com/python-built-in-functions</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 函数</title>
    <url>/posts/7abf7b36.html</url>
    <content><![CDATA[<h1>Python 函数</h1>
<p>函数是应用最重要的方面。一个函数可以被定义为可重用代码的组织块，它可以在任何需要的时候被调用。</p>
<p>Python 允许我们将一个大型程序划分为称为函数的基本构建块。该函数包含由{}括起来的一组编程语句。一个函数可以被多次调用，为 Python 程序提供可重用性和模块化。</p>
<p>这个函数帮助程序员把程序分成更小的部分。它非常有效地组织了代码，避免了代码的重复。随着程序的增长，函数使程序更有条理。</p>
<p>Python 为我们提供了各种内置功能，如 <strong>range()</strong> 或 <strong>print()</strong> 。虽然，用户可以创建它的函数，这些函数可以称为用户定义函数。</p>
<p>主要有两种功能。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>User-Defined Function</strong> -用户自定义功能是由<strong>用户</strong>为执行特定任务而定义的功能。</p>
</li>
<li class="lvl-4">
<p><strong>内置函数</strong> -内置函数是那些在 Python 中<strong>预定义</strong>的函数。</p>
</li>
</ul>
<p>在本教程中，我们将讨论用户定义函数。</p>
<h2 id="Python-中函数的优势">Python 中函数的优势</h2>
<p>Python 函数有以下优点。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>使用函数，我们可以避免在程序中一次又一次地重写相同的逻辑/代码。</p>
</li>
<li class="lvl-4">
<p>我们可以在一个程序中多次调用 Python 函数，也可以在程序的任何地方调用。</p>
</li>
<li class="lvl-4">
<p>当一个大型 Python 程序被分成多个函数时，我们可以很容易地跟踪它。</p>
</li>
<li class="lvl-4">
<p>可重用性是 Python 函数的主要成就。</p>
</li>
<li class="lvl-4">
<p>然而，在 Python 程序中，函数调用总是开销很大。</p>
</li>
</ul>
<h3 id="创建函数">创建函数</h3>
<p>Python 提供了 <strong>def</strong> 关键字来定义函数。下面给出了定义函数的语法。</p>
<p><strong>语法:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>(<span class="params">parameters</span>):</span><br><span class="line">      function_block</span><br><span class="line"><span class="keyword">return</span> expression</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>让我们理解函数定义的语法。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>def</strong> 关键字和函数名一起用于定义函数。</p>
</li>
<li class="lvl-4">
<p>标识符规则必须遵循函数名。</p>
</li>
<li class="lvl-4">
<p>函数接受参数(参数)，它们可以是可选的。</p>
</li>
<li class="lvl-4">
<p>功能块以冒号(:)开头，块语句必须在同一缩进处。</p>
</li>
<li class="lvl-4">
<p><strong>return</strong> 语句用于返回值。一个功能只能有一个<strong>返回</strong></p>
</li>
</ul>
<h3 id="函数调用">函数调用</h3>
<p>在 Python 中，创建函数后，我们可以从另一个函数调用它。函数必须在函数调用之前定义；否则，Python 解释器会给出一个错误。要调用该函数，请使用后跟括号的函数名。</p>
<p>考虑下面一个简单示例的例子，该示例打印消息“Hello World”。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#function definition</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)  </span><br><span class="line"><span class="comment"># function calling</span></span><br><span class="line">hello_world()    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">hello world</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="return">return</h2>
<p>return 语句用在函数的末尾，并返回函数的结果。它终止函数的执行，并将结果传送到调用函数的地方。return 语句不能在函数外使用。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> [expression_list]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它可以包含表达式，该表达式将被求值并将值返回给调用者函数。如果 return 语句没有表达式或者本身不存在于函数中，那么它返回 <strong>None</strong> 对象。</p>
<p>考虑以下示例:</p>
<h3 id="例-1-10">例 1</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Defining function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>():</span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    b = <span class="number">20</span></span><br><span class="line">    c = a+b</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"><span class="comment"># calling sum() function in print statement</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The sum is:&quot;</span>,<span class="built_in">sum</span>())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The <span class="built_in">sum</span> <span class="keyword">is</span>: <span class="number">30</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们定义了名为 <strong>sum</strong>的函数，它有一个语句 <strong>c = a+b</strong>  计算给定值，结果由 return 语句返回给调用者函数。</p>
<h3 id="示例-2-创建没有return语句的函数">示例 2 创建没有<code>return</code>语句的函数</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Defining function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>():</span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    b = <span class="number">20</span></span><br><span class="line">    c = a+b</span><br><span class="line"><span class="comment"># calling sum() function in print statement</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们定义了相同的没有 return 语句的函数，因为我们可以看到 <strong>sum()</strong> 函数向调用者函数返回了 <strong>None</strong> 对象。</p>
<h2 id="函数中的参数">函数中的参数</h2>
<p>参数是可以传递给函数的信息类型。参数在括号中指定。我们可以传递任意数量的参数，但是它们必须用逗号隔开。</p>
<p>考虑以下示例，其中包含一个接受字符串作为参数的函数。</p>
<h3 id="例-1-11">例 1</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#defining the function  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span> (name):  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hi &quot;</span>,name) </span><br><span class="line"><span class="comment">#calling the function   </span></span><br><span class="line">func(<span class="string">&quot;Devansh&quot;</span>)   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Hi Devansh</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例-2-8">例 2</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Python function to calculate the sum of two variables   </span></span><br><span class="line"><span class="comment">#defining the function  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span> (a,b):  </span><br><span class="line">    <span class="keyword">return</span> a+b;  </span><br><span class="line"></span><br><span class="line"><span class="comment">#taking values from the user  </span></span><br><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter a: &quot;</span>))  </span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter b: &quot;</span>))  </span><br><span class="line"></span><br><span class="line"><span class="comment">#printing the sum of a and b  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sum = &quot;</span>,<span class="built_in">sum</span>(a,b))  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter a: <span class="number">10</span></span><br><span class="line">Enter b: <span class="number">20</span></span><br><span class="line">Sum =  <span class="number">30</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Python-中的引用调用">Python 中的引用调用</h2>
<p>在 Python 中，引用调用意味着将实际值作为参数传递给函数。所有函数都是通过引用调用的，也就是说，对函数内部的引用所做的所有更改都会恢复到引用所引用的原始值。</p>
<h3 id="示例-1-传递不可变对象-list">示例 1 传递不可变对象(list)</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#defining the function  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_list</span>(<span class="params">list1</span>):  </span><br><span class="line">    list1.append(<span class="number">20</span>) </span><br><span class="line">    list1.append(<span class="number">30</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;list inside function = &quot;</span>,list1)  </span><br><span class="line"></span><br><span class="line"><span class="comment">#defining the list  </span></span><br><span class="line">list1 = [<span class="number">10</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>]  </span><br><span class="line"></span><br><span class="line"><span class="comment">#calling the function   </span></span><br><span class="line">change_list(list1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;list outside function = &quot;</span>,list1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> inside function =  [<span class="number">10</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="built_in">list</span> outside function =  [<span class="number">10</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="示例-2-传递可变对象-str">示例 2 传递可变对象(str)</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#defining the function  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_string</span> (<span class="built_in">str</span>):  </span><br><span class="line">    <span class="built_in">str</span> = <span class="built_in">str</span> + <span class="string">&quot; Hows you &quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;printing the string inside function :&quot;</span>,<span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line">string1 = <span class="string">&quot;Hi I am there&quot;</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">#calling the function  </span></span><br><span class="line">change_string(string1)  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;printing the string outside function :&quot;</span>,string1)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">printing the string inside function : Hi I am there Hows you </span><br><span class="line">printing the string outside function : Hi I am there</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="参数类型">参数类型</h2>
<p>可能有几种类型的参数可以在函数调用时传递。</p>
<ol>
<li class="lvl-4">
<p>必需的参数</p>
</li>
<li class="lvl-4">
<p>关键字参数</p>
</li>
<li class="lvl-4">
<p>默认参数</p>
</li>
<li class="lvl-4">
<p>可变长度参数</p>
</li>
</ol>
<h3 id="必需的参数">必需的参数</h3>
<p>到目前为止，我们已经了解了 Python 中的函数调用。但是，我们可以在函数调用时提供参数。就所需参数而言，这些是在函数调用时需要传递的参数，它们在函数调用和函数定义中的位置完全匹配。如果函数调用中没有提供任何一个参数，或者参数的位置发生了变化，Python 解释器将显示错误。</p>
<p>考虑下面的例子。</p>
<p><strong>例 1</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">name</span>):  </span><br><span class="line">    message = <span class="string">&quot;Hi &quot;</span>+name</span><br><span class="line">    <span class="keyword">return</span> message</span><br><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;Enter the name:&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(func(name))  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the name: John</span><br><span class="line">Hi John</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例 2</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#the function simple_interest accepts three arguments and returns the simple interest accordingly  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">simple_interest</span>(<span class="params">p,t,r</span>):  </span><br><span class="line">    <span class="keyword">return</span> (p*t*r)/<span class="number">100</span>  </span><br><span class="line">p = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the principle amount? &quot;</span>))  </span><br><span class="line">r = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the rate of interest? &quot;</span>))  </span><br><span class="line">t = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the time in years? &quot;</span>))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Simple Interest: &quot;</span>,simple_interest(p,r,t))  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the principle amount: <span class="number">5000</span></span><br><span class="line">Enter the rate of interest: <span class="number">5</span></span><br><span class="line">Enter the time <span class="keyword">in</span> years: <span class="number">3</span></span><br><span class="line">Simple Interest:  <span class="number">750.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例 3</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#the function calculate returns the sum of two arguments a and b  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">a,b</span>):  </span><br><span class="line">    <span class="keyword">return</span> a+b  </span><br><span class="line">calculate(<span class="number">10</span>) <span class="comment"># this causes an error as we are missing a required arguments b.  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">TypeError: calculate() missing <span class="number">1</span> required positional argument: <span class="string">&#x27;b&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="默认参数">默认参数</h2>
<p>Python 允许我们在函数定义中初始化参数。如果在函数调用时没有提供任何参数的值，那么即使在函数调用时没有指定参数，也可以用定义中给出的值初始化该参数。</p>
<p><strong>例 1</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printme</span>(<span class="params">name,age=<span class="number">22</span></span>):  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My name is&quot;</span>,name,<span class="string">&quot;and age is&quot;</span>,age)  </span><br><span class="line">printme(name = <span class="string">&quot;john&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">My name <span class="keyword">is</span> John <span class="keyword">and</span> age <span class="keyword">is</span> <span class="number">22</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例 2</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printme</span>(<span class="params">name,age=<span class="number">22</span></span>):  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My name is&quot;</span>,name,<span class="string">&quot;and age is&quot;</span>,age)  </span><br><span class="line">printme(name = <span class="string">&quot;john&quot;</span>) <span class="comment">#the variable age is not passed into the function however the default value of age is considered in the function  </span></span><br><span class="line">printme(age = <span class="number">10</span>,name=<span class="string">&quot;David&quot;</span>) <span class="comment">#the value of age is overwritten here, 10 will be printed as age </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">My name <span class="keyword">is</span> john <span class="keyword">and</span> age <span class="keyword">is</span> <span class="number">22</span></span><br><span class="line">My name <span class="keyword">is</span> David <span class="keyword">and</span> age <span class="keyword">is</span> <span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="可变长度参数-参数">可变长度参数(*参数)</h3>
<p>在大型项目中，有时我们可能不知道要提前传递的参数数量。在这种情况下，Python 为我们提供了提供逗号分隔值的灵活性，这些值在函数调用时在内部被视为元组。通过使用可变长度参数，我们可以传递任意数量的参数。</p>
<p>然而，在函数定义中，我们使用 <em><strong>args</strong> (star)将变长参数定义为</em> &lt;变量名&gt;。</p>
<p>考虑下面的例子。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printme</span>(<span class="params">*names</span>):  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;type of passed argument is &quot;</span>,<span class="built_in">type</span>(names))  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;printing the passed arguments...&quot;</span>)  </span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:  </span><br><span class="line">        <span class="built_in">print</span>(name)  </span><br><span class="line">printme(<span class="string">&quot;john&quot;</span>,<span class="string">&quot;David&quot;</span>,<span class="string">&quot;smith&quot;</span>,<span class="string">&quot;nick&quot;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> of passed argument <span class="keyword">is</span>  &lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line">printing the passed arguments...</span><br><span class="line">john</span><br><span class="line">David</span><br><span class="line">smith</span><br><span class="line">nick</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们传递了<strong>name</strong> 作为变长参数。我们调用了函数，并传递了在内部被视为元组的值。元组是与列表相同的可迭代序列。为了打印给定值，我们迭代了用于循环的*<strong>参数名</strong>。</p>
<h3 id="关键字参数-kwargs">关键字参数(**kwargs)</h3>
<p>Python 允许我们使用关键字参数调用函数。这种函数调用将使我们能够以随机顺序传递参数。</p>
<p>参数的名称被视为关键字，并在函数调用和定义中匹配。如果找到相同的匹配，则在函数定义中复制参数的值。</p>
<p>考虑下面的例子。</p>
<p><strong>例 1</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#function func is called with the name and message as the keyword arguments  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">name,message</span>):  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;printing the message with&quot;</span>,name,<span class="string">&quot;and &quot;</span>,message)  </span><br><span class="line"></span><br><span class="line">    <span class="comment">#name and message is copied with the values John and hello respectively  </span></span><br><span class="line">    func(name = <span class="string">&quot;John&quot;</span>,message=<span class="string">&quot;hello&quot;</span>) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">printing the message <span class="keyword">with</span> John <span class="keyword">and</span>  hello</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例 2 在调用</strong>时提供不同顺序的值</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#The function simple_interest(p, t, r) is called with the keyword arguments the order of arguments doesn&#x27;t matter in this case  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">simple_interest</span>(<span class="params">p,t,r</span>):  </span><br><span class="line">    <span class="keyword">return</span> (p*t*r)/<span class="number">100</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Simple Interest: &quot;</span>,simple_interest(t=<span class="number">10</span>,r=<span class="number">10</span>,p=<span class="number">1900</span>))   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Simple Interest:  <span class="number">1900.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果我们在函数调用时提供不同的参数名称，将会抛出一个错误。</p>
<p>考虑下面的例子。</p>
<p><strong>例 3</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#The function simple_interest(p, t, r) is called with the keyword arguments.   </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">simple_interest</span>(<span class="params">p,t,r</span>):  </span><br><span class="line">    <span class="keyword">return</span> (p*t*r)/<span class="number">100</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># doesn&#x27;t find the exact match of the name of the arguments (keywords)    </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Simple Interest: &quot;</span>,simple_interest(time=<span class="number">10</span>,rate=<span class="number">10</span>,principle=<span class="number">1900</span>)) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">TypeError: simple_interest() got an unexpected keyword argument <span class="string">&#x27;time&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Python 允许我们在函数调用时提供所需参数和关键字参数的混合。但是，必需的参数不能在关键字参数之后给出，即一旦在函数调用中遇到关键字参数，以下参数也必须是关键字参数。</p>
<p>考虑下面的例子。</p>
<p><strong>例 4</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">name1,message,name2</span>):  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;printing the message with&quot;</span>,name1,<span class="string">&quot;,&quot;</span>,message,<span class="string">&quot;,and&quot;</span>,name2)  </span><br><span class="line"><span class="comment">#the first argument is not the keyword argument  </span></span><br><span class="line">func(<span class="string">&quot;John&quot;</span>,message=<span class="string">&quot;hello&quot;</span>,name2=<span class="string">&quot;David&quot;</span>) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">printing the message <span class="keyword">with</span> John , hello ,<span class="keyword">and</span> David</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面的示例将导致一个错误，因为在函数调用中传递了关键字和必需参数的不正确组合。</p>
<p><strong>例 5</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">name1,message,name2</span>): </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;printing the message with&quot;</span>,name1,<span class="string">&quot;,&quot;</span>,message,<span class="string">&quot;,and&quot;</span>,name2)  </span><br><span class="line">func(<span class="string">&quot;John&quot;</span>,message=<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;David&quot;</span>)      </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">SyntaxError: positional argument follows keyword argument</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Python 提供了传递多个关键字参数的工具，这些参数可以表示为 **<strong>kwargs</strong> 。它与 *<strong>args</strong> 相似，但它以字典格式存储参数。</p>
<p>当我们事先不知道参数的数量时，这种类型的参数是有用的。</p>
<p>考虑以下示例:</p>
<p><strong>示例 6:使用关键字参数</strong>的多个参数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">food</span>(<span class="params">**kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line">food(a=<span class="string">&quot;Apple&quot;</span>)</span><br><span class="line">food(fruits=<span class="string">&quot;Orange&quot;</span>, Vagitables=<span class="string">&quot;Carrot&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;Apple&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;fruits&#x27;</span>: <span class="string">&#x27;Orange&#x27;</span>, <span class="string">&#x27;Vagitables&#x27;</span>: <span class="string">&#x27;Carrot&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="变量的范围">变量的范围</h2>
<p>变量的范围取决于变量被声明的位置。程序的一部分中声明的变量可能无法被其他部分访问。</p>
<p>在 python 中，变量是用两种类型的作用域定义的。</p>
<ol>
<li class="lvl-4">
<p>全局变量</p>
</li>
<li class="lvl-4">
<p>局部变量</p>
</li>
</ol>
<p>任何函数外部定义的变量都具有全局作用域，而函数内部定义的变量具有局部作用域。</p>
<p>考虑下面的例子。</p>
<h3 id="示例-1-局部变量">示例 1 局部变量</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_message</span>():  </span><br><span class="line">    message = <span class="string">&quot;hello !! I am going to print a message.&quot;</span> <span class="comment"># the variable message is local to the function itself  </span></span><br><span class="line">    <span class="built_in">print</span>(message)  </span><br><span class="line">print_message()  </span><br><span class="line"><span class="built_in">print</span>(message) <span class="comment"># this will cause an error since a local variable cannot be accessible here.    </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">hello !! I am going to <span class="built_in">print</span> a message.</span><br><span class="line">  File <span class="string">&quot;/root/PycharmProjects/PythonTest/Test1.py&quot;</span>, line <span class="number">5</span>, <span class="keyword">in</span> </span><br><span class="line">    <span class="built_in">print</span>(message)</span><br><span class="line">NameError: name <span class="string">&#x27;message&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="示例-2-全局变量">示例 2 全局变量</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">*args</span>):  </span><br><span class="line">    <span class="built_in">sum</span>=<span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:  </span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span> +arg  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The sum is&quot;</span>,<span class="built_in">sum</span>)  </span><br><span class="line"><span class="built_in">sum</span>=<span class="number">0</span>  </span><br><span class="line">calculate(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>) <span class="comment">#60 will be printed as the sum  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Value of sum outside the function:&quot;</span>,<span class="built_in">sum</span>) <span class="comment"># 0 will be printed  Output:</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The <span class="built_in">sum</span> <span class="keyword">is</span> <span class="number">60</span></span><br><span class="line">Value of <span class="built_in">sum</span> outside the function: <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-functions">https://www.javatpoint.com/python-functions</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 列表</title>
    <url>/posts/95b8e516.html</url>
    <content><![CDATA[<h1>Python 列表</h1>
<p>Python 中的列表用于存储各种类型数据的序列。Python 列表是可变类型的，这意味着我们可以在它创建后修改它的元素。然而，Python 由六种能够存储序列的数据类型组成，但最常见和最可靠的类型是列表。</p>
<p>列表可以定义为不同类型的值或项的集合。列表中的项目用逗号(,)分隔，并用方括号[]括起来。</p>
<p>列表可以定义如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">L1 = [<span class="string">&quot;John&quot;</span>, <span class="number">102</span>, <span class="string">&quot;USA&quot;</span>]  </span><br><span class="line">L2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果我们尝试使用 type()函数打印 L1、L2 和 L3 的类型，那么它将显示为一个列表。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(L1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(L2))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="列表的特征">列表的特征</h3>
<p>该列表具有以下特征:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>名单是有序的。</p>
</li>
<li class="lvl-4">
<p>列表的元素可以通过索引来访问。</p>
</li>
<li class="lvl-4">
<p>列表是可变类型的。</p>
</li>
<li class="lvl-4">
<p>列表是可变类型。</p>
</li>
<li class="lvl-4">
<p>列表可以存储各种元素的数量。</p>
</li>
</ul>
<p>让我们检查第一个陈述，列表是有序的。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;Peter&quot;</span>,<span class="number">4.50</span>,<span class="string">&quot;Ricky&quot;</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="string">&quot;Peter&quot;</span>,<span class="number">4.50</span>,<span class="string">&quot;Ricky&quot;</span>,<span class="number">6</span>]</span><br><span class="line">a ==b</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>两个列表都由相同的元素组成，但是第二个列表改变了第五个元素的索引位置，这违反了列表的顺序。当比较两个列表时，它返回 false。</p>
<p>列表在生存期内保持元素的顺序。这就是为什么它是有序的对象集合。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>,<span class="string">&quot;Peter&quot;</span>, <span class="number">4.50</span>,<span class="string">&quot;Ricky&quot;</span>,<span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>,<span class="string">&quot;Peter&quot;</span>, <span class="number">4.50</span>,<span class="string">&quot;Ricky&quot;</span>,<span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">a == b</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>让我们详细看一下列表示例。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">emp = [<span class="string">&quot;John&quot;</span>, <span class="number">102</span>, <span class="string">&quot;USA&quot;</span>]   </span><br><span class="line">Dep1 = [<span class="string">&quot;CS&quot;</span>,<span class="number">10</span>]</span><br><span class="line">Dep2 = [<span class="string">&quot;IT&quot;</span>,<span class="number">11</span>]  </span><br><span class="line">HOD_CS = [<span class="number">10</span>,<span class="string">&quot;Mr. Holding&quot;</span>]  </span><br><span class="line">HOD_IT = [<span class="number">11</span>, <span class="string">&quot;Mr. Bewon&quot;</span>]  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;printing employee data...&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Name : %s, ID: %d, Country: %s&quot;</span>%(emp[<span class="number">0</span>],emp[<span class="number">1</span>],emp[<span class="number">2</span>]))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;printing departments...&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Department 1:\nName: %s, ID: %d\nDepartment 2:\nName: %s, ID: %s&quot;</span>%(Dep1[<span class="number">0</span>],Dep2[<span class="number">1</span>],Dep2[<span class="number">0</span>],Dep2[<span class="number">1</span>]))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;HOD Details ....&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;CS HOD Name: %s, Id: %d&quot;</span>%(HOD_CS[<span class="number">1</span>],HOD_CS[<span class="number">0</span>]))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;IT HOD Name: %s, Id: %d&quot;</span>%(HOD_IT[<span class="number">1</span>],HOD_IT[<span class="number">0</span>]))  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(emp),<span class="built_in">type</span>(Dep1),<span class="built_in">type</span>(Dep2),<span class="built_in">type</span>(HOD_CS),<span class="built_in">type</span>(HOD_IT))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">printing employee data...</span><br><span class="line">Name : John, ID: <span class="number">102</span>, Country: USA</span><br><span class="line">printing departments...</span><br><span class="line">Department <span class="number">1</span>:</span><br><span class="line">Name: CS, ID: <span class="number">11</span></span><br><span class="line">Department <span class="number">2</span>:</span><br><span class="line">Name: IT, ID: <span class="number">11</span></span><br><span class="line">HOD Details ....</span><br><span class="line">CS HOD Name: Mr. Holding, Id: <span class="number">10</span></span><br><span class="line">IT HOD Name: Mr. Bewon, Id: <span class="number">11</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们创建了包含员工和部门详细信息的列表，并打印了相应的详细信息。观察上面的代码，更好地理解列表的概念。</p>
<h2 id="列表索引和拆分">列表索引和拆分</h2>
<p>索引的处理方式与字符串的处理方式相同。可以使用 slice 运算符[]访问列表的元素。</p>
<p>索引从 0 开始，长度为- 1。列表的第一个元素存储在第 0 个索引处，列表的第二个元素存储在第 1 个索引处，依此类推。</p>
<p><img src="/img/cd09874c013575f9a7505a36176f8460.png" alt="Python Lists"></p>
<p>我们可以使用以下语法获取列表的子列表。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">list_varible(start:stop:step)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>开始</strong>表示列表的开始索引位置。</p>
</li>
<li class="lvl-4">
<p><strong>停止</strong>表示列表的最后一个索引位置。</p>
</li>
<li class="lvl-4">
<p><strong>步骤</strong>用于跳过<strong>开始:停止</strong>内的第<code>n</code>个元素</p>
</li>
</ul>
<p>考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">3</span>])</span><br><span class="line"><span class="comment"># Slicing the elements</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">0</span>:<span class="number">6</span>])</span><br><span class="line"><span class="comment"># By default the index value is 0 so its starts from the 0th element and go for index -1.</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[:])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">2</span>:<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">1</span>:<span class="number">6</span>:<span class="number">2</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>与其他语言不同，Python 还提供了使用负索引的灵活性。负指数从右边算起。列表的最后一个元素(最右边)的索引为-1；其相邻的左边元素出现在索引-2 处，以此类推，直到遇到最左边的元素。</p>
<p>让我们看看下面的例子，我们将使用负索引来访问列表的元素。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[-<span class="number">3</span>:])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[:-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[-<span class="number">3</span>:-<span class="number">1</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如上所述，我们可以通过使用负索引来获取元素。在上面的代码中，第一个 print 语句返回列表中最右边的元素。第二个 print 语句返回子列表，依此类推。</p>
<h2 id="更新列表值">更新列表值</h2>
<p>列表是 Python 中最通用的数据结构，因为它们是可变的，并且它们的值可以通过使用切片和赋值操作符来更新。</p>
<p>Python 还提供了 append()和 insert()方法，可用于向列表中添加值。</p>
<p>考虑以下示例来更新列表中的值。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]   </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)   </span><br><span class="line"><span class="comment"># It will assign value to the value to the second index </span></span><br><span class="line"><span class="built_in">list</span>[<span class="number">2</span>] = <span class="number">10</span> </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)  </span><br><span class="line"><span class="comment"># Adding multiple-element </span></span><br><span class="line"><span class="built_in">list</span>[<span class="number">1</span>:<span class="number">3</span>] = [<span class="number">89</span>, <span class="number">78</span>]   </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>) </span><br><span class="line"><span class="comment"># It will add value at the end of the list</span></span><br><span class="line"><span class="built_in">list</span>[-<span class="number">1</span>] = <span class="number">25</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">89</span>, <span class="number">78</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">89</span>, <span class="number">78</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">25</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以使用 <strong>del</strong> 关键字删除列表元素。如果我们不知道要从列表中删除哪个元素，Python 还为我们提供了 <strong>remove()</strong> 方法。</p>
<p>考虑以下示例来删除列表元素。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]   </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)   </span><br><span class="line"><span class="comment"># It will assign value to the value to second index </span></span><br><span class="line"><span class="built_in">list</span>[<span class="number">2</span>] = <span class="number">10</span> </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)  </span><br><span class="line"><span class="comment"># Adding multiple element </span></span><br><span class="line"><span class="built_in">list</span>[<span class="number">1</span>:<span class="number">3</span>] = [<span class="number">89</span>, <span class="number">78</span>]   </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>) </span><br><span class="line"><span class="comment"># It will add value at the end of the list</span></span><br><span class="line"><span class="built_in">list</span>[-<span class="number">1</span>] = <span class="number">25</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">89</span>, <span class="number">78</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">89</span>, <span class="number">78</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">25</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Python-列表操作">Python 列表操作</h2>
<p>串联(+)和重复(*)运算符的工作方式与它们处理字符串的方式相同。</p>
<h3 id="1-Repetition-重复">1. Repetition(重复)</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># repetition of list  </span></span><br><span class="line"><span class="comment"># declaring the list  </span></span><br><span class="line">list1 = [<span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>]  </span><br><span class="line"><span class="comment"># repetition operator *  </span></span><br><span class="line">l = list1 * <span class="number">2</span>  </span><br><span class="line"><span class="built_in">print</span>(l)  </span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>]</span><br></pre></td></tr></table></figure>
<h3 id="2-Concatenation-串联">2. Concatenation(串联)</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># concatenation of two lists  </span></span><br><span class="line"><span class="comment"># declaring the lists  </span></span><br><span class="line">list1 = [<span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>]  </span><br><span class="line">list2 = [<span class="number">9</span>, <span class="number">10</span>, <span class="number">32</span>, <span class="number">54</span>, <span class="number">86</span>]  </span><br><span class="line"><span class="comment"># concatenation operator +  </span></span><br><span class="line">l = list1 + list2  </span><br><span class="line"><span class="built_in">print</span>(l)  </span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">32</span>, <span class="number">54</span>, <span class="number">86</span>]</span><br></pre></td></tr></table></figure>
<h3 id="3-Length">3. Length</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># size of the list  </span></span><br><span class="line"><span class="comment"># declaring the list  </span></span><br><span class="line">list1 = [<span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">23</span>, <span class="number">27</span>, <span class="number">39</span>, <span class="number">40</span>]  </span><br><span class="line"><span class="comment"># finding length of the list  </span></span><br><span class="line"><span class="built_in">len</span>(list1)  </span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>
<h3 id="4-Iteration">4. Iteration</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iteration of the list  </span></span><br><span class="line"><span class="comment"># declaring the list  </span></span><br><span class="line">list1 = [<span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">39</span>, <span class="number">40</span>]  </span><br><span class="line"><span class="comment"># iterating  </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list1:   </span><br><span class="line">    <span class="built_in">print</span>(i)  </span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">39</span></span><br><span class="line"><span class="number">40</span></span><br></pre></td></tr></table></figure>
<h3 id="5-Membership">5. Membership</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># membership of the list  </span></span><br><span class="line"><span class="comment"># declaring the list  </span></span><br><span class="line">list1 = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>]  </span><br><span class="line"><span class="comment"># true will be printed if value exists  </span></span><br><span class="line"><span class="comment"># and false if not  </span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="number">600</span> <span class="keyword">in</span> list1)  </span><br><span class="line"><span class="built_in">print</span>(<span class="number">700</span> <span class="keyword">in</span> list1)  </span><br><span class="line"><span class="built_in">print</span>(<span class="number">1040</span> <span class="keyword">in</span> list1)  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="number">300</span> <span class="keyword">in</span> list1)  </span><br><span class="line"><span class="built_in">print</span>(<span class="number">100</span> <span class="keyword">in</span> list1)  </span><br><span class="line"><span class="built_in">print</span>(<span class="number">500</span> <span class="keyword">in</span> list1) </span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h2 id="迭代列表">迭代列表</h2>
<p>可以通过使用 for - in 循环来迭代列表。包含四个字符串的简单列表，可以如下迭代。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [<span class="string">&quot;John&quot;</span>, <span class="string">&quot;David&quot;</span>, <span class="string">&quot;James&quot;</span>, <span class="string">&quot;Jonathan&quot;</span>]  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>: </span><br><span class="line">    <span class="comment"># The i variable will iterate over the elements of the List and contains each element in each iteration.   </span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">John</span><br><span class="line">David</span><br><span class="line">James</span><br><span class="line">Jonathan</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="向列表中添加元素">向列表中添加元素</h2>
<p>Python 提供了 append()函数，用于将元素添加到列表中。但是，append()函数只能在列表的末尾添加值。</p>
<p>考虑下面的例子，我们从用户那里获取列表的元素，并在控制台上打印该列表。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#Declaring the empty list</span></span><br><span class="line">l =[]</span><br><span class="line"><span class="comment">#Number of elements will be entered by the user  </span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the number of elements in the list:&quot;</span>))</span><br><span class="line"><span class="comment"># for loop to take the input</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n):   </span><br><span class="line">    <span class="comment"># The input is taken from the user and added to the list as the item</span></span><br><span class="line">    l.append(<span class="built_in">input</span>(<span class="string">&quot;Enter the item:&quot;</span>))   </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;printing the list items..&quot;</span>) </span><br><span class="line"><span class="comment"># traversal loop to print the list items  </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> l: </span><br><span class="line">    <span class="built_in">print</span>(i, end = <span class="string">&quot;  &quot;</span>)   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the number of elements <span class="keyword">in</span> the <span class="built_in">list</span>:<span class="number">5</span></span><br><span class="line">Enter the item:<span class="number">25</span></span><br><span class="line">Enter the item:<span class="number">46</span></span><br><span class="line">Enter the item:<span class="number">12</span></span><br><span class="line">Enter the item:<span class="number">75</span></span><br><span class="line">Enter the item:<span class="number">42</span></span><br><span class="line">printing the <span class="built_in">list</span> items</span><br><span class="line"><span class="number">25</span>  <span class="number">46</span>  <span class="number">12</span>  <span class="number">75</span>  <span class="number">42</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="从列表中删除元素">从列表中删除元素</h2>
<p>Python 提供了 <strong>remove()</strong> 函数，用于从列表中移除元素。考虑下面的例子来理解这个概念。</p>
<p><strong>示例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]   </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;printing original list: &quot;</span>);  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:  </span><br><span class="line">    <span class="built_in">print</span>(i,end=<span class="string">&quot; &quot;</span>)  </span><br><span class="line"><span class="built_in">list</span>.remove(<span class="number">2</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nprinting the list after the removal of first element...&quot;</span>)  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:  </span><br><span class="line">    <span class="built_in">print</span>(i,end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">printing original <span class="built_in">list</span>: </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br><span class="line">printing the <span class="built_in">list</span> after the removal of first element...</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Python-列表内置函数">Python 列表内置函数</h2>
<p>Python 提供了以下内置函数，可以与列表一起使用。</p>
<p><strong>len()</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">L1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(L1))</span><br><span class="line">    <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p><strong>max()</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">L1 = [<span class="number">12</span>,<span class="number">34</span>,<span class="number">26</span>,<span class="number">48</span>,<span class="number">72</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(L1))</span><br><span class="line"><span class="number">72</span></span><br></pre></td></tr></table></figure>
<p><strong>min()</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">L1 = [<span class="number">12</span>,<span class="number">34</span>,<span class="number">26</span>,<span class="number">48</span>,<span class="number">72</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(L1))</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<p><strong>list()</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;Johnson&quot;</span></span><br><span class="line">s = <span class="built_in">list</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(s))</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="title class_">list</span>&gt;</span><br></pre></td></tr></table></figure>
<p>让我们来看看几个列表示例。</p>
<p><strong>示例:1</strong> 编写程序删除列表的重复元素。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">55</span>,<span class="number">98</span>,<span class="number">65</span>,<span class="number">65</span>,<span class="number">13</span>,<span class="number">29</span>]</span><br><span class="line"><span class="comment"># Declare an empty list that will store unique values</span></span><br><span class="line">list2 = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list1:</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> list2:</span><br><span class="line">        list2.append(i)</span><br><span class="line"><span class="built_in">print</span>(list2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">55</span>, <span class="number">98</span>, <span class="number">65</span>, <span class="number">13</span>, <span class="number">29</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例:2</strong> 写一个程序，求列表中元素的和。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">list1 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">24</span>]</span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list1:</span><br><span class="line">    <span class="built_in">sum</span> = <span class="built_in">sum</span>+i    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The sum is:&quot;</span>,<span class="built_in">sum</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The <span class="built_in">sum</span> <span class="keyword">is</span>: <span class="number">67</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例:3</strong> 编写程序，找出至少包含一个公共元素的列表。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">list2 = [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">10</span>]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> list1:</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> list2:</span><br><span class="line">        <span class="keyword">if</span> x == y:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;The common element is:&quot;</span>,x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The common element <span class="keyword">is</span>: <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-lists">https://www.javatpoint.com/python-lists</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 列表与元组</title>
    <url>/posts/97185454.html</url>
    <content><![CDATA[<h1>Python 列表与元组</h1>
<p>在本教程中，我们将学习列表和元组之间的重要区别，以及它们在 Python 中如何发挥重要作用。</p>
<p>列表和元组用于顺序存储一个或多个 Python 对象或数据类型。两者都可以存储任何数据，如整数、浮点、字符串和字典。列表和元组在大多数因素上是相似的，但是在这里我们将描述它们之间的主要区别。</p>
<p>让我们讨论以下几点的主要区别。</p>
<h2 id="代表性差异">代表性差异</h2>
<p>列表和元组的表示略有不同。列表通常用方括号[]括起来，元素是逗号分隔的元素。元组用括号()括起来，元素用逗号分隔。括号是可选的，这些类型的元组被称为元组打包。</p>
<p>考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">list1 = [<span class="string">&#x27;JavaTpoint&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">54.30</span>, &#123;<span class="string">&#x27;Name: &#x27;</span><span class="string">&#x27;Peter&#x27;</span>&#125;]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">list</span>))</span><br><span class="line">tuple1 = (<span class="string">&#x27;JavaTpoint&#x27;</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">31.9</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(tuple1))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的程序中，我们定义了一个 <strong>list1</strong> 变量，它保存了从索引 0 到 4 的不同数据类型的列表。我们定义了另一个变量 <strong>tuple1，</strong>，它包含不同数据类型的元组。它由()括起来。</p>
<h2 id="可变列表和不可变元组">可变列表和不可变元组</h2>
<p>这是列表和元组之间最重要的区别，而列表是可变的，元组是不可变的。列表是可变的，这意味着 Python 对象在创建后可以修改，而元组在创建后不能修改。考虑给定的示例。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a = [<span class="string">&quot;Peter&quot;</span>,<span class="string">&quot;Joseph&quot;</span>,<span class="string">&quot;Mathew&quot;</span>,<span class="string">&quot;Ricky&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;Peter&#x27;</span>, <span class="string">&#x27;Joseph&#x27;</span>, <span class="string">&#x27;Mathew&#x27;</span>, <span class="string">&#x27;Ricky&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在我们将第 0 个索引元素“Peter”更改为“Samson”。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a[<span class="number">0</span>] = <span class="string">&quot;Samson&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;Samson&#x27;</span>, <span class="string">&#x27;Joseph&#x27;</span>, <span class="string">&#x27;Mathew&#x27;</span>, <span class="string">&#x27;Ricky&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在我们创建一个元组并做同样的事情。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a = (<span class="number">10</span>,<span class="number">20</span>,<span class="string">&quot;JavaTpoint&quot;</span>,<span class="number">30</span>,<span class="number">40</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="number">10</span>, <span class="number">20</span>, <span class="string">&#x27;JavaTpoint&#x27;</span>, <span class="number">30</span>, <span class="number">40</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">50</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">TypeError Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">5</span>-52b2981fae12&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; <span class="number">1</span> a[<span class="number">0</span>] = <span class="number">50</span></span><br><span class="line"></span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于不变性，我们在更改元组的 1st 元素时出错。它不支持项目分配。</p>
<h2 id="排除故障">排除故障</h2>
<p>由于元组的不变性，在大型项目中很容易调试。如果我们有一个小项目或较少数量的数据，那么列表就发挥了有效的作用。让我们考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a = [<span class="number">6</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line"><span class="comment"># Copying address of a in b</span></span><br><span class="line">b = a</span><br><span class="line">a[<span class="number">3</span>] = <span class="string">&quot;JavaToint&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="string">&#x27;JavaToint&#x27;</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们做了<strong>b = a</strong>；这里我们没有将列表对象从 b 复制到 a。<strong>b</strong>指的是列表 <strong>a</strong> 的地址。这意味着如果我们在 b 中进行更改，那么它将反映与列表 <strong>a</strong>中相同的内容，这使得调试变得容易。但是对于 Python 对象可能有多个引用的重要项目来说，这很难。</p>
<p>跟踪列表中的那些变化会非常复杂，但是不可变的对象元组在创建后不能改变。</p>
<p>所以元组很容易调试。</p>
<h2 id="功能支持">功能支持</h2>
<p>元组支持的操作比列表少。内置的 **dir(对象)**用于获取列表和元组支持的所有函数。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>列出功能</strong></p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">dir</span>(<span class="built_in">list</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;__add__&#x27;</span>,<span class="string">&#x27;__class__&#x27;</span>,<span class="string">&#x27;__contains__&#x27;</span>,<span class="string">&#x27;__delattr__&#x27;</span>,<span class="string">&#x27;__delitem__&#x27;</span>,<span class="string">&#x27;__dir_,</span></span><br><span class="line"><span class="string"> &#x27;</span>__doc__<span class="string">&#x27;,&#x27;</span>__eq__<span class="string">&#x27;,&#x27;</span>__format__<span class="string">&#x27;, &#x27;</span>__get__<span class="string">&#x27;,&#x27;</span>__getattribute__<span class="string">&#x27;,&#x27;</span>__getitem_<span class="string">&#x27; &#x27;</span>__gt__<span class="string">&#x27;,&#x27;</span>__hash__<span class="string">&#x27;,&#x27;</span>__iadd__<span class="string">&#x27;,&#x27;</span>__imul__<span class="string">&#x27;,&#x27;</span>__init__<span class="string">&#x27;,&#x27;</span>__init_subclass__<span class="string">&#x27;&#x27;</span>__iter__<span class="string">&#x27;,&#x27;</span>__le__<span class="string">&#x27;,&#x27;</span>__len__<span class="string">&#x27;,&#x27;</span>__lt__<span class="string">&#x27;,&#x27;</span>__mul__<span class="string">&#x27;, &#x27;</span>__ne__<span class="string">&#x27;,&#x27;</span>__new__<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>__reduce__<span class="string">&#x27;, &#x27;</span>__reduce_ex__<span class="string">&#x27;,&#x27;</span>__repr__<span class="string">&#x27;,&#x27;</span>__reversed__<span class="string">&#x27;,&#x27;</span>__rmul__<span class="string">&#x27;,&#x27;</span>__setattr__<span class="string">&#x27;,&#x27;</span>__setitem__<span class="string">&#x27;,&#x27;</span>__sizeof__<span class="string">&#x27;,&#x27;</span>__str__<span class="string">&#x27;,&#x27;</span>__subclasshook__<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>append<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>clea<span class="string">r&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>copy<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>count<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>extend<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>index<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>insert<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>pop<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>remove<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>reverse<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>sort<span class="string">&#x27;]</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>元组函数</strong></p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">dir</span>(<span class="built_in">tuple</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;__add__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__class__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__contains__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__delattr__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__dir__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__doc__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__eq__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__format__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__ge__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__getattribute__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__getitem__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__getnewargs__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__gt__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__hash__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__init__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__init_subclass__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__iter__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__le__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__len__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__lt__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__mul__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__ne__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__new__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__reduce__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__reduce_ex__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__repr__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__rmul__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__setattr__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__sizeof__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__str__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__subclasshook__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;count&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;index&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="内存高效">内存高效</h2>
<p>元组比列表更节省内存，因为元组的内置操作更少。列表适用于较少的元素，而元组对于大量数据来说比列表快一点。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">Tuple</span> = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">5485</span>,<span class="number">87525</span>,<span class="number">955</span>,<span class="number">3343</span>,<span class="number">53234</span>,<span class="number">6423</span>,<span class="number">623456</span>,<span class="number">234535</span>)</span><br><span class="line"><span class="type">List</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">78</span>,<span class="number">34</span>,<span class="number">43</span>,<span class="number">32</span>,<span class="number">43</span>,<span class="number">55</span>,<span class="number">54</span>,<span class="number">212</span>,<span class="number">642</span>,<span class="number">533</span>,<span class="number">43434</span>,<span class="number">54532</span> ]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Tuple size =&#x27;</span>, <span class="type">Tuple</span>.__sizeof__())       <span class="comment"># Tuple size = 52</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;List size =&#x27;</span>, <span class="type">List</span>.__sizeof__())  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="type">Tuple</span> size = <span class="number">168</span></span><br><span class="line"><span class="type">List</span> size = <span class="number">216</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="结论-4">结论</h2>
<ul class="lvl-0">
<li class="lvl-4">
<p>在某些情况下，列表可能比元组更有用。但是元组是 Python 的重要数据结构。元组通常用于不可更改的数据，或者我们可以说数据将在元组中被<strong>写保护</strong>。元组向 Python 解释器发送数据将来不应改变的指示。</p>
</li>
<li class="lvl-4">
<p>我们可以像使用字典一样使用元组，而不用使用键来存储数据。例如-</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">list1 = [(<span class="number">101</span>, <span class="string">&quot;Mike&quot;</span>, <span class="number">24</span>),(<span class="number">102</span>, <span class="string">&#x27;Hussey&#x27;</span>, <span class="number">26</span>),(<span class="number">103</span>, <span class="string">&#x27;David&#x27;</span>, <span class="number">27</span>),(<span class="number">104</span>,  <span class="string">&#x27;Warner&#x27;</span>, <span class="number">29</span>)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p>元组可以用于字典关键字，因为这些关键字是可哈希和不可变的，而列表不能在字典中使用关键字。</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">dict</span> = &#123;(<span class="string">&quot;Mike&quot;</span>,<span class="number">22</span>):<span class="number">24000</span>&#125;    <span class="comment">#valid dictionary</span></span><br><span class="line"><span class="built_in">dict</span> = &#123;[<span class="string">&quot;Peter&quot;</span>,<span class="number">26</span>]:<span class="number">25000</span>&#125;   <span class="comment">#Invalid dictionary</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-list-vs-tuple">https://www.javatpoint.com/python-list-vs-tuple</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 推导式</title>
    <url>/posts/a5129ea8.html</url>
    <content><![CDATA[<h1>Python 推导式</h1>
<p>Python 推导式是一种独特的数据处理方式，可以从一个数据序列构建另一个新的数据序列的结构体。</p>
<p>Python 支持各种数据结构的推导式：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>列表(list)推导式</p>
</li>
<li class="lvl-2">
<p>字典(dict)推导式</p>
</li>
<li class="lvl-2">
<p>集合(set)推导式</p>
</li>
<li class="lvl-2">
<p>元组(tuple)推导式</p>
</li>
</ul>
<h2 id="列表推导式">列表推导式</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表] </span><br><span class="line">[out_exp_res <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list]</span><br><span class="line"></span><br><span class="line">或者 </span><br><span class="line"></span><br><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表 <span class="keyword">if</span> 条件]</span><br><span class="line">[out_exp_res <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list <span class="keyword">if</span> condition]</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>out_exp_res：列表生成元素表达式，可以是有返回值的函数。</p>
</li>
<li class="lvl-2">
<p>for out_exp in input_list：迭代 input_list 将 out_exp 传入到 out_exp_res 表达式中。</p>
</li>
<li class="lvl-2">
<p>if condition：条件语句，可以过滤列表中不符合条件的值。</p>
</li>
</ul>
<p><strong>实例</strong><br>
过滤掉长度小于或等于3的字符串列表，并将剩下的转换成大写字母：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>names = [<span class="string">&#x27;Bob&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;alice&#x27;</span>,<span class="string">&#x27;Jerry&#x27;</span>,<span class="string">&#x27;Wendy&#x27;</span>,<span class="string">&#x27;Smith&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new_names = [name.upper()<span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">if</span> <span class="built_in">len</span>(name)&gt;<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(new_names)</span><br><span class="line">[<span class="string">&#x27;ALICE&#x27;</span>, <span class="string">&#x27;JERRY&#x27;</span>, <span class="string">&#x27;WENDY&#x27;</span>, <span class="string">&#x27;SMITH&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>计算 30 以内可以被 3 整除的整数：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>multiples = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>) <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(multiples)</span><br><span class="line">[<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">21</span>, <span class="number">24</span>, <span class="number">27</span>]</span><br></pre></td></tr></table></figure>
<h2 id="字典推导式">字典推导式</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123; key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection &#125;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">&#123; key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition &#125;</span><br></pre></td></tr></table></figure>
<p>使用字符串及其长度创建字典：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">listdemo = [<span class="string">&#x27;Google&#x27;</span>,<span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br><span class="line"><span class="comment"># 将列表中各字符串值为键，各字符串的长度为值，组成键值对</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newdict = &#123;key:<span class="built_in">len</span>(key) <span class="keyword">for</span> key <span class="keyword">in</span> listdemo&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newdict</span><br><span class="line">&#123;<span class="string">&#x27;Google&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;Runoob&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;Taobao&#x27;</span>: <span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>
<p>提供三个数字，以三个数字为键，三个数字的平方为值来创建字典：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic = &#123;x: x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>)&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic</span><br><span class="line">&#123;<span class="number">2</span>: <span class="number">4</span>, <span class="number">4</span>: <span class="number">16</span>, <span class="number">6</span>: <span class="number">36</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(dic)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="集合推导式">集合推导式</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123; expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> &#125;</span><br><span class="line">或</span><br><span class="line">&#123; expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> <span class="keyword">if</span> conditional &#125;</span><br></pre></td></tr></table></figure>
<p>计算数字 1,2,3 的平方数：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>setnew = &#123;i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>setnew</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure>
<p>判断不是 abc 的字母并输出：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;abracadabra&#x27;</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&#123;<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;r&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(a)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;set&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="元组推导式（生成器表达式）">元组推导式（生成器表达式）</h2>
<p>元组推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> )</span><br><span class="line">或</span><br><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> <span class="keyword">if</span> conditional )</span><br></pre></td></tr></table></figure>
<p>元组推导式和列表推导式的用法也完全相同，只是元组推导式是用 () 圆括号将各部分括起来，而列表推导式用的是中括号 []，另外元组推导式返回的结果是一个生成器对象。</p>
<p>例如，我们可以使用下面的代码生成一个包含数字 1~9 的元组：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x7faf6ee20a50</span>&gt;   <span class="comment"># 返回的是生成器对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">tuple</span>(a)      <span class="comment"># 使用 tuple() 函数，可以直接将生成器对象转换成元组</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://www.runoob.com/python3/python-comprehensions.html">https://www.runoob.com/python3/python-comprehensions.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 历史和版本</title>
    <url>/posts/255b14f4.html</url>
    <content><![CDATA[<h1>Python 历史和版本</h1>
<ul class="lvl-0">
<li class="lvl-4">Python 在 20 世纪 80 年代末奠定了基础。</li>
<li class="lvl-4">Python 的实现始于 1989 年 12 月荷兰 CWI 的吉多·范·罗松。</li>
<li class="lvl-4">1991 年 2 月， <strong>Guido Van Rossum</strong> 发布了代码(标记为版本 0.9.0)来替换源代码。</li>
<li class="lvl-4">1994 年，Python 1.0 发布了新特性，如 lambda、map、filter 和 reduce。</li>
<li class="lvl-4">Python 2.0 增加了新功能，如列表推导、垃圾收集系统。</li>
<li class="lvl-4">2008 年 12 月 3 日，Python 3.0(也叫“Py3K”)发布。它旨在纠正语言的根本缺陷。</li>
<li class="lvl-4"><em>ABC 编程语言</em>据说是 Python 语言的前身，它能够处理异常并与阿米巴操作系统接口。</li>
<li class="lvl-4">以下编程语言会影响 Python:
<ul class="lvl-2">
<li class="lvl-8">ABC 语言。</li>
<li class="lvl-8">Modula-3</li>
</ul>
</li>
</ul>
<h2 id="为什么叫-Python？">为什么叫 Python？</h2>
<p>选择名称 Python 背后有一个事实。<strong>吉多·范·罗苏姆</strong>正在阅读英国广播公司(BBC)热门喜剧系列《T4》的剧本《巨蟒飞行马戏团》。那是 20 世纪 70 年代后期的节目。</p>
<p>范·罗瑟姆想选择一个独特的、有点神秘的名字。所以他决定为他们新创建的编程语言选择以**“蒙蒂·Python 的飞行马戏团”**命名 Python。</p>
<p>这部喜剧系列很有创意，也很随意。它无所不谈。因此，它是缓慢和不可预测的，这使得它非常有趣。</p>
<p>Python 也是多才多艺，广泛应用于各个技术领域，如机器学习、人工智能、Web 开发、移动应用、桌面应用、科学计算等。</p>
<h2 id="Python-版本列表">Python 版本列表</h2>
<p>Python 编程语言正在定期更新，增加了新的功能和支持。Python 版本中有很多更新，从 1994 年开始到当前版本。</p>
<p>下面列出了 Python 版本及其发布日期。</p>
<table>
<thead>
<tr>
<th>Python 版本</th>
<th>发布日期</th>
</tr>
</thead>
<tbody>
<tr>
<td>Python 1.0</td>
<td>1994 年 1 月</td>
</tr>
<tr>
<td>Python 1.5</td>
<td>1997 年 12 月</td>
</tr>
<tr>
<td>Python 1.6</td>
<td>2000 年 9 月</td>
</tr>
<tr>
<td>Python 2.0</td>
<td>2000 年 10 月</td>
</tr>
<tr>
<td>Python 2.1</td>
<td>2001 年 4 月</td>
</tr>
<tr>
<td>Python 2.2</td>
<td>2001 年 12 月</td>
</tr>
<tr>
<td>Python 2.3</td>
<td>2003 年 7 月</td>
</tr>
<tr>
<td>Python 2.4</td>
<td>2004 年 11 月</td>
</tr>
<tr>
<td>Python 2.5</td>
<td>2006 年 9 月</td>
</tr>
<tr>
<td>Python 2.6</td>
<td>2008 年 10 月</td>
</tr>
<tr>
<td>Python 2.7</td>
<td>2010 年 7 月</td>
</tr>
<tr>
<td>Python 3.0</td>
<td>2008 年 12 月</td>
</tr>
<tr>
<td>Python 3.1</td>
<td>2009 年 6 月</td>
</tr>
<tr>
<td>Python 3.2</td>
<td>2011 年 2 月</td>
</tr>
<tr>
<td>Python 3.3</td>
<td>2012 年 9 月</td>
</tr>
<tr>
<td>Python 3.4</td>
<td>2014 年 3 月</td>
</tr>
<tr>
<td>Python 3.5</td>
<td>2015 年 9 月</td>
</tr>
<tr>
<td>Python 3.6</td>
<td>2016 年 12 月</td>
</tr>
<tr>
<td>Python 3.7</td>
<td>2018 年 6 月</td>
</tr>
<tr>
<td>Python 3.8</td>
<td>2019 年 10 月</td>
</tr>
</tbody>
</table>
<h2 id="学习-Python-时要牢记的技巧">学习 Python 时要牢记的技巧</h2>
<p>初学者最常问的问题- **“学习 Python 最好的方法是什么”？**这是最初的相关问题，因为学习任何编程语言的第一步都是知道如何学习。</p>
<p>正确的学习方式有助于我们快速学习，成为一名优秀的 Python 开发人员。</p>
<p>在本节中，我们将讨论学习 Python 时应该记住的各种技巧。</p>
<h3 id="1-明确我们为什么要学习">1.明确我们为什么要学习</h3>
<p>在学习 Python 之前，目标应该是明确的。Python 是一门简单的语言，也是一门庞大的语言。它包括许多库、模块、内置函数和数据结构。如果目标不明确，那么学习 Python 将会是一段枯燥而单调的旅程。如果没有明确的目标，你可能无法完成。</p>
<p>所以，首先弄清楚学习背后的动机，可以是任何事情，比如了解一些新的东西，使用 Python 开发项目，切换到 Python 等。下面是 Python 被广泛使用的一般领域。随便挑一个。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>数据分析和处理</p>
</li>
<li class="lvl-4">
<p>人工智能</p>
</li>
<li class="lvl-4">
<p>比赛</p>
</li>
<li class="lvl-4">
<p>硬件/传感器/机器人</p>
</li>
<li class="lvl-4">
<p>桌面应用</p>
</li>
</ul>
<p>根据自己的兴趣选择任意一两个领域，开始学习 Python 的旅程。</p>
<h3 id="2-学习基本语法">2.学习基本语法</h3>
<p>学习 Python 编程语言的语法是最基本的一步。在深入学习语法之前，我们必须先学习基本的语法。正如我们在前面的教程中所讨论的，Python 很容易学习，并且语法简单。它不使用分号和括号。它的句法就像英语一样。</p>
<p>所以学习它的语法只需要最少的时间。一旦我们正确理解了它的语法，进一步的学习将会更容易更快地开始项目。</p>
<h4 id="注意-学习-Python-3，而不是-Python-2-7，因为行业不再使用它。我们的-Python-教程基于其最新版本-Python-3。">注意-学习 Python 3，而不是 Python 2.7，因为行业不再使用它。我们的 Python 教程基于其最新版本 Python 3。</h4>
<h3 id="3-自己写代码">3.自己写代码</h3>
<p>编写代码是学习 Python 最有效、最健壮的方法。首先，试着在纸上写代码并在脑海中运行(模拟运行)，然后进入系统。在纸上写代码将有助于我们快速熟悉存储在深层记忆中的语法和概念。编写代码时，尽量使用正确的函数和合适的变量名称。</p>
<p>Python 编程有许多编辑器，可以自动突出语法相关的问题。所以我们不需要太在意这些错误。</p>
<h3 id="4-继续练习">4.继续练习</h3>
<p>下一个重要的步骤是练习。它需要通过代码实现 Python 概念。我们应该与我们的日常编码实践保持一致。</p>
<p>一致性是生活中任何方面成功的关键，不仅仅是在编程方面。每天写代码将有助于发展肌肉记忆。</p>
<p>我们可以做相关概念的习题或者解决至少 2 到 3 个 Python 的问题。这看起来很难，但肌肉记忆在编程中起着很大的作用。它将带领我们超越那些认为只有 Python 的阅读概念就足够了的人。</p>
<h3 id="5-根据需要做笔记">5.根据需要做笔记</h3>
<p>自己创建笔记是学习 Python 概念和语法的绝佳方法。它将建立稳定性和专注度，帮助你成为一名 Python 开发人员。用相关信息做简短的笔记，并包括相关主题的适当例子。</p>
<p>保持自己的笔记也有助于快速学习。发表在《心理科学》上的一项研究显示-</p>
<blockquote>
<p>在研究中做手写笔记的学生被迫变得更有选择性——因为你不能像打字一样快。</p>
</blockquote>
<h3 id="6-与他人讨论概念">6.与他人讨论概念</h3>
<p>编码似乎是一种孤立的活动，但我们可以通过与他人互动来提高自己的技能。我们应该向正在学习 Python 的专家或朋友讨论我们的疑惑。这个习惯将有助于获得额外的信息、提示和技巧，以及编码问题的解决方案。Python 最大的优势之一是它有一个很棒的社区。因此，我们也可以向热情的 Python 爱好者学习。</p>
<h3 id="7-做小项目">7.做小项目</h3>
<p>了解 Python 的基本概念后，初学者应该尝试在小项目上工作。这将有助于更深入地理解 Python，并在其中变得更有分量。理论知识不足以掌握 Python 语言。这些项目可以是任何东西，只要它们教会你一些东西。你可以从小项目开始，如计算器应用、tic-toc-toe 游戏、闹钟应用、待办事项列表、学生或客户管理系统等。</p>
<p>一旦你对一个小项目得心应手，你就可以轻松地转向你感兴趣的领域(机器学习、网络开发等)。).</p>
<h3 id="8-教导他人">8.教导他人</h3>
<p>有一句名言**“如果你想学点什么，那你应该教其他人”**。在学习 Python 的情况下也是如此。通过创建博客、录制视频或在当地培训中心上课，将您的信息分享给其他学生。它将帮助我们增强对 Python 的理解，并探索您知识中看不见的漏洞。如果您不想做所有这些，请加入在线论坛，并在 Python 相关问题上发布您的答案。</p>
<h3 id="9-探索库和框架">9.探索库和框架</h3>
<p>Python 由大量的库和各种框架组成。在熟悉了 Python 的基本概念之后，下一步是探索 Python 库。库对于处理领域特定的项目是必不可少的。在下一节中，我们将简要介绍主要的库。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong><a href="https://www.javatpoint.com/tensorflow">TensorFlow</a> -</strong> 它是一个人工智能库，允许我们创建大规模的基于 AI 的项目。</p>
</li>
<li class="lvl-4">
<p><strong><a href="https://www.javatpoint.com/django-tutorial">Django</a> -</strong> 它是一个开源框架，允许我们开发 web 应用。它简单、灵活且易于管理。</p>
</li>
<li class="lvl-4">
<p><strong><a href="https://www.javatpoint.com/flask-tutorial">Flask</a> -</strong> 也是一个开源的 web 框架。它用于开发轻量级 web 应用。</p>
</li>
<li class="lvl-4">
<p><strong><a href="https://www.javatpoint.com/python-pandas">Pandas</a> -</strong> 这是一个用来进行科学计算的 Python 库。</p>
</li>
<li class="lvl-4">
<p><strong><a href="https://www.javatpoint.com/keras">Keras</a> -</strong> 它是一个开源库，用来围绕神经网络工作。</p>
</li>
</ul>
<p>Python 中有很多库。以上，我们已经提到了其中的几个。</p>
<h3 id="10-为开源做贡献">10.为开源做贡献</h3>
<p>众所周知，Python 是一种开源语言，这意味着它对每个人都是免费的。我们还可以向 Python 在线社区投稿，以增强我们的知识。为开源项目做贡献是探索自己知识的最好方式。我们还会收到对我们提交的工作的反馈、意见或建议。反馈将支持 Python 编程的最佳实践，并帮助我们成为一名优秀的 Python 开发人员。</p>
<h2 id="Python-的用法">Python 的用法</h2>
<p>Python 是一种通用、开源的高级编程语言，也提供了许多库和框架。Python 因其简单、易于语法和用户友好的环境而广受欢迎。Python 的用法如下。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>桌面应用</p>
</li>
<li class="lvl-4">
<p>网络应用</p>
</li>
<li class="lvl-4">
<p><a href="https://www.javatpoint.com/data-science">数据科学</a></p>
</li>
<li class="lvl-4">
<p><a href="https://www.javatpoint.com/artificial-intelligence-tutorial">人工智能</a></p>
</li>
<li class="lvl-4">
<p><a href="https://www.javatpoint.com/machine-learning">机器学习</a></p>
</li>
<li class="lvl-4">
<p>科学计算</p>
</li>
<li class="lvl-4">
<p><a href="https://www.javatpoint.com/robotics-tutorial">机器人</a></p>
</li>
<li class="lvl-4">
<p><a href="https://www.javatpoint.com/iot-internet-of-things">物联网(IoT)</a></p>
</li>
<li class="lvl-4">
<p>移动应用</p>
</li>
<li class="lvl-4">
<p>数据分析和预处理</p>
</li>
</ul>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-history">https://www.javatpoint.com/python-history</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 变量</title>
    <url>/posts/18ed7528.html</url>
    <content><![CDATA[<h1>Python 变量</h1>
<p>变量是用于引用内存位置的名称。Python 变量也称为标识符，用于保存值。</p>
<p>在 Python 中，我们不需要指定变量的类型，因为 Python 是一种推断语言，并且足够聪明，可以获得变量类型。</p>
<p>变量名可以是一组字母和数字，但它们必须以字母或下划线开头。</p>
<p>建议变量名使用小写字母。rahul 和 Rahul 都是两个不同的变量。</p>
<h2 id="标识符命名">标识符命名</h2>
<p>变量是标识符的例子。标识符用于标识程序中使用的字面值。命名标识符的规则如下。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>变量的第一个字符必须是字母或下划线（<code>_</code>）。</p>
</li>
<li class="lvl-4">
<p>除第一个字符外，所有字符都可以是小写字母(a-z)、大写字母(A-Z)、下划线或数字(0-9)。</p>
</li>
<li class="lvl-4">
<p>标识符名称不能包含任何空格或特殊字符(！, @, #, %, ^, &amp;, *).</p>
</li>
<li class="lvl-4">
<p>标识符名称不得与语言中定义的任何关键字相似。</p>
</li>
<li class="lvl-4">
<p>标识符名称区分大小写；比如我的名字，和我的名字不一样。</p>
</li>
<li class="lvl-4">
<p>有效标识符的例子:a123，_n，n_9 等。</p>
</li>
<li class="lvl-4">
<p>无效标识符的示例:1a、n%4、n 9 等。</p>
</li>
</ul>
<h2 id="声明变量并赋值">声明变量并赋值</h2>
<p>Python 不要求我们在应用中使用变量之前声明变量。它允许我们在需要的时候创建一个变量。</p>
<p>我们不需要在 Python 中显式声明变量。当我们给变量赋值时，该变量会自动声明。</p>
<p>等号(=)运算符用于给变量赋值。</p>
<h2 id="对象引用">对象引用</h2>
<p>当我们声明一个变量时，有必要了解 Python 解释器是如何工作的。处理变量的过程与许多其他编程语言有些不同。</p>
<p>Python 是高度面向对象的编程语言；这就是为什么每个数据项都属于特定类型的类。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;John&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">John</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Python 对象创建一个整数对象，并将其显示在控制台上。在上面的 print 语句中，我们创建了一个字符串对象。让我们使用 Python 内置的 <strong>type()</strong> 函数来检查它的类型。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>(<span class="string">&quot;John&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在 Python 中，变量是一个符号名称，是对对象的引用或指针。变量用来用这个名字来表示对象。</p>
<p>让我们理解下面的例子</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = <span class="number">50</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/b2d2c994c879691b8703f74bb137b1a3.png" alt="Python Variables"></p>
<p>在上图中，变量 <strong>a</strong> 指的是一个整数对象。</p>
<p>假设我们将整数值 50 赋给一个新变量 b。</p>
<p>a = 50</p>
<p>b = a</p>
<p><img src="/img/bb04824d45f1fd8453e1b3933054fb99.png" alt="Python Variables"></p>
<p>变量 b 引用了 a 指向的同一个对象，因为 Python 不会创建另一个对象。</p>
<p>让我们将新值赋给 b。现在两个变量将引用不同的对象。</p>
<p>a = 50</p>
<p>b =100</p>
<p><img src="/img/019075008623bcf1a77c3545a3c8146c.png" alt="Python Variables"></p>
<p>如果我们将同一个变量赋给两个不同的值，Python 可以有效地管理内存。</p>
<h2 id="对象标识">对象标识</h2>
<p>在 Python 中，每个创建的对象在 Python 中都是唯一标识的。Python 保证没有两个对象具有相同的标识符。内置 <strong>id()</strong> 功能，用于识别对象标识符。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = <span class="number">50</span></span><br><span class="line">b = a</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b))</span><br><span class="line"><span class="comment"># Reassigned variable a</span></span><br><span class="line">a = <span class="number">500</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">140734982691168</span></span><br><span class="line"><span class="number">140734982691168</span></span><br><span class="line"><span class="number">2822056960944</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们指定 <strong>b = a，a</strong> 和 <strong>b</strong> 都指向同一个对象。当我们通过 <strong>id()</strong> 函数检查时，它返回了相同的数字。我们将 <strong>a</strong> 重新分配给 500；然后它引用新的对象标识符。</p>
<h2 id="变量名">变量名</h2>
<p>我们已经讨论了如何声明有效变量。变量名可以是任意长度，可以有大写、小写(A 到 Z、A 到 Z)、数字(0-9)和下划线字符（<code>_</code>）。考虑以下有效变量名称的示例。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;Devansh&quot;</span></span><br><span class="line">age = <span class="number">20</span></span><br><span class="line">marks = <span class="number">80.50</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(name)</span><br><span class="line"><span class="built_in">print</span>(age)</span><br><span class="line"><span class="built_in">print</span>(marks)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Devansh</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">80.5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>请考虑以下有效变量名称。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;A&quot;</span></span><br><span class="line">Name = <span class="string">&quot;B&quot;</span></span><br><span class="line">naMe = <span class="string">&quot;C&quot;</span></span><br><span class="line">NAME = <span class="string">&quot;D&quot;</span></span><br><span class="line">n_a_m_e = <span class="string">&quot;E&quot;</span></span><br><span class="line">_name = <span class="string">&quot;F&quot;</span></span><br><span class="line">name_ = <span class="string">&quot;G&quot;</span></span><br><span class="line">_name_ = <span class="string">&quot;H&quot;</span></span><br><span class="line">na56me = <span class="string">&quot;I&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(name,Name,naMe,NAME,n_a_m_e, NAME, n_a_m_e, _name, name_,_name, na56me)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">A B C D E D E F G F I</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们已经声明了一些有效的变量名，比如 name，Name，等等。但不建议这样做，因为当我们试图阅读代码时，可能会造成混乱。变量名应该是描述性的，以使代码更易读。</p>
<p>多词关键字可以通过以下方法创建。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Camel Case -</strong> 在 Camel Case 中，中间的每个单词或缩写都以大写字母开头。没有空白的介入。例如- nameOfStudent、valueOfVaraible 等。</p>
</li>
<li class="lvl-4">
<p><strong>Pascal Case -</strong> 与 Camel Case 相同，但这里第一个字也是大写。例如- NameOfStudent 等。</p>
</li>
<li class="lvl-4">
<p><strong>Snake Case-</strong> 在Snake Case中，单词用下划线隔开。例如-学生姓名等。</p>
</li>
</ul>
<h2 id="多重赋值">多重赋值</h2>
<p>Python 允许我们在一条语句中为多个变量赋值，这也称为多次赋值。</p>
<p>我们可以通过两种方式应用多个赋值，要么将单个值赋给多个变量，要么将多个值赋给多个变量。考虑下面的例子。</p>
<p><strong>1.给多个变量赋值</strong></p>
<p><strong>Eg:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">x=y=z=<span class="number">50</span>  </span><br><span class="line"><span class="built_in">print</span>(x)  </span><br><span class="line"><span class="built_in">print</span>(y)  </span><br><span class="line"><span class="built_in">print</span>(z)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">50</span>  </span><br><span class="line"><span class="number">50</span>  </span><br><span class="line"><span class="number">50</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>2.给多个变量分配多个值:</strong></p>
<p><strong>Eg:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a,b,c=<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>  </span><br><span class="line"><span class="built_in">print</span> a  </span><br><span class="line"><span class="built_in">print</span> b  </span><br><span class="line"><span class="built_in">print</span> c  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>  </span><br><span class="line"><span class="number">10</span>  </span><br><span class="line"><span class="number">15</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这些值将按照变量出现的顺序进行分配。</p>
<h2 id="Python-变量类型">Python 变量类型</h2>
<p>Python 中有两种类型的变量——局部变量和全局变量。让我们了解以下变量。</p>
<h3 id="局部变量">局部变量</h3>
<p>局部变量是在函数内部声明并在函数内部有作用域的变量。让我们理解下面的例子。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Declaring a function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line">    <span class="comment"># Defining local variables. They has scope only within a function</span></span><br><span class="line">    a = <span class="number">20</span></span><br><span class="line">    b = <span class="number">30</span></span><br><span class="line">    c = a + b</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The sum is:&quot;</span>, c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calling a function</span></span><br><span class="line">add()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The <span class="built_in">sum</span> <span class="keyword">is</span>: <span class="number">50</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的代码中，我们声明了一个名为 <strong>add()</strong> 的函数，并在函数中分配了一些变量。这些变量将被称为<strong>局部变量</strong>，其范围仅在函数内部。如果我们试图在函数外使用它们，我们会得到以下错误。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add()</span><br><span class="line"><span class="comment"># Accessing local variable outside the function </span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The <span class="built_in">sum</span> <span class="keyword">is</span>: <span class="number">50</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">NameError: name <span class="string">&#x27;a&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们试图在它们的范围之外使用局部变量；它抛出了<strong>命名错误。</strong></p>
<h3 id="全局变量">全局变量</h3>
<p>全局变量可以在整个程序中使用，其范围在整个程序中。我们可以在函数内部或外部使用全局变量。</p>
<p>默认情况下，在函数外部声明的变量是全局变量。Python 提供了<strong>全局</strong>关键字来使用函数内部的全局变量。如果我们不使用<strong>全局</strong>关键字，函数会将其视为局部变量。让我们理解下面的例子。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Declare a variable and initialize it</span></span><br><span class="line">x = <span class="number">101</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Global variable in function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mainFunction</span>():</span><br><span class="line">    <span class="comment"># printing a global variable</span></span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    <span class="comment"># modifying a global variable</span></span><br><span class="line">    x = <span class="string">&#x27;Welcome To Javatpoint&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line">mainFunction()</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">101</span></span><br><span class="line">Welcome To Javatpoint</span><br><span class="line">Welcome To Javatpoint</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的代码中，我们声明了一个全局变量 <strong>x</strong> ，并为其赋值。接下来，我们定义了一个函数，并使用函数内部的<strong>全局</strong>关键字访问了声明的变量。现在我们可以修改它的值。然后，我们给变量 x 分配了一个新的字符串值。</p>
<p>现在，我们调用该函数并继续打印 <strong>x</strong> 。它打印为新分配的 x 值。</p>
<h2 id="删除变量">删除变量</h2>
<p>我们可以使用 <strong>del</strong> 关键字删除变量。语法如下。</p>
<p><strong>语法-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> &lt;variable_name&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在下面的例子中，我们创建了一个变量 x，并为其赋值。我们删除了变量 x，打印出来，得到错误**“变量 x 没有定义”**。变量 x 今后将不再使用。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Assigning a value to x</span></span><br><span class="line">x = <span class="number">6</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment"># deleting a variable. </span></span><br><span class="line"><span class="keyword">del</span> x</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;C:/Users/DEVANSH SHARMA/PycharmProjects/Hello/multiprocessing.py&quot;</span>, line <span class="number">389</span>, <span class="keyword">in</span> <span class="built_in">print</span>(x)</span><br><span class="line">NameError: name <span class="string">&#x27;x&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined </span><br></pre></td></tr></table></figure>
<h2 id="Python-中整数的最大可能值">Python 中整数的最大可能值</h2>
<p>与其他编程语言不同，Python 没有长整型或浮点型数据类型。它将所有整数值视为 <strong>int</strong> 数据类型。这里，问题出现了。Python 中变量能容纳的最大可能值是多少？考虑下面的例子。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># A Python program to display that we can store</span></span><br><span class="line"><span class="comment"># large numbers in Python</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">10000000000000000000000000000000000000000000</span></span><br><span class="line">a = a + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"><span class="built_in">print</span> (a)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line"><span class="number">10000000000000000000000000000000000000000001</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>正如我们在上面的例子中看到的，我们给变量 <strong>x</strong> 分配了一个大的整数值，并检查了它的类型。它打印了<strong>类&lt; int &gt;</strong> 不长 int。因此，没有位数的限制，我们可以扩展到我们的内存极限。</p>
<p>Python 没有任何特殊的数据类型来存储更大的数字。</p>
<h3 id="用-Python-打印单个和多个变量">用 Python 打印单个和多个变量</h3>
<p>我们可以在一个 print 语句中打印多个变量。以下是单个和多个打印值的示例。</p>
<p><strong>示例- 1(打印单变量)</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># printing single value </span></span><br><span class="line">a = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>((a))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例- 2(打印多个变量)</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line">b = <span class="number">6</span></span><br><span class="line"><span class="comment"># printing multiple variables</span></span><br><span class="line"><span class="built_in">print</span>(a,b)</span><br><span class="line"><span class="comment"># separate the variables by the comma</span></span><br><span class="line">Print(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="基本原理">基本原理:</h2>
<p>本节包含 Python 的基础知识，例如:</p>
<p><strong>i)Tokens及其类型</strong></p>
<p><strong>ii)Comments</strong></p>
<p><strong>a)Tokens</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>标记可以定义为标点符号、保留词和语句中的每个词。</p>
</li>
<li class="lvl-4">
<p>令牌是给定程序中最小的单元。</p>
</li>
</ul>
<p>Python 中有以下标记:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>关键词</p>
</li>
<li class="lvl-4">
<p>标识符</p>
</li>
<li class="lvl-4">
<p>字面值</p>
</li>
<li class="lvl-4">
<p>操作符</p>
</li>
</ul>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-variables">https://www.javatpoint.com/python-variables</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 命令行参数</title>
    <url>/posts/4e90abbc.html</url>
    <content><![CDATA[<h1>Python 命令行参数</h1>
<p>Python 支持可以在命令行上运行的程序，并带有命令行参数。它是执行脚本时需要传递给脚本的输入参数。</p>
<p>它意味着与脚本的命令行界面进行交互。</p>
<p>它提供了一个 <strong>getopt</strong> 模块，可以在其中解析命令行参数和选项。</p>
<h2 id="What-is-argument-passing？">What is argument passing？</h2>
<p>命令 <strong>ls</strong> 通常用于获取特定目录中文件和文件夹的摘要。</p>
<h2 id="为什么要使用-argparse？">为什么要使用 argparse？</h2>
<p>它意味着程序的作者和用户之间的通信，这不需要进入代码并对脚本进行更改。它为用户提供了输入命令行参数的能力。</p>
<h2 id="访问命令行参数">访问命令行参数</h2>
<p>Python <code>sys</code>模块通过 sys.argv 提供对命令行参数的访问。</p>
<h2 id="Python-sys模块">Python <code>sys</code>模块</h2>
<p>这是早期 Python 发行版附带的一个基本模块。这与 C 库使用 argc/argv 访问参数的方法类似。<code>sys</code>模块在一个名为 sys.argv 的简单列表结构中实现命令行参数。</p>
<p>每个列表元素代表一个参数。第一个- sys.argv[0] -是 Python 脚本的名称。其他列表元素是 sys.argv[1]到 sys.argv[n]-是命令行参数 2 到 n。作为参数之间的分隔符，使用了空格。相应地，必须引用包含空格的参数值。</p>
<p>它将命令行参数存储到一个列表中；我们可以使用 <strong>sys.argv</strong> 访问它。这是非常有用的，也是以字符串形式读取命令行参数的简单方法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(sys.argv))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The command line arguments are:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sys.argv:</span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="python-getopt模块">python <code>getopt</code>模块</h2>
<p>Python <code>getopt</code>模块通过参数验证扩展了输入字符串的分离。基于 getopt C 函数，它允许短选项和长选项，包括赋值。</p>
<p>它与解析命令行参数的 C getopt()函数非常相似。</p>
<p>它在解析命令行参数时非常有用，我们希望用户输入一些选项。</p>
<p><strong>代码</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> getopt</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">argv = sys.argv[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    opts, args = getopt.getopt(argv, <span class="string">&#x27;hm:d&#x27;</span>, [<span class="string">&#x27;help&#x27;</span>, <span class="string">&#x27;my_file=&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(opts)</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line"><span class="keyword">except</span> getopt.GetoptError:</span><br><span class="line">    <span class="comment"># Print a message or do something useful</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Something went wrong!&#x27;</span>)</span><br><span class="line">    sys.exit(<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="python-argparse-module-python-剖析模组">python argparse module-python 剖析模组</h2>
<p>它提供了一个带有标准化输出的命令行界面，而前两个解决方案将大部分工作留给了您。argparse 允许使用 UNIX 或 GNU 风格的名称检查来验证固定参数和可选参数。这是解析命令行参数的首选方式。它提供了许多选项，如位置参数、参数的默认值、帮助消息、指定参数的数据类型等。</p>
<p>它使得编写用户友好的命令行界面变得容易。当用户给程序提供无效参数时，它会自动生成帮助和使用信息并发出错误。</p>
<p><strong>getopt.getopt 方法</strong></p>
<p>此方法用于解析命令行选项和参数列表。</p>
<p><strong>语法:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">getopt.getopt(args, options, [long_options])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>args</strong> -是需要解析的参数列表。</p>
<p><strong>options</strong> -脚本想要识别的一串选项字母，其中的选项需要一个参数，参数后面应该跟一个冒号(😃。</p>
<p><strong>long_options(可选)</strong> -必须是包含长选项名称的字符串，应该支持。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>该方法返回一个由两个元素组成的值，即(<strong>选项列表，值</strong>)对，选项列表被剥离后留下的程序参数列表。</p>
</li>
<li class="lvl-4">
<p>每个选项和值对作为选项的第一个元素返回，短选项以连字符为前缀(例如，'-x ‘)，长选项以两个连字符为前缀(例如，’- long-option ')。</p>
</li>
</ul>
<p><strong>Exception getopt.GetoptError</strong></p>
<p>当在参数列表中发现无法识别的选项时，或者当任何需要参数的选项都没有给出参数时，就会出现这种异常。</p>
<p>异常的参数是指示错误原因的字符串。属性<strong>消息</strong>和<strong>选择</strong>给出错误信息和相关选项。</p>
<p><strong>代码</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> sys, getopt</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line">   inputfile = <span class="string">&#x27;&#x27;</span></span><br><span class="line">   outputfile = <span class="string">&#x27;&#x27;</span></span><br><span class="line">   <span class="keyword">try</span>:</span><br><span class="line">      opts, args = getopt.getopt(argv,<span class="string">&quot;hi:o:&quot;</span>,[<span class="string">&quot;ifile=&quot;</span>,<span class="string">&quot;ofile=&quot;</span>])</span><br><span class="line">   <span class="keyword">except</span> getopt.GetoptError:</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&#x27;test.py -i &lt;inputfile&gt; -o &lt;outputfile&gt;&#x27;</span></span><br><span class="line">      sys.exit(<span class="number">2</span>)</span><br><span class="line">   <span class="keyword">for</span> opt, arg <span class="keyword">in</span> opts:</span><br><span class="line">      <span class="keyword">if</span> opt == <span class="string">&#x27;-h&#x27;</span>:</span><br><span class="line">         <span class="built_in">print</span> <span class="string">&#x27;test.py -i &lt;inputfile&gt; -o &lt;outputfile&gt;&#x27;</span></span><br><span class="line">         sys.exit()</span><br><span class="line">      <span class="keyword">elif</span> opt <span class="keyword">in</span> (<span class="string">&quot;-i&quot;</span>, <span class="string">&quot;--ifile&quot;</span>):</span><br><span class="line">         inputfile = arg</span><br><span class="line">      <span class="keyword">elif</span> opt <span class="keyword">in</span> (<span class="string">&quot;-o&quot;</span>, <span class="string">&quot;--ofile&quot;</span>):</span><br><span class="line">         outputfile = arg</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&#x27;Input file is &quot;&#x27;</span>, inputfile</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&#x27;Output file is &quot;&#x27;</span>, outputfile</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">   main(sys.argv[<span class="number">1</span>:])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">$ test.py -h</span><br><span class="line">usage: test.py -i &lt;inputfile&gt; -o &lt;outputfile&gt;</span><br><span class="line"></span><br><span class="line">$ test.py -i BMP -o</span><br><span class="line">usage: test.py -i &lt;inputfile&gt; -o &lt;outputfile&gt;</span><br><span class="line"></span><br><span class="line">$ test.py -i inputfile</span><br><span class="line">Input file <span class="keyword">is</span> <span class="string">&quot; inputfile</span></span><br><span class="line"><span class="string">Output file is &quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="python-中如何使用命令行参数？">python 中如何使用命令行参数？</h2>
<table>
<thead>
<tr>
<th>组件</th>
<th>使用</th>
<th>Python 版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>sys</td>
<td>sys.argv 中的所有参数(基本)</td>
<td>all</td>
</tr>
<tr>
<td>argparse</td>
<td>构建命令行界面</td>
<td>&gt;= 2.3</td>
</tr>
<tr>
<td>docopt</td>
<td>已创建命令行界面</td>
<td>&gt;= 2.5</td>
</tr>
<tr>
<td>fire</td>
<td>自动生成命令行界面(CLi)</td>
<td>all</td>
</tr>
<tr>
<td>optparse</td>
<td>Deprecated</td>
<td>&lt; 2.7</td>
</tr>
</tbody>
</table>
<p>docopt</p>
<p>Docopt 用于创建命令行界面。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> docopt <span class="keyword">import</span> docopt</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">arguments = docopt(__doc__, version=<span class="string">&#x27;Example 1&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(arguments) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Fire</strong></p>
<p>Python Fire 自动生成命令行界面；你只需要一行代码。与其他模块不同，它可以立即工作。</p>
<p>您不需要定义任何参数；默认情况下，所有方法都是链接的。</p>
<p>要安装它，请键入:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install fire</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>定义或使用类别:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> fire</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">       <span class="keyword">def</span> <span class="title function_">openfile</span>(<span class="params">self, filename</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Open file &#x27;&quot;</span> + filename + <span class="string">&quot;&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    fire.Fire(Python) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>您有与类方法匹配的选项:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">python example.py hello</span><br><span class="line">python example.py openfile filename.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-command-line-arguments">https://www.javatpoint.com/python-command-line-arguments</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 多进程</title>
    <url>/posts/4300f84b.html</url>
    <content><![CDATA[<h1>Python 多进程</h1>
<p>在本文中，我们将学习如何使用 Python 实现多进程。我们还讨论了它的高级概念。</p>
<h3 id="什么是多进程？">什么是多进程？</h3>
<p>多进程是系统并行运行一个或多个进程的能力。简单来说，多进程使用单个计算机系统内的两个或更多 <a href="https://www.javatpoint.com/cpu-full-form">CPU</a> 。该方法还能够在多个进程之间分配任务。</p>
<p>处理单元共享主存储器和外围设备来同时处理程序。多进程应用分成更小的部分，独立运行。操作系统将每个进程分配给处理器。</p>
<p><a href="https://www.javatpoint.com/python-tutorial">Python</a> 提供了支持交换进程的称为多进程的内置包。在使用多进程之前，我们必须了解进程对象。</p>
<h3 id="为什么是多进程？">为什么是多进程？</h3>
<p>多进程对于在计算机系统中执行多种任务是必不可少的。假设一台计算机没有多进程器或单处理器。我们同时为该系统分配不同的进程。</p>
<p>然后，它将不得不中断前一个任务，并转移到另一个任务，以保持所有进程的运行。这就像厨师独自在厨房工作一样简单。他要做几个任务来烹饪食物，比如切、清洗、烹饪、揉面、烘焙等。</p>
<p>因此，多进程对于同时执行几个任务而不中断是必不可少的。它还使得跟踪所有任务变得容易。这就是为什么多进程的概念会出现。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>多进程可以表示为一台具有多个中央处理器的计算机。</p>
</li>
<li class="lvl-4">
<p>多核处理器是指具有两个或更多独立单元的单个计算组件。</p>
</li>
</ul>
<p>在多进程中， <a href="https://www.javatpoint.com/central-processing-unit">CPU</a> 可以一次分配多个任务，每个任务都有自己的处理器。</p>
<h2 id="Python-中的多进程">Python 中的多进程</h2>
<p>Python 提供了<code>multiprocessing</code>模块来在单个系统中执行多个任务。它提供了一个用户友好和直观的 API 来处理多进程。</p>
<p>让我们理解多进程的简单例子。</p>
<p>示例-</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">disp</span>():</span><br><span class="line">      <span class="built_in">print</span> (<span class="string">&#x27;Hello !! Welcome to Python Tutorial&#x27;</span>)</span><br><span class="line">      <span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">      p = Process(target=disp)</span><br><span class="line">      p.start()</span><br><span class="line">      p.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;Hello !! Welcome to Python Tutorial&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的代码中，我们已经导入了 Process 类，然后在 <strong>disp()</strong> 函数中创建了 Process 对象。然后我们使用 <strong>start()</strong> 方法开始流程，并使用 <strong>join()</strong> 方法完成流程。我们也可以使用<strong>参数</strong>关键字在声明的函数中传递参数。</p>
<p>让我们理解下面这个带参数的多进程的例子。</p>
<p><strong>示例- 2</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Python multiprocessing example</span></span><br><span class="line"><span class="comment"># importing the multiprocessing module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cube</span>(<span class="params">n</span>):</span><br><span class="line">   <span class="comment"># This function will print the cube of the given number</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;The Cube is: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(n * n * n))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="comment"># This function will print the square of the given number</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;The Square is: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(n * n))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">   <span class="comment"># creating two processes</span></span><br><span class="line">   process1 = multiprocessing.Process(target= square, args=(<span class="number">5</span>, ))</span><br><span class="line">   process2 = multiprocessing.Process(target= cube, args=(<span class="number">5</span>, ))</span><br><span class="line"></span><br><span class="line">   <span class="comment"># Here we start the process 1</span></span><br><span class="line">   process1.start()</span><br><span class="line">   <span class="comment"># Here we start process 2</span></span><br><span class="line">   process2.start()</span><br><span class="line"></span><br><span class="line">   <span class="comment"># The join() method is used to wait for process 1 to complete</span></span><br><span class="line">   process1.join()</span><br><span class="line">   <span class="comment"># It is used to wait for process 1 to complete</span></span><br><span class="line">   process2.join()</span><br><span class="line"></span><br><span class="line">   <span class="comment"># Print if both processes are completed</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Both processes are finished&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The Cube <span class="keyword">is</span>: <span class="number">125</span></span><br><span class="line">The Square <span class="keyword">is</span>: <span class="number">25</span></span><br><span class="line">Both processes are finished</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>解释-</strong></p>
<p>在上面的例子中，我们创建了两个函数-**cube()**函数计算给定数字的立方， <strong>square()</strong> 函数计算给定数字的平方。</p>
<p>接下来，我们定义了 process 类的 Process 对象，它有两个参数。第一个参数是代表要执行的函数的<strong>目标</strong>，第二个参数是代表要在函数中传递的参数的<strong>参数。</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">process1 = multiprocessing.Process(target= square, args=(<span class="number">5</span>, ))</span><br><span class="line">process2 = multiprocessing.Process(target= cube, args=(<span class="number">5</span>, ))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们使用了 <strong>start()</strong> 方法来启动流程。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">process1.start()</span><br><span class="line">process2.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>正如我们在输出中看到的，它等待完成<strong>过程一</strong>，然后是<strong>过程二</strong>。最后一条语句在两个进程完成后执行。</p>
<h2 id="Python-多进程类">Python 多进程类</h2>
<p>Python <code>multiprocessing</code>模块提供了许多常用于构建并行程序的类。我们将讨论它的主要类——进程、队列和锁。我们已经在前面的例子中讨论了 Process 类。现在我们将讨论队列和锁类。</p>
<p>让我们看一个简单的例子，获取系统中当前的 CPU 数量。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The number of CPU currently working in system : &quot;</span>, multiprocessing.cpu_count())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;The number of CPU currently woking in system : &#x27;</span>, <span class="number">32</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上 CPU 数量可能因您的电脑而异。对我们来说，核心数量是 32。</p>
<h2 id="使用队列类的-Python-多进程">使用队列类的 Python 多进程</h2>
<p>我们知道队列是数据结构的重要部分。Python 多进程与基于“先进先出”概念的数据结构队列完全相同。队列通常存储 Python 对象，并在进程间共享数据方面发挥重要作用。</p>
<p>队列作为参数在进程的目标函数中传递，以允许进程使用数据。队列提供 <strong>put()</strong> 函数插入数据， <strong>get()</strong> 函数从队列中获取数据。让我们理解下面的例子。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Importing Queue Class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line">fruits = [<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Orange&#x27;</span>, <span class="string">&#x27;Guava&#x27;</span>, <span class="string">&#x27;Papaya&#x27;</span>, <span class="string">&#x27;Banana&#x27;</span>]</span><br><span class="line">count = <span class="number">1</span></span><br><span class="line"><span class="comment"># creating a queue object</span></span><br><span class="line">queue = Queue()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;pushing items to the queue:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> fr <span class="keyword">in</span> fruits:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;item no: &#x27;</span>, count, <span class="string">&#x27; &#x27;</span>, fr)</span><br><span class="line">    queue.put(fr)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\npopping items from the queue:&#x27;</span>)</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> queue.empty():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;item no: &#x27;</span>, count, <span class="string">&#x27; &#x27;</span>, queue.get())</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">pushing items to the queue:</span><br><span class="line">(<span class="string">&#x27;item no: &#x27;</span>, <span class="number">1</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;Apple&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;item no: &#x27;</span>, <span class="number">2</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;Orange&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;item no: &#x27;</span>, <span class="number">3</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;Guava&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;item no: &#x27;</span>, <span class="number">4</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;Papaya&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;item no: &#x27;</span>, <span class="number">5</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;Banana&#x27;</span>)</span><br><span class="line"></span><br><span class="line">popping items <span class="keyword">from</span> the queue:</span><br><span class="line">(<span class="string">&#x27;item no: &#x27;</span>, <span class="number">0</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;Apple&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;item no: &#x27;</span>, <span class="number">1</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;Orange&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;item no: &#x27;</span>, <span class="number">2</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;Guava&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;item no: &#x27;</span>, <span class="number">3</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;Papaya&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;item no: &#x27;</span>, <span class="number">4</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;Banana&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>解释-</strong></p>
<p>在上面的代码中，我们已经导入了<strong>队列</strong>类，并初始化了名为水果的列表。接下来，我们将<strong>计数</strong>指定为 1。count 变量将计算元素的总数。然后，我们通过调用 <strong>Queue()</strong> 方法来创建队列对象。该对象将用于执行队列中的操作。在 <code>for</code>循环中，我们使用 <strong>put()</strong> 函数将元素一个接一个地插入到队列中，并随着循环的每次迭代将计数增加 1。</p>
<h2 id="Python-多进程锁类">Python 多进程锁类</h2>
<p>多进程 Lock 类用于获取进程的锁，这样我们就可以保持另一个进程执行类似的代码，直到锁被释放。锁类主要执行两个任务。第一种是使用 <strong>acquire()</strong> 功能获取锁，第二种是使用 <strong>release()</strong> 功能释放锁。</p>
<h2 id="Python-多进程示例">Python 多进程示例</h2>
<p>假设我们有多个任务。因此，我们创建了两个队列:第一个队列将维护任务，另一个队列将存储完整的任务日志。下一步是实例化进程来完成任务。如前所述，Queue 类已经同步，所以我们不需要使用 lock 类获取锁。</p>
<p>在下面的例子中，我们将把所有的多进程类合并在一起。让我们看看下面的例子。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Lock, Process, Queue, current_process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> queue </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">jobTodo</span>(<span class="params">tasks_to_perform, complete_tasks</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># The try block to catch task from the queue.</span></span><br><span class="line">            <span class="comment"># The get_nowait() function is used to</span></span><br><span class="line">            <span class="comment"># raise queue.Empty exception if the queue is empty.</span></span><br><span class="line"></span><br><span class="line">            task = tasks_to_perform.get_nowait()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> queue.Empty:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">                <span class="comment"># if no exception has been raised, the else block will execute</span></span><br><span class="line">                <span class="comment"># add the task completion</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(task)</span><br><span class="line">            complete_tasks.put(task + <span class="string">&#x27; is done by &#x27;</span> + current_process().name)</span><br><span class="line">            time.sleep(<span class="number">.5</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    total_task = <span class="number">8</span></span><br><span class="line">    total_number_of_processes = <span class="number">3</span></span><br><span class="line">    tasks_to_perform = Queue()</span><br><span class="line">    complete_tasks = Queue()</span><br><span class="line">    number_of_processes = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(total_task):</span><br><span class="line">        tasks_to_perform.put(<span class="string">&quot;Task no &quot;</span> + <span class="built_in">str</span>(i))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># defining number of processes</span></span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(total_number_of_processes):</span><br><span class="line">        p = Process(target=jobTodo, args=(tasks_to_perform, complete_tasks))</span><br><span class="line">        number_of_processes.append(p)</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># completing process</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> number_of_processes:</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print the output</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> complete_tasks.empty():</span><br><span class="line">        <span class="built_in">print</span>(complete_tasks.get())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Task no <span class="number">2</span></span><br><span class="line">Task no <span class="number">5</span></span><br><span class="line">Task no <span class="number">0</span></span><br><span class="line">Task no <span class="number">3</span></span><br><span class="line">Task no <span class="number">6</span></span><br><span class="line">Task no <span class="number">1</span></span><br><span class="line">Task no <span class="number">4</span></span><br><span class="line">Task no <span class="number">7</span></span><br><span class="line">Task no <span class="number">0</span> <span class="keyword">is</span> done by Process-<span class="number">1</span></span><br><span class="line">Task no <span class="number">1</span> <span class="keyword">is</span> done by Process-<span class="number">3</span></span><br><span class="line">Task no <span class="number">2</span> <span class="keyword">is</span> done by Process-<span class="number">2</span></span><br><span class="line">Task no <span class="number">3</span> <span class="keyword">is</span> done by Process-<span class="number">1</span></span><br><span class="line">Task no <span class="number">4</span> <span class="keyword">is</span> done by Process-<span class="number">3</span></span><br><span class="line">Task no <span class="number">5</span> <span class="keyword">is</span> done by Process-<span class="number">2</span></span><br><span class="line">Task no <span class="number">6</span> <span class="keyword">is</span> done by Process-<span class="number">1</span></span><br><span class="line">Task no <span class="number">7</span> <span class="keyword">is</span> done by Process-<span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Python-多进程池">Python 多进程池</h2>
<p>Python 多进程池对于跨多个输入值并行执行一个函数至关重要。它还用于将输入数据分布在进程间**(数据并行)**。考虑以下多进程池的示例。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">w = ([<span class="string">&quot;V&quot;</span>, <span class="number">5</span>], [<span class="string">&quot;X&quot;</span>, <span class="number">2</span>], [<span class="string">&quot;Y&quot;</span>, <span class="number">1</span>], [<span class="string">&quot;Z&quot;</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work_log</span>(<span class="params">data_for_work</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; Process name is %s waiting time is %s seconds&quot;</span> % (data_for_work[<span class="number">0</span>], data_for_work[<span class="number">1</span>]))</span><br><span class="line">    time.sleep(<span class="built_in">int</span>(data_for_work[<span class="number">1</span>]))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; Process %s Executed.&quot;</span> % data_for_work[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handler</span>():</span><br><span class="line">    p = Pool(<span class="number">2</span>)</span><br><span class="line">    p.<span class="built_in">map</span>(work_log, w)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    handler()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Process name <span class="keyword">is</span> V waiting time <span class="keyword">is</span> <span class="number">5</span> seconds</span><br><span class="line">Process V Executed.</span><br><span class="line">Process name <span class="keyword">is</span> X waiting time <span class="keyword">is</span> <span class="number">2</span> seconds</span><br><span class="line">Process X Executed.</span><br><span class="line">Process name <span class="keyword">is</span> Y waiting time <span class="keyword">is</span> <span class="number">1</span> seconds</span><br><span class="line">Process Y Executed.</span><br><span class="line">Process name <span class="keyword">is</span> Z waiting time <span class="keyword">is</span> <span class="number">3</span> seconds</span><br><span class="line">Process Z Executed.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>让我们了解多进程池的另一个例子。</p>
<p><strong>示例- 2</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> Pool(<span class="number">5</span>) <span class="keyword">as</span> p:</span><br><span class="line">        <span class="built_in">print</span>(p.<span class="built_in">map</span>(fun, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">27</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="代理对象">代理对象</h2>
<p>代理对象被称为驻留在不同进程中的共享对象。这个对象也被称为代理。多个代理对象可能有相似的引用。代理对象由各种方法组成，这些方法用于调用其引用对象的相应方法。下面是代理对象的例子。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager</span><br><span class="line">manager = Manager()</span><br><span class="line">l = manager.<span class="built_in">list</span>([i*i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)])</span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">repr</span>(l))</span><br><span class="line"><span class="built_in">print</span>(l[<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(l[<span class="number">2</span>:<span class="number">5</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line">&lt;ListProxy <span class="built_in">object</span>, typeid <span class="string">&#x27;list&#x27;</span> at <span class="number">0x7f063621ea10</span>&gt;</span><br><span class="line"><span class="number">16</span></span><br><span class="line">[<span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代理对象是可选择的，因此我们可以在进程之间传递它们。这些对象也用于同步的控制级别。</p>
<h2 id="多进程的常用功能">多进程的常用功能</h2>
<p>到目前为止，我们已经讨论了使用 Python 进行多进程的基本概念。多进程本身是一个广泛的主题，对于在单个系统中执行各种任务至关重要。我们正在定义一些常用于实现多进程的基本功能。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pipe()</td>
<td>pipe()函数返回一对连接对象。</td>
</tr>
<tr>
<td>pipe()</td>
<td>run()方法用于表示流程活动。</td>
</tr>
<tr>
<td>start()</td>
<td>start()方法用于启动进程。</td>
</tr>
<tr>
<td>join([timeout])</td>
<td>join()方法用于阻塞进程，直到调用 join()方法的进程终止。超时是可选参数。</td>
</tr>
<tr>
<td>is_alive()</td>
<td>如果进程是活动的，它将返回。</td>
</tr>
<tr>
<td>terminate()</td>
<td>顾名思义，它用于终止进程。永远记住 Linux 中使用 <strong>terminate()</strong> 方法，对于 Windows，我们使用 <strong>TerminateProcess()</strong> 方法。</td>
</tr>
<tr>
<td>kill()</td>
<td>这种方法类似于<strong>终止()</strong>，但使用的是 Unix 上的 SIGKILL 信号。</td>
</tr>
<tr>
<td>close()</td>
<td>该方法用于关闭<strong>进程</strong>对象，并释放与之相关的所有资源。</td>
</tr>
<tr>
<td>qsize()</td>
<td>它返回队列的大致大小。</td>
</tr>
<tr>
<td>empty()</td>
<td>如果队列为空，则返回<strong>真</strong>。</td>
</tr>
<tr>
<td>full()</td>
<td>如果队列已满，则返回<strong>真</strong>。</td>
</tr>
<tr>
<td>get_await()</td>
<td>这个方法相当于<strong>得到(False)</strong> 。</td>
</tr>
<tr>
<td>get()</td>
<td>此方法用于从队列中获取元素。它从队列中移除并返回一个元素。</td>
</tr>
<tr>
<td>put()</td>
<td>此方法用于将元素插入队列。</td>
</tr>
<tr>
<td>cpu_count()</td>
<td>它返回系统中工作的中央处理器的数量。</td>
</tr>
<tr>
<td>current_process()</td>
<td>它返回对应于当前进程的 Process 对象。</td>
</tr>
<tr>
<td>parent_process()</td>
<td>它返回对应于当前进程的父进程对象。</td>
</tr>
<tr>
<td>task_done()</td>
<td>此功能用于指示排队的任务已完成。</td>
</tr>
<tr>
<td>join_thread()</td>
<td>此方法用于连接后台线程</td>
</tr>
</tbody>
</table>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-multiprocessing">https://www.javatpoint.com/python-multiprocessing</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 字典</title>
    <url>/posts/781e27f3.html</url>
    <content><![CDATA[<h1>Python 字典</h1>
<p>Python 字典用于以键值对格式存储数据。字典是 Python 中的数据类型，它可以模拟现实生活中的数据排列，其中某个特定的键存在某个特定的值。它是可变的数据结构。字典被定义为元素键和值。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>键必须是单个元素</p>
</li>
<li class="lvl-4">
<p>值可以是任何类型，如列表、元组、整数等。</p>
</li>
</ul>
<p>换句话说，我们可以说字典是键值对的集合，其中的值可以是任何 Python 对象。相反，键是不可变的 Python 对象，即数字、字符串或元组。</p>
<h2 id="创建字典">创建字典</h2>
<p>字典可以通过使用用花括号{}括起来的多个键值对来创建，每个键都用冒号(:)与其值分开。下面给出了定义字典的语法。</p>
<p><strong>语法:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="type">Dict</span> = &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">22</span>&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的字典 <strong>Dict</strong> 中，键<strong>名称</strong>和<strong>年龄</strong>是不可变对象的字符串。</p>
<p>让我们看一个创建字典并打印其内容的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Employee = &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">29</span>, <span class="string">&quot;salary&quot;</span>:<span class="number">25000</span>,<span class="string">&quot;Company&quot;</span>:<span class="string">&quot;GOOGLE&quot;</span>&#125;  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Employee))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;printing Employee data .... &quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(Employee)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line">Printing Employee data .... </span><br><span class="line">&#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">29</span>, <span class="string">&#x27;salary&#x27;</span>: <span class="number">25000</span>, <span class="string">&#x27;Company&#x27;</span>: <span class="string">&#x27;GOOGLE&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Python 提供了内置函数 <strong>dict()</strong> 方法，也是用来创建字典的。空花括号{}用于创建空字典。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creating an empty Dictionary </span></span><br><span class="line"><span class="type">Dict</span> = &#123;&#125; </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Empty Dictionary: &quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="type">Dict</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Creating a Dictionary </span></span><br><span class="line"><span class="comment"># with dict() method </span></span><br><span class="line"><span class="type">Dict</span> = <span class="built_in">dict</span>(&#123;<span class="number">1</span>: <span class="string">&#x27;Java&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;T&#x27;</span>, <span class="number">3</span>:<span class="string">&#x27;Point&#x27;</span>&#125;) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nCreate Dictionary by using  dict(): &quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="type">Dict</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Creating a Dictionary </span></span><br><span class="line"><span class="comment"># with each item as a Pair </span></span><br><span class="line"><span class="type">Dict</span> = <span class="built_in">dict</span>([(<span class="number">1</span>, <span class="string">&#x27;Devansh&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;Sharma&#x27;</span>)]) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nDictionary with each item as a pair: &quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="type">Dict</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Empty Dictionary: </span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">Create Dictionary by using <span class="built_in">dict</span>(): </span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;Java&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;T&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;Point&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">Dictionary <span class="keyword">with</span> each item <span class="keyword">as</span> a pair: </span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;Devansh&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Sharma&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="访问字典值">访问字典值</h2>
<p>我们已经讨论了如何使用索引在列表和元组中访问数据。</p>
<p>但是，可以通过使用键来访问字典中的值，因为键在字典中是唯一的。</p>
<p>字典值可以通过以下方式访问。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Employee = &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">29</span>, <span class="string">&quot;salary&quot;</span>:<span class="number">25000</span>,<span class="string">&quot;Company&quot;</span>:<span class="string">&quot;GOOGLE&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Employee))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;printing Employee data .... &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Name : %s&quot;</span> %Employee[<span class="string">&quot;Name&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Age : %d&quot;</span> %Employee[<span class="string">&quot;Age&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Salary : %d&quot;</span> %Employee[<span class="string">&quot;salary&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Company : %s&quot;</span> %Employee[<span class="string">&quot;Company&quot;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line">printing Employee data .... </span><br><span class="line">Name : John</span><br><span class="line">Age : <span class="number">29</span></span><br><span class="line">Salary : <span class="number">25000</span></span><br><span class="line">Company : GOOGLE</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Python 为我们提供了一种使用 get()方法访问字典值的替代方法。它会给出与索引相同的结果。</p>
<h2 id="添加字典值">添加字典值</h2>
<p>字典是一种可变的数据类型，它的值可以通过使用特定的键来更新。该值可随键 <strong>Dict[key]=value</strong>一起更新。update()方法也用于更新现有值。</p>
<p>注意:如果键值已经存在于字典中，该值将被更新。否则，在字典中添加新的键。</p>
<p>让我们看一个更新字典值的例子。</p>
<p><strong>示例- 1:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creating an empty Dictionary </span></span><br><span class="line"><span class="type">Dict</span> = &#123;&#125; </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Empty Dictionary: &quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="type">Dict</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Adding elements to dictionary one at a time </span></span><br><span class="line"><span class="type">Dict</span>[<span class="number">0</span>] = <span class="string">&#x27;Peter&#x27;</span></span><br><span class="line"><span class="type">Dict</span>[<span class="number">2</span>] = <span class="string">&#x27;Joseph&#x27;</span></span><br><span class="line"><span class="type">Dict</span>[<span class="number">3</span>] = <span class="string">&#x27;Ricky&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nDictionary after adding 3 elements: &quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="type">Dict</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Adding set of values  </span></span><br><span class="line"><span class="comment"># with a single Key </span></span><br><span class="line"><span class="comment"># The Emp_ages doesn&#x27;t exist to dictionary</span></span><br><span class="line"><span class="type">Dict</span>[<span class="string">&#x27;Emp_ages&#x27;</span>] = <span class="number">20</span>, <span class="number">33</span>, <span class="number">24</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nDictionary after adding 3 elements: &quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="type">Dict</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Updating existing Key&#x27;s Value </span></span><br><span class="line"><span class="type">Dict</span>[<span class="number">3</span>] = <span class="string">&#x27;JavaTpoint&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nUpdated key value: &quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="type">Dict</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Empty Dictionary: </span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">Dictionary after adding <span class="number">3</span> elements: </span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">&#x27;Peter&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Joseph&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;Ricky&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">Dictionary after adding <span class="number">3</span> elements: </span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">&#x27;Peter&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Joseph&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;Ricky&#x27;</span>, <span class="string">&#x27;Emp_ages&#x27;</span>: (<span class="number">20</span>, <span class="number">33</span>, <span class="number">24</span>)&#125;</span><br><span class="line"></span><br><span class="line">Updated key value: </span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">&#x27;Peter&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Joseph&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;JavaTpoint&#x27;</span>, <span class="string">&#x27;Emp_ages&#x27;</span>: (<span class="number">20</span>, <span class="number">33</span>, <span class="number">24</span>)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例- 2:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Employee = &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">29</span>, <span class="string">&quot;salary&quot;</span>:<span class="number">25000</span>,<span class="string">&quot;Company&quot;</span>:<span class="string">&quot;GOOGLE&quot;</span>&#125;  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Employee))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;printing Employee data .... &quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(Employee)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Enter the details of the new employee....&quot;</span>);  </span><br><span class="line">Employee[<span class="string">&quot;Name&quot;</span>] = <span class="built_in">input</span>(<span class="string">&quot;Name: &quot;</span>);  </span><br><span class="line">Employee[<span class="string">&quot;Age&quot;</span>] = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Age: &quot;</span>));  </span><br><span class="line">Employee[<span class="string">&quot;salary&quot;</span>] = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Salary: &quot;</span>));  </span><br><span class="line">Employee[<span class="string">&quot;Company&quot;</span>] = <span class="built_in">input</span>(<span class="string">&quot;Company:&quot;</span>);  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;printing the new data&quot;</span>);  </span><br><span class="line"><span class="built_in">print</span>(Employee)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Empty Dictionary: </span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">Dictionary after adding <span class="number">3</span> elements: </span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">&#x27;Peter&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Joseph&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;Ricky&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">Dictionary after adding <span class="number">3</span> elements: </span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">&#x27;Peter&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Joseph&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;Ricky&#x27;</span>, <span class="string">&#x27;Emp_ages&#x27;</span>: (<span class="number">20</span>, <span class="number">33</span>, <span class="number">24</span>)&#125;</span><br><span class="line"></span><br><span class="line">Updated key value: </span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">&#x27;Peter&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Joseph&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;JavaTpoint&#x27;</span>, <span class="string">&#x27;Emp_ages&#x27;</span>: (<span class="number">20</span>, <span class="number">33</span>, <span class="number">24</span>)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="使用-del-关键字删除元素">使用 del 关键字删除元素</h2>
<p>使用下面给出的 <strong>del</strong> 关键字可以删除字典中的项目。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Employee = &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">29</span>, <span class="string">&quot;salary&quot;</span>:<span class="number">25000</span>,<span class="string">&quot;Company&quot;</span>:<span class="string">&quot;GOOGLE&quot;</span>&#125;  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Employee))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;printing Employee data .... &quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(Employee)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Deleting some of the employee data&quot;</span>)   </span><br><span class="line"><span class="keyword">del</span> Employee[<span class="string">&quot;Name&quot;</span>]  </span><br><span class="line"><span class="keyword">del</span> Employee[<span class="string">&quot;Company&quot;</span>]  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;printing the modified information &quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(Employee)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Deleting the dictionary: Employee&quot;</span>);  </span><br><span class="line"><span class="keyword">del</span> Employee  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Lets try to print it again &quot;</span>);  </span><br><span class="line"><span class="built_in">print</span>(Employee)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line">printing Employee data .... </span><br><span class="line">&#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">29</span>, <span class="string">&#x27;salary&#x27;</span>: <span class="number">25000</span>, <span class="string">&#x27;Company&#x27;</span>: <span class="string">&#x27;GOOGLE&#x27;</span>&#125;</span><br><span class="line">Deleting some of the employee data</span><br><span class="line">printing the modified information </span><br><span class="line">&#123;<span class="string">&#x27;Age&#x27;</span>: <span class="number">29</span>, <span class="string">&#x27;salary&#x27;</span>: <span class="number">25000</span>&#125;</span><br><span class="line">Deleting the dictionary: Employee</span><br><span class="line">Lets <span class="keyword">try</span> to <span class="built_in">print</span> it again </span><br><span class="line">NameError: name <span class="string">&#x27;Employee&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面代码中的最后一个 print 语句，它引发了一个错误，因为我们试图打印已经删除的 Employee 字典。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>使用 pop()方法</strong></p>
</li>
</ul>
<p><strong>pop()</strong> 方法接受键作为参数，并移除相关联的值。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creating a Dictionary </span></span><br><span class="line"><span class="type">Dict</span> = &#123;<span class="number">1</span>: <span class="string">&#x27;JavaTpoint&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Peter&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;Thomas&#x27;</span>&#125; </span><br><span class="line"><span class="comment"># Deleting a key  </span></span><br><span class="line"><span class="comment"># using pop() method </span></span><br><span class="line">pop_ele = <span class="type">Dict</span>.pop(<span class="number">3</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="type">Dict</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;JavaTpoint&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Peter&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Python 还提供了一个内置的方法 popitem()和 clear()方法，用于从字典中移除元素。popitem()从字典中移除任意元素，而 clear()方法移除整个字典中的所有元素。</p>
<h2 id="迭代字典">迭代字典</h2>
<p>字典可以使用 <code>for</code>循环进行迭代，如下所示。</p>
<h3 id="例-1-12">例 1</h3>
<p><strong># <code>for</code>循环打印字典的所有键</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Employee = &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">29</span>, <span class="string">&quot;salary&quot;</span>:<span class="number">25000</span>,<span class="string">&quot;Company&quot;</span>:<span class="string">&quot;GOOGLE&quot;</span>&#125;  </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> Employee:  </span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Name</span><br><span class="line">Age</span><br><span class="line">salary</span><br><span class="line">Company</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例-2-9">例 2</h3>
<p><strong>#<code>for</code>循环打印字典的所有值</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Employee = &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">29</span>, <span class="string">&quot;salary&quot;</span>:<span class="number">25000</span>,<span class="string">&quot;Company&quot;</span>:<span class="string">&quot;GOOGLE&quot;</span>&#125;  </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> Employee:  </span><br><span class="line">    <span class="built_in">print</span>(Employee[x])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">John</span><br><span class="line"><span class="number">29</span></span><br><span class="line"><span class="number">25000</span></span><br><span class="line">GOOGLE</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="示例-3-2">示例- 3</h3>
<p><strong>#<code>for</code>循环使用 values()方法打印字典的值。</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Employee = &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">29</span>, <span class="string">&quot;salary&quot;</span>:<span class="number">25000</span>,<span class="string">&quot;Company&quot;</span>:<span class="string">&quot;GOOGLE&quot;</span>&#125;  </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> Employee.values():  </span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">John</span><br><span class="line"><span class="number">29</span></span><br><span class="line"><span class="number">25000</span></span><br><span class="line">GOOGLE</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例-4">例 4</h3>
<p><strong>#<code>for</code>循环使用 items()方法打印字典的项目。</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Employee = &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">29</span>, <span class="string">&quot;salary&quot;</span>:<span class="number">25000</span>,<span class="string">&quot;Company&quot;</span>:<span class="string">&quot;GOOGLE&quot;</span>&#125;  </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> Employee.items():  </span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;John&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;Age&#x27;</span>, <span class="number">29</span>)</span><br><span class="line">(<span class="string">&#x27;salary&#x27;</span>, <span class="number">25000</span>)</span><br><span class="line">(<span class="string">&#x27;Company&#x27;</span>, <span class="string">&#x27;GOOGLE&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="字典键的属性">字典键的属性</h2>
<p>1.在字典中，我们不能为同一个键存储多个值。如果我们为一个键传递多个值，那么最后分配的值被认为是该键的值。</p>
<p>考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Employee=&#123;<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;John&quot;</span>,<span class="string">&quot;Age&quot;</span>:<span class="number">29</span>,<span class="string">&quot;Salary&quot;</span>:<span class="number">25000</span>,<span class="string">&quot;Company&quot;</span>:<span class="string">&quot;GOOGLE&quot;</span>,<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;John&quot;</span>&#125;  </span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> Employee.items():  </span><br><span class="line">    <span class="built_in">print</span>(x,y)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Name John</span><br><span class="line">Age <span class="number">29</span></span><br><span class="line">Salary <span class="number">25000</span></span><br><span class="line">Company GOOGLE</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.在 python 中，键不能是任何可变对象。我们可以使用数字、字符串或元组作为关键字，但是我们不能使用任何像列表这样的可变对象作为字典中的关键字。</p>
<p>考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Employee = &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">29</span>, <span class="string">&quot;salary&quot;</span>:<span class="number">25000</span>,<span class="string">&quot;Company&quot;</span>:<span class="string">&quot;GOOGLE&quot;</span>,[<span class="number">100</span>,<span class="number">201</span>,<span class="number">301</span>]:<span class="string">&quot;Department ID&quot;</span>&#125;  </span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> Employee.items():  </span><br><span class="line">    <span class="built_in">print</span>(x,y)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;dictionary.py&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> </span><br><span class="line">    Employee = &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">29</span>, <span class="string">&quot;salary&quot;</span>:<span class="number">25000</span>,<span class="string">&quot;Company&quot;</span>:<span class="string">&quot;GOOGLE&quot;</span>,[<span class="number">100</span>,<span class="number">201</span>,<span class="number">301</span>]:<span class="string">&quot;Department ID&quot;</span>&#125;</span><br><span class="line">TypeError: unhashable <span class="built_in">type</span>: <span class="string">&#x27;list&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="内置字典功能">内置字典功能</h2>
<p>下面给出了内置的 python 字典方法以及描述。</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>len(dict)</td>
<td>它被用来计算字典的长度。</td>
</tr>
<tr>
<td>any(dict)</td>
<td>与处理列表和元组的方式一样，如果一个字典键确实具有计算结果为 True 的布尔表达式，则 any() 方法确实会返回 True。</td>
</tr>
<tr>
<td>all(dict)</td>
<td>与any()方法不同的是，all()只有在字典的每个键都包含一个True布尔值时才返回True。</td>
</tr>
<tr>
<td>sorted(dict)</td>
<td>与列表和元组一样，sorted() 方法返回字典键的有序序列。升序排序对原始Python字典没有影响。</td>
</tr>
</tbody>
</table>
<h2 id="内置字典方法">内置字典方法</h2>
<p>下面给出了内置的 python 字典方法以及描述。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>dict.clear()</td>
<td>它用于删除字典中的所有条目。</td>
</tr>
<tr>
<td>dict.copy()</td>
<td>它返回字典的一个简单副本。</td>
</tr>
<tr>
<td>dict.from key(iterable，value= None，/)</td>
<td>根据值等于值的可迭代表创建新字典。</td>
</tr>
<tr>
<td>dict.get(key，default=“none”)</td>
<td>它用于获取为传递的键指定的值。</td>
</tr>
<tr>
<td>dict.has_key(key)</td>
<td>如果字典包含指定的键，则返回 true。</td>
</tr>
<tr>
<td>dict.items()</td>
<td>它以元组的形式返回所有键值对。</td>
</tr>
<tr>
<td>dict.key()</td>
<td>它返回字典的所有键。</td>
</tr>
<tr>
<td>dict.setdefault(key，default =“None”)</td>
<td>如果没有在字典中指定关键字，它用于将关键字设置为默认值</td>
</tr>
<tr>
<td>dict.update(dict2)</td>
<td>它通过向字典中添加 dict2 的键值对来更新字典。</td>
</tr>
<tr>
<td>values()</td>
<td>它返回字典的所有值。</td>
</tr>
<tr>
<td>len()</td>
<td>长度</td>
</tr>
<tr>
<td>popitem()</td>
<td>随机删除元素</td>
</tr>
<tr>
<td>pop()</td>
<td>指定删除元素</td>
</tr>
<tr>
<td>count()</td>
<td>计数</td>
</tr>
<tr>
<td>index()</td>
<td>索引</td>
</tr>
</tbody>
</table>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-dictionary">https://www.javatpoint.com/python-dictionary</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 字符串</title>
    <url>/posts/fe4ed95b.html</url>
    <content><![CDATA[<h1>Python 字符串</h1>
<p>到目前为止，我们已经讨论了 Python 中作为标准数据类型的数字。在本节教程中，我们将讨论 Python 中最流行的数据类型，即字符串。</p>
<p>Python 字符串是由单引号、双引号或三引号括起来的字符的集合。计算机不理解字符；在内部，它将被操纵的字符存储为 0 和 1 的组合。</p>
<p>每个字符都用 ASCII 或 Unicode 字符编码。所以我们可以说 Python 字符串也叫做 Unicode 字符的集合。</p>
<p>在 Python 中，字符串可以通过在引号中包含字符或字符序列来创建。Python 允许我们使用单引号、双引号或三引号来创建字符串。</p>
<p>考虑下面 Python 中的例子来创建一个字符串。</p>
<h3 id="语法">语法:</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;Hi Python !&quot;</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，如果我们使用 Python 脚本检查变量<strong>字符串</strong>的类型</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">str</span>)), then it will <span class="built_in">print</span> a string (<span class="built_in">str</span>).  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在 Python 中，字符串被视为字符序列，这意味着 Python 不支持字符数据类型；相反，写为“p”的单个字符被视为长度为 1 的字符串。</p>
<h2 id="用-Python-创建字符串">用 Python 创建字符串</h2>
<p>我们可以通过用单引号或双引号将字符括起来来创建字符串。Python 还提供了三重引号来表示字符串，但它通常用于多行字符串或<strong>文档字符串</strong>。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#Using single quotes</span></span><br><span class="line">str1 = <span class="string">&#x27;Hello Python&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(str1)</span><br><span class="line"><span class="comment">#Using double quotes</span></span><br><span class="line">str2 = <span class="string">&quot;Hello Python&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Using triple quotes</span></span><br><span class="line">str3 = <span class="string">&#x27;&#x27;&#x27;Triple quotes are generally used for </span></span><br><span class="line"><span class="string">    represent the multiline or</span></span><br><span class="line"><span class="string">    docstring&#x27;&#x27;&#x27;</span> </span><br><span class="line"><span class="built_in">print</span>(str3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Hello Python</span><br><span class="line">Hello Python</span><br><span class="line">Triple quotes are generally used <span class="keyword">for</span> </span><br><span class="line">    represent the multiline <span class="keyword">or</span></span><br><span class="line">    docstring</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="字符串索引和拆分">字符串索引和拆分</h2>
<p>像其他语言一样，Python 字符串的索引从 0 开始。例如，字符串“HELLO”的索引如下图所示。</p>
<p><img src="/img/e7cc0c71bb40b0c8f29f30e3107ed2cc.png" alt="Python String"></p>
<p>考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;HELLO&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">4</span>])</span><br><span class="line"><span class="comment"># It returns the IndexError because 6th index doesn&#x27;t exist</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">6</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">H</span><br><span class="line">E</span><br><span class="line">L</span><br><span class="line">L</span><br><span class="line">O</span><br><span class="line">IndexError: string index out of <span class="built_in">range</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如 Python 所示，切片运算符[]用于访问字符串的各个字符。但是，我们可以使用 Python 中的:(冒号)运算符从给定的字符串中访问子字符串。考虑下面的例子。</p>
<p><img src="/img/843b99a3c370382db5fab064dd71f623.png" alt="Python String"></p>
<p>在这里，我们必须注意到切片运算符中给出的上限总是排他的，即如果给定了 str = 'HELLO '，那么 str[1:3]将始终包括 str[1] = 'E '，str[2] = 'L '等。</p>
<p>考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Given String</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;JAVATPOINT&quot;</span></span><br><span class="line"><span class="comment"># Start Oth index to end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>:])</span><br><span class="line"><span class="comment"># Starts 1th index to 4th index</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">1</span>:<span class="number">5</span>])</span><br><span class="line"><span class="comment"># Starts 2nd index to 3rd index</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:<span class="number">4</span>])</span><br><span class="line"><span class="comment"># Starts 0th to 2nd index</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[:<span class="number">3</span>])</span><br><span class="line"><span class="comment">#Starts 4th to 6th index</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">4</span>:<span class="number">7</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">JAVATPOINT</span><br><span class="line">AVAT</span><br><span class="line">VA</span><br><span class="line">JAV</span><br><span class="line">TPO</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以在字符串中进行负切片；它从最右边的字符开始，表示为-1。第二个最右边的索引表示-2，依此类推。请看下图。</p>
<p><img src="/img/215eeac38272afdae7bb1ffb34ee8579.png" alt="Python String"></p>
<p>考虑以下示例</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;JAVATPOINT&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[-<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[-<span class="number">2</span>:])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[-<span class="number">4</span>:-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[-<span class="number">7</span>:-<span class="number">2</span>])</span><br><span class="line"><span class="comment"># Reversing the given string</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[::-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[-<span class="number">12</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">T</span><br><span class="line">I</span><br><span class="line">NT</span><br><span class="line">OIN</span><br><span class="line">ATPOI</span><br><span class="line">TNIOPTAVAJ</span><br><span class="line">IndexError: string index out of <span class="built_in">range</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="重新分配字符串">重新分配字符串</h2>
<p>更新字符串的内容就像将其分配给新字符串一样简单。字符串对象不支持项赋值，即字符串只能用新字符串替换，因为它的内容不能被部分替换。字符串在 Python 中是不可变的。</p>
<p>考虑下面的例子。</p>
<h3 id="例-1-13">例 1</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;HELLO&quot;</span>  </span><br><span class="line"><span class="built_in">str</span>[<span class="number">0</span>] = <span class="string">&quot;h&quot;</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;12.py&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">str</span>[<span class="number">0</span>] = <span class="string">&quot;h&quot;</span>;</span><br><span class="line">TypeError: <span class="string">&#x27;str&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然而，在示例 1 中，字符串 <strong>str</strong> 可以被完全分配给新的内容，如以下示例中所指定的。</p>
<h3 id="例-2-10">例 2</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;HELLO&quot;</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)  </span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;hello&quot;</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">HELLO</span><br><span class="line">hello  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="删除字符串">删除字符串</h2>
<p>我们知道字符串是不可变的。我们不能删除字符串中的字符。但是我们可以使用 <strong>del</strong> 关键字删除整个字符串。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;JAVATPOINT&quot;</span></span><br><span class="line"><span class="keyword">del</span> <span class="built_in">str</span>[<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">TypeError: <span class="string">&#x27;str&#x27;</span> <span class="built_in">object</span> doesn<span class="string">&#x27;t support item deletion</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>现在我们删除整个字符串。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">str1 = <span class="string">&quot;JAVATPOINT&quot;</span></span><br><span class="line"><span class="keyword">del</span> str1</span><br><span class="line"><span class="built_in">print</span>(str1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">NameError: name <span class="string">&#x27;str1&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="字符串运算符">字符串运算符</h2>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>它被称为连接运算符，用于连接运算符两侧的字符串。</td>
</tr>
<tr>
<td>*</td>
<td>它被称为重复算子。它将同一字符串的多个副本连接起来。</td>
</tr>
<tr>
<td>[]</td>
<td>它被称为切片算子。它用于访问特定字符串的子字符串。</td>
</tr>
<tr>
<td>[:]</td>
<td>它被称为范围切片运算符。它用于访问指定范围内的字符。</td>
</tr>
<tr>
<td>in</td>
<td>它被称为成员运算符。如果指定的字符串中存在特定的子字符串，则返回。</td>
</tr>
<tr>
<td>not in</td>
<td>它也是一个成员操作符，其作用与 in 完全相反。如果指定的字符串中不存在特定的子字符串，则返回 true。</td>
</tr>
<tr>
<td>r/R</td>
<td>它用于指定原始字符串。原始字符串用于我们需要打印转义字符(如“C://python”)的实际含义的情况。要将任何字符串定义为原始字符串，字符 R 或 R 后面是字符串。</td>
</tr>
<tr>
<td>%</td>
<td>它用于执行字符串格式化。它利用 C 编程中使用的格式说明符，如%d 或%f，在 python 中映射它们的值。我们将讨论如何在 python 中进行格式化。</td>
</tr>
</tbody>
</table>
<h3 id="例子-38">例子</h3>
<p>考虑下面的例子来理解 Python 操作符的真正用途。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;Hello&quot;</span>   </span><br><span class="line">str1 = <span class="string">&quot; world&quot;</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>*<span class="number">3</span>) <span class="comment"># prints HelloHelloHello  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>+str1)<span class="comment"># prints Hello world   </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">4</span>]) <span class="comment"># prints o              </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:<span class="number">4</span>]); <span class="comment"># prints ll                  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;w&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>) <span class="comment"># prints false as w is not present in str  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;wo&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> str1) <span class="comment"># prints false as wo is present in str1\.   </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">r&#x27;C://python37&#x27;</span>) <span class="comment"># prints C://python37 as it is written  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The string str : %s&quot;</span>%(<span class="built_in">str</span>)) <span class="comment"># prints The string str : Hello   </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">HelloHelloHello</span><br><span class="line">Hello world</span><br><span class="line">o</span><br><span class="line">ll</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line">C://python37</span><br><span class="line">The string <span class="built_in">str</span> : Hello</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Python-字符串格式">Python 字符串格式</h2>
<h3 id="换码顺序">换码顺序</h3>
<p>让我们假设我们需要把文本写成——他们说，“你好，发生什么事了？”-给定的语句可以用单引号或双引号写出，但它会引发<strong>语法错误</strong>，因为它同时包含单引号和双引号。</p>
<h2 id="例子-39">例子</h2>
<p>考虑下面的例子来理解 Python 操作符的真正用途。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;They said, &quot;</span>Hello what<span class="string">&#x27;s going on?&quot;&quot;</span></span><br><span class="line"><span class="string">print(str)</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">SyntaxError: invalid syntax</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以使用三重引号来解决这个问题，但是 Python 提供了转义序列。</p>
<p>反斜杠(/)符号表示转义序列。反斜杠后面可以跟一个特殊的字符，它有不同的解释。字符串中的单引号必须转义。我们可以应用与双引号中相同的内容。</p>
<h3 id="示例-9">示例-</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># using triple quotes</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;&#x27;They said, &quot;What&#x27;s there?&quot;&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># escaping single quotes</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;They said, &quot;What\&#x27;s going on?&quot;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># escaping double quotes</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;They said, \&quot;What&#x27;s going on?\&quot;&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">They said, <span class="string">&quot;What&#x27;s there?&quot;</span></span><br><span class="line">They said, <span class="string">&quot;What&#x27;s going on?&quot;</span></span><br><span class="line">They said, <span class="string">&quot;What&#x27;s going on?&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>转义序列列表如下所示:</p>
<p><img src="/img/2023-07-1815.20.32.png" alt="转义序列"></p>
<p>以下是转义序列的简单示例。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;C:\\Users\\DEVANSH SHARMA\\Python32\\Lib&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;This is the \n multiline quotes&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;This is \x48\x45\x58 representation&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">C:\Users\DEVANSH SHARMA\Python32\Lib</span><br><span class="line">This <span class="keyword">is</span> the </span><br><span class="line"> multiline quotes</span><br><span class="line">This <span class="keyword">is</span> HEX representation</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以使用原始字符串忽略给定字符串的转义序列。我们可以通过在字符串前面写 <strong>r</strong> 或 <strong>R</strong> 来实现。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">r&quot;C:\\Users\\DEVANSH SHARMA\\Python32&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">C:\\Users\\DEVANSH SHARMA\\Python32</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="format-方法">format()方法</h2>
<p><strong>format()</strong> 方法是格式化字符串时最灵活、最有用的方法。大括号{}用作字符串中的占位符，并被**格式()**方法参数替换。让我们看一下给出的一个例子:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Using Curly braces</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; and &#123;&#125; both are the best friend&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;Devansh&quot;</span>,<span class="string">&quot;Abhishek&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#Positional Argument</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;1&#125; and &#123;0&#125; best players &quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;Virat&quot;</span>,<span class="string">&quot;Rohit&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#Keyword Argument</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;a&#125;,&#123;b&#125;,&#123;c&#125;&quot;</span>.<span class="built_in">format</span>(a = <span class="string">&quot;James&quot;</span>, b = <span class="string">&quot;Peter&quot;</span>, c = <span class="string">&quot;Ricky&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Devansh <span class="keyword">and</span> Abhishek both are the best friend</span><br><span class="line">Rohit <span class="keyword">and</span> Virat best players </span><br><span class="line">James,Peter,Ricky </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="使用-运算符的-Python-字符串格式">使用%运算符的 Python 字符串格式</h2>
<p>Python 允许我们使用 C 的 printf 语句中使用的格式说明符。Python 中的格式说明符的处理方式与 c 语言中的相同。但是，Python 提供了一个额外的运算符%，用作格式说明符及其值之间的接口。换句话说，我们可以说它将格式说明符绑定到值。</p>
<p>考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Integer = <span class="number">10</span>;  </span><br><span class="line">Float = <span class="number">1.290</span>  </span><br><span class="line">String = <span class="string">&quot;Devansh&quot;</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hi I am Integer ... My value is %d\nHi I am float ... My value is %f\nHi I am string ... My value is %s&quot;</span>%(Integer,Float,String))  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Hi I am Integer ... My value <span class="keyword">is</span> <span class="number">10</span></span><br><span class="line">Hi I am <span class="built_in">float</span> ... My value <span class="keyword">is</span> <span class="number">1.290000</span></span><br><span class="line">Hi I am string ... My value <span class="keyword">is</span> Devansh</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-字符串函数">Python 字符串函数</h2>
<p>Python 提供了各种用于字符串处理的内置函数。许多字符串乐趣</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>capitalize()</td>
<td>它将字符串的第一个字符大写。python3 中不推荐使用此函数</td>
</tr>
<tr>
<td>casefold()</td>
<td>它返回适合无大小写比较的 s 版本。</td>
</tr>
<tr>
<td>center(width ,fillchar)</td>
<td>它返回一个空格填充的字符串，原始字符串以相等数量的左右空格为中心。</td>
</tr>
<tr>
<td>count(string,begin,end)</td>
<td>它计算字符串中开始和结束索引之间的子字符串出现的次数。</td>
</tr>
<tr>
<td>decode(encoding = ‘UTF8’, errors = ‘strict’)</td>
<td>使用注册用于编码的编解码器解码字符串。</td>
</tr>
<tr>
<td>encode()</td>
<td>使用为编码注册的编解码器对 S 进行编码。默认编码为“utf-8”。</td>
</tr>
<tr>
<td>endswith(suffix ,begin=0,end=len(string))</td>
<td>如果字符串在开始和结束之间以给定后缀结束，它将返回一个布尔值。</td>
</tr>
<tr>
<td>expandtabs(tabsize = 8)</td>
<td>它将字符串中的制表符定义为多个空格。默认空间值为 8。</td>
</tr>
<tr>
<td>find(substring ,beginIndex, endIndex)</td>
<td>它返回在开始索引和结束索引之间找到子字符串的字符串的索引值。</td>
</tr>
<tr>
<td>format(value)</td>
<td>它使用传递的值返回 S 的格式化版本。</td>
</tr>
<tr>
<td>index(subsring, beginIndex, endIndex)</td>
<td>如果找不到字符串，它将引发异常。它的工作原理与 find()方法相同。</td>
</tr>
<tr>
<td>isalnum()</td>
<td>如果字符串中的字符是字母数字，即字母或数字，并且至少有 1 个字符，则返回 true。否则，它返回 false。</td>
</tr>
<tr>
<td>isalpha()</td>
<td>如果所有字符都是字母并且至少有一个字符，则返回真，否则返回假。</td>
</tr>
<tr>
<td>isdiction()</td>
<td>如果字符串的所有字符都是小数，则返回 true。</td>
</tr>
<tr>
<td>isdigital()</td>
<td>如果所有字符都是数字并且至少有一个字符，则返回真，否则返回假。</td>
</tr>
<tr>
<td>isidentifier()</td>
<td>如果字符串是有效的标识符，则返回 true。</td>
</tr>
<tr>
<td>islower())</td>
<td>如果字符串的字符是小写，则返回 true，否则返回 false。</td>
</tr>
<tr>
<td>isnumeric()</td>
<td>如果字符串只包含数字字符，则返回 true。</td>
</tr>
<tr>
<td>isprintable()</td>
<td>如果 s 的所有字符都是可打印的或 s 为空，则返回 true，否则返回 false。</td>
</tr>
<tr>
<td>isupper()</td>
<td>如果字符串的字符为大写，则返回 false，否则返回 False。</td>
</tr>
<tr>
<td>isspace()</td>
<td>如果字符串的字符是空格，则返回 true，否则返回 false。</td>
</tr>
<tr>
<td>istitle()</td>
<td>如果字符串标题正确，则返回 true，否则返回 false。标题字符串的第一个字符是大写的，而其他字符是小写的。</td>
</tr>
<tr>
<td>isupper()</td>
<td>如果字符串的所有字符(如果存在)都为真，则返回真，否则返回假。</td>
</tr>
<tr>
<td>join(seq)</td>
<td>它合并给定序列的字符串表示。</td>
</tr>
<tr>
<td>len(string)</td>
<td>它返回字符串的长度。</td>
</tr>
<tr>
<td>ljust(width[,fillchar])</td>
<td>它返回空格填充的字符串，原始字符串左对齐给定的宽度。</td>
</tr>
<tr>
<td>lower()</td>
<td>它将字符串的所有字符转换为小写。</td>
</tr>
<tr>
<td>lstrip()</td>
<td>它删除字符串的所有前导空格，也可用于删除前导中的特定字符。</td>
</tr>
<tr>
<td>partition()</td>
<td>它在 S 中搜索分隔符 sep，并返回它之前的部分、分隔符本身和它之后的部分。如果找不到分隔符，返回 S 和两个空字符串。</td>
</tr>
<tr>
<td>maketrans()</td>
<td>它返回一个用于翻译函数的翻译表。</td>
</tr>
<tr>
<td>replace(old,new[,count])</td>
<td>它用新的字符序列替换旧的字符序列。如果给定了 max，则 max 字符将被替换。</td>
</tr>
<tr>
<td>rfind(str，beg=0，end=len(str))</td>
<td>它类似于 find，但它以向后的方向遍历字符串。</td>
</tr>
<tr>
<td>rindex(str，beg=0，end=len(str))</td>
<td>它与索引相同，但它以向后的方向遍历字符串。</td>
</tr>
<tr>
<td>rjust(width,[,fillchar])</td>
<td>返回一个空格填充的字符串，其原始字符串右对齐指定的字符数。</td>
</tr>
<tr>
<td>rstrip()</td>
<td>它删除字符串的所有尾部空白，也可以用来删除尾部的特定字符。</td>
</tr>
<tr>
<td>rsplit(sep = none，maxsplit = -1)</td>
<td>它与 split()相同，但它从向后的方向处理字符串。它返回字符串中的单词列表。如果未指定分隔符，则字符串会根据空格进行拆分。</td>
</tr>
<tr>
<td>split(str,num=string.count(str))</td>
<td>根据分隔符字符串拆分字符串。如果未提供分隔符，字符串将根据空格进行拆分。它返回与分隔符连接的子字符串列表。</td>
</tr>
<tr>
<td>splitlines(num=string.count(‘\n’))</td>
<td>它返回删除换行符后每行的字符串列表。</td>
</tr>
<tr>
<td>startswith(str，beg=0，end=len(str))</td>
<td>如果字符串从开始和结束之间的给定字符串开始，它将返回一个布尔值。</td>
</tr>
<tr>
<td>strip([chars])</td>
<td>它用于对字符串执行 lstrip()和 rstrip()。</td>
</tr>
<tr>
<td>swapcase()</td>
<td>它反转字符串中所有字符的大小写。</td>
</tr>
<tr>
<td>title()</td>
<td>它用于将字符串转换为标题大小写，即字符串<strong>meereut</strong>将转换为 meereut。</td>
</tr>
<tr>
<td>translate(table,deletechars = ‘’)</td>
<td>它根据函数中传递的转换表来转换字符串。</td>
</tr>
<tr>
<td>upper()</td>
<td>它将字符串的所有字符转换为大写。</td>
</tr>
<tr>
<td>zfill(width)</td>
<td>返回用零填充的原始字符串，总宽度为个字符；zfill()用于数字，保留任何给定的符号(小于零)。</td>
</tr>
<tr>
<td>rpartition()</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-strings">https://www.javatpoint.com/python-strings</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 字面量</title>
    <url>/posts/df094b34.html</url>
    <content><![CDATA[<h1>Python 字面量</h1>
<p>Python 字面量可以定义为变量或常量中给出的数据。</p>
<p>Python 支持以下字面量:</p>
<h3 id="1-字符串字面量">1.字符串字面量:</h3>
<p>字符串可以用引号括起来。我们可以使用单引号和双引号来创建字符串。</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Aman&quot;</span> , <span class="string">&#x27;12345&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>字符串类型:</strong></p>
<p>Python 支持两种类型的字符串:</p>
<p><strong>a)单行字符串</strong> -在单行内终止的字符串称为单行字符串。</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">text1=<span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>b)多行字符串-</strong> 多行书写的文本称为多行字符串。</p>
<p>有两种方法可以创建多行字符串:</p>
<p><strong>1)每行末尾加黑色斜线。</strong></p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">text1=<span class="string">&#x27;hello\  </span></span><br><span class="line"><span class="string">user&#x27;</span>  </span><br><span class="line"><span class="built_in">print</span>(text1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;hellouser&#x27;</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>2)使用三重引号:-</strong></p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">str2=<span class="string">&#x27;&#x27;&#x27;welcome </span></span><br><span class="line"><span class="string">to </span></span><br><span class="line"><span class="string">SSSIT&#x27;&#x27;&#x27;</span>  </span><br><span class="line"><span class="built_in">print</span> str2 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">welcome  </span><br><span class="line">to  </span><br><span class="line">SSSIT  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="二-数值字面量">二.数值字面量:</h3>
<p>数值是不可变的。数字字面量可以属于以下四种不同的数字类型。</p>
<table>
<thead>
<tr>
<th>Int</th>
<th>Long</th>
<th>float</th>
<th>Complex</th>
</tr>
</thead>
<tbody>
<tr>
<td>没有小数部分的数字(可以是正数也可以是负数)</td>
<td>大小不限的整数，后跟小写或大写字母 L 例如:87032845L</td>
<td>既有整数部分又有小数部分的实数，例如:-26.2</td>
<td>形式为 a+bj，其中 a 构成复数的实部，b 构成复数的虚部。例:3.14j</td>
</tr>
</tbody>
</table>
<p><strong>示例-数值字面量</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">x = <span class="number">0b10100</span> <span class="comment">#Binary Literals</span></span><br><span class="line">y = <span class="number">100</span> <span class="comment">#Decimal Literal </span></span><br><span class="line">z = <span class="number">0o215</span> <span class="comment">#Octal Literal</span></span><br><span class="line">u = <span class="number">0x12d</span> <span class="comment">#Hexadecimal Literal</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Float Literal</span></span><br><span class="line">float_1 = <span class="number">100.5</span> </span><br><span class="line">float_2 = <span class="number">1.5e2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Complex Literal </span></span><br><span class="line">a = <span class="number">5</span>+<span class="number">3.14j</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x, y, z, u)</span><br><span class="line"><span class="built_in">print</span>(float_1, float_2)</span><br><span class="line"><span class="built_in">print</span>(a, a.imag, a.real)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span> <span class="number">100</span> <span class="number">141</span> <span class="number">301</span></span><br><span class="line"><span class="number">100.5</span> <span class="number">150.0</span></span><br><span class="line">(<span class="number">5</span>+<span class="number">3.14j</span>) <span class="number">3.14</span> <span class="number">5.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="三-布尔字面量">三.布尔字面量:</h3>
<p>布尔字面量可以有两个值中的任何一个:真或假。</p>
<p><strong>示例-布尔字面量</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">x = (<span class="number">1</span> == <span class="literal">True</span>)</span><br><span class="line">y = (<span class="number">2</span> == <span class="literal">False</span>)</span><br><span class="line">z = (<span class="number">3</span> == <span class="literal">True</span>)</span><br><span class="line">a = <span class="literal">True</span> + <span class="number">10</span></span><br><span class="line">b = <span class="literal">False</span> + <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x is&quot;</span>, x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y is&quot;</span>, y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;z is&quot;</span>, z)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a:&quot;</span>, a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b:&quot;</span>, b)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">x <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line">y <span class="keyword">is</span> <span class="literal">False</span></span><br><span class="line">z <span class="keyword">is</span> <span class="literal">False</span></span><br><span class="line">a: <span class="number">11</span></span><br><span class="line">b: <span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="四-特殊字面量。">四.特殊字面量。</h3>
<p>Python 包含一个特殊的字面量，即<strong>None</strong></p>
<p>无用于指定未创建的字段。它也用于 Python 中列表的结尾。</p>
<p><strong>示例-特殊字面量</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">val1=<span class="number">10</span>  </span><br><span class="line">val2=<span class="literal">None</span>  </span><br><span class="line"><span class="built_in">print</span>(val1)   </span><br><span class="line"><span class="built_in">print</span>(val2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="动词（verb-的缩写）字面量集合。">动词（verb 的缩写）字面量集合。</h3>
<p>Python 提供了四种类型的字面量集合，如列表字面量、元组字面量、字典字面量和集合字面量。</p>
<p><strong>列表:</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>列表包含不同数据类型的项目。列表是可变的，即可修改的。</p>
</li>
<li class="lvl-4">
<p>列表中存储的值由逗号(,)分隔，并包含在方括号([])中。我们可以在列表中存储不同类型的数据。</p>
</li>
</ul>
<p><strong>示例-列表字面量</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>=[<span class="string">&#x27;John&#x27;</span>,<span class="number">678</span>,<span class="number">20.4</span>,<span class="string">&#x27;Peter&#x27;</span>]  </span><br><span class="line">list1=[<span class="number">456</span>,<span class="string">&#x27;Andrew&#x27;</span>]  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span> + list1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;John&#x27;</span>, <span class="number">678</span>, <span class="number">20.4</span>, <span class="string">&#x27;Peter&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;John&#x27;</span>, <span class="number">678</span>, <span class="number">20.4</span>, <span class="string">&#x27;Peter&#x27;</span>, <span class="number">456</span>, <span class="string">&#x27;Andrew&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>字典:</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>Python 字典将数据存储在键值对中。</p>
</li>
<li class="lvl-4">
<p>它由花括号{}括起来，每对用逗号(,)隔开。</p>
</li>
</ul>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Pater&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>:<span class="number">18</span>,<span class="string">&#x27;Roll_nu&#x27;</span>:<span class="number">101</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Pater&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;Roll_nu&#x27;</span>: <span class="number">101</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>元组:</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>Python 元组是不同数据类型集合。它是不可变的，这意味着它在创建后不能被修改。</p>
</li>
<li class="lvl-4">
<p>它用括号()括起来，每个元素用逗号(,)分隔。</p>
</li>
</ul>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tup = (<span class="number">10</span>,<span class="number">20</span>,<span class="string">&quot;Dev&quot;</span>,[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(tup)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">(<span class="number">10</span>, <span class="number">20</span>, <span class="string">&#x27;Dev&#x27;</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>设定:</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>Python 集合是无序数据集的集合。</p>
</li>
<li class="lvl-4">
<p>它用{}括起来，每个元素用逗号(,)隔开。</p>
</li>
</ul>
<p><strong>示例:-设置字面量量</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> = &#123;<span class="string">&#x27;apple&#x27;</span>,<span class="string">&#x27;grapes&#x27;</span>,<span class="string">&#x27;guava&#x27;</span>,<span class="string">&#x27;papaya&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;guava&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;papaya&#x27;</span>, <span class="string">&#x27;grapes&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-literals">https://www.javatpoint.com/python-literals</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 异常</title>
    <url>/posts/28b176d2.html</url>
    <content><![CDATA[<h1>Python 异常</h1>
<p>异常可以定义为程序中导致程序流程中断的异常。</p>
<p>每当出现异常时，程序就会停止执行，因此不会执行下一个代码。因此，一个异常是无法处理 Python 脚本的运行时错误。异常是表示错误的 Python 对象</p>
<p>Python 提供了一种处理异常的方法，这样代码就可以在没有任何中断的情况下执行。如果我们不处理异常，解释器就不会执行异常后存在的所有代码。</p>
<p>Python 有许多<strong>内置异常</strong>，使我们的程序能够不间断运行并给出输出。这些异常如下:</p>
<h2 id="常见异常">常见异常</h2>
<p>Python 提供了内置异常的数量，但这里我们描述的是常见的标准异常。下面列出了标准 Python 程序可能引发的常见异常。</p>
<ol>
<li class="lvl-4">
<p><strong>ZeroDivisionError:</strong> 当一个数被零除时发生。</p>
</li>
<li class="lvl-4">
<p><strong>NameError:</strong> 找不到名称时出现。它可能是局部的，也可能是全局的。</p>
</li>
<li class="lvl-4">
<p><strong>IOError:</strong> 输入输出操作失败时出现。</p>
</li>
<li class="lvl-4">
<p><strong>EOFError:</strong> 当到达文件末尾，但仍在执行操作时，就会出现这种情况。</p>
</li>
</ol>
<hr>
<h2 id="不处理异常的问题">不处理异常的问题</h2>
<p>正如我们已经讨论过的，异常是中止程序执行的异常。</p>
<p>假设我们有两个变量 <strong>a</strong> 和 <strong>b</strong> ，它们接受用户的输入并执行这些值的除法。如果用户输入零作为分母呢？它将中断程序执行，并通过一个<strong>零分</strong>异常。让我们看看下面的例子。</p>
<h3 id="例子-40">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter a:&quot;</span>))  </span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter b:&quot;</span>))  </span><br><span class="line">c = a/b</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a/b = %d&quot;</span> %c)  </span><br><span class="line"></span><br><span class="line"><span class="comment">#other code:  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hi I am other part of the program&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter a:<span class="number">10</span></span><br><span class="line">Enter b:<span class="number">0</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;exception-test.py&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    c = a/b;</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的程序在语法上是正确的，但是它由于异常输入而出错。这种编程可能不适合或不推荐项目，因为这些项目需要不间断的执行。这就是为什么异常处理在处理这些意外异常时起着重要作用。我们可以用以下方式处理这些异常。</p>
<h2 id="python-中的异常处理">python 中的异常处理</h2>
<h3 id="try-except语句">try-except语句</h3>
<p>如果 Python 程序包含可能引发异常的可疑代码，我们必须将该代码放在 <strong>try</strong> 块中。 <strong>try</strong> 块后面必须跟有<strong>except</strong>语句，该语句包含一个代码块，如果 try 块中有异常，将执行该代码块。</p>
<p><img src="/img/91cbc9604d5533a4c10d8f532597cad7.png" alt="Python Exception handling"></p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    <span class="comment">#block of code   </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Exception1:  </span><br><span class="line">    <span class="comment">#block of code  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Exception2:  </span><br><span class="line">    <span class="comment">#block of code  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#other code  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>考虑下面的例子。</p>
<p><strong>例 1</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter a:&quot;</span>))  </span><br><span class="line">    b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter b:&quot;</span>))  </span><br><span class="line">    c = a/b</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Can&#x27;t divide with zero&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter a:<span class="number">10</span></span><br><span class="line">Enter b:<span class="number">0</span></span><br><span class="line">Can<span class="string">&#x27;t divide with zero</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>我们还可以将 else 语句与 try-except 语句一起使用，在 try 语句中，如果 try 块中没有发生异常，我们可以放置将在场景中执行的代码。</p>
<p>下面给出了将 else 语句与 try-except 语句一起使用的语法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    <span class="comment">#block of code   </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Exception1:  </span><br><span class="line">    <span class="comment">#block of code   </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    <span class="comment">#this code executes if no except block is executed  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/e59c291f3d732153e8fb4ad437231bb9.png" alt="Python Exception handling"></p>
<p>考虑以下程序。</p>
<p><strong>例 2</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter a:&quot;</span>))  </span><br><span class="line">    b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter b:&quot;</span>))  </span><br><span class="line">    c = a/b</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a/b = %d&quot;</span>%c)  </span><br><span class="line"><span class="comment"># Using Exception with except statement. If we print(Exception) it will return exception class</span></span><br><span class="line"><span class="keyword">except</span> Exception:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;can&#x27;t divide by zero&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(Exception)</span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hi I am else block&quot;</span>)   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter a:<span class="number">10</span></span><br><span class="line">Enter b:<span class="number">0</span></span><br><span class="line">can<span class="string">&#x27;t divide by zero</span></span><br><span class="line"><span class="string">&lt;class &#x27;</span>Exception<span class="string">&#x27;&gt;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<h2 id="无异常的异常语句">无异常的异常语句</h2>
<p>Python 提供了不在异常语句中指定异常名称的灵活性。</p>
<p>考虑下面的例子。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter a:&quot;</span>))  </span><br><span class="line">    b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter b:&quot;</span>))  </span><br><span class="line">    c = a/b;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a/b = %d&quot;</span>%c)  </span><br><span class="line"><span class="keyword">except</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;can&#x27;t divide by zero&quot;</span>)  </span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hi I am else block&quot;</span>)   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="与异常变量一起使用的-except-语句">与异常变量一起使用的 except 语句</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter a:&quot;</span>))  </span><br><span class="line">    b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter b:&quot;</span>))  </span><br><span class="line">    c = a/b</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a/b = %d&quot;</span>%c)  </span><br><span class="line">    <span class="comment"># Using exception object with the except statement</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;can&#x27;t divide by zero&quot;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hi I am else block&quot;</span>)   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter a:<span class="number">10</span></span><br><span class="line">Enter b:<span class="number">0</span></span><br><span class="line">can<span class="string">&#x27;t divide by zero</span></span><br><span class="line"><span class="string">division by zero</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<h2 id="需要记住的要点-2">需要记住的要点</h2>
<ol>
<li class="lvl-4">
<p>Python 方便我们不用 except 语句指定异常。</p>
</li>
<li class="lvl-4">
<p>我们可以在 except 语句中声明多个异常，因为 try 块可能包含引发不同类型异常的语句。</p>
</li>
<li class="lvl-4">
<p>我们还可以在 try-except 语句中指定一个 else 块，如果 try 块中没有引发异常，就会执行该语句。</p>
</li>
<li class="lvl-4">
<p>不抛出异常的语句应该放在 else 块中。</p>
</li>
</ol>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    <span class="comment">#this will throw an exception if the file doesn&#x27;t exist.   </span></span><br><span class="line">    fileptr = <span class="built_in">open</span>(<span class="string">&quot;file.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)  </span><br><span class="line"><span class="keyword">except</span> IOError:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;File not found&quot;</span>)  </span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The file opened successfully&quot;</span>)  </span><br><span class="line">    fileptr.close()  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">File <span class="keyword">not</span> found</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="声明多个异常">声明多个异常</h2>
<p>Python 允许我们用 except 子句声明多个异常。在 try 块引发多个异常的情况下，声明多个异常非常有用。语法如下。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    <span class="comment">#block of code   </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> (&lt;Exception <span class="number">1</span>&gt;,&lt;Exception <span class="number">2</span>&gt;,&lt;Exception <span class="number">3</span>&gt;,...&lt;Exception n&gt;)  </span><br><span class="line">    <span class="comment">#block of code   </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    <span class="comment">#block of code  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:    </span><br><span class="line">    a=<span class="number">10</span>/<span class="number">0</span>;    </span><br><span class="line"><span class="keyword">except</span>(ArithmeticError, IOError):    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Arithmetic Exception&quot;</span>)    </span><br><span class="line"><span class="keyword">else</span>:    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Successfully Done&quot;</span>)     </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Arithmetic Exception</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="try…finally">try…finally</h2>
<p>Python 提供了可选的 <strong>finally</strong> 语句，与 <strong>try</strong> 语句一起使用。无论发生什么异常，它都会被执行，并用于释放外部资源。finally 块为执行提供了保证。</p>
<p>我们可以将 finally 块与 try 块一起使用，在 try 块中我们可以调整必要的代码，这些代码必须在 try 语句引发异常之前执行。</p>
<p>下面给出了使用 finally 块的语法。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    <span class="comment"># block of code   </span></span><br><span class="line">    <span class="comment"># this may throw an exception  </span></span><br><span class="line"><span class="keyword">finally</span>:  </span><br><span class="line">    <span class="comment"># block of code  </span></span><br><span class="line">    <span class="comment"># this will always be executed   </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/9876a92311a75281788d0410bb5ab466.png" alt="Python Exception handling"></p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    fileptr = <span class="built_in">open</span>(<span class="string">&quot;file2.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)    </span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">        fileptr.write(<span class="string">&quot;Hi I am good&quot;</span>)  </span><br><span class="line">    <span class="keyword">finally</span>:  </span><br><span class="line">        fileptr.close()  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;file closed&quot;</span>)  </span><br><span class="line"><span class="keyword">except</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error&quot;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">file closed</span><br><span class="line">Error</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="raise-Exception">raise Exception</h2>
<p>使用 Python 中的 <strong>raise</strong> 子句可以强制引发异常。在我们需要引发异常来停止程序执行的场景中，这非常有用。</p>
<p>例如，有一个程序需要 2GB 内存来执行，如果程序试图占用 2GB 内存，那么我们可以引发一个异常来停止程序的执行。</p>
<p>下面给出了使用 raise 语句的语法。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">raise</span> Exception_class,&lt;value&gt;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>记分</strong></p>
<ol>
<li class="lvl-4">
<p>若要引发异常，请使用 raise 语句。异常类名紧随其后。</p>
</li>
<li class="lvl-4">
<p>可以为异常提供一个可以在括号中给出的值。</p>
</li>
<li class="lvl-4">
<p>使用关键字访问值<strong>as e</strong> 用作存储异常值的参考变量。</p>
</li>
<li class="lvl-4">
<p>我们可以将该值传递给异常，以指定异常类型。</p>
</li>
</ol>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    age = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the age:&quot;</span>))  </span><br><span class="line">    <span class="keyword">if</span>(age&lt;<span class="number">18</span>):  </span><br><span class="line">        <span class="keyword">raise</span> ValueError </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;the age is valid&quot;</span>)  </span><br><span class="line"><span class="keyword">except</span> ValueError:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The age is not valid&quot;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the age:<span class="number">17</span></span><br><span class="line">The age <span class="keyword">is</span> <span class="keyword">not</span> valid</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例 2 通过消息</strong>引发异常</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">     num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter a positive integer: &quot;</span>))</span><br><span class="line">     <span class="keyword">if</span>(num &lt;= <span class="number">0</span>):</span><br><span class="line"><span class="comment"># we can pass the message in the raise statement</span></span><br><span class="line">         <span class="keyword">raise</span> ValueError(<span class="string">&quot;That is  a negative number!&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">     <span class="built_in">print</span>(e)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter a positive integer: -<span class="number">5</span></span><br><span class="line">That <span class="keyword">is</span> a negative number!</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例 3</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter a:&quot;</span>))  </span><br><span class="line">    b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter b:&quot;</span>))  </span><br><span class="line">    <span class="keyword">if</span> b <span class="keyword">is</span> <span class="number">0</span>:  </span><br><span class="line">        <span class="keyword">raise</span> ArithmeticError</span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;a/b = &quot;</span>,a/b)  </span><br><span class="line"><span class="keyword">except</span> ArithmeticError:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The value of b can&#x27;t be 0&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter a:<span class="number">10</span></span><br><span class="line">Enter b:<span class="number">0</span></span><br><span class="line">The value of b can<span class="string">&#x27;t be 0</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<h2 id="自定义异常">自定义异常</h2>
<p>Python 允许我们创建可以从程序中引发并使用 except 子句捕获的异常。但是，我们建议您在访问 Python 对象和类后阅读这一部分。</p>
<p>考虑下面的例子。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorInCode</span>(<span class="title class_ inherited__">Exception</span>):    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):    </span><br><span class="line">        self.data = data    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):    </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">repr</span>(self.data)    </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:    </span><br><span class="line">    <span class="keyword">raise</span> ErrorInCode(<span class="number">2000</span>)    </span><br><span class="line"><span class="keyword">except</span> ErrorInCode <span class="keyword">as</span> ae:    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Received error:&quot;</span>, ae.data)    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Received error: <span class="number">2000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-exception-handling">https://www.javatpoint.com/python-exception-handling</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 循环</title>
    <url>/posts/3ebc62bf.html</url>
    <content><![CDATA[<h1>Python 循环</h1>
<p>默认情况下，用任何编程语言编写的程序流都是连续的。有时我们可能需要改变程序的流程。特定代码的执行可能需要重复几次。</p>
<p>为此，编程语言提供了各种类型的循环，这些循环能够多次重复某些特定的代码。考虑下图来理解循环语句的工作原理。</p>
<p><img src="/img/90feeebbf07e6277b451324829840d35.png" alt="Python Loops"></p>
<h2 id="为什么我们在-python-中使用循环？">为什么我们在 python 中使用循环？</h2>
<p>循环将复杂的问题简化为简单的问题。它使我们能够改变程序的流程，这样我们就可以在有限的时间内重复相同的代码，而不是一次又一次地编写相同的代码。例如，如果我们需要打印前 10 个自然数，那么我们可以在最多运行 10 次迭代的循环中打印，而不是使用 print 语句 10 次。</p>
<h2 id="循环的优点">循环的优点</h2>
<p>Python 中的循环有以下优点。</p>
<ol>
<li class="lvl-4">
<p>它提供代码的可重用性。</p>
</li>
<li class="lvl-4">
<p>使用循环，我们不需要一次又一次地编写相同的代码。</p>
</li>
<li class="lvl-4">
<p>使用循环，我们可以遍历数据结构的元素(数组或链表)。</p>
</li>
</ol>
<p>Python 中有以下循环语句。</p>
<table>
<thead>
<tr>
<th>循环语句</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>for</code>循环</td>
<td><code>for</code>循环用于我们需要执行部分代码直到满足给定条件的情况。<code>for</code>循环也称为经过测试的循环。如果迭代次数事先已知，最好使用 <code>for</code>循环。</td>
</tr>
<tr>
<td><code>While</code>循环</td>
<td><code>While</code>循环将用于我们事先不知道迭代次数的场景。语句块在 <code>While</code>循环中执行，直到满足 <code>While</code>循环中指定的条件。它也被称为预测试循环。</td>
</tr>
<tr>
<td>do-<code>While</code>循环</td>
<td>do-<code>While</code>循环一直持续到给定条件满足为止。它也被称为后测试循环。当需要至少执行一次循环时使用(主要是菜单驱动程序)。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-loops">https://www.javatpoint.com/python-loops</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 数据类型</title>
    <url>/posts/cbc5e2b2.html</url>
    <content><![CDATA[<h1>Python 数据类型</h1>
<p>变量可以保存值，每个值都有一个数据类型。Python 是一种动态类型语言；因此，我们在声明变量时不需要定义它的类型。解释器隐式地将值与其类型绑定。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>变量 <strong>a</strong> 保存整数值 5，我们没有定义它的类型。Python 解释器会自动将变量 <strong>a</strong> 解释为整数类型。</p>
<p>Python 使我们能够检查程序中使用的变量的类型。Python 为我们提供了 <strong>type()</strong> 函数，返回传递的变量的类型。</p>
<p>考虑以下示例来定义不同数据类型的值并检查其类型。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a=<span class="number">10</span></span><br><span class="line">b=<span class="string">&quot;Hi Python&quot;</span></span><br><span class="line">c = <span class="number">10.5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(c))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;float&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="标准数据类型">标准数据类型</h2>
<p>一个变量可以保存不同类型的值。例如，一个人的名字必须存储为字符串，而他的 id 必须存储为整数。</p>
<p>Python 提供了各种标准数据类型，定义了每种类型的存储方法。下面给出了 Python 中定义的数据类型。</p>
<ol>
<li class="lvl-4">
<p><a href="#Numbers">数字类型</a></p>
</li>
<li class="lvl-4">
<p><a href="#SequenceType">序列类型</a></p>
</li>
<li class="lvl-4">
<p><a href="#Boolean">布尔</a></p>
</li>
<li class="lvl-4">
<p><a href="#Set">集合</a></p>
</li>
<li class="lvl-4">
<p><a href="#Dictionary">字典</a></p>
</li>
</ol>
<p><img src="/img/a00048e994264539ed0e8efced9e71c8.png" alt="Python Data Types"></p>
<p>在教程的这一部分，我们将简要介绍上述数据类型。我们将在本教程的后面详细讨论每一个。</p>
<h3 id="Numbers">Numbers</h3>
<p>Number 存储数值。整数、浮点和复数值属于 Python Numbers 数据类型。Python 提供了 <strong>type()</strong> 函数来知道变量的数据类型。类似地， <strong>isinstance()</strong> 函数用于检查某个对象是否属于某个特定的类。</p>
<p>当一个数字被分配给一个变量时，Python 会创建数字对象。比如；</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The type of a&quot;</span>, <span class="built_in">type</span>(a))</span><br><span class="line"></span><br><span class="line">b = <span class="number">40.5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The type of b&quot;</span>, <span class="built_in">type</span>(b))</span><br><span class="line"></span><br><span class="line">c = <span class="number">1</span>+<span class="number">3j</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The type of c&quot;</span>, <span class="built_in">type</span>(c))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; c is a complex number&quot;</span>, <span class="built_in">isinstance</span>(<span class="number">1</span>+<span class="number">3j</span>,<span class="built_in">complex</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The <span class="built_in">type</span> of a &lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line">The <span class="built_in">type</span> of b &lt;<span class="keyword">class</span> <span class="string">&#x27;float&#x27;</span>&gt;</span><br><span class="line">The <span class="built_in">type</span> of c &lt;<span class="keyword">class</span> <span class="string">&#x27;complex&#x27;</span>&gt;</span><br><span class="line">c <span class="keyword">is</span> <span class="built_in">complex</span> number: <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Python 支持三种类型的数字数据。</p>
<ol>
<li class="lvl-4">
<p><strong>Int -</strong> 整数值可以是任意长度，如整数 10、2、29、-20、-150 等。Python 对整数的长度没有限制。其价值属于<strong>国际</strong></p>
</li>
<li class="lvl-4">
<p><strong>Float -</strong> Float 用于存储 1.9、9.902、15.2 等浮点数。它精确到小数点后 15 位。</p>
</li>
<li class="lvl-4">
<p><strong>复数-</strong> 复数包含有序对，即 x + iy，其中 x 和 y 分别表示实部和虚部。2.14j、2.0 + 2.3j 等复数。</p>
</li>
</ol>
<h3 id="SequenceType">SequenceType</h3>
<h3 id="Strings">Strings</h3>
<p>字符串可以定义为引号中表示的字符序列。在 Python 中，我们可以使用单引号、双引号或三引号来定义字符串。</p>
<p>Python 中的字符串处理是一项简单的任务，因为 Python 提供了内置函数和运算符来执行字符串中的操作。</p>
<p>在字符串处理的情况下，运算符+用于连接两个字符串，因为操作*“hello”+“python”<em>返回</em>“hello python”*。</p>
<p>运算符<em>被称为重复运算符，因为操作“Python”</em> 2 返回“Python Python”。</p>
<p>以下示例说明了 Python 中的字符串。</p>
<p><strong>示例- 1</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;string using double quotes&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line">s = <span class="string">&#x27;&#x27;&#x27;A multiline</span></span><br><span class="line"><span class="string">string&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">string using double quotes</span><br><span class="line">A multiline</span><br><span class="line">string</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>考虑下面的字符串处理示例。</p>
<p><strong>示例- 2</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&#x27;hello javatpoint&#x27;</span> <span class="comment">#string str1  </span></span><br><span class="line">str2 = <span class="string">&#x27; how are you&#x27;</span> <span class="comment">#string str2  </span></span><br><span class="line"><span class="built_in">print</span> (str1[<span class="number">0</span>:<span class="number">2</span>]) <span class="comment">#printing first two character using slice operator  </span></span><br><span class="line"><span class="built_in">print</span> (str1[<span class="number">4</span>]) <span class="comment">#printing 4th character of the string  </span></span><br><span class="line"><span class="built_in">print</span> (str1*<span class="number">2</span>) <span class="comment">#printing the string twice  </span></span><br><span class="line"><span class="built_in">print</span> (str1 + str2) <span class="comment">#printing the concatenation of str1 and str2  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">he</span><br><span class="line">o</span><br><span class="line">hello javatpointhello javatpoint</span><br><span class="line">hello javatpoint how are you</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="List">List</h3>
<p>Python 列表类似于 c 语言中的数组。但是，列表可以包含不同类型的数据。列表中存储的项目用逗号(,)分隔，并括在方括号[]内。</p>
<p>我们可以使用 slice [:]运算符来访问列表的数据。串联运算符(+)和重复运算符(*)处理列表的方式与处理字符串的方式相同。</p>
<p>考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">list1  = [<span class="number">1</span>, <span class="string">&quot;hi&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="number">2</span>]  </span><br><span class="line"><span class="comment">#Checking type of given list</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(list1))</span><br><span class="line"></span><br><span class="line"><span class="comment">#Printing the list1</span></span><br><span class="line"><span class="built_in">print</span> (list1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># List slicing</span></span><br><span class="line"><span class="built_in">print</span> (list1[<span class="number">3</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># List slicing</span></span><br><span class="line"><span class="built_in">print</span> (list1[<span class="number">0</span>:<span class="number">2</span>]) </span><br><span class="line"></span><br><span class="line"><span class="comment"># List Concatenation using + operator</span></span><br><span class="line"><span class="built_in">print</span> (list1 + list1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># List repetation using * operator</span></span><br><span class="line"><span class="built_in">print</span> (list1 * <span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="string">&#x27;hi&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="string">&#x27;hi&#x27;</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="string">&#x27;hi&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="string">&#x27;hi&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="string">&#x27;hi&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="string">&#x27;hi&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="string">&#x27;hi&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="number">2</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Tuple">Tuple</h3>
<p>元组在许多方面类似于列表。像列表一样，元组也包含不同数据类型项的集合。元组的项用逗号(,)分隔，并包含在括号()中。</p>
<p>元组是只读的数据结构，因为我们不能修改元组的项目的大小和值。</p>
<p>让我们看一个简单的元组例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tup  = (<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="number">2</span>)  </span><br><span class="line"><span class="comment"># Checking type of tup</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">type</span>(tup))  </span><br><span class="line"></span><br><span class="line"><span class="comment">#Printing the tuple</span></span><br><span class="line"><span class="built_in">print</span> (tup)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Tuple slicing</span></span><br><span class="line"><span class="built_in">print</span> (tup[<span class="number">1</span>:])  </span><br><span class="line"><span class="built_in">print</span> (tup[<span class="number">0</span>:<span class="number">1</span>])  </span><br><span class="line"></span><br><span class="line"><span class="comment"># Tuple concatenation using + operator</span></span><br><span class="line"><span class="built_in">print</span> (tup + tup)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># Tuple repatation using * operator</span></span><br><span class="line"><span class="built_in">print</span> (tup * <span class="number">3</span>)   </span><br><span class="line"></span><br><span class="line"><span class="comment"># Adding value to tup. It will throw an error.</span></span><br><span class="line">t[<span class="number">2</span>] = <span class="string">&quot;hi&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line">(<span class="string">&#x27;hi&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="string">&#x27;Python&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="string">&#x27;hi&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;hi&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;hi&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="string">&#x27;hi&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;hi&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;hi&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;main.py&quot;</span>, line <span class="number">14</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    t[<span class="number">2</span>] = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Dictionary">Dictionary</h3>
<p>字典是项的键值对的无序集合。它就像一个关联数组或哈希表，其中每个键存储一个特定的值。键可以保存任何原始数据类型，而值是任意的 Python 对象。</p>
<p>字典中的项目用逗号(,)分隔，并包含在大括号{}中。</p>
<p>考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="number">1</span>:<span class="string">&#x27;Jimmy&#x27;</span>, <span class="number">2</span>:<span class="string">&#x27;Alex&#x27;</span>, <span class="number">3</span>:<span class="string">&#x27;john&#x27;</span>, <span class="number">4</span>:<span class="string">&#x27;mike&#x27;</span>&#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment"># Printing dictionary</span></span><br><span class="line"><span class="built_in">print</span> (d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Accesing value using keys</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1st name is &quot;</span>+d[<span class="number">1</span>]) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;2nd name is &quot;</span>+ d[<span class="number">4</span>])  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (d.keys())  </span><br><span class="line"><span class="built_in">print</span> (d.values())  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">1st name <span class="keyword">is</span> Jimmy</span><br><span class="line">2nd name <span class="keyword">is</span> mike</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;Jimmy&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Alex&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;john&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;mike&#x27;</span>&#125;</span><br><span class="line">dict_keys([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">dict_values([<span class="string">&#x27;Jimmy&#x27;</span>, <span class="string">&#x27;Alex&#x27;</span>, <span class="string">&#x27;john&#x27;</span>, <span class="string">&#x27;mike&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Boolean">Boolean</h3>
<p>布尔类型提供两个内置值，真和假。这些值用于确定给定语句的真假。它由类 bool 表示。True 可以用任何非零值或“T”表示，而 false 可以用 0 或“F”表示。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python program to check the boolean type</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">True</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">False</span>))</span><br><span class="line"><span class="built_in">print</span>(false)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;bool&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;bool&#x27;</span>&gt;</span><br><span class="line">NameError: name <span class="string">&#x27;false&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Set">Set</h3>
<p>Python 集是数据类型的无序集合。它是可迭代的、可变的(可以在创建后修改)，并且具有独特的元素。在 set 中，元素的顺序是未定义的；它可以返回元素的改变的序列。通过使用内置函数 **set()，**创建集合，或者在花括号中传递一系列元素，并用逗号分隔。它可以包含各种类型的值。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creating Empty set</span></span><br><span class="line">set1 = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">set2 = &#123;<span class="string">&#x27;James&#x27;</span>, <span class="number">2</span>, <span class="number">3</span>,<span class="string">&#x27;Python&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#Printing Set value</span></span><br><span class="line"><span class="built_in">print</span>(set2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Adding element to the set</span></span><br><span class="line"></span><br><span class="line">set2.add(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(set2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Removing element from the set</span></span><br><span class="line">set2.remove(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(set2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">3</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;James&#x27;</span>, <span class="number">2</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;James&#x27;</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">10</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;James&#x27;</span>, <span class="number">3</span>, <span class="number">10</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-data-types">https://www.javatpoint.com/python-data-types</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 数组</title>
    <url>/posts/3f108209.html</url>
    <content><![CDATA[<h1>Python 数组</h1>
<p>数组被定义为存储在连续内存位置的项的集合。它是一个可以容纳固定数量物品的容器,这些物品应该是同一类型的。数组在大多数编程语言中很流行,比如 C/C++、JavaScript 等。</p>
<p>数组是一种将多个相同类型的项存储在一起的思想,通过简单地在基值上添加一个偏移量,可以更容易地计算每个元素的位置。数组的组合可以通过减少代码的整体大小来节省大量时间。它用于在单个变量中存储多个值。如果您有一个存储在相应变量中的项目列表,如下所示:</p>
<p>car1 = “Lamborghini”</p>
<p>car2 = “bugatti”</p>
<p>car3 = &quot;Koenigsegg &quot;</p>
<p>如果你想在汽车中循环并找到一个特定的,你可以使用数组。</p>
<p>数组可以用 Python 通过一个名为<strong>数组</strong>的模块来处理。当我们只需要操作特定的数据值时,这是非常有用的。以下是理解数组概念的术语:</p>
<p><strong>Element</strong> -存储在数组中的每个项目称为一个元素。</p>
<p><strong>Index</strong> -数组中元素的位置有一个数字索引,用来标识元素的位置。</p>
<h2 id="数组表示">数组表示</h2>
<p>数组可以用不同的方式和不同的语言来声明。应该考虑的要点如下:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>索引从 0 开始。</p>
</li>
<li class="lvl-4">
<p>我们可以通过索引访问每个元素。</p>
</li>
<li class="lvl-4">
<p>数组的长度定义了存储元素的容量。</p>
</li>
</ul>
<h2 id="数组操作">数组操作</h2>
<p>阵列支持的一些基本操作如下:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>遍历</strong> -它会逐个打印所有元素。</p>
</li>
<li class="lvl-4">
<p><strong>插入</strong> -它在给定的索引处添加一个元素。</p>
</li>
<li class="lvl-4">
<p><strong>删除</strong> -删除给定索引处的元素。</p>
</li>
<li class="lvl-4">
<p><strong>搜索</strong> -它使用给定的索引或按值搜索元素。</p>
</li>
<li class="lvl-4">
<p><strong>更新</strong> -它更新给定索引处的元素。</p>
</li>
</ul>
<p>通过将数组模块导入 python 程序,可以在 Python 中创建数组。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> *</span><br><span class="line">arrayName = array(typecode, [initializers]) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>访问数组元素</strong></p>
<p>我们可以使用数组元素各自的索引来访问这些元素。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> array <span class="keyword">as</span> arr</span><br><span class="line">a = arr.array(<span class="string">&#x27;i&#x27;</span>, [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;First element:&quot;</span>, a[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Second element:&quot;</span>, a[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Second last element:&quot;</span>, a[-<span class="number">1</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">First element: <span class="number">2</span></span><br><span class="line">Second element: <span class="number">4</span></span><br><span class="line">Second last element: <span class="number">8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>**说明:**在上面的例子中,我们导入了一个数组,定义了一个名为“a”的变量,该变量保存数组的元素,并通过数组的索引访问元素来打印元素。</p>
<h2 id="如何更改或添加元素">如何更改或添加元素</h2>
<p>数组是可变的,它们的元素可以像列表一样以类似的方式改变。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> array <span class="keyword">as</span> arr</span><br><span class="line">numbers = arr.array(<span class="string">&#x27;i&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># changing first element</span></span><br><span class="line">numbers[<span class="number">0</span>] = <span class="number">0</span>   </span><br><span class="line"><span class="built_in">print</span>(numbers)    <span class="comment"># Output: array(&#x27;i&#x27;, [0, 2, 3, 5, 7, 10])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># changing 3rd to 5th element</span></span><br><span class="line">numbers[<span class="number">2</span>:<span class="number">5</span>] = arr.array(<span class="string">&#x27;i&#x27;</span>, [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>])  </span><br><span class="line"><span class="built_in">print</span>(numbers)    <span class="comment"># Output: array(&#x27;i&#x27;, [0, 2, 4, 6, 8, 10])</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">array(<span class="string">&#x27;i&#x27;</span>, [<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">10</span>])</span><br><span class="line">array(<span class="string">&#x27;i&#x27;</span> ,[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>**说明:**在上面的例子中,我们导入了一个数组,并定义了一个名为“numbers”的变量来保存数组的值。如果我们想更改或添加数组中的元素,我们可以通过定义要更改或添加元素的数组的特定索引来实现。</p>
<h2 id="为什么要在-Python-中使用数组？">为什么要在 Python 中使用数组？</h2>
<p>数组的组合节省了大量时间。数组可以减少代码的整体大小。</p>
<h2 id="如何从数组中删除元素？">如何从数组中删除元素？</h2>
<p>可以使用 Python 的 <strong>del</strong> 语句从数组中删除元素。如果我们想从数组中删除任何值,我们可以通过使用特定元素的索引来实现。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> array <span class="keyword">as</span> arr</span><br><span class="line">number = arr.array(<span class="string">&#x27;i&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="keyword">del</span> number[<span class="number">2</span>]                           <span class="comment"># removing third element</span></span><br><span class="line"><span class="built_in">print</span>(number)                           <span class="comment"># Output: array(&#x27;i&#x27;, [1, 2, 3, 4])</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">array(<span class="string">&#x27;i&#x27;</span>, [<span class="number">10</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">60</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>**说明:**在上面的例子中,我们导入了一个数组,并定义了一个名为“number”的变量来存储数组的值。这里,通过使用 <code>del</code>语句,我们移除了给定数组的第三个元素[3]。</p>
<h2 id="求数组的长度">求数组的长度</h2>
<p>数组的长度定义为数组中存在的元素数量。它返回一个整数值,该整数值等于该数组中存在的元素总数。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">len</span>(array_name)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="数组连接">数组连接</h2>
<p>我们可以使用+符号轻松连接任意两个数组。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a=arr.array(<span class="string">&#x27;d&#x27;</span>,[<span class="number">1.1</span> , <span class="number">2.1</span> ,<span class="number">3.1</span>,<span class="number">2.6</span>,<span class="number">7.8</span>])</span><br><span class="line">b=arr.array(<span class="string">&#x27;d&#x27;</span>,[<span class="number">3.7</span>,<span class="number">8.6</span>])</span><br><span class="line">c=arr.array(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">c=a+b</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Array c = &quot;</span>,c)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Array c= array(<span class="string">&#x27;d&#x27;</span>, [<span class="number">1.1</span>, <span class="number">2.1</span>, <span class="number">3.1</span>, <span class="number">2.6</span>, <span class="number">7.8</span>, <span class="number">3.7</span>, <span class="number">8.6</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>解释</strong></p>
<p>在上面的例子中,我们定义了名为“a,b,c”的变量来保存数组的值。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> array <span class="keyword">as</span> arr</span><br><span class="line">x = arr.array(<span class="string">&#x27;i&#x27;</span>, [<span class="number">4</span>, <span class="number">7</span>, <span class="number">19</span>, <span class="number">22</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;First element:&quot;</span>, x[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Second element:&quot;</span>, x[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Second last element:&quot;</span>, x[-<span class="number">1</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">First element: <span class="number">4</span></span><br><span class="line">Second element: <span class="number">7</span></span><br><span class="line">Second last element: <span class="number">22</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>**说明:**在上面的例子中,首先,我们导入了一个数组,并定义了一个名为“x”的变量,该变量保存了一个数组的值,然后,我们使用数组的索引打印了元素。</p>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-arrays">https://www.javatpoint.com/python-arrays</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 文件处理</title>
    <url>/posts/4f5b6974.html</url>
    <content><![CDATA[<h1>Python 文件处理</h1>
<p>到目前为止，我们从控制台获取输入，并将其写回控制台，以便与用户进行交互。</p>
<p>有时候，仅仅在控制台上显示数据是不够的。要显示的数据可能非常大，并且只能在控制台上显示有限数量的数据，因为内存是易失性的，不可能一次又一次地恢复以编程方式生成的数据。</p>
<p>当数据需要永久存储到文件中时，文件处理起着重要的作用。文件是磁盘上存储相关信息的命名位置。我们可以在程序终止后访问存储的信息(非易失性的)。</p>
<p>在其他编程语言中，文件处理实现略长或复杂，但在 Python 中，它更简单、更短。</p>
<p>在 Python 中，文件在两种模式下被视为文本或二进制文件。文件可以是文本或二进制格式，文件的每一行都以特殊字符结尾。</p>
<p>因此，文件操作可以按以下顺序进行。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>打开文件</p>
</li>
<li class="lvl-4">
<p>读取或写入-执行操作</p>
</li>
<li class="lvl-4">
<p>关闭文件</p>
</li>
</ul>
<h2 id="打开文件">打开文件</h2>
<p>Python 提供了一个 <strong>open()</strong> 函数，接受两个参数，文件名和访问文件的访问模式。该函数返回一个文件对象，该对象可用于执行各种操作，如读取、写入等。</p>
<p><strong>语法:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">file <span class="built_in">object</span> = <span class="built_in">open</span>(&lt;file-name&gt;, &lt;access-mode&gt;, &lt;buffering&gt;)   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以使用各种模式(如读取、写入或追加)来访问这些文件。以下是有关打开文件的访问模式的详细信息。</p>
<table>
<thead>
<tr>
<th>存取方式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>它以只读模式打开文件。文件指针存在于开头。如果没有通过访问模式，默认情况下，文件在此模式下是打开的。</td>
</tr>
<tr>
<td>rb</td>
<td>它以二进制格式将文件打开为只读。文件指针存在于文件的开头。</td>
</tr>
<tr>
<td>r+</td>
<td>它打开文件进行读写。文件指针存在于文件的开头。</td>
</tr>
<tr>
<td>rb+</td>
<td>它以二进制格式打开文件进行读写。文件指针存在于文件的开头。</td>
</tr>
<tr>
<td>w</td>
<td>它打开文件只写。如果文件以前存在，它会覆盖该文件；如果不存在同名文件，它会创建一个新文件。文件指针存在于文件的开头。</td>
</tr>
<tr>
<td>wb</td>
<td>它打开文件，只以二进制格式写入。如果文件以前存在，它会覆盖该文件；如果没有文件，它会创建一个新文件。文件指针存在于文件的开头。</td>
</tr>
<tr>
<td>w+</td>
<td>它打开文件进行读写。它与 r+的不同之处在于，如果存在先前的文件，它会覆盖先前的文件，而 r+不会覆盖先前写入的文件。如果没有文件，它会创建一个新文件。文件指针存在于文件的开头。</td>
</tr>
<tr>
<td>wb+</td>
<td>它以二进制格式打开文件进行读写。文件指针存在于文件的开头。</td>
</tr>
<tr>
<td>a</td>
<td>它以追加模式打开文件。文件指针存在于先前写入的文件(如果存在)的末尾。如果不存在同名文件，它会创建一个新文件。</td>
</tr>
<tr>
<td>ab</td>
<td>它以二进制格式在追加模式下打开文件。指针存在于先前写入的文件的末尾。如果不存在同名文件，它会创建一个二进制格式的新文件。</td>
</tr>
<tr>
<td>a+</td>
<td>它打开一个文件来附加和读取两者。如果文件存在，文件指针将保留在文件的末尾。如果不存在同名文件，它会创建一个新文件。</td>
</tr>
<tr>
<td>ab+</td>
<td>它打开一个文件，以二进制格式追加和读取两者。文件指针保持在文件的末尾。</td>
</tr>
</tbody>
</table>
<p>让我们看一个简单的例子，以读取模式打开一个名为&quot;file.txt&quot;(存储在同一个目录中)的文件，并在控制台上打印其内容。</p>
<h2 id="例子-41">例子</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#opens the file file.txt in read mode  </span></span><br><span class="line">fileptr = <span class="built_in">open</span>(<span class="string">&quot;file.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> fileptr:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;file is opened successfully&quot;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;_io.TextIOWrapper&#x27;</span>&gt;</span><br><span class="line">file <span class="keyword">is</span> opened successfully</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们传递了<strong>filename</strong>作为第一个参数，并以读取模式打开了文件，正如我们提到的 <strong>r</strong> 作为第二个参数。<strong>文件程序</strong>保存文件对象，如果文件打开成功，它将执行打印语句</p>
<h2 id="close-方法">close()方法</h2>
<p>一旦文件上的所有操作完成，我们必须使用 <strong>close()</strong> 方法通过 Python 脚本关闭它。一旦在文件对象上调用 <strong>close()</strong> 方法，任何未写的信息都会被销毁。</p>
<p>我们可以使用当前在 Python 中打开的文件系统在外部对文件执行任何操作；因此，最好在所有操作完成后关闭文件。</p>
<p>下面给出了使用 <strong>close()</strong> 方法的语法。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">fileobject.close() </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># opens the file file.txt in read mode  </span></span><br><span class="line">fileptr = <span class="built_in">open</span>(<span class="string">&quot;file.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> fileptr:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;file is opened successfully&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">#closes the opened file  </span></span><br><span class="line">fileptr.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>关闭文件后，我们无法在文件中执行任何操作。该文件需要正确关闭。如果在文件中执行某些操作时出现任何异常，程序将终止，而不会关闭文件。</p>
<p>我们应该用下面的方法来克服这类问题。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">   fileptr = <span class="built_in">open</span>(<span class="string">&quot;file.txt&quot;</span>)</span><br><span class="line">   <span class="comment"># perform file operations</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">   fileptr.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="with-语句">with 语句</h2>
<p>python 2.5 中引入了带有语句的with 语句在操作文件的情况下很有用。它用于一对语句之间要执行一段代码的场景。</p>
<p>下面给出了使用和语句打开文件的语法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(&lt;file name&gt;, &lt;access mode&gt;) <span class="keyword">as</span> &lt;file-pointer&gt;:  </span><br><span class="line">    <span class="comment">#statement suite   </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用 with 语句的优点是，无论嵌套块如何退出，它都能保证关闭文件。</p>
<p>在文件的情况下总是建议使用<strong>with</strong>语句，因为如果中断、返回或异常发生在嵌套的代码块中，那么它会自动关闭文件，我们不需要编写 <strong>close()</strong> 函数。它不会让文件损坏。</p>
<p>考虑下面的例子。</p>
<h3 id="例子-42">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;file.txt&quot;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">    content = f.read();  </span><br><span class="line">    <span class="built_in">print</span>(content)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="正在写入文件">正在写入文件</h2>
<p>要向文件中写入一些文本，我们需要使用 open 方法以下列访问模式之一打开文件。</p>
<p><strong>w:</strong> 如果有文件存在，会覆盖文件。文件指针在文件的开头。</p>
<p><strong>a:</strong> 将追加已有文件。文件指针在文件的末尾。如果没有文件，它会创建一个新文件。</p>
<p>考虑下面的例子。</p>
<h3 id="例子-43">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># open the file.txt in append mode. Create a new file if no such file exists.</span></span><br><span class="line">fileptr = <span class="built_in">open</span>(<span class="string">&quot;file2.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># appending the content to the file</span></span><br><span class="line">fileptr.write(<span class="string">&#x27;&#x27;&#x27;Python is the modern day language. It makes things so simple.</span></span><br><span class="line"><span class="string">It is the fastest-growing programing language&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># closing the opened the file</span></span><br><span class="line">fileptr.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<p>File2.txt</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Python <span class="keyword">is</span> the modern-day language. It makes things so simple. It <span class="keyword">is</span> the fastest growing programming language.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>文件快照 2.txt</strong></p>
<p><img src="/img/8746120179208b4814be588cc221fcbd.png" alt="Python File Handling"></p>
<p>我们已经在 <strong>w</strong> 模式下打开了文件。<strong>file1.txt</strong> 文件不存在，它创建了一个新文件，我们已经使用 <strong>write()</strong> 函数在文件中写入了内容。</p>
<h3 id="例-2-11">例 2</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#open the file.txt in write mode.  </span></span><br><span class="line">fileptr = <span class="built_in">open</span>(<span class="string">&quot;file2.txt&quot;</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#overwriting the content of the file  </span></span><br><span class="line">fileptr.write(<span class="string">&quot; Python has an easy syntax and user-friendly interaction.&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">#closing the opened file   </span></span><br><span class="line">fileptr.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Python <span class="keyword">is</span> the modern day language. It makes things so simple.</span><br><span class="line">It <span class="keyword">is</span> the fastest growing programing language Python has an easy syntax <span class="keyword">and</span> user-friendly interaction.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>文件快照 2.txt</strong></p>
<p><img src="/img/9d825d5bd62cb15a83550d49521770b8.png" alt="Python File Handling"></p>
<p>我们可以看到文件的内容被修改了。我们已经在模式下打开了该文件，并在现有的file2.txt中添加了内容。</p>
<p>要使用 Python 脚本读取文件，Python 提供了 <strong>read()</strong> 方法。 <strong>read()</strong> 方法从文件中读取一个字符串。它可以读取文本和二进制格式的数据。</p>
<p><strong>read()</strong> 方法的语法如下。</p>
<p><strong>语法:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">fileobj.read(&lt;count&gt;)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，计数是从文件的开头开始要从文件中读取的字节数。如果没有指定计数，那么它可以读取文件的内容直到结束。</p>
<p>考虑下面的例子。</p>
<h3 id="例子-44">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#open the file.txt in read mode. causes error if no such file exists.  </span></span><br><span class="line">fileptr = <span class="built_in">open</span>(<span class="string">&quot;file2.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line"><span class="comment">#stores all the data of the file into the variable content  </span></span><br><span class="line">content = fileptr.read(<span class="number">10</span>) </span><br><span class="line"><span class="comment"># prints the type of the data stored in the file  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(content))    </span><br><span class="line"><span class="comment">#prints the content of the file  </span></span><br><span class="line"><span class="built_in">print</span>(content)     </span><br><span class="line"><span class="comment">#closes the opened file  </span></span><br><span class="line">fileptr.close()  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line">Python <span class="keyword">is</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们已经使用 <strong>read()</strong> 函数读取了<strong>file2.txt</strong> 的内容。我们将计数值传递为十，这意味着它将从文件中读取前十个字符。</p>
<p>如果我们使用下面一行，那么它将打印文件的所有内容。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">content = fileptr.read()</span><br><span class="line"><span class="built_in">print</span>(content) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Python <span class="keyword">is</span> the modern-day language. It makes things so simple.</span><br><span class="line">It <span class="keyword">is</span> the fastest-growing programing language Python has easy an syntax <span class="keyword">and</span> user-friendly interaction.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="循环读取文件">循环读取文件</h3>
<p>我们可以使用 <code>for</code>循环来读取文件。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#open the file.txt in read mode. causes an error if no such file exists.  </span></span><br><span class="line">fileptr = <span class="built_in">open</span>(<span class="string">&quot;file2.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);   </span><br><span class="line"><span class="comment">#running a for loop   </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> fileptr:  </span><br><span class="line">    <span class="built_in">print</span>(i) <span class="comment"># i contains each line of the file   </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Python <span class="keyword">is</span> the modern day language.</span><br><span class="line"></span><br><span class="line">It makes things so simple.</span><br><span class="line"></span><br><span class="line">Python has easy syntax <span class="keyword">and</span> user-friendly interaction.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="读取文件的行">读取文件的行</h2>
<p>Python 通过使用函数 <strong>readline()</strong> 方法来方便逐行读取文件。 <strong>readline()</strong> 方法从头开始读取文件的行，也就是说，如果我们使用 readline()方法两次，那么我们就可以得到文件的前两行。</p>
<p>考虑下面的例子，它包含一个函数 <strong>readline()</strong> ，该函数读取我们的文件<strong>file2.txt</strong>的第一行，该文件包含三行。考虑下面的例子。</p>
<h3 id="示例-1-使用-readline-函数读取行">示例 1:使用 readline()函数读取行</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#open the file.txt in read mode. causes error if no such file exists.  </span></span><br><span class="line">fileptr = <span class="built_in">open</span>(<span class="string">&quot;file2.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);   </span><br><span class="line"><span class="comment">#stores all the data of the file into the variable content  </span></span><br><span class="line">content = fileptr.readline()   </span><br><span class="line">content1 = fileptr.readline()</span><br><span class="line"><span class="comment">#prints the content of the file  </span></span><br><span class="line"><span class="built_in">print</span>(content)   </span><br><span class="line"><span class="built_in">print</span>(content1)</span><br><span class="line"><span class="comment">#closes the opened file  </span></span><br><span class="line">fileptr.close()  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Python <span class="keyword">is</span> the modern day language.</span><br><span class="line"></span><br><span class="line">It makes things so simple.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们两次调用了 <strong>readline()</strong> 函数，这就是它从文件中读取两行的原因。</p>
<p>Python 还提供了用于读取行的<strong>读取行()<strong>方法。它返回行的列表，直到到达</strong>文件(EOF)</strong> 的末尾。</p>
<h3 id="示例-2-使用-readlines-函数读取行">示例 2:使用 <code>readlines()</code>函数读取行</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#open the file.txt in read mode. causes error if no such file exists.  </span></span><br><span class="line">fileptr = <span class="built_in">open</span>(<span class="string">&quot;file2.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);   </span><br><span class="line"></span><br><span class="line"><span class="comment">#stores all the data of the file into the variable content  </span></span><br><span class="line">content = fileptr.readlines()   </span><br><span class="line"></span><br><span class="line"><span class="comment">#prints the content of the file  </span></span><br><span class="line"><span class="built_in">print</span>(content)   </span><br><span class="line"></span><br><span class="line"><span class="comment">#closes the opened file  </span></span><br><span class="line">fileptr.close()  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;Python is the modern day language.\n&#x27;</span>, <span class="string">&#x27;It makes things so simple.\n&#x27;</span>, <span class="string">&#x27;Python has easy syntax and user-friendly interaction.&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="创建新文件">创建新文件</h2>
<p>在函数 open()的情况下，可以使用以下访问模式之一创建新文件。</p>
<p><strong>x:</strong> 它用指定的名称创建一个新文件。如果存在同名文件，则会导致错误。</p>
<p><strong>a:</strong> 如果不存在指定名称的文件，则创建该文件。如果具有指定名称的文件已经存在，它会将内容追加到文件中。</p>
<p><strong>w:</strong> 如果不存在指定名称的文件，它会创建一个新文件。它会覆盖现有文件。</p>
<p>考虑下面的例子。</p>
<h3 id="例-1-14">例 1</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#open the file.txt in read mode. causes error if no such file exists.  </span></span><br><span class="line">fileptr = <span class="built_in">open</span>(<span class="string">&quot;file2.txt&quot;</span>,<span class="string">&quot;x&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(fileptr)  </span><br><span class="line"><span class="keyword">if</span> fileptr:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;File created successfully&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;_io.TextIOWrapper name=<span class="string">&#x27;file2.txt&#x27;</span> mode=<span class="string">&#x27;x&#x27;</span> encoding=<span class="string">&#x27;cp1252&#x27;</span>&gt;</span><br><span class="line">File created successfully </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="文件指针位置">文件指针位置</h2>
<p>Python 提供了 tell()方法，用于打印文件指针当前所在的字节数。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># open the file file2.txt in read mode  </span></span><br><span class="line">fileptr = <span class="built_in">open</span>(<span class="string">&quot;file2.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">#initially the filepointer is at 0   </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The filepointer is at byte :&quot;</span>,fileptr.tell())  </span><br><span class="line"></span><br><span class="line"><span class="comment">#reading the content of the file  </span></span><br><span class="line">content = fileptr.read();  </span><br><span class="line"></span><br><span class="line"><span class="comment">#after the read operation file pointer modifies. tell() returns the location of the fileptr.   </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;After reading, the filepointer is at:&quot;</span>,fileptr.tell())  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The filepointer <span class="keyword">is</span> at byte : <span class="number">0</span></span><br><span class="line">After reading, the filepointer <span class="keyword">is</span> at: <span class="number">117</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="修改文件指针位置">修改文件指针位置</h2>
<p>在现实应用中，有时我们需要从外部更改文件指针位置，因为我们可能需要在不同的位置读取或写入内容。</p>
<p>为此，Python 为我们提供了 <code>seek()</code>方法，使我们能够在外部修改文件指针的位置。</p>
<p>下面给出了使用 <code>seek()</code>方法的语法。</p>
<p><strong>语法:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;file-ptr&gt;.seek(offset[, <span class="keyword">from</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>seek()</code>方法接受两个参数:</p>
<p>**偏移量:**指文件指针在文件内的新位置。</p>
<p><strong>from:</strong> 表示字节移动的参考位置。如果设置为 0，文件的开头将用作参考位置。如果设置为 1，文件指针的当前位置将用作参考位置。如果设置为 2，文件指针的末端将用作参考位置。</p>
<p>考虑下面的例子。</p>
<h3 id="例子-45">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># open the file file2.txt in read mode  </span></span><br><span class="line">fileptr = <span class="built_in">open</span>(<span class="string">&quot;file2.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">#initially the filepointer is at 0   </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The filepointer is at byte :&quot;</span>,fileptr.tell())  </span><br><span class="line"></span><br><span class="line"><span class="comment">#changing the file pointer location to 10\.  </span></span><br><span class="line">fileptr.seek(<span class="number">10</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">#tell() returns the location of the fileptr.   </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;After reading, the filepointer is at:&quot;</span>,fileptr.tell())  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The filepointer <span class="keyword">is</span> at byte : <span class="number">0</span></span><br><span class="line">After reading, the filepointer <span class="keyword">is</span> at: <span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Python-os模块">Python <code>os</code>模块</h2>
<h3 id="重命名文件">重命名文件</h3>
<p>Python <strong>os</strong> 模块支持与操作系统的交互。os 模块提供文件处理操作中涉及的功能，如重命名、删除等。它为我们提供了 rename()方法，将指定的文件重命名为新名称。下面给出了使用**重命名()**方法的语法。</p>
<p><strong>语法:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">rename(current-name, new-name)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第一个参数是当前文件名，第二个参数是修改后的名称。我们可以绕过这两个参数来更改文件名。</p>
<p><strong>例 1:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os  </span><br><span class="line"></span><br><span class="line"><span class="comment">#rename file2.txt to file3.txt  </span></span><br><span class="line">os.rename(<span class="string">&quot;file2.txt&quot;</span>,<span class="string">&quot;file3.txt&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<p>以上代码将当前<strong>file2.txt</strong> 重命名为<strong>file3.txt</strong></p>
<h3 id="正在删除文件">正在删除文件</h3>
<p>os 模块提供 <strong>remove()</strong> 方法，用于删除指定的文件。下面给出了使用 <strong>remove()</strong> 方法的语法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">remove(file-name) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例 1</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os;  </span><br><span class="line"><span class="comment">#deleting the file named file3.txt   </span></span><br><span class="line">os.remove(<span class="string">&quot;file3.txt&quot;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="创建新目录">创建新目录</h2>
<p><strong>mkdir()</strong> 方法用于创建当前工作目录中的目录。下面给出了创建新目录的语法。</p>
<p><strong>语法:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">mkdir(directory name)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例 1</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os  </span><br><span class="line"></span><br><span class="line"><span class="comment">#creating a new directory with the name new  </span></span><br><span class="line">os.mkdir(<span class="string">&quot;new&quot;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="getcwd-方法">getcwd()方法</h2>
<p>此方法返回当前工作目录。</p>
<p>下面给出了使用 getcwd()方法的语法。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">os.getcwd()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.getcwd()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;C:\\Users\\DEVANSH SHARMA&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="更改当前工作目录">更改当前工作目录</h2>
<p>chdir()方法用于将当前工作目录更改为指定目录。</p>
<p>下面给出了使用 chdir()方法的语法。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">chdir(<span class="string">&quot;new-directory&quot;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例子-46">例子</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="comment"># Changing current directory with the new directiory</span></span><br><span class="line">os.chdir(<span class="string">&quot;C:\\Users\\DEVANSH SHARMA\\Documents&quot;</span>)</span><br><span class="line"><span class="comment">#It will display the current working directory</span></span><br><span class="line">os.getcwd()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;C:\\Users\\DEVANSH SHARMA\\Documents&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="正在删除目录">正在删除目录</h2>
<p>rmdir()方法用于删除指定的目录。</p>
<p>下面给出了使用 rmdir()方法的语法。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">os.rmdir(directory name)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例 1</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment">#removing the new directory   </span></span><br><span class="line">os.rmdir(<span class="string">&quot;directory_name&quot;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它将删除指定的目录。</p>
<h2 id="将-Python-输出写入文件">将 Python 输出写入文件</h2>
<p>在 Python 中，需要将 Python 脚本的输出写入文件。</p>
<p>模块<strong>子流程</strong>的 <strong>check_call()</strong> 方法用于执行 Python 脚本，并将该脚本的输出写入文件。</p>
<p>以下示例包含两个 python 脚本。脚本文件 <a href="http://1.py">1.py</a> 执行脚本文件. py，并将其输出写入文本文件 <strong>output.txt.</strong></p>
<p><strong>例</strong></p>
<p><strong><a href="http://file.py">file.py</a></strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">temperatures=[<span class="number">10</span>,-<span class="number">20</span>,-<span class="number">289</span>,<span class="number">100</span>]  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">c_to_f</span>(<span class="params">c</span>):  </span><br><span class="line">    <span class="keyword">if</span> c&lt; -<span class="number">273.15</span>:  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;That temperature doesn&#x27;t make sense!&quot;</span>  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        f=c*<span class="number">9</span>/<span class="number">5</span>+<span class="number">32</span>  </span><br><span class="line">        <span class="keyword">return</span> f  </span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> temperatures:  </span><br><span class="line">    <span class="built_in">print</span>(c_to_f(t))  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong><a href="http://file.py">file.py</a></strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess  </span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">    subprocess.check_call([<span class="string">&quot;python&quot;</span>, <span class="string">&quot;file.py&quot;</span>], stdout=f)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="文件相关方法">文件相关方法</h2>
<p>文件对象提供以下方法来操作各种操作系统上的文件。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>file.close()</td>
<td>它关闭打开的文件。文件一旦关闭，就不能再读写了。</td>
</tr>
<tr>
<td>File.flush()</td>
<td>它会刷新内部缓冲区。</td>
</tr>
<tr>
<td>File.fileno（）</td>
<td>它返回底层实现用来向操作系统请求输入/输出的文件描述符。</td>
</tr>
<tr>
<td>File.isatty()</td>
<td>如果文件连接到 TTY 设备，则返回 true，否则返回 false。</td>
</tr>
<tr>
<td>File.next()</td>
<td>它返回文件的下一行。</td>
</tr>
<tr>
<td>file.read([size])</td>
<td>它读取指定大小的文件。</td>
</tr>
<tr>
<td>file.readline([size])</td>
<td>它从文件中读取一行，并将文件指针放在新行的开头。</td>
</tr>
<tr>
<td>file.readline([sizehint])</td>
<td>它返回一个包含文件所有行的列表。它使用 readline()函数读取文件，直到发生 EOF。</td>
</tr>
<tr>
<td>File.seek(offset[，from)</td>
<td>它将文件指针的位置修改为具有指定引用的指定偏移量。</td>
</tr>
<tr>
<td>File.tell()</td>
<td>它返回文件指针在文件中的当前位置。</td>
</tr>
<tr>
<td>file.truncate([size])</td>
<td>它会将文件截断到可选的指定大小。</td>
</tr>
<tr>
<td>File.write(str)</td>
<td>它将指定的字符串写入文件</td>
</tr>
<tr>
<td>File.writelines(seq)</td>
<td>它将一系列字符串写入文件。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-files-io">https://www.javatpoint.com/python-files-io</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 日期和时间</title>
    <url>/posts/f7e311b4.html</url>
    <content><![CDATA[<h1>Python 日期和时间</h1>
<p>Python 为<strong>日期时间</strong>模块提供了真实的日期和时间。在现实应用中，我们需要处理日期和时间。Python 使我们能够安排我们的 Python 脚本在特定的时间运行。</p>
<p>在 Python 中，日期不是数据类型，但是我们可以通过导入以<strong>日期时间、时间和日历</strong>命名的模块来处理日期对象。</p>
<p>在教程的这一部分，我们将讨论如何在 Python 中使用日期和时间对象。</p>
<p><strong>日期时间</strong>类别分为六个主要类别。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>date</strong> -它由年、月和日作为属性组成。</p>
</li>
<li class="lvl-4">
<p><strong>time</strong> -这是一个完美的时间，假设每天都有精确的 24<em>60</em>60 秒。它有小时、分钟、秒、微秒和 <strong>tzinfo</strong> 属性。</p>
</li>
<li class="lvl-4">
<p><strong>datetime</strong> -它是日期和时间的分组，以及年、月、日、小时、分钟、秒、微秒和 tzinfo 属性。</p>
</li>
<li class="lvl-4">
<p><strong>timedelta-</strong> 它表示两个日期、时间或日期时间实例到微秒分辨率之间的差异。</p>
</li>
<li class="lvl-4">
<p><strong>tzinfo</strong> -提供时区信息对象。</p>
</li>
<li class="lvl-4">
<p><strong>datetime-</strong> 包含在新版 Python 中。它是实现 <strong>tzinfo</strong> 抽象基类的类。</p>
</li>
</ul>
<h2 id="滴答声">滴答声</h2>
<p>在 Python 中，时间瞬间是从 1970 年 1 月 1 日上午 12 点开始计算的。模块时间的函数 <strong>time()</strong> 返回自 1970 年 1 月 1 日上午 12 点以来总数。刻度可以看作是测量时间的最小单位。</p>
<p>考虑以下示例</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time;</span><br><span class="line"><span class="comment">#prints the number of ticks spent since 12 AM, 1st January 1970</span></span><br><span class="line"><span class="built_in">print</span>(time.time())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1585928913.6519969</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="如何获取当前时间？">如何获取当前时间？</h2>
<p>时间模块的 localtime()函数用于获取当前的时间元组。考虑下面的例子。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time;  </span><br><span class="line"></span><br><span class="line"><span class="comment">#returns a time tuple   </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(time.localtime(time.time()))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">time.struct_time(tm_year=<span class="number">2020</span>, tm_mon=<span class="number">4</span>, tm_mday=<span class="number">3</span>, tm_hour=<span class="number">21</span>, tm_min=<span class="number">21</span>, tm_sec=<span class="number">40</span>, tm_wday=<span class="number">4</span>, tm_yday=<span class="number">94</span>, tm_isdst=<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="时间元组">时间元组</h2>
<p>时间被视为 9 个数字的元组。让我们看看时间元组的成员。</p>
<p><img src="/img/WX20230718-161550@2x.png" alt="Python时间元组"></p>
<h2 id="获取格式化时间">获取格式化时间</h2>
<p>可以使用时间模块的 <strong>asctime()</strong> 功能格式化时间。它返回正在传递的时间元组的格式化时间。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time  </span><br><span class="line">  <span class="comment">#returns the formatted time    </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(time.asctime(time.localtime(time.time())))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Tue Dec <span class="number">18</span> <span class="number">15</span>:<span class="number">31</span>:<span class="number">39</span> <span class="number">2018</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Python-睡眠时间">Python 睡眠时间</h2>
<p>时间模块的 <strong>sleep()</strong> 方法用于在给定的时间内停止脚本的执行。输出将延迟作为浮点提供的秒数。</p>
<p>考虑下面的例子。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="comment">#Each element will be printed after 1 second</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="日期时间模块">日期时间模块</h2>
<p><strong>日期时间</strong>模块使我们能够创建自定义日期对象，对日期执行各种操作，如比较等。</p>
<p>要使用日期作为日期对象，我们必须将<strong>datetime</strong>模块导入 python 源代码。</p>
<p>考虑以下示例来获取当前时间的<strong>日期时间</strong>对象表示。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="comment">#returns the current datetime object   </span></span><br><span class="line"><span class="built_in">print</span>(datetime.datetime.now())  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span>-04-04 <span class="number">13</span>:<span class="number">18</span>:<span class="number">35.252578</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="创建日期对象">创建日期对象</h2>
<p>我们可以在日期时间构造器中绕过需要创建日期对象的日期来创建日期对象。</p>
<p>考虑下面的例子。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime  </span><br><span class="line"><span class="comment">#returns the datetime object for the specified date  </span></span><br><span class="line"><span class="built_in">print</span>(datetime.datetime(<span class="number">2020</span>,04,04))  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span>-04-04 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们还可以指定创建 datetime 对象的时间和日期。考虑下面的例子。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment">#returns the datetime object for the specified time    </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(datetime.datetime(<span class="number">2020</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">26</span>,<span class="number">40</span>))  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span>-04-04 01:<span class="number">26</span>:<span class="number">40</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们以顺序的方式传入了 <strong>datetime()</strong> 函数年、月、日、小时、分钟和毫秒属性。</p>
<h2 id="两个日期的比较">两个日期的比较</h2>
<p>我们可以使用比较运算符如&gt;、&gt; =、</p>
<p>考虑下面的例子。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime <span class="keyword">as</span> dt  </span><br><span class="line"><span class="comment">#Compares the time. If the time is in between 8AM and 4PM, then it prints working hours otherwise it prints fun hours  </span></span><br><span class="line"><span class="keyword">if</span> dt(dt.now().year,dt.now().month,dt.now().day,<span class="number">8</span>)&lt;dt.now()&lt;dt(dt.now().year,dt.now().month,dt.now().day,<span class="number">16</span>):  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Working hours....&quot;</span>)  </span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;fun hours&quot;</span>) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">fun hours</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="日历模块">日历模块</h2>
<p>Python 提供了一个日历对象，其中包含各种使用日历的方法。</p>
<p>考虑以下示例来打印 2018 年最后一个月的日历。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> calendar;  </span><br><span class="line">cal = calendar.month(<span class="number">2020</span>,<span class="number">3</span>)  </span><br><span class="line"><span class="comment">#printing the calendar of December 2018  </span></span><br><span class="line"><span class="built_in">print</span>(cal)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">March <span class="number">2020</span></span><br><span class="line">Mo Tu We Th Fr Sa Su</span><br><span class="line">                   <span class="number">1</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></span><br><span class="line"> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span></span><br><span class="line"><span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span> <span class="number">21</span> <span class="number">22</span></span><br><span class="line"><span class="number">23</span> <span class="number">24</span> <span class="number">25</span> <span class="number">26</span> <span class="number">27</span> <span class="number">28</span> <span class="number">29</span></span><br><span class="line"><span class="number">30</span> <span class="number">31</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="打印全年日历">打印全年日历</h2>
<p>日历模块的 prcal()方法用于打印全年的日历。要打印日历的年份必须传递到此方法中。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> calendar  </span><br><span class="line"><span class="comment">#printing the calendar of the year 2019  </span></span><br><span class="line">s = calendar.prcal(<span class="number">2020</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<p><img src="/img/dad88516687d0ffd2db69d6126f4b657.png" alt="Python Date and time"></p>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-date">https://www.javatpoint.com/python-date</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 栈和队列</title>
    <url>/posts/fcfa0d23.html</url>
    <content><![CDATA[<h1>Python 栈和队列</h1>
<p>数据结构组织计算机中的存储，以便我们可以轻松地访问和更改数据。栈和队列是计算机科学中最早定义的数据结构。一个简单的 Python 列表也可以充当队列和栈。队列遵循先进先出规则，用于编程排序。栈和队列通常用数组或链表来实现。</p>
<h2 id="堆">堆</h2>
<p>栈是遵循后进先出原则的数据结构。要实现栈，我们需要两个简单的操作:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>push -</strong> 它在栈顶增加一个元素。</p>
</li>
<li class="lvl-4">
<p><strong>pop -</strong> 它从栈顶部移除一个元素。</p>
</li>
</ul>
<p><img src="/img/c9a5e014de2c318eb07a1be9a5e1aad1.png" alt="Python Stack and Queue"><br>
<img src="/img/9999d88be401c76225c1afa90d8a539b.png" alt="Python Stack and Queue"></p>
<p><strong>操作:</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Adding -</strong> 增加栈中的项目，增加栈大小。加法发生在栈的顶部。</p>
</li>
<li class="lvl-4">
<p><strong>Deletion -</strong> 它由两个条件组成，第一，如果栈中没有元素，那么栈中会发生下溢，第二，如果栈包含一些元素，那么最顶层的元素会被移除。它减小了栈大小。</p>
</li>
<li class="lvl-4">
<p><strong>Traversing -</strong> 它涉及访问栈的每个元素。</p>
</li>
</ul>
<p><strong>特征:</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>栈的插入顺序被保留。</p>
</li>
<li class="lvl-4">
<p>对解析操作很有用。</p>
</li>
<li class="lvl-4">
<p>允许双重。</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Code to demonstrate Implementation of </span></span><br><span class="line"><span class="comment"># stack using list </span></span><br><span class="line">x = [<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;Android&quot;</span>] </span><br><span class="line">x.push(<span class="string">&quot;Java&quot;</span>) </span><br><span class="line">x.push(<span class="string">&quot;C++&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(x) </span><br><span class="line"><span class="built_in">print</span>(x.pop()) </span><br><span class="line"><span class="built_in">print</span>(x) </span><br><span class="line"><span class="built_in">print</span>(x.pop()) </span><br><span class="line"><span class="built_in">print</span>(x) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;Android&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;C++&#x27;</span>]</span><br><span class="line">C++</span><br><span class="line">[<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;Android&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>]</span><br><span class="line">Java</span><br><span class="line">[<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;Android&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="队列">队列</h2>
<p>队列遵循先进先出原则。它是从两端打开的，因此我们可以很容易地在后面添加元素，也可以从前面移除元素。</p>
<p>为了实现队列，我们需要两个简单的操作:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>enqueue -</strong> 它在队列末尾添加一个元素。</p>
</li>
<li class="lvl-4">
<p><strong>dequeue -</strong> 它从队列的开头移除元素。</p>
</li>
</ul>
<p><img src="/img/abeb66cf570ae556cbf354b900476da3.png" alt="Python Stack and Queue"><br>
<img src="/img/c61e6e42c53b0a070c8cb7478428f4d2.png" alt="Python Stack and Queue"></p>
<p><strong>队列上的操作</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Addition -</strong> 它将队列中的元素相加，并发生在后端，即队列的后面。</p>
</li>
<li class="lvl-4">
<p><strong>Deletion -</strong> 它由两个条件组成——如果队列中没有元素，则队列中出现下溢，或者如果栈包含一些元素，则位于前面的元素被删除。</p>
</li>
<li class="lvl-4">
<p><strong>Traversing -</strong> 它包括访问队列的每个元素。</p>
</li>
</ul>
<p><strong>特征</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>队列的插入顺序被保留。</p>
</li>
<li class="lvl-4">
<p>允许双重。</p>
</li>
<li class="lvl-4">
<p>对解析 CPU 任务操作很有用。</p>
</li>
</ul>
<h4 id="注意-队列的实现有点不一样。队列遵循“先进先出”。时间在这里起着重要的作用。栈很快，因为我们从列表的末尾插入和弹出元素，而在队列中，插入和弹出是从列表的开头开始的，所以它变得很慢。这种时间差的原因是由于列表的属性，列表在结束操作时很快，但在开始操作时很慢，因为所有其他元素都必须一个接一个地移动。">注意:队列的实现有点不一样。队列遵循“先进先出”。时间在这里起着重要的作用。栈很快，因为我们从列表的末尾插入和弹出元素，而在队列中，插入和弹出是从列表的开头开始的，所以它变得很慢。这种时间差的原因是由于列表的属性，列表在结束操作时很快，但在开始操作时很慢，因为所有其他元素都必须一个接一个地移动。</h4>
<h3 id="密码">密码</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> queue </span><br><span class="line"><span class="comment"># Queue is created as an object &#x27;L&#x27;</span></span><br><span class="line">L = queue.Queue(maxsize=<span class="number">10</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Data is inserted in &#x27;L&#x27; at the end using put() </span></span><br><span class="line">L.put(<span class="number">9</span>) </span><br><span class="line">L.put(<span class="number">6</span>) </span><br><span class="line">L.put(<span class="number">7</span>) </span><br><span class="line">L.put(<span class="number">4</span>) </span><br><span class="line"><span class="comment"># get() takes data from </span></span><br><span class="line"><span class="comment"># from the head  </span></span><br><span class="line"><span class="comment"># of the Queue </span></span><br><span class="line"><span class="built_in">print</span>(L.get()) </span><br><span class="line"><span class="built_in">print</span>(L.get()) </span><br><span class="line"><span class="built_in">print</span>(L.get()) </span><br><span class="line"><span class="built_in">print</span>(L.get()) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-stack-and-queue">https://www.javatpoint.com/python-stack-and-queue</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 模块</title>
    <url>/posts/cae0d850.html</url>
    <content><![CDATA[<h1>Python 模块</h1>
<p>python 模块可以定义为 python 程序文件，其中包含 python 代码，包括 python 函数、类或变量。换句话说，我们可以说我们的 python 代码文件以扩展名(.py)被视为模块。我们可能在 python 模块中有一个可运行的代码。</p>
<p>Python 中的模块为我们提供了以逻辑方式组织代码的灵活性。</p>
<p>要将一个模块的功能用于另一个模块，我们必须导入特定的模块。</p>
<h2 id="例子-47">例子</h2>
<p>在这个例子中，我们将创建一个名为 <a href="http://file.py">file.py</a> 的模块，它包含一个函数 func，该函数 func 包含在控制台上打印一些消息的代码。</p>
<p>让我们创建名为 <strong><a href="http://file.py">file.py</a>.</strong> 的模块</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#displayMsg prints a message to the name being passed. </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">displayMsg</span>(<span class="params">name</span>)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;Hi &quot;</span>+name);  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，我们需要将这个模块包含到我们的主模块中，以调用在名为 file 的模块中定义的 displayMsg()方法。</p>
<h2 id="在-python-代码中加载模块">在 python 代码中加载模块</h2>
<p>我们需要在 python 代码中加载该模块来使用它的功能.python 提供了两种类型的语句，定义如下。</p>
<ol>
<li class="lvl-4">
<p>进口声明</p>
</li>
<li class="lvl-4">
<p>自导入语句</p>
</li>
</ol>
<h2 id="import-声明">import 声明</h2>
<p>import 语句用于将一个模块的所有功能导入到另一个模块中。在这里，我们必须注意到，我们可以通过将任何 python 源文件作为模块导入另一个 python 源文件来使用该文件的功能。</p>
<p>我们可以用一个 import 语句导入多个模块，但是一个模块被加载一次，无论加载多少次，它都已经被导入到我们的文件中。</p>
<p>下面给出了使用 import 语句的语法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> module1,module2,........ module n</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因此，如果我们需要调用 <a href="http://file.py">file.py</a> 中定义的函数 displayMsg()，我们必须将该文件作为一个模块导入到我们的模块中，如下例所示。</p>
<h2 id="示例-10">示例:</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> file;</span><br><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;Enter the name?&quot;</span>)</span><br><span class="line">file.displayMsg(name)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the name?John</span><br><span class="line">Hi John</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="from-import">from-import</h2>
<p>python 提供了仅导入模块特定属性的灵活性，而不是将整个模块导入命名空间。这可以通过使用 from？导入语句。下面给出了使用 from-import 语句的语法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> &lt; module-name&gt; <span class="keyword">import</span> &lt;name <span class="number">1</span>&gt;, &lt;name <span class="number">2</span>&gt;..,&lt;name n&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>考虑以下名为计算的模块，它包含求和、乘法和除法三个函数。</p>
<p><strong><a href="http://calculation.py">calculation.py</a>:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#place the code in the calculation.py </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">summation</span>(<span class="params">a,b</span>):</span><br><span class="line">	<span class="keyword">return</span> a+b</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multiplication</span>(<span class="params">a,b</span>):</span><br><span class="line">	<span class="keyword">return</span> a*b;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">a,b</span>):</span><br><span class="line">	<span class="keyword">return</span> a/b;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong><a href="http://Main.py">Main.py</a>:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> calculation <span class="keyword">import</span> summation  </span><br><span class="line"><span class="comment">#it will import only the summation() from calculation.py</span></span><br><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the first number&quot;</span>))</span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the second number&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sum = &quot;</span>,summation(a,b)) <span class="comment">#we do not need to specify the module name while accessing summation()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the first number10</span><br><span class="line">Enter the second number20</span><br><span class="line">Sum =  <span class="number">30</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>来自…如果我们事先知道要从模块中导入的属性，那么使用 import 语句总是更好。它不会让我们的代码变得更重。我们还可以使用*从模块中导入所有属性。</p>
<p>请考虑以下语法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> &lt;module&gt; <span class="keyword">import</span> * </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="重命名模块">重命名模块</h2>
<p>Python 为我们提供了导入具有特定名称的模块的灵活性，这样我们就可以在 python 源文件中使用这个名称来使用那个模块。</p>
<p>重命名模块的语法如下。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;module-name&gt; <span class="keyword">as</span> &lt;specific-name&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="例子-48">例子</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#the module calculation of previous example is imported in this example as cal. </span></span><br><span class="line"><span class="keyword">import</span> calculation <span class="keyword">as</span> cal;</span><br><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter a?&quot;</span>));</span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter b?&quot;</span>));</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sum = &quot;</span>,cal.summation(a,b))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter a?<span class="number">10</span></span><br><span class="line">Enter b?<span class="number">20</span></span><br><span class="line">Sum =  <span class="number">30</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="使用-dir-函数">使用 dir()函数</h2>
<p>dir()函数返回在传递的模块中定义的名称的排序列表。该列表包含该模块中定义的所有子模块、变量和函数。</p>
<p>考虑下面的例子。</p>
<h2 id="例子-49">例子</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="type">List</span> = <span class="built_in">dir</span>(json)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="type">List</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;JSONDecoder&#x27;</span>, <span class="string">&#x27;JSONEncoder&#x27;</span>, <span class="string">&#x27;__all__&#x27;</span>, <span class="string">&#x27;__author__&#x27;</span>, <span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;__cached__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;__file__&#x27;</span>, <span class="string">&#x27;__loader__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;__path__&#x27;</span>, <span class="string">&#x27;__spec__&#x27;</span>, <span class="string">&#x27;__version__&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;_default_decoder&#x27;</span>, <span class="string">&#x27;_default_encoder&#x27;</span>, <span class="string">&#x27;decoder&#x27;</span>, <span class="string">&#x27;dump&#x27;</span>, <span class="string">&#x27;dumps&#x27;</span>, <span class="string">&#x27;encoder&#x27;</span>, <span class="string">&#x27;load&#x27;</span>, <span class="string">&#x27;loads&#x27;</span>, <span class="string">&#x27;scanner&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="reload-函数">reload()函数</h2>
<p>正如我们已经说过的，一个模块被加载一次，不管它被导入 python 源文件的次数是多少。但是，如果您想重新加载已经导入的模块来重新执行顶层代码，python 为我们提供了 reload()函数。下面给出了使用 reload()函数的语法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">reload(&lt;module-name&gt;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>例如，要重新加载前面示例中定义的模块计算，我们必须使用下面一行代码。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">reload(calculation)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="变量的范围-2">变量的范围</h2>
<p>在 Python 中，变量与两种类型的范围相关联。模块中定义的所有变量都包含全局范围，除非或直到它在函数中定义。</p>
<p>函数内部定义的所有变量都包含一个局部范围，该范围仅限于该函数本身。我们不能全局访问局部变量。</p>
<p>如果两个变量在两个不同的作用域(即局部和全局)中用相同的名称定义，那么优先级将始终给予局部变量。</p>
<p>考虑下面的例子。</p>
<h2 id="例子-50">例子</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;john&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_name</span>(<span class="params">name</span>):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;Hi&quot;</span>,name) <span class="comment">#prints the name that is local to this function only.</span></span><br><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;Enter the name?&quot;</span>)</span><br><span class="line">print_name(name)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Hi David </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-包">Python 包</h2>
<p>python 中的包通过提供分层目录结构来方便开发人员使用应用开发环境，其中包包含子包、模块和子模块。这些包用于有效地对应用级代码进行分类。</p>
<p>让我们在您的主目录中创建一个名为 Employees 的包。请考虑以下步骤。</p>
<p>1.在路径/ <strong>home</strong>上创建一个名为 Employees 的目录。</p>
<p>2.在路径/ <strong>home</strong> / <strong>Employees</strong> 上创建一个名为 <a href="http://ITEmployees.py">ITEmployees.py</a> 的 python 源文件。</p>
<p><strong>项目员工. py</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getITNames</span>():</span><br><span class="line">	<span class="type">List</span> = [<span class="string">&quot;John&quot;</span>, <span class="string">&quot;David&quot;</span>, <span class="string">&quot;Nick&quot;</span>, 	<span class="string">&quot;Martin&quot;</span>]</span><br><span class="line">	<span class="keyword">return</span> <span class="type">List</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3.同样，再创建一个名为 <a href="http://BPOEmployees.py">BPOEmployees.py</a> 的 python 文件，并创建一个函数 getBPONames()。</p>
<p>4.现在，我们在第一步中创建的雇员目录包含两个 python 模块。为了使这个目录成为一个包，我们需要在这里包含一个文件，即 <strong>init</strong>.py，包含此目录中定义的模块的导入语句。</p>
<p><strong><strong>init</strong>.py</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ITEmployees <span class="keyword">import</span> getITNames</span><br><span class="line"><span class="keyword">from</span> BPOEmployees <span class="keyword">import</span> getBPONames</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>5.现在目录 <strong>Employees</strong> 变成了包含两个 python 模块的包。这里我们必须注意到，我们必须创建 <strong>init</strong>.py 在一个目录中，将这个目录转换成一个包。</p>
<p>6.要使用雇员包中定义的模块，我们必须在 python 源文件中导入这些模块。让我们在主目录(/home)中创建一个简单的 python 源文件，它使用这个包中定义的模块。</p>
<p><strong>测试 py</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Employees</span><br><span class="line"><span class="built_in">print</span>(Employees.getNames())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;David&#x27;</span>, <span class="string">&#x27;Nick&#x27;</span>, <span class="string">&#x27;Martin&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以在包裹里有子包裹。我们可以根据应用需求将包嵌套到任何级别。</p>
<p>下图显示了应用库管理系统的目录结构，该系统包含三个子包，即管理员、图书管理员和学生。子包包含 python 模块。</p>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-modules">https://www.javatpoint.com/python-modules</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 正则表达式</title>
    <url>/posts/76b9023d.html</url>
    <content><![CDATA[<h1>Python 正则表达式</h1>
<p>正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。<br>
Python 自1.5版本起增加了re 模块，它提供 Perl 风格的正则表达式模式。<br>
re 模块使 Python 语言拥有全部的正则表达式功能。<br>
compile 函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。<br>
re 模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数。</p>
<h2 id="re-match函数">re.match函数</h2>
<p>re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。</p>
<p><strong>函数语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">re.match(pattern, string, flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pattern</td>
<td>匹配的正则表达式</td>
</tr>
<tr>
<td>string</td>
<td>要匹配的字符串。</td>
</tr>
<tr>
<td>flags</td>
<td>标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</td>
</tr>
</tbody>
</table>
<p>匹配成功re.match方法返回一个匹配的对象，否则返回None。我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。</p>
<table>
<thead>
<tr>
<th>匹配对象方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>group(num=0)</td>
<td>匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。</td>
</tr>
<tr>
<td>groups()</td>
<td>返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。</td>
</tr>
</tbody>
</table>
<p><strong>实例1</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="built_in">print</span>(re.match(<span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>).span())  <span class="comment"># 在起始位置匹配</span></span><br><span class="line"><span class="built_in">print</span>(re.match(<span class="string">&#x27;com&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>))         <span class="comment"># 不在起始位置匹配</span></span><br><span class="line"></span><br><span class="line">(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p><strong>实例2</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"> </span><br><span class="line">line = <span class="string">&quot;Cats are smarter than dogs&quot;</span></span><br><span class="line"><span class="comment"># .* 表示任意匹配除换行符（\n、\r）之外的任何单个或多个字符</span></span><br><span class="line"><span class="comment"># (.*?) 表示&quot;非贪婪&quot;模式，只保存第一个匹配到的子串</span></span><br><span class="line">matchObj = re.match( <span class="string">r&#x27;(.*) are (.*?) .*&#x27;</span>, line, re.M|re.I)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> matchObj:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;matchObj.group() : &quot;</span>, matchObj.group())</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;matchObj.group(1) : &quot;</span>, matchObj.group(<span class="number">1</span>))</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;matchObj.group(2) : &quot;</span>, matchObj.group(<span class="number">2</span>))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;No match!!&quot;</span>)</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"><span class="comment"># out</span></span><br><span class="line">matchObj.group() :  Cats are smarter than dogs</span><br><span class="line">matchObj.group(<span class="number">1</span>) :  Cats</span><br><span class="line">matchObj.group(<span class="number">2</span>) :  smarter   </span><br></pre></td></tr></table></figure>
<h2 id="re-search方法">re.search方法</h2>
<p>re.search 扫描整个字符串并返回第一个成功的匹配。</p>
<p><strong>函数语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">re.search(pattern, string, flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pattern</td>
<td>匹配的正则表达式</td>
</tr>
<tr>
<td>string</td>
<td>要匹配的字符串。</td>
</tr>
<tr>
<td>flags</td>
<td>标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</td>
</tr>
</tbody>
</table>
<p>匹配成功re.search方法返回一个匹配的对象，否则返回None。</p>
<p>我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。</p>
<table>
<thead>
<tr>
<th>匹配对象方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>group(num=0)</td>
<td>匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。</td>
</tr>
<tr>
<td>groups()</td>
<td>返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。</td>
</tr>
</tbody>
</table>
<p><strong>实例1</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(re.search(<span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>).span())  <span class="comment"># 在起始位置匹配</span></span><br><span class="line"><span class="built_in">print</span>(re.search(<span class="string">&#x27;com&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>).span())         <span class="comment"># 不在起始位置匹配</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#out：</span></span><br><span class="line"></span><br><span class="line">(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">11</span>, <span class="number">14</span>)</span><br></pre></td></tr></table></figure>
<p><strong>实例2</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"> </span><br><span class="line">line = <span class="string">&quot;Cats are smarter than dogs&quot;</span></span><br><span class="line"> </span><br><span class="line">searchObj = re.search( <span class="string">r&#x27;(.*) are (.*?) .*&#x27;</span>, line, re.M|re.I)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> searchObj:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;searchObj.group() : &quot;</span>, searchObj.group())</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;searchObj.group(1) : &quot;</span>, searchObj.group(<span class="number">1</span>))</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;searchObj.group(2) : &quot;</span>, searchObj.group(<span class="number">2</span>))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;Nothing found!!&quot;</span>)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># out:</span></span><br><span class="line"></span><br><span class="line">searchObj.group() :  Cats are smarter than dogs</span><br><span class="line">searchObj.group(<span class="number">1</span>) :  Cats</span><br><span class="line">searchObj.group(<span class="number">2</span>) :  smarter</span><br></pre></td></tr></table></figure>
<h2 id="re-match与re-search的区别">re.match与re.search的区别</h2>
<p>re.match 只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回 None，而 re.search 匹配整个字符串，直到找到一个匹配。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"> </span><br><span class="line">line = <span class="string">&quot;Cats are smarter than dogs&quot;</span></span><br><span class="line"> </span><br><span class="line">matchObj = re.match( <span class="string">r&#x27;dogs&#x27;</span>, line, re.M|re.I)</span><br><span class="line"><span class="keyword">if</span> matchObj:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;match --&gt; matchObj.group() : &quot;</span>, matchObj.group())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;No match!!&quot;</span>)</span><br><span class="line"> </span><br><span class="line">matchObj = re.search( <span class="string">r&#x27;dogs&#x27;</span>, line, re.M|re.I)</span><br><span class="line"><span class="keyword">if</span> matchObj:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;search --&gt; matchObj.group() : &quot;</span>, matchObj.group())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;No match!!&quot;</span>)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># out:</span></span><br><span class="line">No match!!</span><br><span class="line">search --&gt; matchObj.group() :  dogs</span><br></pre></td></tr></table></figure>
<h2 id="检索和替换">检索和替换</h2>
<p>Python 的re模块提供了re.sub用于替换字符串中的匹配项。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">re.sub(pattern, repl, string, count=<span class="number">0</span>, flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>pattern : 正则中的模式字符串。必选</p>
</li>
<li class="lvl-2">
<p>repl : 替换的字符串，也可为一个函数。必选</p>
</li>
<li class="lvl-2">
<p>string : 要被查找替换的原始字符串。必选</p>
</li>
<li class="lvl-2">
<p>count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。可选</p>
</li>
<li class="lvl-2">
<p>flags : 编译时用的匹配模式，数字形式。可选</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"> </span><br><span class="line">phone = <span class="string">&quot;2004-959-559 # 这是一个电话号码&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 删除注释</span></span><br><span class="line">num = re.sub(<span class="string">r&#x27;#.*$&#x27;</span>, <span class="string">&quot;&quot;</span>, phone)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;电话号码 : &quot;</span>, num)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 移除非数字的内容</span></span><br><span class="line">num = re.sub(<span class="string">r&#x27;\D&#x27;</span>, <span class="string">&quot;&quot;</span>, phone)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;电话号码 : &quot;</span>, num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">电话号码 :  <span class="number">2004</span>-<span class="number">959</span>-<span class="number">559</span> </span><br><span class="line">电话号码 :  <span class="number">2004959559</span></span><br></pre></td></tr></table></figure>
<p><strong>repl是一个函数</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 将匹配的数字乘以 2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">double</span>(<span class="params">matched</span>):</span><br><span class="line">    value = <span class="built_in">int</span>(matched.group(<span class="string">&#x27;value&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(value * <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line">s = <span class="string">&#x27;A23G4HFD567&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(re.sub(<span class="string">&#x27;(?P&lt;value&gt;\d+)&#x27;</span>, double, s))</span><br><span class="line"></span><br><span class="line">A46G8HFD1134</span><br></pre></td></tr></table></figure>
<h2 id="compile函数">compile函数</h2>
<p>compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">re.<span class="built_in">compile</span>(pattern[, flags])</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>pattern : 一个字符串形式的正则表达式</p>
</li>
<li class="lvl-2">
<p>flags 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为：</p>
</li>
<li class="lvl-2">
<p>re.I 忽略大小写</p>
</li>
<li class="lvl-2">
<p>re.L 表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境</p>
</li>
<li class="lvl-2">
<p>re.M 多行模式</p>
</li>
<li class="lvl-2">
<p>re.S 即为’ . ‘并且包括换行符在内的任意字符（’ . '不包括换行符）</p>
</li>
<li class="lvl-2">
<p>re.U 表示特殊字符集 \w, \W, \b, \B, \d, \D, \s, \S 依赖于 Unicode 字符属性数据库</p>
</li>
<li class="lvl-2">
<p>re.X 为了增加可读性，忽略空格和’ # '后面的注释</p>
</li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d+&#x27;</span>)                    <span class="comment"># 用于匹配至少一个数字</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = pattern.match(<span class="string">&#x27;one12twothree34four&#x27;</span>)        <span class="comment"># 查找头部，没有匹配</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>( m )</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = pattern.match(<span class="string">&#x27;one12twothree34four&#x27;</span>, <span class="number">2</span>, <span class="number">10</span>) <span class="comment"># 从&#x27;e&#x27;的位置开始匹配，没有匹配</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>( m )</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = pattern.match(<span class="string">&#x27;one12twothree34four&#x27;</span>, <span class="number">3</span>, <span class="number">10</span>) <span class="comment"># 从&#x27;1&#x27;的位置开始匹配，正好匹配</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>( m )                                        <span class="comment"># 返回一个 Match 对象</span></span><br><span class="line">&lt;_sre.SRE_Match <span class="built_in">object</span> at <span class="number">0x10a42aac0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">0</span>)   <span class="comment"># 可省略 0</span></span><br><span class="line"><span class="string">&#x27;12&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.start(<span class="number">0</span>)   <span class="comment"># 可省略 0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.end(<span class="number">0</span>)     <span class="comment"># 可省略 0</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.span(<span class="number">0</span>)    <span class="comment"># 可省略 0</span></span><br><span class="line">(<span class="number">3</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>在上面，当匹配成功时返回一个 Match 对象，其中：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>group([group1, …]) 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 group() 或 group(0)；</p>
</li>
<li class="lvl-2">
<p>start([group]) 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0；</p>
</li>
<li class="lvl-2">
<p>end([group]) 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0；</p>
</li>
<li class="lvl-2">
<p>span([group]) 方法返回 (start(group), end(group))。</p>
</li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;([a-z]+) ([a-z]+)&#x27;</span>, re.I)   <span class="comment"># re.I 表示忽略大小写</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = pattern.match(<span class="string">&#x27;Hello World Wide Web&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>( m )                            <span class="comment"># 匹配成功，返回一个 Match 对象</span></span><br><span class="line">&lt;_sre.SRE_Match <span class="built_in">object</span> at <span class="number">0x10bea83e8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">0</span>)                            <span class="comment"># 返回匹配成功的整个子串</span></span><br><span class="line"><span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.span(<span class="number">0</span>)                             <span class="comment"># 返回匹配成功的整个子串的索引</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">11</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>)                            <span class="comment"># 返回第一个分组匹配成功的子串</span></span><br><span class="line"><span class="string">&#x27;Hello&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.span(<span class="number">1</span>)                             <span class="comment"># 返回第一个分组匹配成功的子串的索引</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">2</span>)                            <span class="comment"># 返回第二个分组匹配成功的子串</span></span><br><span class="line"><span class="string">&#x27;World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.span(<span class="number">2</span>)                             <span class="comment"># 返回第二个分组匹配成功的子串索引</span></span><br><span class="line">(<span class="number">6</span>, <span class="number">11</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.groups()                            <span class="comment"># 等价于 (m.group(1), m.group(2), ...)</span></span><br><span class="line">(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;World&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">3</span>)                            <span class="comment"># 不存在第三个分组</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">IndexError: no such group</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="findall">findall</h2>
<p>在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果有多个匹配模式，则返回元组列表，如果没有找到匹配的，则返回空列表。注意： match 和 search 是匹配一次 findall 匹配所有。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">re.findall(pattern, string, flags=<span class="number">0</span>)</span><br><span class="line">或</span><br><span class="line">pattern.findall(string[, pos[, endpos]])</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>pattern 匹配模式。</p>
</li>
<li class="lvl-2">
<p>string 待匹配的字符串。</p>
</li>
<li class="lvl-2">
<p>pos 可选参数，指定字符串的起始位置，默认为 0。</p>
</li>
<li class="lvl-2">
<p>endpos 可选参数，指定字符串的结束位置，默认为字符串的长度。</p>
</li>
</ul>
<p><strong>实例</strong> 查找字符串中的所有数字：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">result1 = re.findall(<span class="string">r&#x27;\d+&#x27;</span>,<span class="string">&#x27;runoob 123 google 456&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d+&#x27;</span>)   <span class="comment"># 查找数字</span></span><br><span class="line">result2 = pattern.findall(<span class="string">&#x27;runoob 123 google 456&#x27;</span>)</span><br><span class="line">result3 = pattern.findall(<span class="string">&#x27;run88oob123google456&#x27;</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result1)</span><br><span class="line"><span class="built_in">print</span>(result2)</span><br><span class="line"><span class="built_in">print</span>(result3)</span><br><span class="line">输出结果：</span><br><span class="line">[<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;456&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;456&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;88&#x27;</span>, <span class="string">&#x27;12&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>多个匹配模式，返回元组列表：<br>
<strong>实例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">result = re.findall(<span class="string">r&#x27;(\w+)=(\d+)&#x27;</span>, <span class="string">&#x27;set width=20 and height=10&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line">[(<span class="string">&#x27;width&#x27;</span>, <span class="string">&#x27;20&#x27;</span>), (<span class="string">&#x27;height&#x27;</span>, <span class="string">&#x27;10&#x27;</span>)]</span><br></pre></td></tr></table></figure>
<p>##re.finditer</p>
<p>和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">re.finditer(pattern, string, flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>pattern	匹配的正则表达式</p>
</li>
<li class="lvl-2">
<p>string	要匹配的字符串。</p>
</li>
<li class="lvl-2">
<p>flags	标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。<br>
<strong>实例</strong></p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">it = re.finditer(<span class="string">r&quot;\d+&quot;</span>,<span class="string">&quot;12a32bc43jf3&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> match <span class="keyword">in</span> it:</span><br><span class="line"><span class="built_in">print</span> (match.group() )</span><br><span class="line">输出结果：</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">43</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="re-split">re.split</h2>
<p>split 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">re.split(pattern, string[, maxsplit=<span class="number">0</span>, flags=<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>pattern	匹配的正则表达式</p>
</li>
<li class="lvl-2">
<p>string	要匹配的字符串。<br>
= maxsplit	分割次数，maxsplit=1 分割一次，默认为 0，不限制次数。<br>
= flags	标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：正则表达式修饰符 - 可选标志<br>
<strong>实例</strong></p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">&#x27;\W+&#x27;</span>, <span class="string">&#x27;runoob, runoob, runoob.&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">&#x27;(\W+)&#x27;</span>, <span class="string">&#x27; runoob, runoob, runoob.&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;, &#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;, &#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">&#x27;\W+&#x27;</span>, <span class="string">&#x27; runoob, runoob, runoob.&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">[<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;runoob, runoob, runoob.&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">&#x27;a*&#x27;</span>, <span class="string">&#x27;hello world&#x27;</span>)   <span class="comment"># 对于一个找不到匹配的字符串而言，split 不会对其作出分割</span></span><br><span class="line">[<span class="string">&#x27;hello world&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h2 id="正则表达式对象">正则表达式对象</h2>
<p><strong>re.RegexObject</strong></p>
<p>re.compile() 返回 RegexObject 对象。</p>
<p><strong>re.MatchObject</strong><br>
group() 返回被 RE 匹配的字符串。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>start() 返回匹配开始的位置</p>
</li>
<li class="lvl-2">
<p>end() 返回匹配结束的位置</p>
</li>
<li class="lvl-2">
<p>span() 返回一个元组包含匹配 (开始,结束) 的位置</p>
</li>
</ul>
<h2 id="正则表达式修饰符-可选标志">正则表达式修饰符 - 可选标志</h2>
<p>正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>re.I	使匹配对大小写不敏感</p>
</li>
<li class="lvl-2">
<p>re.L	做本地化识别（locale-aware）匹配</p>
</li>
<li class="lvl-2">
<p>re.M	多行匹配，影响 ^ 和 $</p>
</li>
<li class="lvl-2">
<p>re.S	使 . 匹配包括换行在内的所有字符</p>
</li>
<li class="lvl-2">
<p>re.U	根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.</p>
</li>
<li class="lvl-2">
<p>re.X	该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。</p>
</li>
</ul>
<h2 id="正则表达式模式">正则表达式模式</h2>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>匹配字符串的开头</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串的末尾。</td>
</tr>
<tr>
<td>.</td>
<td>匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。</td>
</tr>
<tr>
<td>[…]</td>
<td>用来表示一组字符,单独列出：[amk] 匹配 ‘a’，‘m’或’k’</td>
</tr>
<tr>
<td>[^…]</td>
<td>不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。</td>
</tr>
<tr>
<td>re*</td>
<td>匹配0个或多个的表达式。</td>
</tr>
<tr>
<td>re+</td>
<td>匹配1个或多个的表达式。</td>
</tr>
<tr>
<td>re?</td>
<td>匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式</td>
</tr>
<tr>
<td>re{ n}</td>
<td>匹配n个前面表达式。例如，&quot;o{2}“不能匹配&quot;Bob&quot;中的&quot;o”，但是能匹配&quot;food&quot;中的两个o。</td>
</tr>
<tr>
<td>re{ n,}</td>
<td>精确匹配n个前面表达式。例如，&quot;o{2,}“不能匹配&quot;Bob&quot;中的&quot;o”，但能匹配&quot;foooood&quot;中的所有o。&quot;o{1,}“等价于&quot;o+”。&quot;o{0,}“则等价于&quot;o*”。</td>
</tr>
<tr>
<td>re{ n, m}</td>
<td>匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式</td>
</tr>
<tr>
<td>a| b</td>
<td>匹配a或b</td>
</tr>
<tr>
<td>(re)</td>
<td>匹配括号内的表达式，也表示一个组</td>
</tr>
<tr>
<td>(?imx)</td>
<td>正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。</td>
</tr>
<tr>
<td>(?-imx)</td>
<td>正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。</td>
</tr>
<tr>
<td>(?: re)</td>
<td>类似 (…), 但是不表示一个组</td>
</tr>
<tr>
<td>(?imx: re)</td>
<td>在括号中使用i, m, 或 x 可选标志</td>
</tr>
<tr>
<td>(?-imx: re)</td>
<td>在括号中不使用i, m, 或 x 可选标志</td>
</tr>
<tr>
<td>(?#…)</td>
<td>注释.</td>
</tr>
<tr>
<td>(?= re)</td>
<td>前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。</td>
</tr>
<tr>
<td>(?! re)</td>
<td>前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功。</td>
</tr>
<tr>
<td>(?&gt; re)</td>
<td>匹配的独立模式，省去回溯。</td>
</tr>
<tr>
<td>\w</td>
<td>匹配数字字母下划线</td>
</tr>
<tr>
<td>\W</td>
<td>匹配非数字字母下划线</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任意空白字符，等价于 [\t\n\r\f]。</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任意非空字符</td>
</tr>
<tr>
<td>\d</td>
<td>匹配任意数字，等价于 [0-9]。</td>
</tr>
<tr>
<td>\D</td>
<td>匹配任意非数字</td>
</tr>
<tr>
<td>\A</td>
<td>匹配字符串开始</td>
</tr>
<tr>
<td>\Z</td>
<td>匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。</td>
</tr>
<tr>
<td>\z</td>
<td>匹配字符串结束</td>
</tr>
<tr>
<td>\G</td>
<td>匹配最后匹配完成的位置。</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配&quot;never&quot; 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词边界。‘er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td>
</tr>
<tr>
<td>\n, \t, 等。</td>
<td>匹配一个换行符。匹配一个制表符, 等</td>
</tr>
<tr>
<td>\1…\9</td>
<td>匹配第n个分组的内容。</td>
</tr>
<tr>
<td>\10</td>
<td>匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。</td>
</tr>
</tbody>
</table>
<p>** 实例 **</p>
<table>
<thead>
<tr>
<th>实例</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>[Pp]ython</td>
<td>匹配 “Python” 或 “python”</td>
</tr>
<tr>
<td>rub[ye]</td>
<td>匹配 “ruby” 或 “rube”</td>
</tr>
<tr>
<td>[aeiou]</td>
<td>匹配中括号内的任意一个字母</td>
</tr>
<tr>
<td>[0-9]</td>
<td>匹配任何数字。类似于 [0123456789]</td>
</tr>
<tr>
<td>[a-z]</td>
<td>匹配任何小写字母</td>
</tr>
<tr>
<td>[A-Z]</td>
<td>匹配任何大写字母</td>
</tr>
<tr>
<td>[a-zA-Z0-9]</td>
<td>匹配任何字母及数字</td>
</tr>
<tr>
<td>[^aeiou]</td>
<td>除了aeiou字母以外的所有字符</td>
</tr>
<tr>
<td>[^0-9]</td>
<td>匹配除了数字外的字符</td>
</tr>
</tbody>
</table>
<blockquote>
<p>原文：<a href="https://www.runoob.com/python3/python3-reg-expressions.html">https://www.runoob.com/python3/python3-reg-expressions.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 特性</title>
    <url>/posts/b34390d8.html</url>
    <content><![CDATA[<h1>Python 特性</h1>
<p>Python 提供了许多有用的特性，这些特性使它从其他编程语言中变得流行和有价值。它支持面向对象编程、过程编程方法，并提供动态内存分配。我们在下面列出了一些基本特性。</p>
<h3 id="1-易于学习和使用">1)易于学习和使用</h3>
<p>与其他编程语言相比，Python 很容易学习。它的语法简单明了，与英语非常相似。没有使用分号或大括号，缩进定义了代码块。是初学者推荐的编程语言。</p>
<h3 id="2-表达性语言">2)表达性语言</h3>
<p>Python 可以使用几行代码执行复杂的任务。一个简单的例子，你简单输入<strong>打印的 hello world 程序(“Hello World”)</strong>。它只需要一行代码就可以执行，而 Java 或 C 需要多行代码。</p>
<h3 id="3-解释语言">3)解释语言</h3>
<p>Python 是一种解释语言；它意味着 Python 程序一次执行一行。作为解释语言的优势，它使调试变得容易和可移植。</p>
<h3 id="4-跨平台语言">4)跨平台语言</h3>
<p>Python 可以在 Windows、Linux、UNIX、Macintosh 等不同平台上平等运行。所以，我们可以说 Python 是一种可移植的语言。它使程序员只需编写一次程序，就可以为几个竞争平台开发软件。</p>
<h3 id="5-自由和开源">5)自由和开源</h3>
<p>Python 对每个人都是免费的。在其官方网站<a href="https://www.python.org/">www.python.org</a>上可以免费获得。它在世界各地拥有一个庞大的社区，致力于开发新的 python 模块和函数。任何人都可以为 Python 社区做出贡献。开源的意思是，“任何人都可以下载它的源代码，而不用花一分钱。”</p>
<h3 id="6-面向对象语言">6)面向对象语言</h3>
<p>Python 支持面向对象语言，类和对象的概念应运而生。它支持继承、多态和封装等。面向对象的过程有助于程序员编写可重用的代码，并以更少的代码开发应用。</p>
<h3 id="7-可扩展">7)可扩展</h3>
<p>这意味着其他语言，如 C/C++可以用来编译代码，因此它可以在我们的 Python 代码中进一步使用。它将程序转换成字节码，任何平台都可以使用该字节码。</p>
<h3 id="8-大型标准图书馆">8)大型标准图书馆</h3>
<p>它为各种领域提供了大量的库，如机器学习、web 开发人员以及脚本。有各种机器学习库，如 Tensor flow、Pandas、Numpy、Keras、Pytorch 等。Django、flask是 Python web 开发的流行框架。</p>
<h3 id="9-图形用户界面编程支持">9)图形用户界面编程支持</h3>
<p>图形用户界面用于开发桌面应用。PyQT5、Tkinter、Kivy 是用于开发 web 应用的库。</p>
<h3 id="10-集成">10)集成</h3>
<p>它可以很容易地与 C、C++、JAVA 等语言集成。Python 像 C、C++和 Java 一样逐行运行代码。这使得调试代码变得容易。</p>
<h3 id="11-可嵌入">11.可嵌入</h3>
<p>其他编程语言的代码可以在 Python 源代码中使用。我们也可以使用另一种编程语言的 Python 源代码。它可以将其他语言嵌入到我们的代码中。</p>
<h3 id="12-动态存储分配">12.动态存储分配</h3>
<p>在 Python 中，我们不需要指定变量的数据类型。当我们给变量赋值时，它会在运行时自动给变量分配内存。假设我们被赋予整数值 15 到 <strong>x，</strong>，那么我们不需要写 **int x = 15。**只写 x = 15。</p>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-features">https://www.javatpoint.com/python-features</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 注释</title>
    <url>/posts/7ae95e2f.html</url>
    <content><![CDATA[<h1>Python 注释</h1>
<p>Python 注释对于程序员来说是一个必不可少的工具。注释通常用于解释代码。如果代码有适当的解释，我们很容易理解。一个好的程序员必须使用注释，因为将来任何人都想修改代码以及实现新的模块；然后，它可以很容易地完成。</p>
<p>在其他编程语言(如 C++)中，它为单行注释和/<em>提供了//选项…</em>/表示多行注释，但 Python 提供单行 Python 注释。为了在代码中应用注释，我们在语句或代码的开头使用哈希(#)。</p>
<p>让我们理解下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This is the print statement</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello Python&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，我们使用哈希(#)对 print 语句进行了注释。不会影响我们的打印声明。</p>
<h2 id="Python-多行-Comment">Python 多行 Comment</h2>
<p>我们必须在每一行代码的开头使用哈希(#)来应用多行 Python 注释。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># First line of the comment </span></span><br><span class="line"><span class="comment"># Second line of the comment</span></span><br><span class="line"><span class="comment"># Third line of the comment</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Variable a holds value 5</span></span><br><span class="line"><span class="comment"># Variable b holds value 10</span></span><br><span class="line"><span class="comment"># Variable c holds sum of a and b</span></span><br><span class="line"><span class="comment"># Print the result</span></span><br><span class="line">a = <span class="number">5</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">c = a+b</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The sum is:&quot;</span>, c)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The <span class="built_in">sum</span> <span class="keyword">is</span>: <span class="number">15</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的代码非常易读，即使是绝对的初学者也能理解每一行代码中发生的事情。这就是在代码中使用注释的好处。</p>
<p>对于多行注释，我们也可以使用三重引号(’ ’ ’ ')。三重引号也用于字符串格式。考虑下面的例子。</p>
<h2 id="文档字符串-Python-注释">文档字符串 Python 注释</h2>
<p>docstring 注释主要用于模块、函数、类或方法。它是一个 Python 文档字符串。我们将在后续教程中解释该类/方法。</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">intro</span>():</span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  This function prints Hello Joseph</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Hi Joseph&quot;</span>)            </span><br><span class="line">intro()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Hello Joseph</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以通过使用 <strong>doc</strong> 属性来检查函数的文档字符串。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">intro</span>():</span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  This function prints Hello Joseph</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Hello Joseph&quot;</span>)            </span><br><span class="line">intro.__doc__</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Output:</span><br><span class="line"><span class="string">&#x27;\n  This function prints Hello Joseph\n  &#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="注意-docstring-必须是函数中的第一件事；否则，Python-解释器无法获取-docstring。">注意:docstring 必须是函数中的第一件事；否则，Python 解释器无法获取 docstring。</h4>
<h2 id="Python-缩进">Python 缩进</h2>
<p>Python 使用缩进来定义代码块。其他编程语言如 C、C++和 Java 使用花括号{}，而 Python 使用缩进。空白在 Python 中用作缩进。</p>
<p>缩进在代码的开头使用，并以非预期的一行结束。同一行缩进定义了代码块(函数体、循环等)。)</p>
<p>通常，四个空格用作缩进。缩进量取决于用户，但必须在整个块中保持一致。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">3</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了表示一个代码块，我们用相同的空格缩进代码块的每一行。</p>
<p>考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">dn = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the number:&quot;</span>))</span><br><span class="line"><span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Even Number&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Odd Number&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Task Complete&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the number: <span class="number">10</span></span><br><span class="line">Even Number</span><br><span class="line">Task Complete</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的代码， <strong>if</strong> 和 <strong>else</strong> 是两个独立的代码块。两个代码块都缩进四个空格。print(“任务完成”)语句没有缩进四个空格，并且超出了 <strong>if-else</strong> 块。</p>
<p>如果缩进使用不当，将导致<strong>缩进错误</strong>。</p>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-comments">https://www.javatpoint.com/python-comments</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 生成器</title>
    <url>/posts/23b78c5e.html</url>
    <content><![CDATA[<h1>Python 生成器</h1>
<h2 id="什么是-Python-生成器？">什么是 Python 生成器？</h2>
<p>Python 生成器是返回遍历对象的函数，用于创建迭代器。它一次遍历整个项目。生成器也可以是语法类似于 Python 中列表推导的表达式。</p>
<p>在 Python 中创建迭代有很大的复杂性；我们需要实现 <strong>__iter__()</strong> 和 <strong>__next__()</strong> 方法来跟踪内部状态。</p>
<p>创建迭代器是一个漫长的过程。这就是为什么生成器在简化这一过程中起着至关重要的作用。如果迭代中没有发现值，则引发<strong>停止迭代</strong>异常。</p>
<h2 id="如何用-Python-创建生成器函数？">如何用 Python 创建生成器函数？</h2>
<p>用 Python 创建一个生成器非常简单。类似于 <strong>def</strong> 关键字定义的正常函数，使用 <strong>yield</strong> 关键字代替 return。或者我们可以说，如果任何函数的主体包含一个 <strong>yield</strong> 语句，那么它就会自动成为一个生成函数。考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">simple</span>():</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>):</span><br><span class="line">         <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"><span class="comment">#Successive Function call using for loop</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> simple():</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="yield-vs-return">yield vs return</h3>
<p><strong>yield</strong> 语句负责控制生成器功能的流程。它通过保存所有状态暂停函数执行，并向调用者让步。稍后，当调用一个连续的函数时，它将恢复执行。我们可以在生成器函数中使用多重 <code>yield</code>语句。</p>
<p>return 语句<strong>返回</strong>一个值，终止整个函数，函数中只能使用一个 return 语句。</p>
<p><strong>多重 yield</strong></p>
<p>我们可以在生成器函数中使用多重 <code>yield</code>语句。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multiple_yield</span>():</span><br><span class="line">    str1 = <span class="string">&quot;First String&quot;</span></span><br><span class="line">    <span class="keyword">yield</span> str1</span><br><span class="line"></span><br><span class="line">    str2 = <span class="string">&quot;Second string&quot;</span></span><br><span class="line">    <span class="keyword">yield</span> str2</span><br><span class="line"></span><br><span class="line">    str3 = <span class="string">&quot;Third String&quot;</span></span><br><span class="line">    <span class="keyword">yield</span> str3</span><br><span class="line">obj = multiple_yield()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(obj))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(obj))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(obj))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">First String</span><br><span class="line">Second string</span><br><span class="line">Third String</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="生成器函数和普通函数的区别">生成器函数和普通函数的区别</h3>
<ul class="lvl-0">
<li class="lvl-4">
<p>普通函数只包含一个 L <strong>返回</strong>语句，而生成器函数可以包含一个或多个<strong>返回</strong>语句。</p>
</li>
<li class="lvl-4">
<p>当调用生成器函数时，正常函数会立即暂停，并将控制权转移给调用方。</p>
</li>
<li class="lvl-4">
<p>局部变量及其状态在连续调用之间被记住。</p>
</li>
<li class="lvl-4">
<p>当函数终止时，会自动引发 StopIteration 异常。</p>
</li>
</ul>
<h3 id="生成器表达式">生成器表达式</h3>
<p>我们可以轻松创建生成器表达式，而无需使用用户定义的函数。它与创建匿名函数的 lambda 函数相同；生成器的表达式创建匿名生成器函数。</p>
<p>生成器表达式的表示类似于 Python 列表推导。唯一不同的是<strong>方括号被圆括号</strong>代替。列表推导计算整个列表，而生成器表达式一次计算一个项目。</p>
<p>考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># List Comprehension</span></span><br><span class="line">z = [x**<span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generator expression</span></span><br><span class="line">a = (x**<span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x01BA3CD8</span>&gt;</span><br><span class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">27</span>, <span class="number">64</span>, <span class="number">125</span>, <span class="number">216</span>, <span class="number">343</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的程序中，列表推导返回了元素立方体的列表，而生成器表达式返回了计算值的引用。我们也可以在生成器对象上调用 <strong>next()</strong> ，而不是对循环应用**。让我们考虑另一个例子:**</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">z = (x**<span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(z))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(z))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(z))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(z))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">64</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="注意-当我们调用-next-时，Python-会对我们作为参数传递的函数调用-next-函数。">注意:-当我们调用 next()时，Python 会对我们作为参数传递的函数调用 <strong>next</strong>()函数。</h4>
<p>在上面的程序中，我们使用了 <strong>next()</strong> 函数，该函数返回列表的下一项。</p>
<p>**示例:**编写一个程序，使用生成器打印给定数字的表格。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">table</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">        <span class="keyword">yield</span> n*i</span><br><span class="line">           i = i+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> table(<span class="number">15</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">45</span></span><br><span class="line"><span class="number">60</span></span><br><span class="line"><span class="number">75</span></span><br><span class="line"><span class="number">90</span></span><br><span class="line"><span class="number">105</span></span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="number">135</span></span><br><span class="line"><span class="number">150</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，生成器函数使用 <code>for</code>循环进行迭代。</p>
<h2 id="生成器的优点">生成器的优点</h2>
<p>生成器有各种各样的优点。下面给出了几个例子:</p>
<h3 id="1-易于实现">1.易于实现</h3>
<p>与迭代器相比，生成器很容易实现。在迭代器中，我们必须实现**__ITER __()<strong>和</strong>__next__()**函数。</p>
<h3 id="2-内存高效">2.内存高效</h3>
<p>对于大量序列，生成器具有内存效率。normal 函数返回一个列表序列，在返回结果之前在内存中创建一个完整的序列，但是 generator 函数计算值并暂停它们的执行。它继续连续呼叫。无限序列生成器是内存优化的一个很好的例子。下面我们用 <strong>sys.getsizeof()</strong> 函数来讨论一下。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># List comprehension</span></span><br><span class="line">nums_squared_list = [i * <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>)]</span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;Memory in Bytes:&quot;</span>nums_squared_list))</span><br><span class="line"><span class="comment"># Generator Expression</span></span><br><span class="line">nums_squared_gc = (i ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>))</span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(<span class="string">&quot;Memory in Bytes:&quot;</span>, nums_squared_gc))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Memory <span class="keyword">in</span> Bytes: <span class="number">4508</span></span><br><span class="line">Memory <span class="keyword">in</span> Bytes: <span class="number">56</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以从上面的输出中观察到，列表推导使用了 4508 字节的内存，而生成器表达式使用了 56 字节的内存。这意味着生成器对象比列表压缩效率高得多。</p>
<h3 id="3-Pipelining-with-Generators">3.Pipelining with Generators</h3>
<p>数据管道提供了在不使用额外计算机内存的情况下处理大型数据集或数据流的工具。</p>
<p>假设我们有一个著名餐厅的日志文件。日志文件中有一列(4 <sup>第</sup>列)记录了每小时售出的汉堡数量，我们想对其求和，找出 4 年内售出的汉堡总数。在这种情况下，生成器可以生成包含一系列操作的管道。下面是它的代码:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;sells.log&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">burger_col = (line[<span class="number">3</span>] <span class="keyword">for</span> line <span class="keyword">in</span> file)  per_hour = (<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> burger_col <span class="keyword">if</span> x != <span class="string">&#x27;N/A&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Total burgers sold = &quot;</span>,<span class="built_in">sum</span>(per_hour))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>4.Generate Infinite Sequence</strong></p>
<p>生成器可以生产无限多的物品。内存中不能包含无限序列，由于生成器一次只能生成一个项目，请考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">infinite_sequence</span>():</span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> num</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> infinite_sequence():</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line">.........</span><br><span class="line">..........</span><br><span class="line"><span class="number">315</span></span><br><span class="line"><span class="number">316</span></span><br><span class="line"><span class="number">317</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;C:\Users\DEVANSH SHARMA\Desktop\generator.py&quot;</span>, line <span class="number">33</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">KeyboardInterrupt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在本教程中，我们已经了解了 Python 生成器。</p>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-generators">https://www.javatpoint.com/python-generators</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 简介</title>
    <url>/posts/406f8352.html</url>
    <content><![CDATA[<h1>Python 简介</h1>
<p>Python 教程提供了 Python 的基本和高级概念。 Python 教程是为初学者和专业人士设计的。</p>
<p>Python 是一种简单、通用、高级和面向对象的编程语言。</p>
<p>Python 也是一种解释脚本语言。 <em>Guido Van Rossum</em> 被称为 Python 编程的创始人。</p>
<p>教程包括 Python 编程的所有主题，如安装、控制语句、<a href="/posts/fe4ed95b.html">字符串</a>、<a href="/posts/95b8e516.html">列表</a>、<a href="/posts/3bfa306a.html">元组</a>、<a href="/posts/781e27f3.html">字典</a>、<a href="/posts/cae0d850.html">模块</a>、<a href="/posts/28b176d2.html">异常</a>、<a href="/posts/f7e311b4.html">日期和时间</a>、<a href="/posts/4f5b6974.html">文件I/O</a>、<a href="/posts/4300f84b.html">多进程</a>等。还提供了 Python 面试问题，帮助您更好地理解 Python 编程。</p>
<h2 id="什么是-Python">什么是 Python</h2>
<p><strong>Python</strong> 是一种通用的、动态的、高级的，并且经过解释的编程语言。它支持面向对象编程方法来开发应用。它简单易学，提供了大量的高级数据结构。</p>
<p>Python 是<em>易于学习</em>但功能强大且用途广泛的脚本语言，这使得它对应用开发很有吸引力。</p>
<p>Python 的语法和带有解释性质的<em>动态类型</em>使其成为脚本和快速应用开发的理想语言。</p>
<p>Python 支持<em>多种编程模式</em>，包括面向对象、命令式和函数式或过程式编程风格。</p>
<p>Python 不打算在特定的领域工作，比如 web 编程。这就是为什么它被称为<em>多用途</em>编程语言的原因，因为它可以与 web、企业、3D CAD 等一起使用。</p>
<p>我们不需要用数据类型来声明变量，因为它是<em>动态类型的</em>，所以我们可以写一个=10 来赋一个整型变量中的整数值。</p>
<p>Python 让开发调试<em>变快</em>是因为 Python 开发中没有包含编译步骤，编辑-测试-调试周期非常快。</p>
<h2 id="Python-2-对-Python-3">Python 2 对 Python 3</h2>
<p>在大多数编程语言中，每当新版本发布时，它都支持该语言现有版本的功能和语法，因此，项目更容易在新版本中切换。但是，就 Python 而言，Python 2 和 Python 3 这两个版本彼此有很大的不同。</p>
<p>下面列出了 Python 2 和 Python 3 之间的差异:</p>
<ol>
<li class="lvl-4">
<p>Python 2 使用<strong>打印</strong>作为语句，并用作打印“某物”在控制台上打印一些字符串。另一方面，Python 3 使用<strong>打印</strong>作为功能，并用作打印(“某物”)在控制台上打印某物。</p>
</li>
<li class="lvl-4">
<p>Python 2 使用函数 raw_input()接受用户的输入。它返回表示用户键入的值的字符串。要将其转换为整数，我们需要使用 Python 中的 int()函数。另一方面，Python 3 使用 input()函数，该函数自动解释用户输入的输入类型。但是，我们可以通过使用基元函数(int()，str()，等)将该值转换为任何类型。).</p>
</li>
<li class="lvl-4">
<p>在 Python 2 中，隐式字符串类型是 ASCII，而在 Python 3 中，隐式字符串类型是 Unicode。</p>
</li>
<li class="lvl-4">
<p>Python 3 不包含 Python 2 的 xrange()函数。xrange()是 range()函数的变体，它返回一个 xrange 对象，其工作方式类似于 Java 迭代器。range()返回一个列表，例如函数 range(0，3)包含 0，1，2。</p>
</li>
<li class="lvl-4">
<p>Python 3 中的异常处理也有一个小变化。它将一个关键字<strong>定义为</strong>，这是必须使用的。我们将在 Python 编程教程的异常处理部分讨论它。</p>
</li>
</ol>
<h2 id="Python-历史">Python 历史</h2>
<p>Python 是由吉多·范·罗苏姆于 1991 年在荷兰 CWI 发明的。Python 编程语言的思想取自于 ABC 编程语言或者我们可以说 ABC 是 Python 语言的前身。</p>
<p>选择 Python 这个名字背后也有一个事实。吉多·范·罗苏姆是当时英国广播公司热门喜剧节目《巨蟒飞行马戏团》的粉丝。所以他决定为他新创建的编程语言选择名称 <strong>Python</strong> 。</p>
<p>Python 在世界各地拥有广泛的社区，并在短时间内发布其版本。</p>
<h2 id="为什么要学-Python？">为什么要学 Python？</h2>
<p>Python 为程序员提供了许多有用的特性。这些特点使它成为最受欢迎和广泛使用的语言。我们在下面列出了 Python 的几个基本特性。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>易于使用和学习</p>
</li>
<li class="lvl-2">
<p>表达性语言</p>
</li>
<li class="lvl-2">
<p>解释语言</p>
</li>
<li class="lvl-2">
<p>面向对象语言</p>
</li>
<li class="lvl-2">
<p>开源语言</p>
</li>
<li class="lvl-2">
<p>可扩展</p>
</li>
<li class="lvl-2">
<p>学习标准库</p>
</li>
<li class="lvl-2">
<p>GUI编程支持</p>
</li>
<li class="lvl-2">
<p>可集成</p>
</li>
<li class="lvl-2">
<p>可嵌入</p>
</li>
<li class="lvl-2">
<p>动态存储分配</p>
</li>
<li class="lvl-2">
<p>广泛的库和框架</p>
</li>
<li class="lvl-2">
<p>通用性</p>
</li>
<li class="lvl-2">
<p>大型社区</p>
</li>
<li class="lvl-2">
<p>职业机会</p>
</li>
<li class="lvl-2">
<p>大数据与机器学习</p>
</li>
</ul>
<h2 id="Python-在哪里使用？">Python 在哪里使用？</h2>
<p>Python 是一种通用的、流行的编程语言，它被用于几乎每个技术领域。下面给出了 Python 使用的各个领域。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>数据科学</p>
</li>
<li class="lvl-2">
<p>数据挖掘技术</p>
</li>
<li class="lvl-2">
<p>桌面应用</p>
</li>
<li class="lvl-2">
<p>基于控制台的应用</p>
</li>
<li class="lvl-2">
<p>移动应用</p>
</li>
<li class="lvl-2">
<p>软件开发</p>
</li>
<li class="lvl-2">
<p>人工智能</p>
</li>
<li class="lvl-2">
<p>网络应用</p>
</li>
<li class="lvl-2">
<p>企业应用</p>
</li>
<li class="lvl-2">
<p>三维计算机辅助设计应用</p>
</li>
<li class="lvl-2">
<p>机器学习</p>
</li>
<li class="lvl-2">
<p>计算机视觉或图像处理应用。</p>
</li>
<li class="lvl-2">
<p>语音识别</p>
</li>
<li class="lvl-2">
<p>物联网</p>
</li>
<li class="lvl-2">
<p>自动化测试</p>
</li>
</ul>
<h2 id="Python-基本语法">Python 基本语法</h2>
<p>Python 编程语言中没有使用花括号或分号。这是一种类似英语的语言。但是 Python 使用缩进来定义一个代码块。缩进只不过是在需要时在语句前添加空白。<strong>例如-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">       statement <span class="number">1</span></span><br><span class="line">       statement <span class="number">2</span></span><br><span class="line">       …………………</span><br><span class="line">       …………………</span><br><span class="line">         statement N</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，从右到左的语句属于函数。通常，我们可以用四个空格来定义缩进。</p>
<h2 id="Python-第一程序">Python 第一程序</h2>
<p>与其他编程语言不同，Python 提供了使用几行代码来执行代码的工具。<strong>例如</strong> -假设我们要用 Java 打印<strong>Hello World</strong>程序；打印它需要三行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="comment">// Prints &quot;Hello, World&quot; to the terminal window.</span></span><br><span class="line">      System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另一方面，我们可以使用 Python 中的一条语句来实现这一点。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这两个程序将打印相同的结果，但它只需要一条语句，而不使用 Python 中的分号或大括号。</p>
<h2 id="Python-流行框架和库">Python 流行框架和库</h2>
<p>Python 拥有广泛的库和框架，广泛应用于机器学习、人工智能、web 应用等各个领域。我们定义一些流行的 Python 框架和库如下。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Web 开发(服务器端)-</strong> Django Flask，Pyramid，CherryPy</p>
</li>
<li class="lvl-2">
<p><strong>基于 GUI 的应用-</strong> Tk、PyGTK、PyQt、PyJs 等。</p>
</li>
<li class="lvl-2">
<p><strong>机器学习-</strong> TensorFlow、PyTorch、 <strong>Scikit-learn</strong> 、Matplotlib、Scipy 等。</p>
</li>
<li class="lvl-2">
<p><strong>数学-</strong> Numpy，Pandas 等。</p>
</li>
</ul>
<h2 id="Python-print-函数">Python print()函数</h2>
<p><strong>print()</strong> 功能向标准输出设备(屏幕)或文本流文件显示给定对象。</p>
<p>与其他编程语言不同，Python <strong>print()</strong> 函数是最独特、最通用的函数。</p>
<p><strong>print()</strong> 函数的语法如下。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(*objects, sep=<span class="string">&#x27; &#x27;</span>, end=<span class="string">&#x27;\n&#x27;</span>, file=sys.stdout, flush=<span class="literal">False</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>让我们一个一个解释它的参数。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>object</strong> 对象只不过是需要打印的语句。*符号表示可以有多个语句。</p>
</li>
<li class="lvl-4">
<p><strong>sep</strong>参数分隔打印值。默认值为&quot;&quot;。</p>
</li>
<li class="lvl-4">
<p><strong>end</strong> 语句以某某结尾。</p>
</li>
<li class="lvl-4">
<p><strong>file</strong> 必须是写(字符串)方法的对象。</p>
</li>
<li class="lvl-4">
<p><strong>flush</strong> 如果为真，则强制刷新流或文件。默认情况下，它的值为 false。</p>
</li>
</ul>
<p>让我们理解下面的例子。</p>
<h3 id="示例-1-返回值">示例- 1:返回值</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Welcome to javaTpoint.&quot;</span>)</span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="comment"># Two objects are passed in print() function</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a =&quot;</span>, a)</span><br><span class="line"></span><br><span class="line">b = a</span><br><span class="line"><span class="comment"># Three objects are passed in print function</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a =&#x27;</span>, a, <span class="string">&#x27;= b&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Welcome to javaTpoint.</span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">a = <span class="number">10</span> = b</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从上面的输出中我们可以看到，可以在单个 <strong>print()</strong> 语句中打印多个对象。我们只需要用逗号(,)来分隔彼此。</p>
<h3 id="示例-2-使用-sep-和-end-参数">示例- 2:使用 sep 和 end 参数</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a =&quot;</span>, a, sep=<span class="string">&#x27;dddd&#x27;</span>, end=<span class="string">&#x27;\n\n\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a =&quot;</span>, a, sep=<span class="string">&#x27;0&#x27;</span>, end=<span class="string">&#x27;$$$$$&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a =dddd10</span><br><span class="line"></span><br><span class="line">a =<span class="number">0</span>10$$$$$</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在第一个 <strong>print()</strong> 语句中，我们使用了 <strong>sep</strong> 和 <strong>end</strong> 参数。给定对象刚好在<strong>9</strong>值之后打印。打印在给定对象最后的结束参数值。我们可以看到，第二个 <strong>print()</strong> 函数打印了三条黑线后的结果。</p>
<h2 id="向用户输入">向用户输入</h2>
<p>Python 提供了**input()**功能，用于接受用户的输入。让我们理解下面的例子。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;Enter a name of student:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The student name is: &quot;</span>, name)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter a name of student: Devansh</span><br><span class="line">The student name <span class="keyword">is</span>:   Devansh</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>默认情况下， <strong>input()</strong> 函数接受字符串输入，但是如果我们想接受其他数据类型作为输入呢？</p>
<p>如果我们想把输入当成一个整数，我们需要把 <strong>input()</strong> 函数打造成一个整数。</p>
<p><strong>例如-</strong></p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a  = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter first number: &quot;</span>))</span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter second number: &quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a+b)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter first number: <span class="number">50</span></span><br><span class="line">Enter second number: <span class="number">100</span></span><br><span class="line"><span class="number">150</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以使用**输入()**函数获取任何类型的值。</p>
<h2 id="Python-运算符">Python 运算符</h2>
<p>运算符是对 Python 对象执行各种操作的符号。Python 操作符是处理 Python 数据类型的最基本要素。此外，Python 还提供了标识成员和按位运算符。我们将在下面的教程中通过合适的例子学习所有这些操作符。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong><a href="posts/f05d4701.html">Python 运算符</a></strong></p>
</li>
</ul>
<h2 id="Python-条件语句">Python 条件语句</h2>
<p>条件语句帮助我们为特定的条件执行特定的块。在本教程中，我们将学习如何使用条件表达式来执行不同的语句块。Python 提供了 if 和 else 关键字来设置逻辑条件。elif 关键字也用作条件语句。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong><a href="/posts/394067ff.html">if…else 语句</a></strong></p>
</li>
</ul>
<h2 id="Python-循环">Python 循环</h2>
<p>有时我们可能需要改变程序的流程。特定代码的执行可能需要重复几次。为此，编程语言提供了各种类型的循环，能够多次重复某些特定的代码。考虑下面的教程来详细理解这些语句。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong><a href="/posts/3ebc62bf.html">Python 循环</a></strong></p>
</li>
<li class="lvl-4">
<p><strong><a href="/posts/a8e29766.html">Python For 循环</a></strong></p>
</li>
<li class="lvl-4">
<p><strong><a href="/posts/52a29154.html">Python While 循环</a></strong></p>
</li>
</ul>
<h2 id="Python-数据结构">Python 数据结构</h2>
<p>数据结构是指可以将一些数据保存在一起的结构，或者我们说它们是用来以有组织的方式存储数据的。Python 提供了内置的数据结构，如<strong>列表、元组、字典和集合</strong>。我们可以使用数据结构执行复杂的任务。</p>
<h3 id="Python-列表">Python 列表</h3>
<p>Python 列表保存有序的项目集合。我们可以在列表中存储一系列项目。Python 列表是可变的，这意味着它可以在创建后进行修改。列表项目包含在方括号[]内，用逗号分隔。让我们看看列表的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">L1 = [<span class="string">&quot;John&quot;</span>, <span class="number">102</span>, <span class="string">&quot;USA&quot;</span>]    </span><br><span class="line">L2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果我们尝试使用 <strong>type()</strong> 函数打印 L1、L2 和 L3 的类型，那么它将显示为一个列表。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(L1))  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(L2))  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要了解有关 list 的更多信息，请访问以下教程。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong><a href="/posts/95b8e516.html">Python 列表</a></strong></p>
</li>
<li class="lvl-4">
<p><strong>Python 列表函数</strong></p>
</li>
</ul>
<h3 id="Python-元组">Python 元组</h3>
<p>Python Tuple 用于存储不可变 Python 对象的序列。元组类似于列表，因为存储在列表中的项目的值可以改变，而元组是不可变的，并且存储在元组中的项目的值不能改变。</p>
<p>元组可以定义如下</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tup = (<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Mango&quot;</span> , <span class="string">&quot;Orange&quot;</span> , <span class="string">&quot;Banana&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(tup))</span><br><span class="line"><span class="built_in">print</span>(tup)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line">(<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Mango&#x27;</span>, <span class="string">&#x27;Orange&#x27;</span>, <span class="string">&#x27;Banana&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果我们试图向元组中添加新的，它将抛出一个错误。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tup = (<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Mango&quot;</span> , <span class="string">&quot;Orange&quot;</span> , <span class="string">&quot;Banana&quot;</span>)</span><br><span class="line"></span><br><span class="line">tup[<span class="number">2</span>] = <span class="string">&quot;Papaya&quot;</span></span><br><span class="line"><span class="built_in">print</span>(tup)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;C:/Users/DEVANSH SHARMA/PycharmProjects/Hello/gamewithturtle.py&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> tup[<span class="number">2</span>] = <span class="string">&quot;Papaya&quot;</span></span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment </span><br></pre></td></tr></table></figure>
<p>上面的程序抛出了一个错误，因为元组是不可变的类型。要了解更多关于元组的信息，请访问 Python 元组。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong><a href="/posts/3bfa306a.html">Python 元组</a></strong></p>
</li>
</ul>
<h3 id="Python-字符串">Python 字符串</h3>
<p>Python 字符串是一个字符序列。它是由单引号、双引号或三引号括起来的字符的集合。它也可以定义为 Unicode 字符的集合。我们可以如下创建一个字符串。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creating string using double quotes</span></span><br><span class="line">str1 = <span class="string">&quot;Hi Python&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str1)</span><br><span class="line"><span class="comment"># Creating string using single quotes</span></span><br><span class="line">str1 = <span class="string">&#x27;Hi Python&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(str1)</span><br><span class="line"><span class="comment"># Creating string using triple quotes</span></span><br><span class="line">str1 = <span class="string">&#x27;&#x27;&#x27;Hi Python&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(str1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Hi Python</span><br><span class="line">Hi Python</span><br><span class="line">Hi Python</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Python 不支持字符数据类型。写为“p”的单个字符被视为长度为 1 的字符串。</p>
<p>刺痛也是不可改变的。声明后我们不能改变。要了解有关字符串的更多信息，请访问以下教程。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong><a href="/posts/fe4ed95b.html">Python 字符串</a></strong></p>
</li>
</ul>
<h3 id="字典">字典</h3>
<p>Python 字典是一种最高效的数据结构，用于存储大量数据。它以键值对格式存储数据。每个值都与其键相对应地存储。</p>
<p>键必须是唯一的，值可以是任何类型，如整数、列表、元组等。</p>
<p>它是一个可变类型；我们可以在它创建后重新分配。下面是用 Python 创建字典的例子。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">employee = &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">29</span>, <span class="string">&quot;salary&quot;</span>:<span class="number">250000</span>,<span class="string">&quot;Company&quot;</span>:<span class="string">&quot;GOOGLE&quot;</span>&#125;    </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(employee))    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;printing Employee data .... &quot;</span>)    </span><br><span class="line"><span class="built_in">print</span>(employee)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line">Printing Employee data .... </span><br><span class="line">&#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">29</span>, <span class="string">&#x27;salary&#x27;</span>: <span class="number">250000</span>, <span class="string">&#x27;Company&#x27;</span>: <span class="string">&#x27;GOOGLE&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>空花括号{}用于创建空字典。要了解更多信息，请访问字典的完整教程。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong><a href="/posts/781e27f3.html">Python 字典</a></strong></p>
</li>
</ul>
<h3 id="Python-集合">Python 集合</h3>
<p>Python 集是无序元素的集合。集合中的每个元素必须是唯一且不可变的。集合是可变的，这意味着我们可以在整个程序中随时修改。让我们了解一下用 Python 创建集合的例子。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creating Set</span></span><br><span class="line">Month = &#123;<span class="string">&quot;January&quot;</span>, <span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>, <span class="string">&quot;July&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(Month)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Month))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;March&#x27;</span>, <span class="string">&#x27;July&#x27;</span>, <span class="string">&#x27;April&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;June&#x27;</span>, <span class="string">&#x27;February&#x27;</span>, <span class="string">&#x27;January&#x27;</span>&#125;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;set&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要获得关于集合的更多信息，请访问以下资源。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong><a href="/posts/d8744cec.html">Python 集合</a></strong></p>
</li>
</ul>
<h2 id="Python-函数式编程">Python 函数式编程</h2>
<p>Python 教程的这一部分定义了一些与函数式编程相关的重要工具，比如 <strong>lambda 和递归函数</strong>。这些功能在完成复杂任务时非常有效。我们定义了几个重要的功能，比如<strong>reduce、map、<strong>和</strong>filter。</strong> Python 提供了包含各种<strong>功能编程工具</strong>的<strong>功能工具</strong>模块。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>reduce()函数</p>
</li>
<li class="lvl-2">
<p>map()函数</p>
</li>
<li class="lvl-2">
<p>filter()函数</p>
</li>
<li class="lvl-2">
<p>reduce()函数</p>
</li>
<li class="lvl-2">
<p>functools 模块</p>
</li>
<li class="lvl-2">
<p>Currying()  函数</p>
</li>
<li class="lvl-2">
<p>Memoization() 函数</p>
</li>
<li class="lvl-2">
<p>Threading() 函数</p>
</li>
</ul>
<h2 id="Python-文件输入-输出">Python 文件输入/输出</h2>
<p>文件用于在计算机磁盘中存储数据。在本教程中，我们将解释 Python 的内置文件对象。我们可以使用 Python 脚本打开一个文件，并执行各种操作，如写入、读取和追加。打开文件有多种方法。我们用相关的例子来解释。我们还将学习对二进制文件执行读/写操作。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong><a href="/posts/4f5b6974.html">Python 文件IO</a></strong></p>
</li>
</ul>
<h2 id="Python-模块">Python 模块</h2>
<p>Python 模块是包含 Python 代码或函数的程序文件。Python 中有两种类型的模块——用户定义模块和内置模块。用户定义的模块，或者我们可以说 Python 代码是用**.py** 扩展，被视为用户自定义模块。</p>
<p>内置模块是 Python 的预定义模块。为了使用模块的功能，我们需要将它们导入到我们当前的工作程序中。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong><a href="/posts/cae0d850.html">Python 模块</a></strong></p>
</li>
</ul>
<h2 id="Python-异常">Python 异常</h2>
<p>异常可以定义为程序中导致程序流程中断的异常。</p>
<p>每当出现异常时，程序就会停止执行，因此不会执行下一个代码。因此，一个异常是无法处理 Python 脚本的运行时错误。异常是表示错误的 Python 对象。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong><a href="/posts/28b176d2.html">Python 异常</a></strong></p>
</li>
</ul>
<h2 id="Python-CSV-文件">Python CSV 文件</h2>
<p>A <strong>csv</strong> 代表“逗号分隔值”，它被定义为一种简单的文件格式，使用特定的结构来排列表格数据。它以纯文本形式存储表格数据，如电子表格或数据库，并具有通用的数据交换格式。一个 <strong>csv</strong> 文件打开到 excel 表中，行和列数据定义了标准格式。请访问以下教程，详细了解 CSV 模块。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong><a href="/posts/404ab4d1.html">Python 读取CSV文件</a></strong></p>
</li>
<li class="lvl-4">
<p><strong><a href="/posts/57719496.html">Python 编写CSV文件</a></strong></p>
</li>
</ul>
<h2 id="Python-发送邮件">Python 发送邮件</h2>
<p>我们可以使用 Python 脚本发送或阅读邮件。Python 的标准库模块对于处理各种协议很有用，比如 PoP3 和 IMAP。我们将从 Python 脚本中学习如何使用流行的电子邮件服务 SMTP 发送邮件。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong><a href="/posts/14808f99.html">Python 发送邮件</a></strong></p>
</li>
</ul>
<h2 id="Python-Magic-Methods">Python Magic Methods</h2>
<p>Python 魔法方法被定义为给类增加“魔法”的特殊方法。它以双下划线开始和结束，例如， <strong><em>init</em></strong> 或 <strong><em>str</em>。</strong></p>
<p>内置类定义了许多神奇的方法。 <strong>dir()</strong> 函数可以用来查看一个类继承的魔法方法的数量。它在方法名中有两个前缀和后缀下划线。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong><a href="/posts/b1ff7fde.html">Python Magic Methods</a></strong></p>
</li>
</ul>
<h2 id="Python-oop的概念">Python oop的概念</h2>
<p>Python 中的一切都被视为一个对象，包括整数值、浮点、函数、类和无。除此之外，Python 支持所有面向对象概念。下面是 Python 的 oops 概念的简要介绍。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>类和对象-</strong> Python 类是对象的蓝图。对象是数据和作用于数据的方法的集合。</p>
</li>
<li class="lvl-4">
<p><strong>继承-</strong> 继承是一种技术，其中一个类继承其他类的属性。</p>
</li>
<li class="lvl-4">
<p><strong>构造器-</strong> Python 提供了一种特殊的方法 <strong><strong>init</strong>()</strong> ，被称为构造器。当对象实例化时，会自动调用此方法。</p>
</li>
<li class="lvl-4">
<p><strong>数据成员-</strong> 保存与类及其对象相关联的数据的变量。</p>
</li>
</ul>
<p>要详细阅读 oop 概念，请访问以下资源。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong><a href="/posts/39d0c80e.html">Python OOP概念</a></strong></p>
</li>
<li class="lvl-4">
<p><strong><a href="/posts/a39fbc03.html">Python 对象和类</a></strong></p>
</li>
<li class="lvl-4">
<p><strong><a href="/posts/f1d84d54.html">Python 构造器</a></strong></p>
</li>
<li class="lvl-4">
<p><strong><a href="/posts/1aca788d.html">Python 继承</a></strong></p>
</li>
<li class="lvl-4">
<p><strong><a href="/posts/4bd79900.html">Python 抽象</a></strong></p>
</li>
</ul>
<h2 id="Python-高级主题">Python 高级主题</h2>
<p>Python 包含许多先进而有用的概念，可以帮助程序员解决复杂的任务。这些概念在下面给出。</p>
<h3 id="Python-迭代器">Python 迭代器</h3>
<p>迭代器只是一个可以迭代的对象。它一次返回一个对象。可以使用两种特殊的方法来实现， <strong><strong>iter</strong>()和 <strong>next</strong>()</strong> 。</p>
<p>要了解更多关于迭代器的信息，请访问 <a href="/posts/95d69c19.html"><strong>Python 迭代器</strong></a>。</p>
<h3 id="Python-生成器">Python 生成器</h3>
<p>生成器是创建迭代器最简单的方法。要了解更多信息，请访问<a href="/posts/23b78c5e.html"><strong>Python 生成器</strong></a>。</p>
<h3 id="Python-装饰器">Python 装饰器</h3>
<p>这些用于修改函数的行为。装饰者提供了包装另一个函数的灵活性，以扩展包装函数的工作，而无需永久修改它。</p>
<p>要了解更多信息，请访问 <a href="/posts/d89d2c35.html"><strong>Python 装饰器</strong></a>。</p>
<h2 id="Python-数据库连接">Python 数据库连接</h2>
<p>我们可以使用各种数据库和 Python。您可以通过访问下面的资源来学习完整的教程。Python DBI-API 认可标准功能集，这些功能集将包含在各个关系数据库管理系统产品的数据库连接模块中。我们使用 Python DBI API 解释所有重要的数据库连接。</p>
<h3 id="python-语言">python 语言</h3>
<p>环境设置</p>
<p>数据库连接</p>
<p>创建新数据库</p>
<p>创建表格</p>
<p>插入操作</p>
<p>读取操作</p>
<p>更新操作</p>
<p>连接操作</p>
<p>执行交易</p>
<h3 id="Python-MongoDB">Python MongoDB</h3>
<p>Python MongoDB</p>
<h3 id="Python-SQLite">Python SQLite</h3>
<p>Python SQLite</p>
<h2 id="Python-CGI">Python CGI</h2>
<p>Python CGI 代表**“公共网关接口”，**，用于定义如何在网络服务器和自定义 Python 脚本之间交换信息。<strong>通用网关接口</strong>是外部网关程序与服务器接口的标准，如 HTTP 服务器。要了解更多关于 Python CGI 的信息，请访问下面的教程。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Python CGI</strong></p>
</li>
</ul>
<h2 id="先决条件">先决条件</h2>
<p>在学习 Python 之前，您必须具备编程概念的基本知识。</p>
<h2 id="观众">观众</h2>
<p>Python 教程旨在帮助初学者和专业人士。</p>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-tutorial">https://www.javatpoint.com/python-tutorial</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 编写 CSV 文件</title>
    <url>/posts/57719496.html</url>
    <content><![CDATA[<h1>Python 编写 CSV 文件</h1>
<h2 id="CSV-文件">CSV 文件</h2>
<p>CSV 代表“逗号分隔值”，它被定义为一种简单的文件格式，使用特定的结构来排列表格数据。它以纯文本存储表格数据，如电子表格或数据库，并具有数据交换的标准格式。CSV 文件在 excel 工作表中打开，行和列数据定义了标准格式。</p>
<h2 id="Python-CSV-模块函数">Python CSV 模块函数</h2>
<p>CSV 模块的工作是处理 CSV 文件，以便从指定的列中读取/写入和获取数据。CSV 函数有不同的类型。</p>
<h2 id="编写-CSV-文件">编写 CSV 文件</h2>
<p>我们还可以使用 csv.writer()模块用 Python 编写任何新的和现有的 CSV 文件。它类似于 csv.reader()模块，也有两种方法，即 <strong>writer</strong> 函数或 <strong>Dict Writer</strong> 类。</p>
<p>它呈现两个功能，即 <strong>writerow()</strong> 和<strong>writerows()</strong>。 <strong>writerow()</strong> 函数只写一行，而**writerows()**函数写多行。<br>
<strong>方言</strong></p>
<p>它被定义为允许您创建、存储和重用各种格式参数的构造。它支持几个属性；最常用的是:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Dialect.delimiter:</strong> 该属性用作字段之间的分隔字符。默认值是逗号(，)。</p>
</li>
<li class="lvl-4">
<p><strong>Dialect.quotechar:</strong> 此属性用于引用包含特殊字符的字段。</p>
</li>
<li class="lvl-4">
<p><strong>Dialect.lineterminator:</strong> 用于新建线路，默认值为’ \r\n '。</p>
</li>
</ul>
<p>让我们将以下数据写入 CSV 文件。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">data = [&#123;<span class="string">&#x27;Rank&#x27;</span>: <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;first_name&#x27;</span>: <span class="string">&#x27;Parker&#x27;</span>, <span class="string">&#x27;last_name&#x27;</span>: <span class="string">&#x27;Brian&#x27;</span>&#125;,   </span><br><span class="line">&#123;<span class="string">&#x27;Rank&#x27;</span>: <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;first_name&#x27;</span>: <span class="string">&#x27;Smith&#x27;</span>, <span class="string">&#x27;last_name&#x27;</span>: <span class="string">&#x27;Rodriguez&#x27;</span>&#125;,  </span><br><span class="line">&#123;<span class="string">&#x27;Rank&#x27;</span>: <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;first_name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;last_name&#x27;</span>: <span class="string">&#x27;smith&#x27;</span>&#125;,  </span><br><span class="line">&#123;<span class="string">&#x27;Rank&#x27;</span>: <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;first_name&#x27;</span>: <span class="string">&#x27;Jane&#x27;</span>, <span class="string">&#x27;last_name&#x27;</span>: <span class="string">&#x27;Oscar&#x27;</span>&#125;,   </span><br><span class="line">&#123;<span class="string">&#x27;Rank&#x27;</span>: <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;first_name&#x27;</span>: <span class="string">&#x27;Alex&#x27;</span>, <span class="string">&#x27;last_name&#x27;</span>: <span class="string">&#x27;Tim&#x27;</span>&#125;]  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="示例-11">示例-</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> csv  </span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;Python.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> csvfile:  </span><br><span class="line">    fieldnames = [<span class="string">&#x27;first_name&#x27;</span>, <span class="string">&#x27;last_name&#x27;</span>, <span class="string">&#x27;Rank&#x27;</span>]  </span><br><span class="line">    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)  </span><br><span class="line"></span><br><span class="line">    writer.writeheader()  </span><br><span class="line">    writer.writerow(&#123;<span class="string">&#x27;Rank&#x27;</span>: <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;first_name&#x27;</span>: <span class="string">&#x27;Parker&#x27;</span>, <span class="string">&#x27;last_name&#x27;</span>: <span class="string">&#x27;Brian&#x27;</span>&#125;)  </span><br><span class="line">    writer.writerow(&#123;<span class="string">&#x27;Rank&#x27;</span>: <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;first_name&#x27;</span>: <span class="string">&#x27;Smith&#x27;</span>,  </span><br><span class="line">                     <span class="string">&#x27;last_name&#x27;</span>: <span class="string">&#x27;Rodriguez&#x27;</span>&#125;)  </span><br><span class="line">    writer.writerow(&#123;<span class="string">&#x27;Rank&#x27;</span>: <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;first_name&#x27;</span>: <span class="string">&#x27;Jane&#x27;</span>, <span class="string">&#x27;last_name&#x27;</span>: <span class="string">&#x27;Oscar&#x27;</span>&#125;)  </span><br><span class="line">    writer.writerow(&#123;<span class="string">&#x27;Rank&#x27;</span>: <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;first_name&#x27;</span>: <span class="string">&#x27;Jane&#x27;</span>, <span class="string">&#x27;last_name&#x27;</span>: <span class="string">&#x27;Loive&#x27;</span>&#125;)  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Writing complete&quot;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Writing complete</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它返回名为“Python.csv”的文件，其中包含以下数据:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">first_name,last_name,Rank  </span><br><span class="line">Parker,Brian,B  </span><br><span class="line">Smith,Rodriguez,A  </span><br><span class="line">Jane,Oscar,B  </span><br><span class="line">Jane,Loive,B   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="将-CSV-写入字典">将 CSV 写入字典</h2>
<p>我们也可以使用类 <strong>DictWriter</strong> 将 CSV 文件直接写入字典。</p>
<p>名为 python.csv 的文件包含以下数据:</p>
<p>帕克，会计，11 月</p>
<p>史密斯，信息技术，10 月</p>
<h3 id="示例-12">示例-</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> csv  </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;python.csv&#x27;</span>, mode=<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> csv_file:  </span><br><span class="line">    fieldnames = [<span class="string">&#x27;emp_name&#x27;</span>, <span class="string">&#x27;dept&#x27;</span>, <span class="string">&#x27;birth_month&#x27;</span>]  </span><br><span class="line">    writer = csv.DictWriter(csv_file, fieldnames=fieldnames)  </span><br><span class="line">    writer.writeheader()  </span><br><span class="line">    writer.writerow(&#123;<span class="string">&#x27;emp_name&#x27;</span>: <span class="string">&#x27;Parker&#x27;</span>, <span class="string">&#x27;dept&#x27;</span>: <span class="string">&#x27;Accounting&#x27;</span>, <span class="string">&#x27;birth_month&#x27;</span>: <span class="string">&#x27;November&#x27;</span>&#125;)  </span><br><span class="line">    writer.writerow(&#123;<span class="string">&#x27;emp_name&#x27;</span>: <span class="string">&#x27;Smith&#x27;</span>, <span class="string">&#x27;dept&#x27;</span>: <span class="string">&#x27;IT&#x27;</span>, <span class="string">&#x27;birth_month&#x27;</span>: <span class="string">&#x27;October&#x27;</span>&#125;)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">emp_name,dept,birth_month</span><br><span class="line">Parker,Accounting,November</span><br><span class="line">Smith,IT,October</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="用-Pandas-编写-CSV-文件">用 Pandas 编写 CSV 文件</h2>
<p>Pandas 被定义为建立在 Numpy 库之上的开源库。它为用户提供快速分析、数据清理和数据准备。</p>
<p>就像用 Pandas 读 CSV 文件一样简单。您需要创建 DataFrame，它是一个二维、异构的表格数据结构，由三个主要组件组成——数据、列和行。在这里，我们要读取一个稍微复杂一点的文件，名为 hrdata.csv，其中包含公司员工的数据。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Name,Hire Date,Salary,Leaves Remaining  </span><br><span class="line">John Idle,08/<span class="number">15</span>/<span class="number">14</span>,<span class="number">50000.00</span>,<span class="number">10</span>  </span><br><span class="line">Smith Gilliam,04/07/<span class="number">15</span>,<span class="number">65000.00</span>,<span class="number">8</span>  </span><br><span class="line">Parker Chapman,02/<span class="number">21</span>/<span class="number">14</span>,<span class="number">45000.00</span>,<span class="number">10</span>  </span><br><span class="line">Jones Palin,<span class="number">10</span>/<span class="number">14</span>/<span class="number">13</span>,<span class="number">70000.00</span>,<span class="number">3</span>  </span><br><span class="line">Terry Gilliam,07/<span class="number">22</span>/<span class="number">14</span>,<span class="number">48000.00</span>,<span class="number">7</span>  </span><br><span class="line">Michael Palin,06/<span class="number">28</span>/<span class="number">13</span>,<span class="number">66000.00</span>,<span class="number">8</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="示例-13">示例-</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas  </span><br><span class="line">df = pandas.read_csv(<span class="string">&#x27;hrdata.csv&#x27;</span>,   </span><br><span class="line">            index_col=<span class="string">&#x27;Employee&#x27;</span>,   </span><br><span class="line">            parse_dates=[<span class="string">&#x27;Hired&#x27;</span>],  </span><br><span class="line">            header=<span class="number">0</span>,   </span><br><span class="line">            names=[<span class="string">&#x27;Employee&#x27;</span>, <span class="string">&#x27;Hired&#x27;</span>, <span class="string">&#x27;Salary&#x27;</span>, <span class="string">&#x27;Sick Days&#x27;</span>])  </span><br><span class="line">df.to_csv(<span class="string">&#x27;hrdata_modified.csv&#x27;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Employee, Hired, Salary, Sick Days</span><br><span class="line">John Idle, <span class="number">2014</span>-03-<span class="number">15</span>, <span class="number">50000.0</span>,<span class="number">10</span></span><br><span class="line">Smith Gilliam, <span class="number">2015</span>-06-01, <span class="number">65000.0</span>,<span class="number">8</span></span><br><span class="line">Parker Chapman, <span class="number">2014</span>-05-<span class="number">12</span>, <span class="number">45000.0</span>,<span class="number">10</span></span><br><span class="line">Jones Palin, <span class="number">2013</span>-<span class="number">11</span>-01, <span class="number">70000.0</span>,<span class="number">3</span></span><br><span class="line">Terry Gilliam, <span class="number">2014</span>-08-<span class="number">12</span> , <span class="number">48000.0</span>,<span class="number">7</span></span><br><span class="line">Michael Palin, <span class="number">2013</span>-05-<span class="number">23</span>, <span class="number">66000.0</span>,<span class="number">8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-write-csv-file">https://www.javatpoint.com/python-write-csv-file</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 编写Excel文件</title>
    <url>/posts/40395c62.html</url>
    <content><![CDATA[<h1>Python 编写 Excel 文件</h1>
<p>Python write excel 文件用于使用 <strong>xlwt</strong> 模块对电子表格执行多个操作。这是用将数据和格式信息写入文件的理想方式。xls 扩展。</p>
<p>如果您想将数据写入任何文件，并且不想经历自己做所有事情的麻烦，那么您可以使用 <code>for</code>循环来稍微自动化整个过程。</p>
<h2 id="使用-xlsxwriter-模块编写-Excel-文件">使用 xlsxwriter 模块编写 Excel 文件</h2>
<p>我们也可以使用 <strong>xlsxwriter</strong> 模块编写 excel 文件。它被定义为一个 Python 模块，用于以 XLSX 文件格式编写文件。它还可以用于将文本、数字和公式写入多个工作表。此外，它还支持图表、格式、图像、页面设置、自动过滤器、条件格式等功能。</p>
<p>我们需要使用以下命令来安装 xlsxwriter 模块:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install xlsxwriter   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="注意-在整个-XlsxWriter-中，行和列都是零索引的。工作表中的第一个单元格列为，A1-是-0，0-，B1-是-0，1-，A2-是-1，0-，B2-是-1，1-…，等等。">注意-在整个 XlsxWriter 中，行和列都是零索引的。工作表中的第一个单元格列为，A1 是(0，0)，B1 是(0，1)，A2 是(1，0)，B2 是(1，1)…，等等。</h4>
<h2 id="用-openpyxl-模块编写-Excel-文件">用 openpyxl 模块编写 Excel 文件</h2>
<p>它被定义为一个包，如果您想要读写，通常会推荐它。xlsx、xlsm、xltx 和 xltm 文件。可以通过运行<strong>type(wb)</strong> 进行检查。</p>
<p>load_workbook()函数接受一个参数并返回一个代表文件的 workbook 对象。确保您在电子表格所在的同一目录中。否则，导入时会出现错误。</p>
<p>在 range()函数的帮助下，您可以很容易地使用 <code>for</code>循环来帮助您打印出第 2 列中有值的行的值。如果这些特定的单元格是空的，您将获得无。</p>
<h2 id="用-xlwt-将数据写入-Excel-文件">用 xlwt 将数据写入 Excel 文件</h2>
<p>除了 XlsxWriter 包之外，您还可以使用 xlwt 包来创建包含您的数据的电子表格。它是用于写入数据、格式化信息等的替代包。非常适合用将数据和格式信息写入文件.xls 扩展。它可以对电子表格执行多种操作。</p>
<p>它支持诸如格式、图像、图表、页面设置、自动过滤器、条件格式等功能。</p>
<p>Pandas 有很好的方法从 excel 文件中读取各种数据。我们也可以把结果导入回 Pandas。</p>
<h2 id="用-pyexcel-写文件">用 pyexcel 写文件</h2>
<p>您可以使用 save_as()函数轻松地将数组导出回电子表格，并将目标文件的数组和名称传递给 dest_file_name 参数。</p>
<p>它允许我们指定分隔符并添加 dest_delimiter 参数。您可以传递要用作中间分隔符的符号&quot; &quot;。</p>
<p><strong>代码</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># import xlsxwriter module   </span></span><br><span class="line"><span class="keyword">import</span> xlsxwriter   </span><br><span class="line"></span><br><span class="line">book = xlsxwriter.Book(<span class="string">&#x27;Example2.xlsx&#x27;</span>)   </span><br><span class="line">sheet = book.add_sheet()   </span><br><span class="line"></span><br><span class="line"><span class="comment"># Rows and columns are zero indexed.   </span></span><br><span class="line">row = <span class="number">0</span>  </span><br><span class="line">column = <span class="number">0</span>  </span><br><span class="line"></span><br><span class="line">content = [<span class="string">&quot;Parker&quot;</span>, <span class="string">&quot;Smith&quot;</span>, <span class="string">&quot;John&quot;</span>]   </span><br><span class="line"></span><br><span class="line"><span class="comment"># iterating through the content list   </span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> content :   </span><br><span class="line"></span><br><span class="line">    <span class="comment"># write operation perform   </span></span><br><span class="line">    sheet.write(row, column, item)   </span><br><span class="line"></span><br><span class="line">    <span class="comment"># incrementing the value of row by one with each iterations.   </span></span><br><span class="line">    row += <span class="number">1</span>  </span><br><span class="line"></span><br><span class="line">book.close()   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<p><img src="/img/e6611a713395d80bdc84551db2e656c3.png" alt="Python Write Excel File"></p>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-write-excel-file">https://www.javatpoint.com/python-write-excel-file</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 网页抓取</title>
    <url>/posts/90ed4a77.html</url>
    <content><![CDATA[<h1>Python 网页抓取</h1>
<h2 id="什么是网页抓取？">什么是网页抓取？</h2>
<p>网页抓取是一种从几个网站中提取大量数据的技术。术语**“抓取”<strong>是指从另一个来源(网页)获取信息并将其保存到本地文件中。例如:假设你正在做一个名为</strong>“手机比较网站”**的项目，你需要手机的价格、收视率和型号名称来比较不同的手机。如果你通过查看各种网站来收集这些细节，将会花费很多时间。在这种情况下，网络废弃扮演了一个重要的角色，通过编写几行代码，你可以得到想要的结果。</p>
<p><img src="/img/8a37123f170e26989b070b36174b9399.png" alt="Web Scraping Using Python"></p>
<p>网络抓取以非结构化格式从网站中提取数据。它有助于收集这些非结构化数据并将其转换为结构化形式。</p>
<p>初创公司更喜欢网络抓取，因为这是一种廉价而有效的获取大量数据的方式，而无需与数据销售公司建立任何合作关系。</p>
<h2 id="网络报废合法吗？">网络报废合法吗？</h2>
<p>这里就出现了<strong>抓取是否合法的问题</strong>。答案是有些网站允许合法使用。网页抓取只是一个工具，你可以用正确的方式或错误的方式使用它。</p>
<p>如果有人试图抓取非公开数据，网络抓取是非法的。并非所有人都能获得非公开数据；如果你试图提取这样的数据，那就违反了法律条款。</p>
<p>有几种工具可以从网站上抓取数据，例如:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Scrapping-bot</p>
</li>
<li class="lvl-2">
<p>Scrapper API</p>
</li>
<li class="lvl-2">
<p>Octoparse</p>
</li>
<li class="lvl-2">
<p><a href="http://Import.io">Import.io</a></p>
</li>
<li class="lvl-2">
<p><a href="http://Webhose.io">Webhose.io</a></p>
</li>
<li class="lvl-2">
<p><a href="http://Dexi.io">Dexi.io</a></p>
</li>
<li class="lvl-2">
<p>Outwit</p>
</li>
<li class="lvl-2">
<p>Diffbot</p>
</li>
<li class="lvl-2">
<p>Content Grabber</p>
</li>
<li class="lvl-2">
<p>Mozenda</p>
</li>
<li class="lvl-2">
<p>Web Scrapper Chrome Extension</p>
</li>
</ul>
<h2 id="为什么要爬虫？">为什么要爬虫？</h2>
<p><img src="/img/de495825f19a481c0775844e92002403.png" alt="Web Scraping Using Python"></p>
<p>正如我们上面所讨论的，网络爬取被用来从网站中提取数据。但是我们应该知道如何使用原始数据。原始数据可以用于各种领域。让我们来看看网络报废的用法:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>动态价格监控</strong></p>
</li>
</ul>
<p>它被广泛用于从几个在线购物网站收集数据，比较产品价格，并做出有利可图的定价决策。使用网络爬取数据的价格监控使公司能够了解市场状况并促进动态定价。这确保了他们的公司总是高于其他公司。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>市场调研</strong></p>
</li>
</ul>
<p>爬虫完全适合市场趋势分析。它正在获得对特定市场的洞察。大型组织需要大量数据，而网络报废为数据提供了可靠和准确的保证。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>邮件收集</strong></p>
</li>
</ul>
<p>许多公司使用个人电子邮件数据进行电子邮件营销。他们可以针对特定的受众进行营销。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>新闻和内容监控</strong></p>
</li>
</ul>
<p>一个单一的新闻周期可以对你的业务产生显著的影响或真正的威胁。如果你的公司依赖于一个组织的新闻分析，它经常出现在新闻中。因此，网页抓取为监控和解析最关键的故事提供了终极解决方案。新闻文章和社交媒体平台可以直接影响股市。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>社交媒体报废</strong></p>
</li>
</ul>
<p>网络爬取在从**推特、脸书、**和 **Instagram、**等社交媒体网站上提取数据以找到热门话题方面发挥着至关重要的作用。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>研发</strong></p>
</li>
</ul>
<p>从网站上报废<strong>一般信息、统计数据、温度</strong>等大数据集，分析后用于开展调查或研发。</p>
<h2 id="为什么要用-Python-进行网页爬取？">为什么要用 Python 进行网页爬取？</h2>
<p>还有其他流行的编程语言，但是为什么我们选择Python 而不是其他编程语言来进行网页抓取呢？下面我们将描述 Python 的一些特性，这些特性使得 Python 成为最有用的网络废弃编程语言。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>动态键入</strong></p>
</li>
</ul>
<p>在 Python 中，我们不需要为变量定义数据类型；我们可以在任何需要的地方直接使用这个变量。它节省时间，使任务更快。Python 定义了它的类来识别变量的数据类型。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>庞大的图书馆收藏</strong></p>
</li>
</ul>
<p>Python 附带了广泛的库，如 <strong>NumPy、Matplotlib、Pandas、Scipy 等</strong>。，它为各种用途的工作提供了灵活性。它适用于几乎每个新兴领域，也适用于提取数据和进行操作的网络废弃。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>低代码</strong></p>
</li>
</ul>
<p>爬虫的目的是为了节省时间。但是如果你花更多的时间写代码呢？这就是为什么我们使用 Python，因为它可以用几行代码执行一项任务。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>开源社区</strong></p>
</li>
</ul>
<p>Python 是开源的，这意味着它对每个人都是免费的。它拥有世界上最大的社区之一，如果您在 Python 代码中遇到任何问题，都可以在这里寻求帮助。</p>
<h3 id="爬虫的基础知识">爬虫的基础知识</h3>
<p>网络抓取由两部分组成：网络爬虫和网络抓取器。简单地说，网络爬虫是一匹骏马，而网络搜刮器则是一辆战车。爬虫引导刮板，提取所需的数据。让我们来了解一下网络搜索的这两个组成部分：</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>爬虫</strong></p>
</li>
</ul>
<p><img src="/img/585ec96e5545a9417b24b34ab2527cb8.png" alt="Web Scraping Using Python">网络爬虫一般称为**“蜘蛛。”**它是一种人工智能技术，通过给定的链接浏览互联网来索引和搜索内容。它搜索程序员询问的相关信息。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>刮刀</strong></p>
</li>
</ul>
<p><img src="/img/664f007d6a11b0b10e203b3029d3fa71.png" alt="Web Scraping Using Python">网页抓取器是一种专用工具，旨在快速有效地从多个网站中提取数据。根据项目的不同，网页剪贴机在设计和复杂性上差别很大。</p>
<h3 id="网络爬虫是如何工作的？">网络爬虫是如何工作的？</h3>
<p>以下是执行爬虫的步骤。让我们了解一下网页抓取的工作原理。</p>
<p><strong>第一步:找到想要刮的 URL</strong></p>
<p>首先，你应该根据你的项目了解数据的需求。网页或网站包含大量信息。这就是为什么只废弃相关信息。简单地说，开发人员应该熟悉数据需求。</p>
<p><strong>步骤 2:检查页面</strong></p>
<p>数据以原始 <a href="https://www.javatpoint.com/html-tutorial">HTML</a> 格式提取，必须仔细解析，减少原始数据的噪音。在某些情况下，数据可以像姓名和地址一样简单，也可以像高维天气和股市数据一样复杂。</p>
<p><strong>第三步:写代码</strong></p>
<p>编写代码来提取信息，提供相关信息，并运行代码。</p>
<p><strong>第 4 步:将数据存入文件</strong></p>
<p>将该信息以所需的 csv、 <a href="https://www.javatpoint.com/xml-tutorial">xml</a> 、 <a href="https://www.javatpoint.com/json-tutorial">JSON</a> 文件格式存储。</p>
<h3 id="网页抓取入门">网页抓取入门</h3>
<p>Python 有大量的库，也为网络废弃提供了一个非常有用的库。让我们了解 Python 所需的库。</p>
<p><strong>用于刮网的库</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Selenium-</strong> Selenium 是一个开源的自动化测试库。它用于检查浏览器活动。要安装此库，请在终端中键入以下命令。</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install selenium</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="注意——使用-PyCharm-IDE-很好。">注意——使用 PyCharm IDE 很好。</h4>
<p><img src="/img/60e8af64500b4ee5161bfdae276bb1fc.png" alt="Web Scraping Using Python"></p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Pandas</strong></p>
</li>
</ul>
<p>Pandas 库用于<strong>数据操作和分析</strong>。它用于提取数据并以所需的格式存储。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>BeautifulSoup</strong></p>
</li>
</ul>
<p>BeautifulSoup is a Python library that is used to pull data of HTML and XML files. It is mainly designed for web scrapping. It works with the parser to provide a natural way of navigating, searching, and modifying the parse tree. The latest version of BeautifulSoup is 4.8.1.</p>
<p>让我们详细了解一下<strong>BeautifulSoup</strong>库。</p>
<p><strong>安装BeautifulSoup</strong></p>
<p>您可以通过键入以下命令来安装美观的套件:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install bs4</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>安装解析器</strong></p>
<p>BeautifulSoup 支持 HTML 解析器和几个第三方 Python 解析器。您可以根据您的依赖关系安装其中的任何一个。以下是美观组的解析器列表:</p>
<table>
<thead>
<tr>
<th>句法分析程序</th>
<th>典型用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Python 的 html.parser</td>
<td>BeautifulSoup(markup，“html.parser”)</td>
</tr>
<tr>
<td>lxml 的 HTML 解析器</td>
<td>BeautifulSoup(markup，“lxml”)</td>
</tr>
<tr>
<td>lxml 的 xml 解析器</td>
<td>BeautifulSoup(markup，“lxml-xml”)</td>
</tr>
<tr>
<td>Html5lib</td>
<td>BeautifulSoup(markup，“html5lib”)</td>
</tr>
</tbody>
</table>
<p>我们建议您安装 <strong>html5lib</strong> 解析器，因为它非常适合较新版本的 Python，或者您可以安装 <strong>lxml</strong> 解析器。</p>
<p>在您的终端中键入以下命令:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install html5lib</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/22d6e58b4ca0264102ccfe433bc14dd7.png" alt="Web Scraping Using Python"></p>
<p>BeautifulSoup用于将复杂的 HTML 文档转换成 Python 对象的复杂树。但是有几个主要使用的对象类型:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>标签</strong></p>
</li>
</ul>
<p>一个<strong>标签</strong>对象对应一个 XML 或者 HTML 原始文档。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">soup = bs4.BeautifulSoup(<span class="string">&quot;&lt;b class = &quot;</span>boldest<span class="string">&quot;&gt;Extremely bold&lt;/b&gt;)</span></span><br><span class="line"><span class="string">tag = soup.b</span></span><br><span class="line"><span class="string">type(tag)</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&quot;bs4.element.Tag&quot;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>标签包含许多属性和方法，但是标签最重要的特征是名称和属性。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>名称</strong></p>
</li>
</ul>
<p>每个标签都有一个名称，可以通过<strong>访问。名称:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">tag.name</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>属性</strong></p>
</li>
</ul>
<p>标签可以有任意数量的属性。标签<strong>有一个属性“id”，其值为“最粗”。我们可以通过将标签视为字典来访问标签的属性。</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">tag[<span class="built_in">id</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以添加、移除和修改标签的属性。这可以通过使用标签作为字典来完成。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># add the element</span></span><br><span class="line">tag[<span class="string">&#x27;id&#x27;</span>] = <span class="string">&#x27;verybold&#x27;</span></span><br><span class="line">tag[<span class="string">&#x27;another-attribute&#x27;</span>] = <span class="number">1</span></span><br><span class="line">tag</span><br><span class="line"><span class="comment"># delete the tag</span></span><br><span class="line"><span class="keyword">del</span> tag[<span class="string">&#x27;id&#x27;</span>]	</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>多值属性</strong></p>
</li>
</ul>
<p>在 HTML5 中，有些属性可以有多个值。类(由多个 css 组成)是最常见的多值属性。其他属性有 **rel、rev、accept-charset、headers、**和 <strong>accesskey</strong> 。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class_is_multi= &#123; <span class="string">&#x27;*&#x27;</span> : <span class="string">&#x27;class&#x27;</span>&#125;</span><br><span class="line">xml_soup = BeautifulSoup(<span class="string">&#x27;&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;&#x27;</span>, <span class="string">&#x27;xml&#x27;</span>, multi_valued_attributes=class_is_multi)</span><br><span class="line">xml_soup.p[<span class="string">&#x27;class&#x27;</span>]</span><br><span class="line"><span class="comment"># [u&#x27;body&#x27;, u&#x27;strikeout&#x27;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p>可导航字符串</p>
</li>
</ul>
<p>BeautifulSoup中的字符串引用标签中的文本。美化组使用<strong>导航字符串</strong>类来包含这些文本。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">tag.string</span><br><span class="line"><span class="comment"># u&#x27;Extremely bold&#x27;</span></span><br><span class="line"><span class="built_in">type</span>(tag.string)</span><br><span class="line"><span class="comment"># &lt;class &#x27;bs4.element.NavigableString&#x27;&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>字符串是不可变的，这意味着它不能被编辑。但是可以使用 <strong>replace_with()</strong> 替换为另一个字符串。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">tag.string.replace_with(<span class="string">&quot;No longer bold&quot;</span>)</span><br><span class="line">tag</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在某些情况下，如果您想在BeautifulSoup外使用<strong>导航字符串</strong>，则 <strong>unicode()</strong> 有助于将其转换为正常的 Python Unicode 字符串。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>BeautifulSoup object</strong></p>
</li>
</ul>
<p>BeautifulSoup输出对象将完整的解析文档作为一个整体来表示。在许多情况下，我们可以将其用作标记对象。这意味着它支持导航树和搜索树中描述的大多数方法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">doc=BeautifulSoup(<span class="string">&quot;&lt;document&gt;&lt;content/&gt;INSERT FOOTER HERE&lt;/document&quot;</span>,<span class="string">&quot;xml&quot;</span>)</span><br><span class="line">footer=BeautifulSoup(<span class="string">&quot;&lt;footer&gt;Here&#x27;s the footer&lt;/footer&gt;&quot;</span>,<span class="string">&quot;xml&quot;</span>)</span><br><span class="line">doc.find(text=<span class="string">&quot;INSERT FOOTER HERE&quot;</span>).replace_with(footer)</span><br><span class="line"><span class="built_in">print</span>(doc)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line"><span class="comment"># &lt;document&gt;&lt;content/&gt;&lt;footer&gt;Here&#x27;s the footer&lt;/footer&gt;&lt;/document&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="网络抓取示例">网络抓取示例:</h3>
<p>让我们举个例子，通过从网页中提取数据并检查整个页面来实际理解报废。</p>
<p>首先，在维基百科上打开你喜欢的页面，检查整个页面，在从网页中提取数据之前，你应该确保你的要求。考虑以下代码:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#importing the BeautifulSoup Library</span></span><br><span class="line"></span><br><span class="line">importbs4</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment">#Creating the requests</span></span><br><span class="line"></span><br><span class="line">res = requests.get(<span class="string">&quot;https://en.wikipedia.org/wiki/Machine_learning&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The object type:&quot;</span>,<span class="built_in">type</span>(res))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convert the request object to the Beautiful Soup Object</span></span><br><span class="line">soup = bs4.BeautifulSoup(res.text,<span class="string">&#x27;html5lib&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The object type:&quot;</span>,<span class="built_in">type</span>(soup)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The <span class="built_in">object</span> <span class="built_in">type</span> &lt;<span class="keyword">class</span> <span class="string">&#x27;requests.models.Response&#x27;</span>&gt;</span><br><span class="line">Convert the <span class="built_in">object</span> into: &lt;<span class="keyword">class</span> <span class="string">&#x27;bs4.BeautifulSoup&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在下面几行代码中，我们按照类名提取网页的所有标题。在这里，前端知识在检查网页时起着至关重要的作用。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">soup.select(<span class="string">&#x27;.mw-headline&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> soup.select(<span class="string">&#x27;.mw-headline&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(i.text,end = <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Overview,Machine learning tasks,History <span class="keyword">and</span> relationships to other fields,Relation to data mining,Relation to optimization,Relation to statistics, Theory,Approaches,Types of learning algorithms,Supervised learning,Unsupervised learning,Reinforcement learning,Self-learning,Feature learning,Sparse dictionary learning,Anomaly detection,Association rules,Models,Artificial neural networks,Decision trees,Support vector machines,Regression analysis,Bayesian networks,Genetic algorithms,Training models,Federated learning,Applications,Limitations,Bias,Model assessments,Ethics,Software,Free <span class="keyword">and</span> <span class="built_in">open</span>-source software,Proprietary software <span class="keyword">with</span> free <span class="keyword">and</span> <span class="built_in">open</span>-source editions,Proprietary software,Journals,Conferences,See also,References,Further reading,External links,</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们导入了 <strong>bs4</strong> 和<strong>请求</strong>库。在第三行中，我们创建了一个 <strong>res</strong> 对象，向网页发送请求。正如你所看到的，我们已经从网页上提取了所有的标题。</p>
<p><img src="/img/ff708269f4541f1279e7f6196ca8b84f.png" alt="Web Scraping Using Python"></p>
<p><strong>维基百科学习的网页</strong></p>
<p>让我们理解另一个例子；我们将对 URL 发出 GET 请求，并使用 BeautifulSoup 和 Python 内置的**“html 5lib”**解析器创建一个解析树对象(soup)。</p>
<p>这里我们将废弃给定链接<a href="https://www.javatpoint.com/">的网页(https://www.javatpoint.com/)。</a>考虑以下代码:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">following code:</span><br><span class="line"><span class="comment"># importing the libraries</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url=<span class="string">&quot;https://www.javatpoint.com/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Make a GET request to fetch the raw HTML content</span></span><br><span class="line">html_content = requests.get(url).text</span><br><span class="line"></span><br><span class="line"><span class="comment"># Parse the html content</span></span><br><span class="line">soup = BeautifulSoup(html_content, <span class="string">&quot;html5lib&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(soup.prettify()) <span class="comment"># print the parsed data of html</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的代码将显示 javatpoint 主页的所有 html 代码。</p>
<p>使用<strong>BeautifulSoup</strong>对象，即<strong>soup</strong>，我们可以收集所需的数据表。让我们使用<strong>soup</strong>对象打印一些有趣的信息:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>让我们打印网页的标题。</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">print</span>(soup.title)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>**输出:**它将给出如下输出:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;title&gt;Tutorials <span class="type">List</span> - Javatpoint&lt;/title&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p>在上面的输出中，标题中包含了 HTML 标记。如果需要不带标签的文本，可以使用以下代码:</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">print</span>(soup.title.text)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>**输出:**它将给出如下输出:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Tutorials <span class="type">List</span> - Javatpoint</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-4">
<p>我们可以获得页面上的整个链接及其属性，如 href、标题和内部文本。考虑以下代码:</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> link <span class="keyword">in</span> soup.find_all(<span class="string">&quot;a&quot;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Inner Text is: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(link.text))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Title is: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(link.get(<span class="string">&quot;title&quot;</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;href is: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(link.get(<span class="string">&quot;href&quot;</span>)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>**输出:**将打印所有链接及其属性。这里我们展示了其中的一些:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">href <span class="keyword">is</span>: https://www.facebook.com/javatpoint</span><br><span class="line">Inner Text <span class="keyword">is</span>: </span><br><span class="line">The title <span class="keyword">is</span>: <span class="literal">None</span></span><br><span class="line">href <span class="keyword">is</span>: https://twitter.com/pagejavatpoint</span><br><span class="line">Inner Text <span class="keyword">is</span>: </span><br><span class="line">The title <span class="keyword">is</span>: <span class="literal">None</span></span><br><span class="line">href <span class="keyword">is</span>: https://www.youtube.com/channel/UCUnYvQVCrJoFWZhKK3O2xLg</span><br><span class="line">Inner Text <span class="keyword">is</span>: </span><br><span class="line">The title <span class="keyword">is</span>: <span class="literal">None</span></span><br><span class="line">href <span class="keyword">is</span>: https://javatpoint.blogspot.com</span><br><span class="line">Inner Text <span class="keyword">is</span>: Learn Java</span><br><span class="line">Title <span class="keyword">is</span>: <span class="literal">None</span></span><br><span class="line">href <span class="keyword">is</span>: https://www.javatpoint.com/java-tutorial</span><br><span class="line">Inner Text <span class="keyword">is</span>: Learn Data Structures</span><br><span class="line">Title <span class="keyword">is</span>: <span class="literal">None</span></span><br><span class="line">href <span class="keyword">is</span>: https://www.javatpoint.com/data-structure-tutorial</span><br><span class="line">Inner Text <span class="keyword">is</span>: Learn C Programming</span><br><span class="line">Title <span class="keyword">is</span>: <span class="literal">None</span></span><br><span class="line">href <span class="keyword">is</span>: https://www.javatpoint.com/c-programming-language-tutorial</span><br><span class="line">Inner Text <span class="keyword">is</span>: Learn C++ Tutorial</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="演示-从-Flipkart-网站抓取数据">演示:从 Flipkart 网站抓取数据</h3>
<p>在这个例子中，我们将从流行的电子商务网站之一 Flipkart 中删除手机价格、收视率和型号名称。以下是完成此任务的先决条件:</p>
<p><strong>先决条件:</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>Python 2.x 或 Python 3.x，安装了 <strong>Selenium、BeautifulSoup、Pandas</strong> 库。</p>
</li>
<li class="lvl-4">
<p>谷歌浏览器</p>
</li>
<li class="lvl-4">
<p>废弃解析器，如 html.parser、xlml 等。</p>
</li>
</ul>
<p><strong>第一步:找到想要抓取的网址</strong></p>
<p>第一步是找到你想抓取的网址。这里我们从动画中提取手机细节。这个页面的网址是 <a href="https://www.flipkart.com/search?q">https://www.flipkart.com/search?q</a> = iphones &amp; otracker = search &amp; otracker 1 = search &amp; market place = FLIPKART &amp; as-show = on &amp; as = off。</p>
<p><strong>第 2 步:检查页面</strong></p>
<p>有必要仔细检查页面，因为数据通常包含在标签中。所以我们需要检查选择想要的标签。要检查页面，右键单击元素，然后单击**“检查”**。</p>
<p><strong>第三步:找到要提取的数据</strong></p>
<p>提取价格、名称和评级，它们分别包含在“div”标签中。</p>
<p><strong>第四步:写代码</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoupas soup</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen <span class="keyword">as</span> uReq</span><br><span class="line"></span><br><span class="line"><span class="comment"># Request from the webpage</span></span><br><span class="line">myurl = <span class="string">&quot;https://www.flipkart.com/search?q=iphones&amp;otracker=search&amp;otracker1=search&amp;marketplace=FLIPKART&amp;as-show=on&amp;as=off&quot;</span></span><br><span class="line"></span><br><span class="line">uClient  = uReq(myurl)</span><br><span class="line">page_html = uClient.read()</span><br><span class="line">uClient.close()</span><br><span class="line"></span><br><span class="line">page_soup = soup(page_html, features=<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(soup.prettify(containers[0]))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This variable held all html of webpage</span></span><br><span class="line">containers = page_soup.find_all(<span class="string">&quot;div&quot;</span>,&#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;_3O0U0u&quot;</span>&#125;)</span><br><span class="line"><span class="comment"># container = containers[0]</span></span><br><span class="line"><span class="comment"># # print(soup.prettify(container))</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># price = container.find_all(&quot;div&quot;,&#123;&quot;class&quot;: &quot;col col-5-12 _2o7WAb&quot;&#125;)</span></span><br><span class="line"><span class="comment"># print(price[0].text)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ratings = container.find_all(&quot;div&quot;,&#123;&quot;class&quot;: &quot;niH0FQ&quot;&#125;)</span></span><br><span class="line"><span class="comment"># print(ratings[0].text)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># #</span></span><br><span class="line"><span class="comment"># # print(len(containers))</span></span><br><span class="line"><span class="comment"># print(container.div.img[&quot;alt&quot;])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Creating CSV File that will store all data </span></span><br><span class="line">filename = <span class="string">&quot;product1.csv&quot;</span></span><br><span class="line">f = <span class="built_in">open</span>(filename,<span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line">headers = <span class="string">&quot;Product_Name,Pricing,Ratings\n&quot;</span></span><br><span class="line">f.write(headers)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> container <span class="keyword">in</span> containers:</span><br><span class="line">    product_name = container.div.img[<span class="string">&quot;alt&quot;</span>]</span><br><span class="line"></span><br><span class="line">    price_container = container.find_all(<span class="string">&quot;div&quot;</span>, &#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;col col-5-12 _2o7WAb&quot;</span>&#125;)</span><br><span class="line">    price = price_container[<span class="number">0</span>].text.strip()</span><br><span class="line"></span><br><span class="line">    rating_container = container.find_all(<span class="string">&quot;div&quot;</span>,&#123;<span class="string">&quot;class&quot;</span>:<span class="string">&quot;niH0FQ&quot;</span>&#125;)</span><br><span class="line">    ratings = rating_container[<span class="number">0</span>].text</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(&quot;product_name:&quot;+product_name)</span></span><br><span class="line">    <span class="comment"># print(&quot;price:&quot;+price)</span></span><br><span class="line">    <span class="comment"># print(&quot;ratings:&quot;+ str(ratings))</span></span><br><span class="line"></span><br><span class="line">     edit_price = <span class="string">&#x27;&#x27;</span>.join(price.split(<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">     sym_rupee = edit_price.split(<span class="string">&quot;?&quot;</span>)</span><br><span class="line">     add_rs_price = <span class="string">&quot;Rs&quot;</span>+sym_rupee[<span class="number">1</span>]</span><br><span class="line">     split_price = add_rs_price.split(<span class="string">&quot;E&quot;</span>)</span><br><span class="line">     final_price = split_price[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">     split_rating = <span class="built_in">str</span>(ratings).split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">     final_rating = split_rating[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">     <span class="built_in">print</span>(product_name.replace(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;|&quot;</span>)+<span class="string">&quot;,&quot;</span>+final_price+<span class="string">&quot;,&quot;</span>+final_rating+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">f.write(product_name.replace(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;|&quot;</span>)+<span class="string">&quot;,&quot;</span>+final_price+<span class="string">&quot;,&quot;</span>+final_rating+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">f.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<p><img src="/img/66d71b28beb5b72ea04a97ccca0e6cfa.png" alt="Web Scraping Using Python"></p>
<p>我们取消了 iPhone 的细节，并将这些细节保存在 CSV 文件中，如您在输出中所见。在上面的代码中，出于测试目的，我们对几行代码进行了注释。您可以删除这些注释并观察输出。</p>
<p>在本教程中，我们讨论了网络爬取的所有基本概念，并描述了领先的在线电子商务网站 flipkart 的爬取示例。</p>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/web-scraping-using-python">https://www.javatpoint.com/web-scraping-using-python</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 装饰器</title>
    <url>/posts/d89d2c35.html</url>
    <content><![CDATA[<h1>Python 装饰器</h1>
<p>装饰器是 Python 最有用和最强大的工具之一。这些用于修改函数的行为。装饰器提供了包装另一个函数的灵活性，以扩展包装函数的工作，而无需永久修改它。</p>
<blockquote>
<p>在 Decorators 中，函数作为参数传递给另一个函数，然后在包装函数中调用。</p>
</blockquote>
<p>它也被称为<strong>meta programming</strong>，程序的一部分试图在编译时改变程序的另一部分。</p>
<p>在理解<strong>装饰器</strong>之前，我们需要了解 Python 的一些重要概念。</p>
<h2 id="Python-中有哪些函数？">Python 中有哪些函数？</h2>
<p>Python 有一个最有趣的特性，那就是所有的东西都被当作一个对象，甚至我们在 Python 中定义的类或者任何变量也被假定为一个对象。函数是 Python 中的第一类对象，因为它们可以引用、传递给变量以及从其他函数返回。示例如下:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">msg</span>):</span><br><span class="line">    <span class="built_in">print</span>(msg)</span><br><span class="line">func1(<span class="string">&quot;Hii&quot;</span>)</span><br><span class="line">func2 = func1</span><br><span class="line">func2(<span class="string">&quot;Hii&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Hii</span><br><span class="line">Hii</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的程序中，当我们运行代码时，它为两个函数提供了相同的输出。<strong>func2</strong> 指功能<strong>func1</strong> 并作为功能。我们需要理解函数的以下概念:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>该函数可以被引用并传递给变量，也可以从其他函数返回。</p>
</li>
<li class="lvl-4">
<p>这些函数可以在另一个函数中声明，并作为参数传递给另一个函数。</p>
</li>
</ul>
<h2 id="内部函数">内部函数</h2>
<p>Python 提供了在另一个函数中定义函数的工具。这些类型的函数称为内部函数。考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;We are in first function&quot;</span>)</span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">&quot;This is first child function&quot;</span>)</span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">&quot; This is second child function&quot;</span>)</span><br><span class="line">     func1()</span><br><span class="line">     func2()</span><br><span class="line">func()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">We are <span class="keyword">in</span> first function</span><br><span class="line">This <span class="keyword">is</span> first child function</span><br><span class="line">This <span class="keyword">is</span> second child function</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的程序中，子函数是如何声明的并不重要。子函数的执行会对输出产生影响。这些子函数与**函数()**局部有界，因此不能单独调用。</p>
<p>接受其他函数作为自变量的函数也称为<strong>高阶函数</strong>。考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x+<span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x-<span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">operator</span>(<span class="params">func, x</span>):</span><br><span class="line">    temp = func(x)</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line"><span class="built_in">print</span>(operator(sub,<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(operator(add,<span class="number">20</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的程序中，我们已经将 <strong>sub()</strong> 函数和 <strong>add()</strong> 函数作为参数传递给了 <strong>operator()</strong> 函数。</p>
<p>一个函数可以返回另一个函数。考虑下面的例子:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hi</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> hi</span><br><span class="line">new = hello()</span><br><span class="line">new()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Hello</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的程序中， <strong>hi()</strong> 函数嵌套在 <strong>hello()</strong> 函数中。每次我们呼叫 <strong>hi()</strong> 它都会返回。</p>
<h3 id="用参数装饰函数">用参数装饰函数</h3>
<p>让我们举一个例子来理解参数化装饰函数:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="built_in">print</span>(x/y)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer_div</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">x,y</span>):</span><br><span class="line">        <span class="keyword">if</span>(x</span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">2.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="语法装饰器">语法装饰器</h3>
<p>在上面的程序中，我们已经修饰了 <strong>out_div()</strong> 有点笨重。Python 不使用上述方法，而是允许<strong>用@symbol</strong>轻松使用装饰器。有时它被称为“pie”语法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer_div</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">x,y</span>):</span><br><span class="line">        <span class="keyword">if</span>(x</span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">2.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="重用装饰器">重用装饰器</h3>
<p>我们也可以通过调用装饰函数来重用装饰器。让我们把装饰器做成它自己的模块，可以用在许多其他功能中。使用以下代码创建名为 <strong>mod_decorator.py</strong> 的文件:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_twice</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper_do_twice</span>():</span><br><span class="line">        func()</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> wrapper_do_twice</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以在其他文件中导入 mod_decorator.py。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> decorator <span class="keyword">import</span> do_twice</span><br><span class="line"><span class="meta">@do_twice</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello There&quot;</span>)</span><br><span class="line">say_hello()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Hello There</span><br><span class="line">Hello There</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="带参数的-Python-装饰器">带参数的 Python 装饰器</h3>
<p>我们想在函数中传递一些参数。让我们用下面的代码来实现:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> decorator <span class="keyword">import</span> do_twice</span><br><span class="line"><span class="meta">@do_twice</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">name</span>):</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">f&quot;Hello <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">display()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">TypeError: display() missing <span class="number">1</span> required positional argument: <span class="string">&#x27;name&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以看到，函数没有接受这个参数。运行此代码会引发错误。我们可以通过在内包装函数中使用 <em><strong>args</strong> 和 **<strong>kwargs</strong> 来修复这个错误。如下修改</em><em>装饰器:</em>*</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_twice</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper_function</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        func(*args,**kwargs)</span><br><span class="line">        func(*args,**kwargs)</span><br><span class="line">   <span class="keyword">return</span> wrapper_function</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在 <strong>wrapper_function()</strong> 可以接受任意数量的参数，并将它们传递给函数。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> decorator <span class="keyword">import</span> do_twice</span><br><span class="line"><span class="meta">@do_twice</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">name</span>):</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">f&quot;Hello <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">display(<span class="string">&quot;John&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Hello John</span><br><span class="line">Hello John</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="从修饰函数返回值">从修饰函数返回值</h3>
<p>我们可以控制修饰函数的返回类型。示例如下:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> decorator <span class="keyword">import</span> do_twice</span><br><span class="line"><span class="meta">@do_twice</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">return_greeting</span>(<span class="params">name</span>):</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;We are created greeting&quot;</span>)</span><br><span class="line">     <span class="keyword">return</span> <span class="string">f&quot;Hi <span class="subst">&#123;name&#125;</span>&quot;</span></span><br><span class="line">hi_adam = return_greeting(<span class="string">&quot;Adam&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">We are created greeting</span><br><span class="line">We are created greeting</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="高级装饰师">高级装饰师</h2>
<p>让我们通过以下话题来了解一下高级装饰师:</p>
<h3 id="阶级装饰者">阶级装饰者</h3>
<p>Python 提供了两种修饰类的方法。首先，我们可以在一个类里面修饰方法；Python 中有像 <strong>@classmethod、@staticmethod</strong> 、 <strong>@property</strong> 这样的内置装饰器。 <strong>@classmethod</strong> 和 <strong>@staticmethod</strong> 定义了类内不与类的任何其他实例连接的方法。@属性通常用于修改类属性的 getters 和 setters。让我们通过下面的例子来理解它:</p>
<p>示例:1-<strong>@属性装饰器</strong> -通过使用它，我们可以使用类函数作为属性。考虑以下代码:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,grade</span>):</span><br><span class="line">         self.name = name</span><br><span class="line">         self.grade = grade</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">         <span class="keyword">return</span> self.name + <span class="string">&quot; got grade &quot;</span> + self.grade</span><br><span class="line"></span><br><span class="line">stu = Student(<span class="string">&quot;John&quot;</span>,<span class="string">&quot;B&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Name:&quot;</span>, stu.name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Grade:&quot;</span>, stu.grade)</span><br><span class="line"><span class="built_in">print</span>(stu.display)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Name: John</span><br><span class="line">Grade: B</span><br><span class="line">John got grade B</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>示例:2-<strong>@staticmethod decorator</strong>-该@ static method 用于定义类中的一个静态方法。它通过使用类名和类的实例来调用。考虑以下代码:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line"><span class="meta">     @staticmethod</span></span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&quot;Hello Peter&quot;</span>)</span><br><span class="line">per = Person()</span><br><span class="line">per.hello()</span><br><span class="line">Person.hello()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Hello Peter</span><br><span class="line">Hello Peter</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="单例类">单例类</h3>
<p>单例类只有一个实例。Python 中有很多单例，包括 True、None 等。</p>
<h3 id="嵌套装饰者">嵌套装饰者</h3>
<p>我们可以通过将多个装饰器放在一起来使用它们。让我们考虑以下示例:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@function1</span></span><br><span class="line"><span class="meta">@function2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>(<span class="params">name</span>):</span><br><span class="line">      <span class="built_in">print</span>(f <span class="string">&quot;&#123;name&#125;&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们通过将嵌套装饰器堆叠在一起来使用它们。</p>
<h3 id="带参数的装饰器">带参数的装饰器</h3>
<p>在装饰器中传递参数总是有用的。根据给定的参数值，装饰器可以执行几次。让我们考虑下面的例子:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Import functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">repeat</span>(<span class="params">num</span>):</span><br><span class="line"></span><br><span class="line"><span class="comment">#Creating and returning a wrapper function</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator_repeat</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">        @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">                value = func(*args,**kwargs)</span><br><span class="line">             <span class="keyword">return</span> value</span><br><span class="line">          <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator_repeat</span><br><span class="line"></span><br><span class="line"><span class="comment">#Here we are passing num as an argument which repeats the print function</span></span><br><span class="line"><span class="meta">@repeat(<span class="params">num=<span class="number">5</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function1</span>(<span class="params">name</span>):</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">JavatPoint</span><br><span class="line">JavatPoint</span><br><span class="line">JavatPoint</span><br><span class="line">JavatPoint</span><br><span class="line">JavatPoint</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上例中， <strong>@repeat</strong> 指的是可以在另一个函数中调用的函数对象。 <strong>@repeat(num = 5)</strong> 将返回一个充当装饰器的函数。</p>
<p>上面的代码看起来可能很复杂，但它是最常用的装饰器模式，我们使用了一个额外的 <strong>def</strong> 来处理装饰器的参数。</p>
<h4 id="注意-带参数的-Decorator-在编程中并不常用，但它提供了灵活性。不管有没有争论，我们都可以使用它。">注意:带参数的 Decorator 在编程中并不常用，但它提供了灵活性。不管有没有争论，我们都可以使用它。</h4>
<h3 id="有状态装饰器">有状态装饰器</h3>
<p>有状态装饰器用于跟踪装饰器状态。让我们考虑这样一个例子，我们正在创建一个装饰器，计算函数被调用的次数。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Import functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_function</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">@functools.wraps(<span class="params">func</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wrapper_count_calls</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">wrapper_count_calls.num_calls += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Call<span class="subst">&#123;wrapper_count_calls.num_calls&#125;</span> of <span class="subst">&#123;func.__name__!r&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">wrapper_count_calls.num_calls = <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> wrapper_count_calls</span><br><span class="line"></span><br><span class="line"><span class="meta">@count_function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Say Hello&quot;</span>)</span><br><span class="line"></span><br><span class="line">say_hello()</span><br><span class="line">say_hello()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Call <span class="number">1</span> of <span class="string">&#x27;say_hello&#x27;</span></span><br><span class="line">Say Hello</span><br><span class="line">Call <span class="number">2</span> of <span class="string">&#x27;say_hello&#x27;</span></span><br><span class="line">Say Hello</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上述程序中，状态表示存储在<strong>中的函数的调用次数。num _ 调用包装函数上的</strong>。当我们调用 <strong>say_hello()</strong> 时，它会显示该函数的调用次数。</p>
<h3 id="装饰类">装饰类</h3>
<p>类是保持状态的最佳方式。在这一节中，我们将学习如何使用类作为装饰器。这里我们将创建一个包含 <strong><strong>init</strong>()</strong> 的类，并将<strong>函数</strong>作为参数。该类需要是可调用的，这样它就可以代替修饰函数。</p>
<p>为了使类可调用，我们实现了特殊的 <strong><strong>call</strong>()</strong> 方法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Count_Calls</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">functools.update_wrapper(self, func)</span><br><span class="line">self.func = func</span><br><span class="line">self.num_calls = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">self.num_calls += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Call<span class="subst">&#123;self.num_calls&#125;</span> of <span class="subst">&#123;self.func.__name__!r&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Count_Calls</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Say Hello&quot;</span>)</span><br><span class="line"></span><br><span class="line">say_hello()</span><br><span class="line">say_hello()</span><br><span class="line">say_hello()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Call <span class="number">1</span> of <span class="string">&#x27;say_hello&#x27;</span></span><br><span class="line">Say Hello</span><br><span class="line">Call <span class="number">2</span> of <span class="string">&#x27;say_hello&#x27;</span></span><br><span class="line">Say Hello</span><br><span class="line">Call <span class="number">3</span> of <span class="string">&#x27;say_hello&#x27;</span></span><br><span class="line">Say Hello</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong><strong>init</strong>()</strong> 方法存储对该函数的引用，并且可以进行任何其他所需的初始化。</p>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-decorator">https://www.javatpoint.com/python-decorator</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 读取csv文件</title>
    <url>/posts/404ab4d1.html</url>
    <content><![CDATA[<h1>Python 读取 csv 文件</h1>
<h2 id="CSV-文件-2">CSV 文件</h2>
<p><strong>csv</strong> 代表“逗号分隔值”，它被定义为一种简单的文件格式，使用特定的结构来排列表格数据。它以纯文本形式存储表格数据，如电子表格或数据库，并具有通用的数据交换格式。一个 <strong>csv</strong> 文件打开到 excel 表中，行和列数据定义了标准格式。</p>
<h2 id="Python-CSV-模块函数-2">Python CSV 模块函数</h2>
<p>CSV 模块工作用于处理 CSV 文件，以便从指定的列中读取/写入和获取数据。CSV 函数有不同的类型，如下所示:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>csv.field_size_limit -</strong> 返回解析器当前允许的最大字段大小。</p>
</li>
<li class="lvl-4">
<p><strong>csv.get_dialect-</strong> 返回与名字相关联的方言。</p>
</li>
<li class="lvl-4">
<p><strong>csv.list_dialect-</strong> 返回所有已注册方言的名称。</p>
</li>
<li class="lvl-4">
<p><strong>csv.reader -</strong> 它从 csv 文件中读取数据</p>
</li>
<li class="lvl-4">
<p><strong>csv.register_dialect -</strong> 它将方言与名字联系起来。该名称必须是字符串或 Unicode 对象。</p>
</li>
<li class="lvl-4">
<p><strong>csv.writer -</strong> 它将数据写入 csv 文件</p>
</li>
<li class="lvl-4">
<p><strong>csv.unregister_dialect-</strong> 它从方言注册表中删除与该名称相关联的方言。如果名称不是注册的方言名称，则会引发错误。</p>
</li>
<li class="lvl-4">
<p><strong>csv.QUOTE_MINIMAL -</strong> 它指示编写器对象引用所有字段。csv。它指示编写器对象只引用那些包含特殊字符的字段，如 quotechar、分隔符等。</p>
</li>
<li class="lvl-4">
<p><strong>csv.QUOTE_NONNUMERIC -</strong> 它指示编写器对象引用所有非数字字段。</p>
</li>
<li class="lvl-4">
<p><strong>csv.QUOTE_NONE -</strong> 它指示编写器对象永远不要引用字段。</p>
</li>
</ul>
<h2 id="正在读取-CSV-文件">正在读取 CSV 文件</h2>
<p>Python 提供了各种函数来读取 csv 文件。我们正在描述几种读取函数的方法。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>使用 csv.reader()功能</strong></p>
</li>
</ul>
<p>在 Python 中， <strong>csv.reader()</strong> 模块用于读取 csv 文件。它获取文件的每一行，并列出所有的列。</p>
<p>我们取了一个名为 python.txt 的 txt 文件，它有默认的分隔符<strong>逗号(，</strong>，数据如下:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">name,department,birthday month  </span><br><span class="line">Parker,Accounting,November  </span><br><span class="line">Smith,IT,October  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> csv  </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;python.csv&#x27;</span>) <span class="keyword">as</span> csv_file:  </span><br><span class="line">    csv_reader = csv.reader(csv_file, delimiter=<span class="string">&#x27;,&#x27;</span>)  </span><br><span class="line">    line_count = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> csv_reader:  </span><br><span class="line">        <span class="keyword">if</span> line_count == <span class="number">0</span>:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Column names are <span class="subst">&#123;<span class="string">&quot;, &quot;</span>.join(row)&#125;</span>&#x27;</span>)  </span><br><span class="line">            line_count += <span class="number">1</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Column names are name, department, birthday month</span><br><span class="line">  Parker works <span class="keyword">in</span> the Accounting department, <span class="keyword">and</span> was born <span class="keyword">in</span> November.</span><br><span class="line">  Smith works <span class="keyword">in</span> the IT department, <span class="keyword">and</span> was born <span class="keyword">in</span> October.</span><br><span class="line">Processed <span class="number">3</span> lines.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们已经使用 <strong>open()</strong> 函数打开了‘python . CSV’。我们使用 <strong>csv.reader()</strong> 函数读取文件，返回一个可迭代的 reader 对象。<strong>reader</strong>对象已经包含了数据，我们使用对循环进行迭代，以打印每行的内容</p>
<h2 id="把-csv-文件读入字典">把 csv 文件读入字典</h2>
<p>我们也可以使用 <strong>DictReader()</strong> 函数将 csv 文件直接读入字典，而不是处理单个字符串元素的列表。</p>
<p>同样，我们的输入文件 python.txt 如下:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">name,department,birthday month  </span><br><span class="line">Parker,Accounting,November  </span><br><span class="line">Smith,IT,October  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> csv    </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;python.txt&#x27;</span>, mode=<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> csv_file:  </span><br><span class="line">    csv_reader = csv.DictReader(csv_file)  </span><br><span class="line">    line_count = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> csv_reader:  </span><br><span class="line">        <span class="keyword">if</span> line_count == <span class="number">0</span>:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;The Column names are as follows <span class="subst">&#123;<span class="string">&quot;, &quot;</span>.join(row)&#125;</span>&#x27;</span>)  </span><br><span class="line">            line_count += <span class="number">1</span>  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;\t<span class="subst">&#123;row[<span class="string">&quot;name&quot;</span>]&#125;</span> works in the <span class="subst">&#123;row[<span class="string">&quot;department&quot;</span>]&#125;</span> department, and was born in <span class="subst">&#123;row[<span class="string">&quot;birthday month&quot;</span>]&#125;</span>.&#x27;</span>)  </span><br><span class="line">        line_count += <span class="number">1</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Processed <span class="subst">&#123;line_count&#125;</span> lines.&#x27;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The Column names are <span class="keyword">as</span> follows name, department, birthday month</span><br><span class="line">   Parker works <span class="keyword">in</span> the Accounting department, <span class="keyword">and</span> was born <span class="keyword">in</span> November.</span><br><span class="line">   Smith works <span class="keyword">in</span> the IT department, <span class="keyword">and</span> was born <span class="keyword">in</span> October.</span><br><span class="line">Processed <span class="number">3</span> lines.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="用-Pandas-读取-csv-文件">用 Pandas 读取 csv 文件</h2>
<p>Pandas 被定义为建立在数字图书馆之上的开源图书馆。它为用户提供快速分析、数据清理和数据准备。</p>
<p>将 csv 文件读入 Pandas<strong>DataFrame</strong>是快速直接的。我们不需要写足够多的代码来打开、分析和读取 pandas 中的 csv 文件，它将数据存储在<strong>DataFrame</strong>中。</p>
<p>这里，我们要读取一个稍微复杂一点的文件，名为 hrdata.csv，其中包含公司员工的数据。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Name,Hire Date,Salary,Leaves Remaining  </span><br><span class="line">John Idle,08/<span class="number">15</span>/<span class="number">14</span>,<span class="number">50000.00</span>,<span class="number">10</span>  </span><br><span class="line">Smith Gilliam,04/07/<span class="number">15</span>,<span class="number">65000.00</span>,<span class="number">8</span>  </span><br><span class="line">Parker Chapman,02/<span class="number">21</span>/<span class="number">14</span>,<span class="number">45000.00</span>,<span class="number">10</span>  </span><br><span class="line">Jones Palin,<span class="number">10</span>/<span class="number">14</span>/<span class="number">13</span>,<span class="number">70000.00</span>,<span class="number">3</span>  </span><br><span class="line">Terry Gilliam,07/<span class="number">22</span>/<span class="number">14</span>,<span class="number">48000.00</span>,<span class="number">7</span>  </span><br><span class="line">Michael Palin,06/<span class="number">28</span>/<span class="number">13</span>,<span class="number">66000.00</span>,<span class="number">8</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas  </span><br><span class="line">df = pandas.read_csv(<span class="string">&#x27;hrdata.csv&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(df)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，这三行足以读取文件，其中只有一行在做实际的工作，即 pandas.read_csv()</p>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">         Name                Hire Date     Salary      Leaves Remaining</span><br><span class="line"><span class="number">0</span>     John Idle              03/<span class="number">15</span>/<span class="number">14</span>      <span class="number">50000.0</span>       <span class="number">10</span></span><br><span class="line"><span class="number">1</span>     Smith Gilliam          06/01/<span class="number">15</span>      <span class="number">65000.0</span>       <span class="number">8</span></span><br><span class="line"><span class="number">2</span>     Parker Chapman         05/<span class="number">12</span>/<span class="number">14</span>      <span class="number">45000.0</span>       <span class="number">10</span></span><br><span class="line"><span class="number">3</span>     Jones Palin            <span class="number">11</span>/01/<span class="number">13</span>      <span class="number">70000.0</span>       <span class="number">3</span></span><br><span class="line"><span class="number">4</span>     Terry Gilliam          08/<span class="number">12</span>/<span class="number">14</span>      <span class="number">48000.0</span>       <span class="number">7</span></span><br><span class="line"><span class="number">5</span>     Michael Palin          05/<span class="number">23</span>/<span class="number">13</span>      <span class="number">66000.0</span>       <span class="number">8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-read-csv-file">https://www.javatpoint.com/python-read-csv-file</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 读取excel文件</title>
    <url>/posts/4e02b307.html</url>
    <content><![CDATA[<h1>Python 读取 excel 文件</h1>
<p>Excel 是微软开发的电子表格应用。它是一个易于访问的工具，用于组织、分析和存储表中的数据。它广泛应用于世界各地的许多不同应用中。从分析师到首席执行官，各种专业人士都使用 Excel 进行快速统计和认真的数据处理。</p>
<h2 id="Excel-文档">Excel 文档</h2>
<p>Excel 电子表格文档称为工作簿，保存在带有<strong>的文件中。xlsx</strong> 分机。电子表格的第一行主要保留给标题，而第一列标识采样单位。每个工作簿可以包含多个工作表，这些工作表也称为工作表。位于特定列和行的框称为单元格，每个单元格可以包含一个数字或文本值。包含数据的单元格网格形成一张工作表。</p>
<p>活动工作表被定义为用户当前正在查看或在关闭 Excel 之前最后一次查看的工作表。</p>
<h2 id="从-Excel-文件中读取">从 Excel 文件中读取</h2>
<p>首先，你需要写一个命令来安装 <strong>xlrd</strong> 模块。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install xlrd  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="创建工作簿">创建工作簿</h2>
<p>工作簿包含 excel 文件中的所有数据。您可以从头开始创建新的工作簿，也可以从已经存在的 excel 文件轻松创建工作簿。</p>
<p><strong>输入文件</strong></p>
<p>我们已经拍摄了工作簿的快照。</p>
<p><img src="/img/ee573cf6c88593de27922bf5f6c7ad7a.png" alt="Python Read Excel File"></p>
<p><strong>代码</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Import the xlrd module    </span></span><br><span class="line"><span class="keyword">import</span> xlrd   </span><br><span class="line"></span><br><span class="line"><span class="comment"># Define the location of the file   </span></span><br><span class="line">loc = (<span class="string">&quot;path of file&quot;</span>)   </span><br><span class="line"></span><br><span class="line"><span class="comment"># To open the Workbook   </span></span><br><span class="line">wb = xlrd.open_workbook(loc)   </span><br><span class="line">sheet = wb.sheet_by_index(<span class="number">0</span>)   </span><br><span class="line"></span><br><span class="line"><span class="comment"># For row 0 and column 0   </span></span><br><span class="line">sheet.cell_value(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>**说明:**在上例中，我们首先导入了 xlrd 模块，定义了文件的位置。然后，我们从已经存在的 excel 文件中打开了工作簿。</p>
<h2 id="从-Pandas-那里阅读">从 Pandas 那里阅读</h2>
<p>Pandas 被定义为建立在 NumPy 库之上的开源库。它为用户提供了快速分析、数据清理和数据准备，并支持来自 URL 的 xls 和 xlsx 扩展。</p>
<p>这是一个 python 包，它提供了一种称为数据帧的有益数据结构。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Example - </span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd  </span><br><span class="line"></span><br><span class="line"><span class="comment"># Read the file  </span></span><br><span class="line">data = pd.read_csv(<span class="string">&quot;.csv&quot;</span>, low_memory=<span class="literal">False</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># Output the number of rows  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Total rows: &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(data)))  </span><br><span class="line"></span><br><span class="line"><span class="comment"># See which headers are available  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(data))  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="阅读-openpyxl">阅读 openpyxl</h2>
<p>首先，我们需要从命令行使用 pip 安装一个 openpyxl 模块。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install openpyxl  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之后，我们需要导入模块。</p>
<p>我们还可以使用 openpyxl 从现有的电子表格中读取数据。它还允许用户执行计算并添加不属于原始数据集的内容。</p>
<p><strong>例</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> openpyxl  </span><br><span class="line">my_wb = openpyxl.Workbook()  </span><br><span class="line">my_sheet = my_wb.active  </span><br><span class="line">my_sheet_title = my_sheet.title  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My sheet title: &quot;</span> + my_sheet_title)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">My sheet title: Sheet</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-read-excel-file">https://www.javatpoint.com/python-read-excel-file</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 运算符</title>
    <url>/posts/f05d4701.html</url>
    <content><![CDATA[<h1>Python 运算符</h1>
<p>运算符可以定义为负责两个操作数之间特定操作的符号。运算符是一个程序的支柱，在这个程序上，逻辑是用特定的编程语言构建的。Python 提供了多种运算符，描述如下。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>算术运算符</p>
</li>
<li class="lvl-4">
<p>比较运算符</p>
</li>
<li class="lvl-4">
<p>赋值运算符</p>
</li>
<li class="lvl-4">
<p>逻辑运算符</p>
</li>
<li class="lvl-4">
<p>按位运算符</p>
</li>
<li class="lvl-4">
<p>成员操作符</p>
</li>
<li class="lvl-4">
<p>身份操作符</p>
</li>
</ul>
<h2 id="算术运算符">算术运算符</h2>
<p>算术运算符用于在两个操作数之间执行算术运算。它包括+(加法)、-(减法)、*(乘法)、/(除法)、%(按模取余)、//(地板除法)和指数(**)运算符。</p>
<p>有关算术运算符的详细解释，请参考下表。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>+</strong></td>
<td>它用于相加两个操作数。例如，如果 a = 20，b = 10 =&gt; a+b = 30</td>
</tr>
<tr>
<td><strong>-</strong></td>
<td>它用于从第一个操作数中减去第二个操作数。如果第一个操作数小于第二个操作数，则该值为负。例如，如果 a = 20，b = 10 =&gt; a - b = 10</td>
</tr>
<tr>
<td><strong>/</strong></td>
<td>它返回第一个操作数除以第二个操作数后的商。例如，如果 a = 20，b = 10 =&gt; a/b = 2.0</td>
</tr>
<tr>
<td>*</td>
<td>它用于将一个操作数与另一个操作数相乘。例如，如果 a = 20，b = 10 =&gt; a * b = 200</td>
</tr>
<tr>
<td><strong>%</strong></td>
<td>它在第一个操作数除以第二个操作数后返回提醒。例如，如果 a = 20，b = 10 =&gt; a%b = 0</td>
</tr>
<tr>
<td>**</td>
<td>它是一个指数运算符，表示为计算第一个操作数与第二个操作数的幂。</td>
</tr>
<tr>
<td><strong>//</strong></td>
<td>它给出了两个操作数相除所产生的商的底数。</td>
</tr>
</tbody>
</table>
<h2 id="比较运算符">比较运算符</h2>
<p>比较运算符用于比较两个操作数的值，并相应地返回布尔值 true 或 false。下表描述了比较运算符。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>如果两个操作数的值相等，则条件为真。</td>
</tr>
<tr>
<td>!=</td>
<td>如果两个操作数的值不相等，则条件为真。</td>
</tr>
<tr>
<td>&lt;=</td>
<td>如果第一个操作数小于或等于第二个操作数，则条件为真。</td>
</tr>
<tr>
<td>&gt;=</td>
<td>如果第一个操作数大于或等于第二个操作数，则条件为真。</td>
</tr>
<tr>
<td>&gt;</td>
<td>如果第一个操作数大于第二个操作数，则条件为真。</td>
</tr>
<tr>
<td>&lt;</td>
<td>如果第一个操作数小于第二个操作数，则条件为真。</td>
</tr>
</tbody>
</table>
<h2 id="赋值运算符">赋值运算符</h2>
<p>赋值运算符用于将右表达式的值赋给左操作数。下表描述了赋值运算符。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>它将右表达式的值赋给左操作数。</td>
</tr>
<tr>
<td>+=</td>
<td>它将左操作数的值增加右操作数的值，并将修改后的值分配回左操作数。例如，如果 a = 10，b = 20 =&gt; a+ = b 将等于 a = a+ b，因此 a = 30。</td>
</tr>
<tr>
<td>-=</td>
<td>它将左操作数的值减少右操作数的值，并将修改后的值分配回左操作数。例如，如果 a = 20，b = 10 =&gt; a- = b 将等于 a = a- b，因此 a = 10。</td>
</tr>
<tr>
<td>*=</td>
<td>它将左操作数的值乘以右操作数的值，并将修改后的值赋回左操作数。例如，如果 a = 10，b = 20 =&gt; a* = b 将等于 a = a* b，因此 a = 200。</td>
</tr>
<tr>
<td>%=</td>
<td>它将左操作数的值除以右操作数的值，并将提醒分配回左操作数。例如，如果 a = 20，b = 10 =&gt; a % = b 将等于 a = a % b，因此 a = 0。</td>
</tr>
<tr>
<td>**=</td>
<td>a**=b 将等于 a=a**b，例如，如果 a = 4，b =2，a**=b 将为 a 分配 4**2 = 16。</td>
</tr>
<tr>
<td>//=</td>
<td>a/= b 将等于 a = a// b，例如，如果 a = 4，b = 3，a/= b 将为 a 分配 4//3 = 1。</td>
</tr>
</tbody>
</table>
<h2 id="按位运算符">按位运算符</h2>
<p>按位运算符对两个操作数的值执行逐位运算。考虑下面的例子。</p>
<p><strong>例如</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> a = <span class="number">7</span> </span><br><span class="line">   b = <span class="number">6</span>   </span><br><span class="line">then, binary (a) = 0111  </span><br><span class="line">    binary (b) = 0110  </span><br><span class="line"></span><br><span class="line">hence, a &amp; b = 0011  </span><br><span class="line">      a | b = 0111  </span><br><span class="line">             a ^ b = <span class="number">0</span>100  </span><br><span class="line">       ~ a = <span class="number">1000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;(二进制和)</td>
<td>如果两个操作数中同一位置的两位都是 1，则 1 被复制到结果中。否则，将复制 0。</td>
</tr>
<tr>
<td>| (二进制或)</td>
<td>如果两个位都为零，则结果位将为 0；否则，结果位将为 1。</td>
</tr>
<tr>
<td>^(二进制异或)</td>
<td>如果两个位不同，则结果位将为 1；否则，结果位将为 0。</td>
</tr>
<tr>
<td>~(否定)</td>
<td>它计算操作数每个位的求反，即如果该位为 0，则结果位为 1，反之亦然。</td>
</tr>
<tr>
<td>&lt;&lt;(左移)</td>
<td>左操作数值向左移动右操作数中的位数。</td>
</tr>
<tr>
<td>&gt;&gt;(右移)</td>
<td>左操作数向右移动右操作数中的位数。</td>
</tr>
</tbody>
</table>
<h2 id="逻辑运算符">逻辑运算符</h2>
<p>逻辑运算符主要用于表达式求值以做出决策。Python 支持以下逻辑运算符。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>and</td>
<td>如果两个表达式都为真，则条件为真。如果 a 和 b 是两个表达式，a →真，b →真=&gt; a 和 b →真。</td>
</tr>
<tr>
<td>or</td>
<td>如果其中一个表达式为真，则条件为真。如果 a 和 b 是两个表达式，a →真，b →假=&gt; a 或 b →真。</td>
</tr>
<tr>
<td>not</td>
<td>如果表达式 <strong>a</strong> 为真，那么 not (a)将为假，反之亦然。</td>
</tr>
</tbody>
</table>
<h2 id="成员操作符">成员操作符</h2>
<p>Python 成员操作符用于检查 Python 数据结构中值的成员关系。如果数据结构中存在该值，则结果值为真，否则返回假。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>in</td>
<td>如果在第二个操作数(列表、元组或字典)中找到第一个操作数，则评估为真。</td>
</tr>
<tr>
<td>not in</td>
<td>如果在第二个操作数(列表、元组或字典)中找不到第一个操作数，则评估为真。</td>
</tr>
</tbody>
</table>
<h2 id="身份操作符">身份操作符</h2>
<p>标识运算符用于决定元素是某个类还是某个类型。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>is</td>
<td>如果两侧的引用指向同一个对象，则评估为真。</td>
</tr>
<tr>
<td>is not</td>
<td>如果两侧的引用不指向同一个对象，则评估为真。</td>
</tr>
</tbody>
</table>
<h2 id="运算符优先级">运算符优先级</h2>
<p>运算符的优先级对于找出答案是至关重要的，因为它使我们能够知道应该首先评估哪个运算符。下面给出了 Python 中运算符的优先级表。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>**</td>
<td>指数运算符的优先级高于表达式中使用的所有其他运算符。</td>
</tr>
<tr>
<td>~ + -</td>
<td>否定，一元正和负。</td>
</tr>
<tr>
<td>* / % //</td>
<td>乘法、除法、模块、提醒和楼层划分。</td>
</tr>
<tr>
<td>+ -</td>
<td>二进制加减</td>
</tr>
<tr>
<td>&gt;&gt; &lt;&lt;</td>
<td>左移。右移</td>
</tr>
<tr>
<td>&amp;</td>
<td>二进制和。</td>
</tr>
<tr>
<td>^|</td>
<td>二进制异或，与或</td>
</tr>
<tr>
<td>&lt;= &lt; &gt; &gt;=</td>
<td>比较运算符(小于、小于等于、大于、大于等于)。</td>
</tr>
<tr>
<td>&lt;&gt; == !=</td>
<td>等式运算符。</td>
</tr>
<tr>
<td>= %= /= //= -= +=</td>
<td></td>
</tr>
<tr>
<td>*= **=</td>
<td>赋值运算符</td>
</tr>
<tr>
<td>is is not</td>
<td>身份运算符</td>
</tr>
<tr>
<td>n not in</td>
<td>成员操作符</td>
</tr>
<tr>
<td>not or and</td>
<td>逻辑运算符</td>
</tr>
</tbody>
</table>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-operators">https://www.javatpoint.com/python-operators</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 集合</title>
    <url>/posts/d8744cec.html</url>
    <content><![CDATA[<h1>Python 集合</h1>
<p>Python 集合是无序项目的集合。集合中的每个元素必须是唯一的、不可变的，并且集合移除重复的元素。集合是可变的，这意味着我们可以在它创建后修改它。</p>
<p>与 Python 中的其他集合不同，集合的元素没有附加索引，即我们不能通过索引直接访问集合的任何元素。但是，我们可以一起打印它们，或者我们可以通过循环集合来获得元素列表。</p>
<h2 id="创建集合">创建集合</h2>
<p>可以通过用花括号{}将逗号分隔的不可变项括起来来创建集合。Python 还提供了 set()方法，可用于通过传递的序列创建集合。</p>
<h3 id="示例-1-使用大括号">示例 1:使用大括号</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Days = &#123;<span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span>, <span class="string">&quot;Sunday&quot;</span>&#125;  </span><br><span class="line"><span class="built_in">print</span>(Days)  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Days))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;looping through the set elements ... &quot;</span>)  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Days:  </span><br><span class="line">    <span class="built_in">print</span>(i)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;Friday&#x27;</span>, <span class="string">&#x27;Tuesday&#x27;</span>, <span class="string">&#x27;Monday&#x27;</span>, <span class="string">&#x27;Saturday&#x27;</span>, <span class="string">&#x27;Thursday&#x27;</span>, <span class="string">&#x27;Sunday&#x27;</span>, <span class="string">&#x27;Wednesday&#x27;</span>&#125;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;set&#x27;</span>&gt;</span><br><span class="line">looping through the <span class="built_in">set</span> elements ... </span><br><span class="line">Friday</span><br><span class="line">Tuesday</span><br><span class="line">Monday</span><br><span class="line">Saturday</span><br><span class="line">Thursday</span><br><span class="line">Sunday</span><br><span class="line">Wednesday</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="示例-2-使用-set-方法">示例 2:使用 set()方法</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Days = <span class="built_in">set</span>([<span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span>, <span class="string">&quot;Sunday&quot;</span>])  </span><br><span class="line"><span class="built_in">print</span>(Days)  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Days))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;looping through the set elements ... &quot;</span>)  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Days:  </span><br><span class="line">    <span class="built_in">print</span>(i)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;Friday&#x27;</span>, <span class="string">&#x27;Wednesday&#x27;</span>, <span class="string">&#x27;Thursday&#x27;</span>, <span class="string">&#x27;Saturday&#x27;</span>, <span class="string">&#x27;Monday&#x27;</span>, <span class="string">&#x27;Tuesday&#x27;</span>, <span class="string">&#x27;Sunday&#x27;</span>&#125;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;set&#x27;</span>&gt;</span><br><span class="line">looping through the <span class="built_in">set</span> elements ... </span><br><span class="line">Friday</span><br><span class="line">Wednesday</span><br><span class="line">Thursday</span><br><span class="line">Saturday</span><br><span class="line">Monday</span><br><span class="line">Tuesday</span><br><span class="line">Sunday</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它可以包含任何类型的元素，如整数、浮点、元组等。但是可变元素(列表、字典、集合)不能是集合的成员。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creating a set which have immutable elements</span></span><br><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>, <span class="string">&quot;JavaTpoint&quot;</span>, <span class="number">20.5</span>, <span class="number">14</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(set1))</span><br><span class="line"><span class="comment">#Creating a set which have mutable element</span></span><br><span class="line">set2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="string">&quot;Javatpoint&quot;</span>,<span class="number">4</span>]&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(set2))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;set&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">5</span>-9605bb6fbc68&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">      <span class="number">4</span> </span><br><span class="line">      <span class="number">5</span> <span class="comment">#Creating a set which holds mutable elements</span></span><br><span class="line">----&gt; <span class="number">6</span> set2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="string">&quot;Javatpoint&quot;</span>,<span class="number">4</span>]&#125;</span><br><span class="line">      <span class="number">7</span> <span class="built_in">print</span>(<span class="built_in">type</span>(set2))</span><br><span class="line"></span><br><span class="line">TypeError: unhashable <span class="built_in">type</span>: <span class="string">&#x27;list&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们创建了两个集合，集合 <strong>集合</strong> 有不可变元素，set2 有一个可变元素作为列表。在检查 set2 的类型时，它引发了一个错误，这意味着 set 只能包含不可变的元素。</p>
<p>创建空集合有点不同，因为空的大括号{}也用于创建字典。所以 Python 提供了 set()方法，在没有参数的情况下创建一个空集合。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Empty curly braces will create dictionary</span></span><br><span class="line">set3 = &#123;&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(set3))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Empty set using set() function</span></span><br><span class="line">set4 = <span class="built_in">set</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(set4))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;set&#x27;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>让我们看看如果我们向集合提供重复的元素会发生什么。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">set5 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">10</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Return set with unique elements:&quot;</span>,set5)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Return <span class="built_in">set</span> <span class="keyword">with</span> unique elements: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们可以看到 <strong>set5</strong> 由多个重复的元素组成，当我们打印它时，从集合中移除重复。</p>
<h2 id="向集合中添加项目">向集合中添加项目</h2>
<p>Python 提供了 <strong>add()</strong> 方法和 <strong>update()</strong> 方法，可用于向集合中添加特定的项目。add()方法用于添加单个元素，而 update()方法用于向集合中添加多个元素。考虑下面的例子。</p>
<h3 id="示例-1-使用-add-方法">示例:1 -使用 add()方法</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Months = <span class="built_in">set</span>([<span class="string">&quot;January&quot;</span>,<span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nprinting the original set ... &quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(months)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nAdding other months to the set...&quot;</span>);  </span><br><span class="line">Months.add(<span class="string">&quot;July&quot;</span>);  </span><br><span class="line">Months.add (<span class="string">&quot;August&quot;</span>);  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nPrinting the modified set...&quot;</span>);  </span><br><span class="line"><span class="built_in">print</span>(Months)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nlooping through the set elements ... &quot;</span>)  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Months:  </span><br><span class="line">    <span class="built_in">print</span>(i)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">printing the original <span class="built_in">set</span> ... </span><br><span class="line">&#123;<span class="string">&#x27;February&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;April&#x27;</span>, <span class="string">&#x27;March&#x27;</span>, <span class="string">&#x27;June&#x27;</span>, <span class="string">&#x27;January&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">Adding other months to the <span class="built_in">set</span>...</span><br><span class="line"></span><br><span class="line">Printing the modified <span class="built_in">set</span>...</span><br><span class="line">&#123;<span class="string">&#x27;February&#x27;</span>, <span class="string">&#x27;July&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;April&#x27;</span>, <span class="string">&#x27;March&#x27;</span>, <span class="string">&#x27;August&#x27;</span>, <span class="string">&#x27;June&#x27;</span>, <span class="string">&#x27;January&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">looping through the <span class="built_in">set</span> elements ... </span><br><span class="line">February</span><br><span class="line">July</span><br><span class="line">May</span><br><span class="line">April</span><br><span class="line">March</span><br><span class="line">August</span><br><span class="line">June</span><br><span class="line">January </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要在集合中添加多个项目，Python 提供了 <strong>update()</strong> 方法。它接受 iterable 作为参数。</p>
<p>考虑下面的例子。</p>
<h3 id="示例-2-使用-update-函数">示例- 2 使用 update()函数</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Months = <span class="built_in">set</span>([<span class="string">&quot;January&quot;</span>,<span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nprinting the original set ... &quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(Months)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nupdating the original set ... &quot;</span>)  </span><br><span class="line">Months.update([<span class="string">&quot;July&quot;</span>,<span class="string">&quot;August&quot;</span>,<span class="string">&quot;September&quot;</span>,<span class="string">&quot;October&quot;</span>]);  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nprinting the modified set ... &quot;</span>)   </span><br><span class="line"><span class="built_in">print</span>(Months);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">printing the original <span class="built_in">set</span> ... </span><br><span class="line">&#123;<span class="string">&#x27;January&#x27;</span>, <span class="string">&#x27;February&#x27;</span>, <span class="string">&#x27;April&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;June&#x27;</span>, <span class="string">&#x27;March&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">updating the original <span class="built_in">set</span> ... </span><br><span class="line">printing the modified <span class="built_in">set</span> ... </span><br><span class="line">&#123;<span class="string">&#x27;January&#x27;</span>, <span class="string">&#x27;February&#x27;</span>, <span class="string">&#x27;April&#x27;</span>, <span class="string">&#x27;August&#x27;</span>, <span class="string">&#x27;October&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;June&#x27;</span>, <span class="string">&#x27;July&#x27;</span>, <span class="string">&#x27;September&#x27;</span>, <span class="string">&#x27;March&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="从集合中移除项目">从集合中移除项目</h2>
<p>Python 提供了 <strong>discard()</strong> 方法和 <strong>remove()</strong> 方法。这些函数之间的区别，使用 discard()函数如果集合中不存在该项，则集合保持不变，而 remove()方法将通过一个错误。</p>
<p>考虑下面的例子。</p>
<h3 id="示例-1-使用discard-方法">示例-1 使用discard()方法</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">months = <span class="built_in">set</span>([<span class="string">&quot;January&quot;</span>,<span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nprinting the original set ... &quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(months)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nRemoving some months from the set...&quot;</span>);  </span><br><span class="line">months.discard(<span class="string">&quot;January&quot;</span>);  </span><br><span class="line">months.discard(<span class="string">&quot;May&quot;</span>);  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nPrinting the modified set...&quot;</span>);  </span><br><span class="line"><span class="built_in">print</span>(months)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nlooping through the set elements ... &quot;</span>)  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> months:  </span><br><span class="line">    <span class="built_in">print</span>(i)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">printing the original <span class="built_in">set</span> ... </span><br><span class="line">&#123;<span class="string">&#x27;February&#x27;</span>, <span class="string">&#x27;January&#x27;</span>, <span class="string">&#x27;March&#x27;</span>, <span class="string">&#x27;April&#x27;</span>, <span class="string">&#x27;June&#x27;</span>, <span class="string">&#x27;May&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">Removing some months <span class="keyword">from</span> the <span class="built_in">set</span>...</span><br><span class="line"></span><br><span class="line">Printing the modified <span class="built_in">set</span>...</span><br><span class="line">&#123;<span class="string">&#x27;February&#x27;</span>, <span class="string">&#x27;March&#x27;</span>, <span class="string">&#x27;April&#x27;</span>, <span class="string">&#x27;June&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">looping through the <span class="built_in">set</span> elements ... </span><br><span class="line">February</span><br><span class="line">March</span><br><span class="line">April</span><br><span class="line">June</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Python 还提供了 <strong>remove()</strong> 方法来从集合中移除项目。考虑以下示例，使用 <strong>remove()</strong> 方法移除项目。</p>
<h3 id="示例-2-使用-remove-函数">示例-2 使用 remove()函数</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">months = <span class="built_in">set</span>([<span class="string">&quot;January&quot;</span>,<span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nprinting the original set ... &quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(months)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nRemoving some months from the set...&quot;</span>);  </span><br><span class="line">months.remove(<span class="string">&quot;January&quot;</span>);  </span><br><span class="line">months.remove(<span class="string">&quot;May&quot;</span>);  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nPrinting the modified set...&quot;</span>);  </span><br><span class="line"><span class="built_in">print</span>(months)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">printing the original <span class="built_in">set</span> ... </span><br><span class="line">&#123;<span class="string">&#x27;February&#x27;</span>, <span class="string">&#x27;June&#x27;</span>, <span class="string">&#x27;April&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;January&#x27;</span>, <span class="string">&#x27;March&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">Removing some months <span class="keyword">from</span> the <span class="built_in">set</span>...</span><br><span class="line"></span><br><span class="line">Printing the modified <span class="built_in">set</span>...</span><br><span class="line">&#123;<span class="string">&#x27;February&#x27;</span>, <span class="string">&#x27;June&#x27;</span>, <span class="string">&#x27;April&#x27;</span>, <span class="string">&#x27;March&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们还可以使用 pop()方法移除该项。一般来说，pop()方法总是会删除最后一项，但是集合是无序的，我们无法确定从集合中弹出哪个元素。</p>
<p>考虑以下示例，使用 pop()方法从集合中移除该项。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Months = <span class="built_in">set</span>([<span class="string">&quot;January&quot;</span>,<span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nprinting the original set ... &quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(Months)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nRemoving some months from the set...&quot;</span>);  </span><br><span class="line">Months.pop();  </span><br><span class="line">Months.pop();  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nPrinting the modified set...&quot;</span>);  </span><br><span class="line"><span class="built_in">print</span>(Months)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">printing the original <span class="built_in">set</span> ... </span><br><span class="line">&#123;<span class="string">&#x27;June&#x27;</span>, <span class="string">&#x27;January&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;April&#x27;</span>, <span class="string">&#x27;February&#x27;</span>, <span class="string">&#x27;March&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">Removing some months <span class="keyword">from</span> the <span class="built_in">set</span>...</span><br><span class="line"></span><br><span class="line">Printing the modified <span class="built_in">set</span>...</span><br><span class="line">&#123;<span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;April&#x27;</span>, <span class="string">&#x27;February&#x27;</span>, <span class="string">&#x27;March&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，Months集合的最后一个元素是<strong>March</strong>，但是 pop()方法删除了June和 January，因为集合是无序的，pop()方法无法确定集合的最后一个元素。</p>
<p>Python 提供了 clear()方法来从集合中移除所有项目。</p>
<p>考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Months = <span class="built_in">set</span>([<span class="string">&quot;January&quot;</span>,<span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nprinting the original set ... &quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(Months)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nRemoving all the items from the set...&quot;</span>);  </span><br><span class="line">Months.clear()  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nPrinting the modified set...&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(Months)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">printing the original <span class="built_in">set</span> ... </span><br><span class="line">&#123;<span class="string">&#x27;January&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;June&#x27;</span>, <span class="string">&#x27;April&#x27;</span>, <span class="string">&#x27;March&#x27;</span>, <span class="string">&#x27;February&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">Removing <span class="built_in">all</span> the items <span class="keyword">from</span> the <span class="built_in">set</span>...</span><br><span class="line"></span><br><span class="line">Printing the modified <span class="built_in">set</span>...</span><br><span class="line"><span class="built_in">set</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="丢弃-和移除-之间的区别">丢弃()和移除()之间的区别</h2>
<p>尽管 <strong>discard()</strong> 和 <strong>remove()</strong> 方法都执行相同的任务，但是 discard()和 remove()之间有一个主要区别。</p>
<p>如果要使用 discard()从集合中删除的密钥在集合中不存在，Python 不会给出错误。程序保持其控制流程。</p>
<p>另一方面，如果要使用 remove()从集合中删除的项目在集合中不存在，Python 将会引发错误。</p>
<p>考虑下面的例子。</p>
<h3 id="示例-14">示例-</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Months = <span class="built_in">set</span>([<span class="string">&quot;January&quot;</span>,<span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nprinting the original set ... &quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(Months)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nRemoving items through discard() method...&quot;</span>);  </span><br><span class="line">Months.discard(<span class="string">&quot;Feb&quot;</span>); <span class="comment">#will not give an error although the key feb is not available in the set  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nprinting the modified set...&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(Months)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nRemoving items through remove() method...&quot;</span>);  </span><br><span class="line">Months.remove(<span class="string">&quot;Jan&quot;</span>) <span class="comment">#will give an error as the key jan is not available in the set.   </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nPrinting the modified set...&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(Months)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">printing the original <span class="built_in">set</span> ... </span><br><span class="line">&#123;<span class="string">&#x27;March&#x27;</span>, <span class="string">&#x27;January&#x27;</span>, <span class="string">&#x27;April&#x27;</span>, <span class="string">&#x27;June&#x27;</span>, <span class="string">&#x27;February&#x27;</span>, <span class="string">&#x27;May&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">Removing items through discard() method...</span><br><span class="line"></span><br><span class="line">printing the modified <span class="built_in">set</span>...</span><br><span class="line">&#123;<span class="string">&#x27;March&#x27;</span>, <span class="string">&#x27;January&#x27;</span>, <span class="string">&#x27;April&#x27;</span>, <span class="string">&#x27;June&#x27;</span>, <span class="string">&#x27;February&#x27;</span>, <span class="string">&#x27;May&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">Removing items through remove() method...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;set.py&quot;</span>, line <span class="number">9</span>, <span class="keyword">in</span> </span><br><span class="line">    Months.remove(<span class="string">&quot;Jan&quot;</span>)</span><br><span class="line">KeyError: <span class="string">&#x27;Jan&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Python-集合运算">Python 集合运算</h2>
<p>集合可以进行数学运算，如并集、交集、差集和对称差集。Python 提供了用操作符或方法执行这些操作的工具。我们将这些操作描述如下。</p>
<h3 id="两个集合的并集">两个集合的并集</h3>
<p>两个集合的并集是使用管道(|)运算符计算的。这两个集合的并集包含这两个集合中存在的所有项。</p>
<p><img src="/img/233a7422ede4ec409b1a52c498e53e03.png" alt="Python Set"></p>
<p>考虑下面的例子来计算两个集合的并集。</p>
<p><strong>例 1:使用 |运算符</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Days1 = &#123;<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;Tuesday&quot;</span>,<span class="string">&quot;Wednesday&quot;</span>,<span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Sunday&quot;</span>&#125;  </span><br><span class="line">Days2 = &#123;<span class="string">&quot;Friday&quot;</span>,<span class="string">&quot;Saturday&quot;</span>,<span class="string">&quot;Sunday&quot;</span>&#125;  </span><br><span class="line"><span class="built_in">print</span>(Days1|Days2) <span class="comment">#printing the union of the sets   </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;Friday&#x27;</span>, <span class="string">&#x27;Sunday&#x27;</span>, <span class="string">&#x27;Saturday&#x27;</span>, <span class="string">&#x27;Tuesday&#x27;</span>, <span class="string">&#x27;Wednesday&#x27;</span>, <span class="string">&#x27;Monday&#x27;</span>, <span class="string">&#x27;Thursday&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Python 还提供了 <strong>union()</strong> 方法，也可以用来计算两个集合的并集。考虑下面的例子。</p>
<p><strong>例 2:使用 union()方法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Days1 = &#123;<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;Tuesday&quot;</span>,<span class="string">&quot;Wednesday&quot;</span>,<span class="string">&quot;Thursday&quot;</span>&#125;  </span><br><span class="line">Days2 = &#123;<span class="string">&quot;Friday&quot;</span>,<span class="string">&quot;Saturday&quot;</span>,<span class="string">&quot;Sunday&quot;</span>&#125;  </span><br><span class="line"><span class="built_in">print</span>(Days1.union(Days2)) <span class="comment">#printing the union of the sets   </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;Friday&#x27;</span>, <span class="string">&#x27;Monday&#x27;</span>, <span class="string">&#x27;Tuesday&#x27;</span>, <span class="string">&#x27;Thursday&#x27;</span>, <span class="string">&#x27;Wednesday&#x27;</span>, <span class="string">&#x27;Sunday&#x27;</span>, <span class="string">&#x27;Saturday&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="两个集合的交集">两个集合的交集</h3>
<p>两个集合的交集可以通过 <strong>&amp;</strong> 操作符或 <strong>intersection()</strong> 进行。两个集合的交集被给出为两个集合中公共的元素的集合。</p>
<p><img src="/img/f72532e85c58972275ffd7713edd3fe6.png" alt="Python Set"></p>
<p>考虑下面的例子。</p>
<p><strong>例 1:使用&amp;算子</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Days1 = &#123;<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>&#125;  </span><br><span class="line">Days2 = &#123;<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;Tuesday&quot;</span>,<span class="string">&quot;Sunday&quot;</span>, <span class="string">&quot;Friday&quot;</span>&#125;  </span><br><span class="line"><span class="built_in">print</span>(Days1&amp;Days2) <span class="comment">#prints the intersection of the two sets  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;Monday&#x27;</span>, <span class="string">&#x27;Tuesday&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例 2:使用交集()方法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">set1 = &#123;<span class="string">&quot;Devansh&quot;</span>,<span class="string">&quot;John&quot;</span>, <span class="string">&quot;David&quot;</span>, <span class="string">&quot;Martin&quot;</span>&#125;  </span><br><span class="line">set2 = &#123;<span class="string">&quot;Steve&quot;</span>, <span class="string">&quot;Milan&quot;</span>, <span class="string">&quot;David&quot;</span>, <span class="string">&quot;Martin&quot;</span>&#125;  </span><br><span class="line"><span class="built_in">print</span>(set1.intersection(set2)) <span class="comment">#prints the intersection of the two sets  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;Martin&#x27;</span>, <span class="string">&#x27;David&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例 3:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">20</span>,<span class="number">32</span>,<span class="number">5</span>,<span class="number">9</span>&#125;</span><br><span class="line">set3 = set1.intersection(set2)</span><br><span class="line"><span class="built_in">print</span>(set3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="intersection-update-方法">intersection_update()方法</h2>
<p><strong>intersection_update()</strong> 方法从原始集合中移除两个集合中不存在的项目(如果指定了多个集合，则移除所有集合)。</p>
<p><strong>intersection_update()</strong> 方法不同于intersection()方法，因为它通过移除不需要的项目来修改原始集合，另一方面，intersection()方法返回新的集合。</p>
<p>考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&quot;Devansh&quot;</span>, <span class="string">&quot;bob&quot;</span>, <span class="string">&quot;castle&quot;</span>&#125;  </span><br><span class="line">b = &#123;<span class="string">&quot;castle&quot;</span>, <span class="string">&quot;dude&quot;</span>, <span class="string">&quot;emyway&quot;</span>&#125;  </span><br><span class="line">c = &#123;<span class="string">&quot;fuson&quot;</span>, <span class="string">&quot;gaurav&quot;</span>, <span class="string">&quot;castle&quot;</span>&#125;  </span><br><span class="line"></span><br><span class="line">a.intersection_update(b, c)  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;castle&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="两套之间的差异">两套之间的差异</h2>
<p>两个集合的差可以用减法(-)运算符或 <strong>difference()</strong> 方法计算。假设有两个集合 A 和 B，不同的是 A-B 表示结果集合将获得集合 B 中不存在的元素 A</p>
<p><img src="/img/ae18426476e170c9a939dc15210de8fa.png" alt="Python Set"></p>
<p>考虑下面的例子。</p>
<p><strong>例 1:使用减法(-)运算符</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Days1 = &#123;<span class="string">&quot;Monday&quot;</span>,  <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>&#125;  </span><br><span class="line">Days2 = &#123;<span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Sunday&quot;</span>&#125;  </span><br><span class="line"><span class="built_in">print</span>(Days1-Days2) <span class="comment">#&#123;&quot;Wednesday&quot;, &quot;Thursday&quot; will be printed&#125;  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;Thursday&#x27;</span>, <span class="string">&#x27;Wednesday&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例 2:使用difference()方法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Days1 = &#123;<span class="string">&quot;Monday&quot;</span>,  <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>&#125;  </span><br><span class="line">Days2 = &#123;<span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Sunday&quot;</span>&#125;  </span><br><span class="line"><span class="built_in">print</span>(Days1.difference(Days2)) <span class="comment"># prints the difference of the two sets Days1 and Days2  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;Thursday&#x27;</span>, <span class="string">&#x27;Wednesday&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="两组对称差">两组对称差</h2>
<p>两组对称差用^算子或 <strong>symmetric_difference()</strong> 法计算。集合的对称差，它去掉了存在于两个集合中的元素。考虑以下示例:</p>
<p><img src="/img/d04dd5a83e71270c7b8979a1cbfdadc5.png" alt="Python Set"></p>
<p><strong>示例- 1:使用^算子</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">b = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">10</span>&#125;</span><br><span class="line">c = a^b</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例- 2:使用symmetric_difference()方法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">b = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">10</span>&#125;</span><br><span class="line">c = a.symmetric_difference(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="设置比较">设置比较</h2>
<p>Python 允许我们对集合使用比较运算符，即、&lt;=, &gt; =、==，通过比较运算符，我们可以检查一个集合是子集、超集还是其他集合的等价集合。根据集合中存在的项目，返回布尔值 true 或 false。</p>
<p>考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Days1 = &#123;<span class="string">&quot;Monday&quot;</span>,  <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>&#125;  </span><br><span class="line">Days2 = &#123;<span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>&#125;  </span><br><span class="line">Days3 = &#123;<span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Friday&quot;</span>&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">#Days1 is the superset of Days2 hence it will print true.   </span></span><br><span class="line"><span class="built_in">print</span> (Days1&gt;Days2)   </span><br><span class="line"></span><br><span class="line"><span class="comment">#prints false since Days1 is not the subset of Days2   </span></span><br><span class="line"><span class="built_in">print</span> (Days1</span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="FrozenSets">FrozenSets</h2>
<p>冻结集是正规集的不可变形式，即冻结集的项目不能改变，因此它可以用作字典中的关键字。</p>
<p>创建后不能更改冻结集的元素。我们不能通过使用 add()或 remove()等方法来更改或追加冻结集的内容。</p>
<p>frozenset()方法用于创建 frozenset 对象。可迭代序列被传递到这个方法中，该方法被转换成冻结集作为该方法的返回类型。</p>
<p>考虑以下示例来创建冻结集。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Frozenset = <span class="built_in">frozenset</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])   </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Frozenset))  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nprinting the content of frozen set...&quot;</span>)  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Frozenset:  </span><br><span class="line">    <span class="built_in">print</span>(i);  </span><br><span class="line">Frozenset.add(<span class="number">6</span>) <span class="comment">#gives an error since we cannot change the content of Frozenset after creation   </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;frozenset&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line">printing the content of frozen <span class="built_in">set</span>...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;set.py&quot;</span>, line <span class="number">6</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    Frozenset.add(<span class="number">6</span>) <span class="comment">#gives an error since we can change the content of Frozenset after creation </span></span><br><span class="line">AttributeError: <span class="string">&#x27;frozenset&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;add&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="为字典做准备">为字典做准备</h2>
<p>如果我们将字典作为 frozenset()方法中的序列传递，它将只从字典中获取键，并返回一个 frozenset，该 frozen set 包含字典的键作为其元素。</p>
<p>考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Dictionary = &#123;<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Country&quot;</span>:<span class="string">&quot;USA&quot;</span>, <span class="string">&quot;ID&quot;</span>:<span class="number">101</span>&#125;   </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Dictionary))  </span><br><span class="line">Frozenset = <span class="built_in">frozenset</span>(Dictionary); <span class="comment">#Frozenset will contain the keys of the dictionary  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Frozenset))  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Frozenset:   </span><br><span class="line">    <span class="built_in">print</span>(i)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;frozenset&#x27;</span>&gt;</span><br><span class="line">Name</span><br><span class="line">Country</span><br><span class="line">ID</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="设置编程示例">设置编程示例</h3>
<p><strong>示例- 1:</strong> 编写一个程序，从集合中删除给定的数字。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">my_set = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">24</span>&#125;</span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the number you want to remove&quot;</span>))</span><br><span class="line">my_set.discard(n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;After Removing:&quot;</span>,my_set)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter the number you want to remove:<span class="number">12</span></span><br><span class="line">After Removing: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">24</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例- 2:</strong> 编写一个程序，向集合中添加多个元素。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">set1 = <span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="string">&quot;John&quot;</span>,<span class="string">&quot;CS&quot;</span>])</span><br><span class="line">set1.update([<span class="string">&quot;Apple&quot;</span>,<span class="string">&quot;Mango&quot;</span>,<span class="string">&quot;Grapes&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(set1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;CS&#x27;</span>, <span class="string">&#x27;Mango&#x27;</span>, <span class="string">&#x27;Grapes&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例- 3:</strong> 写一个程序，求两个集合的并集。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">set1 = <span class="built_in">set</span>([<span class="string">&quot;Peter&quot;</span>,<span class="string">&quot;Joseph&quot;</span>, <span class="number">65</span>,<span class="number">59</span>,<span class="number">96</span>])</span><br><span class="line">set2  = <span class="built_in">set</span>([<span class="string">&quot;Peter&quot;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;Joseph&quot;</span>])</span><br><span class="line">set3 = set1.union(set2)</span><br><span class="line"><span class="built_in">print</span>(set3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">96</span>, <span class="number">65</span>, <span class="number">2</span>, <span class="string">&#x27;Joseph&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;Peter&#x27;</span>, <span class="number">59</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例- 4:</strong> 写一个程序，找出两个集合的交集。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">set1 = &#123;<span class="number">23</span>,<span class="number">44</span>,<span class="number">56</span>,<span class="number">67</span>,<span class="number">90</span>,<span class="number">45</span>,<span class="string">&quot;Javatpoint&quot;</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">13</span>,<span class="number">23</span>,<span class="number">56</span>,<span class="number">76</span>,<span class="string">&quot;Sachin&quot;</span>&#125;</span><br><span class="line">set3 = set1.intersection(set2)</span><br><span class="line"><span class="built_in">print</span>(set3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">56</span>, <span class="number">23</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例- 5:</strong> 编写向 frozenset 添加元素的程序。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">set1 = &#123;<span class="number">23</span>,<span class="number">44</span>,<span class="number">56</span>,<span class="number">67</span>,<span class="number">90</span>,<span class="number">45</span>,<span class="string">&quot;Javatpoint&quot;</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">13</span>,<span class="number">23</span>,<span class="number">56</span>,<span class="number">76</span>,<span class="string">&quot;Sachin&quot;</span>&#125;</span><br><span class="line">set3 = set1.intersection(set2)</span><br><span class="line"><span class="built_in">print</span>(set3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">TypeError: <span class="string">&#x27;frozenset&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的代码引发了一个错误，因为 frozensets 是不可变的，创建后不能更改。</p>
<p><strong>例- 6:</strong> 编写程序，找到subset、superset。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">set1 = <span class="built_in">set</span>([<span class="string">&quot;Peter&quot;</span>,<span class="string">&quot;James&quot;</span>,<span class="string">&quot;Camroon&quot;</span>,<span class="string">&quot;Ricky&quot;</span>,<span class="string">&quot;Donald&quot;</span>])</span><br><span class="line">set2 = <span class="built_in">set</span>([<span class="string">&quot;Camroon&quot;</span>,<span class="string">&quot;Washington&quot;</span>,<span class="string">&quot;Peter&quot;</span>])</span><br><span class="line">set3 = <span class="built_in">set</span>([<span class="string">&quot;Peter&quot;</span>])</span><br><span class="line"></span><br><span class="line">issubset = set1 &gt;= set2</span><br><span class="line"><span class="built_in">print</span>(issubset)</span><br><span class="line">issuperset = set1 &lt;= set2</span><br><span class="line"><span class="built_in">print</span>(issuperset)</span><br><span class="line">issubset = set3 &lt;= set2</span><br><span class="line"><span class="built_in">print</span>(issubset)</span><br><span class="line">issuperset = set2 &gt;= set3</span><br><span class="line"><span class="built_in">print</span>(issuperset)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Python-内置的集合方法">Python 内置的集合方法</h2>
<p>Python 包含以下用于集合的方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>add(item)</td>
<td>它向集合中添加一个项目。如果该项目已经存在于集合中，则没有效果。</td>
</tr>
<tr>
<td>clear()</td>
<td>它会从集合中删除所有项目。</td>
</tr>
<tr>
<td>copy()</td>
<td>它返回集合的一个浅拷贝。</td>
</tr>
<tr>
<td>difference_update(…)</td>
<td>它通过删除指定集合中的所有项目来修改该集合。</td>
</tr>
<tr>
<td>discard(item)</td>
<td>它从集合中移除指定的项目。</td>
</tr>
<tr>
<td>intersection()</td>
<td>它返回一个只包含两个集合的公共元素的新集合。(如果指定了两个以上的集合，则为所有集合)。</td>
</tr>
<tr>
<td>intersection_update(…)</td>
<td>它从原始集合中删除两个集合中不存在的项目(如果指定了多个集合，则删除所有集合)。</td>
</tr>
<tr>
<td>Isdisjoint(…)</td>
<td>如果两个集合有空交集，则返回真。</td>
</tr>
<tr>
<td>Issubset（…）</td>
<td>报告另一个集合是否包含此集合。</td>
</tr>
<tr>
<td>Issuperset(…)</td>
<td>报告此集合是否包含另一个集合。</td>
</tr>
<tr>
<td>pop()</td>
<td>移除并返回任意集合元素，即该集合的最后一个元素。如果集合为空，则引发键错误。</td>
</tr>
<tr>
<td>remove(item)</td>
<td>从集合中移除元素；它必须是一个成员。如果元素不是成员，则引发键错误。</td>
</tr>
<tr>
<td>symmetric_difference(…)</td>
<td>从集合中移除元素；它必须是一个成员。如果元素不是成员，则引发键错误。</td>
</tr>
<tr>
<td>symmetric_difference_update(…)</td>
<td>用自身和另一个的对称差更新一个集合。</td>
</tr>
<tr>
<td>union(…)</td>
<td>将集合的并集作为新集合返回。(即任一集合中的所有元素。)</td>
</tr>
<tr>
<td>update()</td>
<td>用自己和他人的联合来更新集合。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-set">https://www.javatpoint.com/python-set</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的`nsetools`</title>
    <url>/posts/501fc57a.html</url>
    <content><![CDATA[<h1>Python 中的<code>nsetools</code></h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/nsetools-in-python">https://www.javatpoint.com/nsetools-in-python</a></p>
</blockquote>
<p>在下面的教程中，我们将讨论 Python 编程语言中的 <strong>nsetools</strong> 库。我们将了解它的特点，并通过一些例子来说明。</p>
<p>那么，让我们开始吧。</p>
<h2 id="了解nsetools库">了解<code>nsetools</code>库</h2>
<p>印度国家证券交易所有限公司是印度主要的证券交易所，位于马哈拉施特拉邦的孟买。NSE 成立于 1992 年，是该国第一个非物质化的电子交易所。</p>
<p>Python 提供了一个库，允许程序员从国家证券交易所(印度)收集实时数据。这个库被称为<strong>n 工具</strong>。我们可以在不同的项目中使用这个库，这需要为提供的指数或股票获取实时报价，或者为进一步的数据分析创建大量的数据集。我们还可以创建命令行界面应用，以极快的速度向我们提供实时市场的详细信息，比任何网络浏览器都快。数据准确性仅与印度国家证券交易所有限公司官方网站上提供的数据一致。(<a href="http://www.nseindia.com">http://www.nseindia.com</a>)</p>
<h2 id="Python-nsetools-库的主要特性">Python nsetools 库的主要特性</h2>
<p>Python <strong>nsetools</strong> 库的一些关键特性如下:</p>
<ol>
<li class="lvl-4">
<p><strong>nsetools</strong>库开箱即用，没有任何设置要求。</p>
</li>
<li class="lvl-4">
<p>这个库帮助程序员以极快的速度获取牲畜代码和索引代码。</p>
</li>
<li class="lvl-4">
<p>它还提供了一套在全国证券交易所交易的所有股票和指数。</p>
</li>
<li class="lvl-4">
<p>此外，它还提供了一组:</p>
<ol>
<li class="lvl-8">Top losers</li>
<li class="lvl-8">Top gainers</li>
<li class="lvl-8">Most active</li>
</ol>
</li>
<li class="lvl-4">
<p>为了验证股票代码和指数代码，它还提供了几个有用的 API。</p>
</li>
<li class="lvl-4">
<p>该库可以选择以 JSON 格式返回数据。</p>
</li>
<li class="lvl-4">
<p>它有百分之百的单元测试覆盖率。</p>
</li>
</ol>
<h2 id="如何安装-Python-nsetools-库？">如何安装 Python nsetools 库？</h2>
<p><strong>nsetools</strong> 库的安装部分相当容易，没有外部依赖。该库的所有依赖项都是 Python 标准发行包的一部分。我们可以使用 pip 安装程序安装 <strong>nsetools</strong> 库，如下语法所示:</p>
<p><strong>语法:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ pip install nsetools</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="更新库">更新库</h3>
<p>如果我们中的一些人已经在他们的系统中安装了 <strong>nsetools</strong> 库，那么下面的命令将允许他们更新库。</p>
<p><strong>语法:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ pip install nsetools -upgrade</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Python-3-支持">Python 3 支持</h3>
<p>Python 3 对该库的支持已经包含在 1.0.0 等版本中。现在，这个库既可以用于 Python 2，也可以用于 Python 3。</p>
<h2 id="创建神经元特异性烯醇化酶对象">创建神经元特异性烯醇化酶对象</h2>
<p>我们可以使用 <strong>nsetools</strong> 库提供的 <strong>Nse()</strong> 功能创建一个 NSE 对象。在下面的例子中可以看到同样的情况:</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># importing the Nse() function from the nsetools library</span></span><br><span class="line"><span class="keyword">from</span> nsetools <span class="keyword">import</span> Nse</span><br><span class="line"></span><br><span class="line"><span class="comment"># creating an NSE object</span></span><br><span class="line">nse_obj = Nse()</span><br><span class="line"></span><br><span class="line"><span class="comment"># printing the value of the object</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;NSE Object:&quot;</span>, nse_obj)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">NSE Object: Driver Class <span class="keyword">for</span> National Stock Exchange (NSE)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的代码片段中，我们已经从库中导入了所需的函数。然后我们定义了一个变量，它使用 <strong>Nse()</strong> 函数来创建一个 Nse 对象。然后，我们为用户打印了变量值。</p>
<h2 id="使用nsetools库获取信息">使用<code>nsetools</code>库获取信息</h2>
<p>让我们考虑一个演示使用<strong>n 工具</strong>收集信息的例子。</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># importing the Nse() function from the nsetools library</span></span><br><span class="line"><span class="keyword">from</span> nsetools <span class="keyword">import</span> Nse</span><br><span class="line"></span><br><span class="line"><span class="comment"># creating an NSE object</span></span><br><span class="line">nse_obj = Nse()</span><br><span class="line"></span><br><span class="line"><span class="comment"># getting quotation of the company</span></span><br><span class="line">the_quotation = nse_obj.get_quote(<span class="string">&#x27;sbin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># printing the name of the company</span></span><br><span class="line"><span class="built_in">print</span>(the_quotation[<span class="string">&quot;companyName&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># printing average price</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Average Price: &quot;</span> + <span class="built_in">str</span>(the_quotation[<span class="string">&quot;averagePrice&quot;</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">State Bank of India</span><br><span class="line">Average Price: <span class="number">431.97</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的代码片段中，我们已经导入了所需的模块，并使用 <strong>Nse()</strong> 函数创建了一个 NSE 对象。然后，我们定义了另一个变量，该变量使用 NSE 对象上的 <strong>get_quote()</strong> 函数来获取指定公司的报价。然后，我们为用户打印了所需的详细信息。</p>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的Gmail API</title>
    <url>/posts/ee89ccac.html</url>
    <content><![CDATA[<h1>Python 中的 Gmail API</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/gmail-api-in-python">https://www.javatpoint.com/gmail-api-in-python</a></p>
</blockquote>
<p>在本教程中，我们将学习 Python 中的 Gmail API，我们还将学习如何使用 Python 中的 Gmail API 来执行许多 Gmail 操作，如发送电子邮件、搜索电子邮件、删除电子邮件等。为此，我们将学习在 Python 脚本中设置 Gmail API。首先，让我们简单介绍一下 Gmail API 及其基本介绍。</p>
<h2 id="Gmail-APIs">Gmail APIs</h2>
<p>Gmail 是当今世界上最受欢迎的邮件服务，几乎所有人和许多组织都在使用它。在过去的几年里，许多 Gmail 功能随着人工智能的使用而得到了增强，包括撰写电子邮件时的建议和安全功能(检测欺诈和垃圾邮件)。</p>
<p>Gmail API 是基于<a href="https://www.javatpoint.com/restful-web-services-tutorial">RESTful</a>API 的 API，允许其用户与我们的 Gmail 账户进行交互，它帮助我们使用 Python 脚本使用其功能。</p>
<h3 id="在-Python-中使用-Gmail-APIs-的先决条件">在 Python 中使用 Gmail APIs 的先决条件</h3>
<p>在 Python 脚本中使用 Gmail API 时，我们必须满足以下要求:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>我们应该有一个高于或等于 2.6 的 Python 版本。</p>
</li>
<li class="lvl-4">
<p>我们必须有一个启用了 Gmail 服务的谷歌账户。</p>
</li>
<li class="lvl-4">
<p>系统必须安装<strong>美化程序</strong>库(如果没有，那么我们应该在命令终端中使用‘pip install bsp’语法将其安装在我们的设备中)。</p>
</li>
<li class="lvl-4">
<p>我们应该有谷歌 OAuth 库和谷歌 API 客户端的基本知识。</p>
</li>
</ul>
<h3 id="所需库的安装">所需库的安装:</h3>
<p>在启用 Gmail API 在我们的 <a href="https://www.javatpoint.com/python-tutorial">Python</a> 脚本中使用它们之前，让我们首先在系统中安装预先需要的库。要安装启用 Gmail APIs 所需的库，我们应该遵循以下步骤:</p>
<p>**第一步:**打开系统的命令提示终端，确定我们的设备有活动的互联网连接。</p>
<p>**第二步:**在终端写下以下命令:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install --upgrade google-api-python-client google-auth-httplib2 google-auth-oauthlib</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，按 enter 键开始安装库。</p>
<p><img src="/img/f0a3e87989d641b983759a957bdaab5f.png" alt="Gmail API in Python"></p>
<p>正如我们所看到的，启用 Gmail APIs 所需的库已经成功安装在我们的系统中。现在，我们可以在本教程中继续启用 Gmail APIs 部分。</p>
<h3 id="在我们的设备中启用-Gmail-API">在我们的设备中启用 Gmail API</h3>
<p>我们必须遵循以下给定的步骤在我们的设备中启用 Gmail API，以便我们可以在 Python 脚本中使用这些 API:</p>
<p><strong>第一步:在谷歌云控制台上创建新项目:</strong></p>
<p>在这一步中，首先我们要用我们的谷歌账号登录到谷歌云控制台**(<a href="https://console.cloud.google.com/?pli=1">https://console.cloud.google.com/?pli=1</a>)**，然后我们要点击‘新建项目’创建一个新项目。</p>
<p><img src="/img/fe0d5660f983fe0fce39b08b76c725c9.png" alt="Gmail API in Python"></p>
<p>如果我们已经有一个现有的项目，那么我们也可以继续现有的项目。</p>
<p><strong>步骤 2:</strong> 现在，我们必须从已经创建的项目菜单中转到 API 和服务选项。</p>
<p><img src="/img/8ad63aef46fb13b1e777680d66b0dd3a.png" alt="Gmail API in Python"></p>
<p>**第三步:**现在，我们可以看到选项‘启用 Gmail API 和服务’，我们必须选择这个选项才能为项目启用 Gmail API。</p>
<p><img src="/img/18095fef1e53259fae0df202eefc2c35.png" alt="Gmail API in Python"></p>
<p><strong>第四步:同意画面配置:</strong></p>
<p>现在，在这一步中，我们将通过单击菜单中给出的**“审核同意屏幕”**选项来配置我们创建的项目的同意屏幕。只有在同意屏幕尚未配置的情况下，我们才能看到此选项。</p>
<p><img src="/img/feb0001cff6e58ccda0e0b4ca053e065.png" alt="Gmail API in Python"></p>
<p>**第五步:**现在，我们要输入自己选择的应用名称，保存项目。</p>
<p>**第 6 步:**现在，点击凭证选项，转到凭证。</p>
<p><img src="/img/8c388f8930db5a6bad408409649a94f7.png" alt="Gmail API in Python"></p>
<p><strong>步骤 7:创建 OAuth 客户端标识:</strong></p>
<p>现在，我们点击**“创建凭证”**选项，转到 OAuth 客户端 ID 创建它。</p>
<p>我们按照以下顺序过程执行此操作，为我们的项目创建一个新的 OAuth 客户端标识:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>首先，我们选择应用类型作为项目的桌面应用。<br>
<img src="/img/39200cebc294c1e5e18e8f6a473d115e.png" alt="Gmail API in Python"></p>
</li>
<li class="lvl-4">
<p>之后，我们输入应用名称(可以与我们在上述步骤中设置的名称相同，也可以不同)，然后单击创建按钮。</p>
</li>
<li class="lvl-4">
<p>现在，将为我们的项目创建 OAuth 客户端 ID，我们下载它，并用“credentials.json”名称和格式保存它，以供将来参考。<br>
<img src="/img/2631afff357d3df3a145652f2dd15379.png" alt="Gmail API in Python"></p>
</li>
</ul>
<p>现在，我们已经完成了启用 Gmail API 的所有步骤，我们可以开始在 Python 脚本中使用 Gmail API 了。</p>
<h4 id="注意-我们必须保存客户标识和密码，以便在将来需要时参考。">注意:我们必须保存客户标识和密码，以便在将来需要时参考。</h4>
<p><strong>导入必要的模块</strong></p>
<p>现在，我们已经设置了所有必要的 API，我们应该继续导入所有必要的模块。让我们看看下面导入模块的例子。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Importing os and pickle module in program</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="comment"># Creating utils for Gmail APIs</span></span><br><span class="line"><span class="keyword">from</span> googleapiclient.discovery <span class="keyword">import</span> build</span><br><span class="line"><span class="keyword">from</span> google_auth_oauthlib.flow <span class="keyword">import</span> InstalledAppFlow</span><br><span class="line"><span class="keyword">from</span> google.auth.transport.requests <span class="keyword">import</span> Request</span><br><span class="line"><span class="comment"># Importing libraries for encoding/decoding messages in base64</span></span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> urlsafe_b64decode, urlsafe_b64encode</span><br><span class="line"><span class="comment"># Importing libraries for dealing with the attachment of MIME types in Gmail</span></span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.mime.image <span class="keyword">import</span> MIMEImage</span><br><span class="line"><span class="keyword">from</span> email.mime.audio <span class="keyword">import</span> MIMEAudio</span><br><span class="line"><span class="keyword">from</span> email.mime.base <span class="keyword">import</span> MIMEBase</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> mimetypes <span class="keyword">import</span> guess_type <span class="keyword">as</span> guess_mime_type</span><br><span class="line"></span><br><span class="line"><span class="comment"># Request all access from Gmail APIs and project</span></span><br><span class="line">SCOPES = [<span class="string">&#x27;https://mail.google.com/&#x27;</span>]</span><br><span class="line">OurEmailID = <span class="string">&#x27;OurMail@gmail.com&#x27;</span> <span class="comment"># giving our Gmail Id</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># using a default function to authenticate Gmail APIs</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">authenticateGmailAPIs</span>():</span><br><span class="line">    creds = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># Authorizing the Gmail APIs with tokens of pickles</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">&quot;token.pickle&quot;</span>): <span class="comment"># using if else statement</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;token.pickle&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> token:</span><br><span class="line">            creds = pickle.load(token)</span><br><span class="line">    <span class="comment"># If there are no valid credentials available in device, we will let the user sign in manually</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> creds <span class="keyword">or</span> <span class="keyword">not</span> creds.valid:</span><br><span class="line">        <span class="keyword">if</span> creds <span class="keyword">and</span> creds.expired <span class="keyword">and</span> creds.refresh_token:</span><br><span class="line">            creds.refresh(Request())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flow = InstalledAppFlow.from_client_secrets_file(<span class="string">&#x27;client_secret_107196167488-dh4b2pmpivffe011kic4em9a4ugrcooi.apps.googleusercontent.com.json&#x27;</span>, SCOPES) <span class="comment"># downloaded credential name</span></span><br><span class="line">            creds = flow.run_local_server(port=<span class="number">0</span>) <span class="comment"># running credentials</span></span><br><span class="line">        <span class="comment"># Save the credentials for the next run</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;token.pickle&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> token:</span><br><span class="line">            pickle.dump(creds, token)</span><br><span class="line">    <span class="keyword">return</span> build(<span class="string">&#x27;Gmail&#x27;</span>, <span class="string">&#x27;v1&#x27;</span>, credentials=creds) <span class="comment"># using Gmail to authenticate</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the Gmail API service by calling the function</span></span><br><span class="line">service = authenticateGmailAPIs()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Please visit this URL to authorize this application: https://accounts.google.com/o/oauth2/auth?response_type=code&amp;client_id=<span class="number">107196167488</span>-dh4b2pmpivffe011kic4em9a4ugrcooi.apps.googleusercontent.com&amp;redirect_uri=http%3A%2F%2Flocalhost%3A55991%2F&amp;scope=https%3A%2F%2Fmail.google.com%2F&amp;state=kfXlNyjvbKetyUK0op7OF9WY7shrKS&amp;access_type=offline</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/17a8e1524365d3e91a1d4e9bcec3dba9.png" alt="Gmail API in Python"></p>
<p><strong>解释-</strong></p>
<p>当我们运行上面给定的程序时，我们会看到一个选择浏览器的选项，如上图所示，如果我们没有看到这样的选项，我们需要点击输出中给定的链接。然后，我们可以选择我们选择的浏览器或系统的默认浏览器来继续这个过程。现在，当我们选择浏览器时，我们将被重定向到我们的浏览器，并可以看到在其中打开的以下选项卡:</p>
<p><img src="/img/c4a79c42c38a6bb6b1d0050eb1a86ad3.png" alt="Gmail API in Python"></p>
<p>现在，我们勾选对话框中显示的复选框选项，以提供所需的权限，然后，我们将不得不单击继续选项。点击继续后，我们可以看到以下窗口将在同一选项卡中打开:</p>
<p><img src="/img/5c3914060be54037e1a84ab766dd51b2.png" alt="Gmail API in Python"></p>
<p>如窗口所示，启用 Gmail API 的身份验证部分已经完成，我们已经将 Gmail 帐户与我们创建的 Gmail API 项目相链接。</p>
<h4 id="注意-当然，我们必须把我们可以连接到-Gmail-APIs-的邮件放在上面程序中提供的“【电子邮件保护】”的地方，以供将来使用-Gmail-APIs-时参考。">注意:当然，我们必须把我们可以连接到 Gmail APIs 的邮件放在上面程序中提供的“<a href="/cdn-cgi/l/email-protection">【电子邮件保护】</a>”的地方，以供将来使用 Gmail APIs 时参考。</h4>
<h2 id="使用-Python-中的-Gmail-APIs-执行操作">使用 Python 中的 Gmail APIs 执行操作</h2>
<p>现在，我们已经用 Python 脚本在我们的项目中完全设置并启用了 Gmail APIs。现在，我们可以使用 Python 程序从 Gmail 帐户执行许多操作。</p>
<p>我们可以在 Python 脚本中使用 Gmail APIs 执行以下 Gmail 操作:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>发送电子邮件</p>
</li>
<li class="lvl-4">
<p>搜索电子邮件</p>
</li>
<li class="lvl-4">
<p>删除电子邮件或整个电子邮件历史记录</p>
</li>
<li class="lvl-4">
<p>阅读电子邮件</p>
</li>
<li class="lvl-4">
<p>标记已读/未读电子邮件等。</p>
</li>
</ul>
<p>在本教程中，我们将只讨论在 Python 程序中使用 Gmail APIs 发送电子邮件，我们将学习使用 Python 脚本编写执行此操作的代码。</p>
<h3 id="发送电子邮件">发送电子邮件</h3>
<p>我们可以通过编写一个 Python 程序并在其中使用启用的 Gmail APIs 来简单地编写和发送一封电子邮件。在这一部分，我们将编写一个 Python 程序，通过运行该程序，我们就可以从 Gmail 帐户发送电子邮件。</p>
<p>为了更好地理解它，请看下面的 Python 程序:</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># importing os and pickle module in program</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="comment"># Creating utils for Gmail APIs</span></span><br><span class="line"><span class="keyword">from</span> googleapiclient.discovery <span class="keyword">import</span> build</span><br><span class="line"><span class="keyword">from</span> google_auth_oauthlib.flow <span class="keyword">import</span> InstalledAppFlow</span><br><span class="line"><span class="keyword">from</span> google.auth.transport.requests <span class="keyword">import</span> Request</span><br><span class="line"><span class="comment"># Importing libraries for encoding/decoding messages in base64</span></span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> urlsafe_b64decode, urlsafe_b64encode</span><br><span class="line"><span class="comment"># Importing libraries for dealing with the attachment of MIME types in Gmail</span></span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.mime.image <span class="keyword">import</span> MIMEImage</span><br><span class="line"><span class="keyword">from</span> email.mime.audio <span class="keyword">import</span> MIMEAudio</span><br><span class="line"><span class="keyword">from</span> email.mime.base <span class="keyword">import</span> MIMEBase</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> mimetypes <span class="keyword">import</span> guess_type <span class="keyword">as</span> guess_mime_type</span><br><span class="line"></span><br><span class="line"><span class="comment"># Request all access from Gmail APIs and project</span></span><br><span class="line">SCOPES = [<span class="string">&#x27;https://mail.google.com/&#x27;</span>] <span class="comment"># providing the scope for Gmail APIs</span></span><br><span class="line">OurEmailID = <span class="string">&#x27;OurMail@gmail.com&#x27;</span> <span class="comment"># giving our Gmail Id</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># using a default function to authenticate Gmail APIs</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">authenticateGmailAPIs</span>():</span><br><span class="line">    creds = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># authorizing the Gmail APIs with tokens of pickles</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">&quot;token.pickle&quot;</span>): <span class="comment"># using if else statement</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;token.pickle&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> token:</span><br><span class="line">            creds = pickle.load(token)</span><br><span class="line">    <span class="comment"># if there are no valid credentials available in device, we will let the user sign in manually</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> creds <span class="keyword">or</span> <span class="keyword">not</span> creds.valid:</span><br><span class="line">        <span class="keyword">if</span> creds <span class="keyword">and</span> creds.expired <span class="keyword">and</span> creds.refresh_token:</span><br><span class="line">            creds.refresh(Request())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flow = InstalledAppFlow.from_client_secrets_file(<span class="string">&#x27;client_secret_107196167488-dh4b2pmpivffe011kic4em9a4ugrcooi.apps.googleusercontent.com.json&#x27;</span>, SCOPES) <span class="comment"># downloaded credential name</span></span><br><span class="line">            creds = flow.run_local_server(port=<span class="number">0</span>) <span class="comment"># running credentials</span></span><br><span class="line">        <span class="comment"># save the credentials for the next run</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;token.pickle&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> token:</span><br><span class="line">            pickle.dump(creds, token)</span><br><span class="line">    <span class="keyword">return</span> build(<span class="string">&#x27;gmail&#x27;</span>, <span class="string">&#x27;v1&#x27;</span>, credentials=creds) <span class="comment"># using Gmail to authenticate</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the Gmail API service by calling the function</span></span><br><span class="line">ServicesGA = authenticateGmailAPIs()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using a default funnction to add attachments in Mail</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">AddAttachment</span>(<span class="params">mail, NameofFile</span>):</span><br><span class="line">    content_type, encoding = guess_mime_type(NameofFile)</span><br><span class="line">    <span class="keyword">if</span> content_type <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> encoding <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: <span class="comment"># defining none file type attachment</span></span><br><span class="line">        content_type = <span class="string">&#x27;application/octet-stream&#x27;</span></span><br><span class="line">    main_type, sub_type = content_type.split(<span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> main_type == <span class="string">&#x27;text&#x27;</span>: <span class="comment"># defining text file type attachment</span></span><br><span class="line">        fp = <span class="built_in">open</span>(NameofFile, <span class="string">&#x27;rb&#x27;</span>) <span class="comment"># opening file</span></span><br><span class="line">        msg = MIMEText(fp.read().decode(), _subtype = sub_type)</span><br><span class="line">        fp.close() </span><br><span class="line">    <span class="keyword">elif</span> main_type == <span class="string">&#x27;image&#x27;</span>: <span class="comment"># defining image file type attachment</span></span><br><span class="line">        fp = <span class="built_in">open</span>(NameofFile, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">        msg = MIMEImage(fp.read(), _subtype = sub_type)</span><br><span class="line">        fp.close()</span><br><span class="line">    <span class="keyword">elif</span> main_type == <span class="string">&#x27;audio&#x27;</span>: <span class="comment"># defining audio file type attachment</span></span><br><span class="line">        fp = <span class="built_in">open</span>(NameofFile, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">        msg = MIMEAudio(fp.read(), _subtype = sub_type) <span class="comment"># reading file</span></span><br><span class="line">        fp.close()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        fp = <span class="built_in">open</span>(NameofFile, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">        msg = MIMEBase(main_type, sub_type)</span><br><span class="line">        msg.set_payload(fp.read())</span><br><span class="line">        fp.close() <span class="comment"># closing file</span></span><br><span class="line">    NameofFile = os.path.basename(NameofFile)</span><br><span class="line">    msg.add_header(<span class="string">&#x27;Content-Disposition&#x27;</span>, <span class="string">&#x27;attachment&#x27;</span>, NameofFile = NameofFile)</span><br><span class="line">    mail.attach(msg) <span class="comment"># composing the mail with given attachment</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Creating mail with a default function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">CreateMail</span>(<span class="params">RecieverMail, SubofMail, BodyofMail, attachments=[]</span>): <span class="comment"># various import content of mail as function&#x27;s parameter</span></span><br><span class="line">    <span class="comment"># Using if else to check if there is any attachment in mail or not</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> attachments: <span class="comment"># no attachment is given in the mail</span></span><br><span class="line">        mail = MIMEText(BodyofMail) <span class="comment"># Body of Mail</span></span><br><span class="line">        mail[<span class="string">&#x27;to&#x27;</span>] = RecieverMail <span class="comment"># mail ID of Reciever</span></span><br><span class="line">        mail[<span class="string">&#x27;from&#x27;</span>] = OurEmailID <span class="comment"># our mail ID</span></span><br><span class="line">        mail[<span class="string">&#x27;subject&#x27;</span>] = SubofMail <span class="comment"># Subject of Mail</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># attachment is given in the mail</span></span><br><span class="line">        mail = MIMEMultipart()</span><br><span class="line">        mail[<span class="string">&#x27;to&#x27;</span>] = RecieverMail</span><br><span class="line">        mail[<span class="string">&#x27;from&#x27;</span>] = OurEmailID</span><br><span class="line">        mail[<span class="string">&#x27;subject&#x27;</span>] = SubofMail</span><br><span class="line">        mail.attach(MIMEText(BodyofMail))</span><br><span class="line">        <span class="keyword">for</span> NameofFile <span class="keyword">in</span> attachments:</span><br><span class="line">            AddAttachment(mail, NameofFile)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;raw&#x27;</span>: urlsafe_b64encode(mail.as_bytes()).decode()&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creating a default function to send a mail</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SendMail</span>(<span class="params">ServicesGA, RecieverMail, SubofMail, BodyofMail, attachments=[]</span>):</span><br><span class="line">    <span class="keyword">return</span> ServicesGA.users().messages().send(</span><br><span class="line">      userId = <span class="string">&quot;me&quot;</span>,</span><br><span class="line">      body = CreateMail(RecieverMail, SubofMail, BodyofMail, attachments)</span><br><span class="line">    ).execute() <span class="comment"># Body of the mail with execute() function</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sending an email by adding important content, i.e., Reciever&#x27;s mail, Subject, Body, etc.</span></span><br><span class="line">SendMail(ServicesGA, <span class="string">&quot;Reciever@gmail.com&quot;</span>, <span class="string">&quot;Python Project i.e., This is the subject of Mail we are send/img!&quot;</span>, </span><br><span class="line">            <span class="string">&quot;Now, this is the body of the email we are writing and we can add only written text here!&quot;</span>, [<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;client_secret_107196167488-dh4b2pmpivffe011kic4em9a4ugrcooi.apps.googleusercontent.com.json&quot;</span>]) <span class="comment"># calling out default SendMail() function</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<p><img src="//img/a347707cf327a1d3cd8dca59bdd88e7e.png" alt="Gmail API in Python"></p>
<p>如果我们把我们的邮件放在收件人邮件的地方，即<a href="/cdn-cgi/l/email-protection">【email protected】</a>，我们会发现邮件实际上是发送给我们在运行程序时作为收件人邮件输入的邮件，与我们在上面的输出图像中看到的一样。</p>
<h2 id="结论-5">结论</h2>
<p>要将 Gmail API 与我们的 Python 脚本或简单地与 Python 一起使用，首先，我们必须启用它们，并使用我们的 Gmail 帐户在谷歌云中创建一个项目。</p>
<p>我们还可以执行许多其他操作，如阅读、删除等。，在我们的 Python 程序中使用 Gmail APIs 就像发送电子邮件一样。我们还可以通过运行我们的 Python 脚本(通过 Gmail APIs 启用)将许多东西修改到我们通过 Gmail APIs 项目验证的 Gmail 帐户中。</p>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的网格搜索</title>
    <url>/posts/ef3a60d1.html</url>
    <content><![CDATA[<h1>Python 中的网格搜索</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/grid-search-in-python">https://www.javatpoint.com/grid-search-in-python</a></p>
</blockquote>
<p>在本教程中，我们将讨论用于优化超参数的网格搜索。我们还将了解网格搜索的工作原理，以及它在优化机器学习方法性能方面的实现。</p>
<p><strong>超参数调整</strong>对于<a href="https://www.javatpoint.com/machine-learning">机器学习(ML)</a> 模型的适当工作具有重要意义。像<strong>网格搜索</strong>这样的方法似乎是超参数优化的基本工具。</p>
<p><strong>网格搜索</strong>方法考虑一些超参数组合，并选择返回较低错误分数的组合。当只有一些超参数需要优化时，这种方法特别有用。然而，当机器学习模型的复杂性增加时，它的性能优于其他加权随机搜索方法。</p>
<p>让我们从理解网格搜索开始。</p>
<h2 id="理解网格搜索">理解网格搜索</h2>
<p><strong>网格搜索</strong>是一种优化算法，它允许我们从我们提供的参数选择列表中选择最佳参数来优化问题，从而使‘试错’方法自动化。虽然我们可以将其应用于多个优化问题；然而，最常见的是将其用于机器学习，以获得模型提供最佳精度的参数。</p>
<p>让我们考虑模型以输入的形式接受以下三个参数:</p>
<ol>
<li class="lvl-4">
<p>隐藏层数[2，4]</p>
</li>
<li class="lvl-4">
<p>每层神经元数量[5，10]</p>
</li>
<li class="lvl-4">
<p>时代数量[10，50]</p>
</li>
</ol>
<p>如果我们想为每个参数输入尝试两个选项(如上面方括号中所指定的)，它会估计不同的组合。例如，一个可能的组合可以是[2，5，10]。手动找到这样的组合将是一件令人头痛的事情。</p>
<p>现在，假设我们有 10 个不同的参数作为输入，我们想要为每个参数尝试 5 个可能的值。每当我们想要更改参数值、重新执行代码以及记录每个参数组合的输出时，都需要程序员手动输入。</p>
<p>网格搜索自动执行该过程，因为它接受每个参数的可能值并执行代码，以便尝试每个可能的组合，输出组合的结果并输出具有最佳精度的组合。</p>
<h2 id="安装所需的库">安装所需的库</h2>
<p>在我们开始用 <a href="https://www.javatpoint.com/python-tutorial">Python 编程语言</a>实现网格搜索之前，让我们简单讨论一下系统中需要安装的一些必要的库和框架。</p>
<p>这些库和框架如下:</p>
<ol>
<li class="lvl-4">
<p>Python 3</p>
</li>
<li class="lvl-4">
<p>num py</p>
</li>
<li class="lvl-4">
<p><a href="https://www.javatpoint.com/python-pandas">Pandas</a></p>
</li>
<li class="lvl-4">
<p><a href="https://www.javatpoint.com/keras">硬</a></p>
</li>
<li class="lvl-4">
<p>Scikit-Learn</p>
</li>
</ol>
<p>它们都很容易安装。我们可以使用 pip 安装程序来安装这些库，如下所示:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ pip install numpy tensorflow pandas scikit-learn keras</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="注意-如果在执行任何软件包时出现任何问题，请尝试重新安装并参考每个软件包的官方文档。">注意:如果在执行任何软件包时出现任何问题，请尝试重新安装并参考每个软件包的官方文档。</h4>
<p>现在，让我们开始用 Python 实现网格搜索</p>
<h2 id="Python-中网格搜索的实现">Python 中网格搜索的实现</h2>
<p>在下一节中，我们将了解如何在实际应用中实现网格搜索。我们将简单地执行代码，并深入讨论网格搜索部分，而不是讨论机器学习和数据预处理部分。</p>
<p>那么，让我们开始吧。</p>
<p>我们将使用饮食数据集，该数据集包含基于各种属性(如性别、年龄和饮食类型)的不同人的身高和体重数据。借助 Pandas <strong>read_csv()</strong> 功能，我们可以直接从在线资源导入数据。</p>
<p>但在此之前，我们必须导入所需的包:</p>
<p><strong>文件:mygrid.py</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV, KFold</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Dropout</span><br><span class="line"><span class="keyword">from</span> keras.wrappers.scikit_learn <span class="keyword">import</span> KerasClassifier</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> Adam</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的代码片段中，我们已经导入了项目所需的包和库。还可以保存程序文件并执行它，以便检查库和包是否正确安装和导入。</p>
<p>一旦包成功导入，我们必须使用下面的代码片段来导入数据集并打印它的前五行。</p>
<p><strong>文件:mygrid.py</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># importing the dataset</span></span><br><span class="line">mydf = pd.read_csv(<span class="string">&quot;Diet_Dataset.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># printing the first five lines of dataset</span></span><br><span class="line"><span class="built_in">print</span>(mydf.head())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">   Person gender  Age  Height  pre.weight  Diet  weight6weeks</span><br><span class="line"><span class="number">0</span>      <span class="number">25</span>          <span class="number">41</span>     <span class="number">171</span>          <span class="number">60</span>     <span class="number">2</span>          <span class="number">60.0</span></span><br><span class="line"><span class="number">1</span>      <span class="number">26</span>          <span class="number">32</span>     <span class="number">174</span>         <span class="number">103</span>     <span class="number">2</span>         <span class="number">103.0</span></span><br><span class="line"><span class="number">2</span>       <span class="number">1</span>      <span class="number">0</span>   <span class="number">22</span>     <span class="number">159</span>          <span class="number">58</span>     <span class="number">1</span>          <span class="number">54.2</span></span><br><span class="line"><span class="number">3</span>       <span class="number">2</span>      <span class="number">0</span>   <span class="number">46</span>     <span class="number">192</span>          <span class="number">60</span>     <span class="number">1</span>          <span class="number">54.0</span></span><br><span class="line"><span class="number">4</span>       <span class="number">3</span>      <span class="number">0</span>   <span class="number">55</span>     <span class="number">170</span>          <span class="number">64</span>     <span class="number">1</span>          <span class="number">63.3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的代码片段中，我们使用<strong>Pandas</strong>库的 <strong>read_csv()</strong> 导入数据集，并将其存储在 <strong>mydf</strong> 变量中。然后，我们使用 <strong>head()</strong> 函数和 <strong>mydf</strong> 变量打印了前五行。</p>
<p>现在，让我们将数据划分为要素集和标签集，以便对数据集应用标准缩放。</p>
<p>其代码片段如下所示:</p>
<p><strong>文件:mygrid.py</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># converting dataframe into numpy array</span></span><br><span class="line">mydataset = mydf.values</span><br><span class="line"></span><br><span class="line">X = mydataset[:, <span class="number">0</span>:<span class="number">6</span>]</span><br><span class="line">Y = mydataset[:, <span class="number">6</span>].astype(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Normalizing the data using sklearn StandardScaler</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"></span><br><span class="line">myscaler = StandardScaler().fit(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Transforming and displaying the training data</span></span><br><span class="line">X_stdized = myscaler.transform(X)</span><br><span class="line"></span><br><span class="line">mydata = pd.DataFrame(X_stdized)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的代码片段中，我们已经将<strong>Pandas</strong>数据帧转换成了 <strong>NumPy</strong> 数组。然后我们从 <strong>sklearn</strong> 库中导入了<strong>标准缩放器</strong>模块，并使用该函数对数据进行归一化。然后，我们使用 <strong>transform()</strong> 函数转换并显示了训练数据。</p>
<p>现在，让我们考虑下面的代码片段，以便创建一个简单的深度学习模型。</p>
<p><strong>文件:mygrid.py</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># defining the function to create model</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_my_model</span>(<span class="params">learnRate, dropoutRate</span>):</span><br><span class="line">    <span class="comment"># Creating model</span></span><br><span class="line">    mymodel = Sequential()</span><br><span class="line">    mymodel.add(Dense(<span class="number">6</span>, input_dim = <span class="number">6</span>, kernel_initializer = <span class="string">&#x27;normal&#x27;</span>, activation = <span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    mymodel.add(Dropout(dropoutRate))</span><br><span class="line">    mymodel.add(Dense(<span class="number">3</span>, input_dim = <span class="number">6</span>, kernel_initializer = <span class="string">&#x27;normal&#x27;</span>, activation = <span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    mymodel.add(Dropout(dropoutRate))</span><br><span class="line">    mymodel.add(Dense(<span class="number">1</span>, activation = <span class="string">&#x27;sigmoid&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Compiling the model</span></span><br><span class="line">    my_Adam = Adam(learning_rate = learnRate)</span><br><span class="line">    mymodel.<span class="built_in">compile</span>(loss = <span class="string">&#x27;binary_crossentropy&#x27;</span>, optimizer = my_Adam, metrics = [<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> mymodel</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>下面的代码片段将函数定义为 <strong>create_my_model()</strong> 接受两个参数，即 <strong>learnRate</strong> 和<strong>dropoultrate</strong>。然后，我们使用<strong>顺序()<strong>功能将模型创建为</strong>我的模型</strong>。我们还使用了 <strong>add()</strong> 以及 <strong>Dense()</strong> 和**drop()**功能。然后我们使用 <strong>compile()</strong> 函数编译了模型。</p>
<p>因此，当我们执行代码时，这将导致加载数据集，对其进行预处理，并创建机器学习模型。因为我们只对理解网格搜索的工作感兴趣，所以我们没有执行训练/测试分割，我们已经在完整的数据集上拟合了模型。</p>
<p>现在，我们将在下一节中了解网格搜索如何通过优化参数使程序员的生活变得更容易。</p>
<h3 id="不使用网格搜索训练模型">不使用网格搜索训练模型</h3>
<p>在下面显示的代码片段中，我们将借助随机决定的或基于直觉的参数值创建一个模型，并看看我们的模型如何运行:</p>
<p><strong>文件:mygrid.py</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Declaring the values of the parameter</span></span><br><span class="line">dropoutRate = <span class="number">0.1</span></span><br><span class="line">epochs = <span class="number">1</span></span><br><span class="line">batchSize = <span class="number">20</span></span><br><span class="line">learnRate = <span class="number">0.001</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Creating the model object by calling the create_my_model function we created above</span></span><br><span class="line">mymodel = create_my_model(learnRate, dropoutRate)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fitting the model onto the training data</span></span><br><span class="line">mymodel.fit(X_stdized, Y, batch_size = batchSize, epochs = epochs, verbose = <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>/<span class="number">4</span> [==============================] - 41s 14ms/step - loss: <span class="number">0.9364</span> - accuracy: <span class="number">0.0000e+00</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的代码片段中，我们已经分别声明了参数的值，即<strong>dropoultrate、epochs、batchSize</strong> 和 <strong>learnRate</strong> 。然后，我们通过调用 <strong>create_my_model()</strong> 函数来创建模型对象。然后，我们将模型拟合到训练数据上。</p>
<p>结果，我们得到的精度是 0.0000e+00。</p>
<h3 id="利用网格搜索优化超参数">利用网格搜索优化超参数</h3>
<p>如果我们没有使用网格搜索方法，我们可以在上面创建的模型上直接调用 <strong>fit()</strong> 函数。但是为了利用网格搜索方法，我们必须向 <strong>create_my_model()</strong> 函数传递一些参数。此外，我们必须用各种选项声明网格，以尝试每个参数。让我们在不同的地方表演。</p>
<p>首先，我们将尝试修改 <strong>create_my_model()</strong> 函数，以便接受来自调用函数的参数，如下所示:</p>
<p><strong>文件:mygrid.py</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_my_model</span>(<span class="params">learnRate, dropoutRate</span>):</span><br><span class="line">    <span class="comment"># Creating the model</span></span><br><span class="line">    mymodel = Sequential()</span><br><span class="line">    mymodel.add(Dense(<span class="number">6</span>, input_dim = <span class="number">6</span>, kernel_initializer = <span class="string">&#x27;normal&#x27;</span>, activation = <span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    mymodel.add(Dropout(dropoutRate))</span><br><span class="line">    mymodel.add(Dense(<span class="number">3</span>, input_dim = <span class="number">6</span>, kernel_initializer = <span class="string">&#x27;normal&#x27;</span>, activation = <span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    mymodel.add(Dropout(dropoutRate))</span><br><span class="line">    mymodel.add(Dense(<span class="number">1</span>, activation = <span class="string">&#x27;sigmoid&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Compile the model</span></span><br><span class="line">    myadam = Adam(learning_rate = learnRate)</span><br><span class="line">    mymodel.<span class="built_in">compile</span>(loss = <span class="string">&#x27;binary_crossentropy&#x27;</span>, optimizer = myadam, metrics = [<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> mymodel</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creating the model object</span></span><br><span class="line">mymodel = KerasClassifier(build_fn = create_my_model, verbose = <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的代码片段中，我们对之前的 <strong>create_my_model</strong> 函数进行了一些更改，并使用了 <strong>KerasClassifier</strong> 来创建模型对象。</p>
<p>现在，让我们实现网格搜索算法，并在其上拟合数据集:</p>
<p><strong>文件:mygrid.py</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Defining the arguments that we want to use in Grid Search along</span></span><br><span class="line"><span class="comment"># with the list of values that we want to try out</span></span><br><span class="line">learnRate = [<span class="number">0.001</span>, <span class="number">0.02</span>, <span class="number">0.2</span>]</span><br><span class="line">dropoutRate = [<span class="number">0.0</span>, <span class="number">0.2</span>, <span class="number">0.4</span>]</span><br><span class="line">batchSize = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line">epochs = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Making a dictionary of the grid search parameters</span></span><br><span class="line">paramgrid = <span class="built_in">dict</span>(learnRate = learnRate, dropoutRate = dropoutRate, batch_size = batchSize, epochs = epochs )</span><br><span class="line"></span><br><span class="line"><span class="comment"># Building and fitting the GridSearchCV</span></span><br><span class="line">mygrid = GridSearchCV(estimator = mymodel, param_grid = paramgrid, cv = KFold(random_state = <span class="literal">None</span>), verbose = <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">gridresults = mygrid.fit(X_stdized, Y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Summarizing the results in a readable format</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Best: &quot;</span> + gridresults.best_score_ + <span class="string">&quot; using &quot;</span> + gridresults.best_params_)</span><br><span class="line"></span><br><span class="line">means = gridresults.cv_results_[<span class="string">&#x27;mean_test_score&#x27;</span>]</span><br><span class="line">stds = gridresults.cv_results_[<span class="string">&#x27;std_test_score&#x27;</span>]</span><br><span class="line">params = gridresults.cv_results_[<span class="string">&#x27;params&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> mean, stdev, param <span class="keyword">in</span> <span class="built_in">zip</span>(means, stds, params):</span><br><span class="line">    <span class="built_in">print</span>(mean + <span class="string">&quot;(&quot;</span> + stdev + <span class="string">&quot;)&quot;</span> + <span class="string">&quot; with: &quot;</span> + param)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Best: <span class="number">0.00347268912077</span>, using &#123;batch_size=<span class="number">10</span>, dropoutRate=<span class="number">0.4</span>, epochs=<span class="number">5</span>, learnRate=<span class="number">0.2</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>上述输出显示了产生最佳精度的参数组合。</p>
<p>最后，我们可以得出结论，网格搜索在 Python 编程语言中非常容易实现，并且节省了我们大量的人工时间。我们可以列出所有想要调优的参数，声明需要测试的值，执行代码，然后忘掉它。这个过程是如此简单和方便，以至于它需要程序员更少的输入。一旦找到最佳参数组合，我们就可以将它用于最终模型。</p>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python找到第`n`个斐波那契数</title>
    <url>/posts/8af701f5.html</url>
    <content><![CDATA[<h1>Python 程序：找到第<code>n</code>个斐波那契数</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-program-to-find-the-nth-fibonacci-number">https://www.javatpoint.com/python-program-to-find-the-nth-fibonacci-number</a></p>
</blockquote>
<p>在下面的教程中，我们将了解如何使用 Python 找到第<code>n</code>个斐波那契数。我们可以定义一个斐波那契数，下面的数字是前面两个数字的和。</p>
<p>斐波那契数列的前两个元素分别是 0 和 1。我们可以通过将前面两个元素相加来计算级数的第三个元素，得到的第三项为 0 + 1，等于 1。同样，第四项将是第二项和第三项的总和，即 1 + 1 = 2，以此类推。这一系列数字被称为斐波那契数列。</p>
<p>递归关系定义了如下所示的斐波那契数:</p>
<p><strong>F<sub>n</sub>= F<sub>n-1</sub>+F<sub>n-2</sub></strong></p>
<p>使用 Python 编程语言有不同的方法可以找到第<code>n</code>个斐波那契数。其中一些如下:</p>
<ol>
<li class="lvl-4">
<p>用递归法求第<code>n</code>个斐波那契数</p>
</li>
<li class="lvl-4">
<p>用动态规划法求第<code>n</code>个斐波那契数</p>
</li>
<li class="lvl-4">
<p>利用动态规划和空间优化寻找第<code>n</code>个斐波那契数</p>
</li>
<li class="lvl-4">
<p>用数组求第<code>n</code>个斐波那契数</p>
</li>
</ol>
<p>在这些方法中，最基本的两种是递归方法和动态方法。</p>
<p>让我们通过例子来详细了解这些方法的工作原理。</p>
<h2 id="用递归法求第n个斐波那契数">用递归法求第<code>n</code>个斐波那契数</h2>
<p>递归这个术语是用来定义自身内部的东西的。在像 Python 这样的编程语言中，递归指的是函数调用自身的过程。有了正确的代码，递归将创建一个有限循环。</p>
<p>为了更好地理解，让我们考虑下面的代码片段。</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># defining the function for Fibonacci Series</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Fibonacci_Series</span>(<span class="params">n</span>): </span><br><span class="line">    <span class="comment"># using if-else conditional statement</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Oops! Incorrect input&quot;</span>)</span><br><span class="line">    <span class="comment"># First Fibonacci number is 0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">0</span>: </span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>) </span><br><span class="line">    <span class="comment"># Second Fibonacci number is 1 </span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> (Fibonacci_Series(n - <span class="number">1</span>) + Fibonacci_Series(n - <span class="number">2</span>)) </span><br><span class="line"><span class="comment"># printing the 12th element of the Fibonacci Series</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;12th Element of the Fibonacci Series:&quot;</span>, Fibonacci_Series(<span class="number">12</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">12th Element of the Fibonacci Series: <span class="number">144</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的代码片段中，我们定义了一个函数为<strong>斐波那契数列()</strong>，该函数接受一个参数为 <strong>n</strong> 。</p>
<p>而且，我们知道斐波那契数列的前两个元素是 <strong>0</strong> 和 <strong>1</strong> 。在输入为 <strong>n = 1</strong> 或 <strong>n = 2</strong> (斐波那契数列的第一项或第二项)的情况下，我们使用 <strong>if-else</strong> 条件语句返回 <strong>0</strong> 或 <strong>1</strong> 。如果 <strong>n</strong> 的值大于 <strong>2</strong> ，函数将以较低的输入值调用自身。我们可以观察到代码返回**(斐波那契数列(n - 1) +斐波那契数列(n - 2))** 。在这里，函数以较低的值调用自己，除非它达到 <strong>n = 1</strong> 和 <strong>n = 2</strong> 的基值，并且我们从前面知道， <strong>n = 1</strong> 返回 <strong>0</strong> ， <strong>n = 2</strong> 返回 <strong>1</strong> 。然后，返回值被连续相加以产生斐波那契数列的序列。</p>
<h2 id="用动态规划法求第n个斐波那契数">用动态规划法求第<code>n</code>个斐波那契数</h2>
<p>动态编程也使用递归；然而，它主要利用 <strong>if-els</strong> e 条件语句。在语句中，斐波那契数的值存储在一个变量中。借助递归，重复加法让我们得到这个斐波那契数。</p>
<p>让我们考虑下面的例子来理解同样的事情。</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># defining the function to find the nth Fibonacci Number</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Fibonacci_series</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="comment"># Taking First two terms of the Fibonacci Series as 0 and 1</span></span><br><span class="line">    fib_Array = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="comment"># Here, as we know that the first two terms of Fibonacci Series are 0 and 1,</span></span><br><span class="line">    <span class="comment"># we append the remaining values (Fibonacci numbers from index 2 to x)</span></span><br><span class="line">    <span class="comment"># in the array using recursion and return the last element. </span></span><br><span class="line">    <span class="comment"># In the range function, we take range(2, x + 1) instead of range(2, x).</span></span><br><span class="line">    <span class="comment"># This is because range function in python iterates until the value</span></span><br><span class="line">    <span class="comment"># before the upper limit. So, if we take from 2 to x, it would only</span></span><br><span class="line">    <span class="comment"># iterate from second to (x - 1)th element.</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, x + <span class="number">1</span>):</span><br><span class="line">        fib_Array.append(fib_Array[n - <span class="number">1</span>] + fib_Array[n - <span class="number">2</span>])</span><br><span class="line">    <span class="keyword">return</span> fib_Array[x]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;12th Term of Fibonacci Series:&quot;</span>, Fibonacci_series(<span class="number">12</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">12th Term of Fibonacci Series: <span class="number">144</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的代码片段中，我们将函数定义为<strong>斐波那契数列()</strong>，它接受参数作为变量 <strong>x</strong> 。我们创建了一个一维数组作为 <strong>fib_Array</strong> ，数据元素 <strong>0</strong> 和 <strong>1</strong> 位于其第 0 个和第 1 个索引中。然后，如果提供的输入(’ <strong>x</strong> ')小于或等于 <strong>2</strong> ，这也是数组 <strong>fib_Array</strong> 的长度，则返回 <strong>0</strong> 作为 <strong>x = 1</strong> 的第一个数字， <strong>1</strong> 作为 <strong>x = 2</strong> 的第二个数字。如果 <strong>x</strong> 的值大于 <strong>2</strong> ，我们已经使用递归调用并插入了前面的两个数据元素。然而，我们没有直接返回第<code>n</code>个斐波那契数，而是将每个求和元素附加到 <strong>fib_Array</strong> 数组中。最后，我们返回了数组的最后一个元素(即第<code>n</code>个元素)，并为用户打印了值。</p>
<h2 id="利用动态规划和空间优化寻找第n个斐波那契数">利用动态规划和空间优化寻找第<code>n</code>个斐波那契数</h2>
<p>这种方法几乎与动态规划完全相同。然而，动态编程利用递归来完成循环加法，而这种方法利用 <code>for</code>循环。</p>
<p>让我们考虑下面的例子来理解同样的事情。</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># defing the function to return the nth element of the Fibonacci Series</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Fibonacci_series</span>(<span class="params">x</span>): </span><br><span class="line">    <span class="comment"># assiging the variables</span></span><br><span class="line">    m = <span class="number">0</span></span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">    <span class="comment"># using the if-elif-else conditional statements</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Wrong input&quot;</span>) </span><br><span class="line">    <span class="keyword">elif</span> x == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> m </span><br><span class="line">    <span class="keyword">elif</span> x == <span class="number">1</span>: </span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># using the for-loop </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, x + <span class="number">1</span>): </span><br><span class="line">            o = m + n</span><br><span class="line">            m = n </span><br><span class="line">            n = o </span><br><span class="line">        <span class="keyword">return</span> n </span><br><span class="line"><span class="comment"># printing the twelveth term of the Fibonacci Series</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;12th element of the Fibonacci Series:&quot;</span>, Fibonacci_series(<span class="number">12</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">12th element of the Fibonacci Series: <span class="number">144</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的代码片段中，我们定义了一个函数并分配了两个变量， <strong>m = 0</strong> 和 <strong>n = 1</strong> 。这些元素是斐波那契数列的第一个和第二个元素。然后我们使用了 <strong>if-elif-else</strong> 条件语句，其中程序为输入值 <strong>x = 1</strong> 返回 <strong>0</strong> ，为输入值 <strong>x = 2</strong> 返回 <strong>1</strong> 。如果 <strong>x</strong> 的值大于 <strong>2</strong> ，我们在 <strong>(2，x + 1)</strong> 范围内使用了 <strong>i</strong> 的 <strong>for-loop</strong> 。我们取了一个变量 o 来存储数列中前面两个元素的和。一旦 <strong>o</strong> 取 <strong>m + n</strong> 的值， <strong>m</strong> 的值被重新分配给 <strong>n</strong> 。随后， <strong>n</strong> 的值被重新分配给 <strong>o</strong> 的值。这个过程继续，值 3 继续重新分配，直到循环结束。一旦循环终止，该函数返回 <strong>n</strong> 的值，该值存储第<code>n</code>个斐波那契数的值。</p>
<h2 id="用数组求第n个斐波那契数">用数组求第<code>n</code>个斐波那契数</h2>
<p>在这个方法中，我们使用 <strong>for-loop</strong> 通过重复加法创建一个大小为 <strong>x</strong> 的数组。因此，返回第<code>n</code>个斐波那契数。</p>
<p>让我们考虑下面的例子来理解同样的事情。</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># defining the function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Fibonacci_series</span>(<span class="params">x</span>): </span><br><span class="line">  <span class="comment"># creating an array in the function</span></span><br><span class="line">   fib_Array = [<span class="number">0</span>] * (x + <span class="number">1</span>)</span><br><span class="line">   fib_Array[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">   <span class="comment"># adding elements of the series to the array using addition of previous two elements.</span></span><br><span class="line">   <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">2</span>, x + <span class="number">1</span>):</span><br><span class="line">      fib_Array[n] = fib_Array[n - <span class="number">1</span>] + fib_Array[n - <span class="number">2</span>] </span><br><span class="line">   <span class="keyword">return</span> fib_Array[x]</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;12th element of the Fibonacci series:&quot;</span>, Fibonacci_series(<span class="number">12</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">12th element of the Fibonacci series: <span class="number">144</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的代码片段中，我们已经定义了函数。在函数中，我们创建了一个数组来寻找斐波那契数列的第<code>n</code>个元素。然后，我们使用 <strong>for-loop</strong> 通过重复前面两个元素的添加，将序列的元素添加到数组中。最后，第<code>n</code>个元素被返回并打印给用户。</p>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python高阶函数</title>
    <url>/posts/62ad0d63.html</url>
    <content><![CDATA[<h1>Python 高阶函数</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-high-order-function">https://www.javatpoint.com/python-high-order-function</a></p>
</blockquote>
<p>因为我们必须了解 Python 函数的基本概念，所以我们应该继续讨论一些与 Python 函数相关的高级概念。在本教程中，我们将讨论 Python 中高阶函数的重要方面，例如什么是高阶函数，我们如何在 Python 中定义它们，如何在 Python 中使用它们，以及高阶函数的属性是什么。</p>
<h3 id="先决条件-2">先决条件:</h3>
<p>要了解 Python 中的高阶函数，我们必须具备以下概念的基本知识:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>Python 函数</p>
</li>
<li class="lvl-4">
<p>Parameters</p>
</li>
<li class="lvl-4">
<p>Python 对象</p>
</li>
<li class="lvl-4">
<p>Python 装饰器</p>
</li>
</ul>
<p>首先，让我们从第一件事开始，即高阶函数，并了解它们的一个基本情况。</p>
<h2 id="高阶函数">高阶函数</h2>
<p>将另一个函数作为参数的函数或在输出中返回另一个函数作为返回的函数称为高阶函数。高阶函数与程序中给出的其他函数一起工作。</p>
<p>关于高阶函数的一个事实是，高阶函数既适用于两个函数，也适用于将函数作为其参数或作为其结果返回函数的方法。在 <a href="https://www.javatpoint.com/python-tutorial">Python</a> 中，这个高阶函数的概念得到了方方面面的支持。</p>
<h3 id="Python-中高阶函数的性质">Python 中高阶函数的性质</h3>
<p>现在，在本节中，我们将讨论同样适用于 Python 的高阶函数的一些重要属性。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>在高阶函数中，我们可以在变量中存储函数。</p>
</li>
<li class="lvl-4">
<p>在高阶函数中，函数可以充当对象类型的瞬间。</p>
</li>
<li class="lvl-4">
<p>在高阶函数中，我们可以将一个函数作为另一个函数的结果返回。</p>
</li>
<li class="lvl-4">
<p>在高阶函数中，我们可以将一个函数作为参数或自变量传递给另一个函数。</p>
</li>
<li class="lvl-4">
<p>我们可以以列表、哈希表等数据结构格式存储 Python 高阶函数。</p>
</li>
</ul>
<h2 id="Python-中的高阶函数">Python 中的高阶函数</h2>
<p>现在，在本节中，我们将具体讨论 Python 高阶函数以及如何定义它们。我们将讨论在 Python 程序中定义和使用高阶函数的方法和手段。</p>
<p>以下是我们将在本教程中讨论的在 Python 代码中定义高阶函数的方法。</p>
<ol>
<li class="lvl-4">
<p>在高阶函数中使用函数作为对象</p>
</li>
<li class="lvl-4">
<p>作为高阶函数的结果返回函数</p>
</li>
<li class="lvl-4">
<p>函数作为另一个函数的参数</p>
</li>
<li class="lvl-4">
<p>装饰者作为高阶函数</p>
</li>
</ol>
<p>现在，我们将详细讨论上面给出的每种方法，并了解它们在 Python 程序中作为高阶函数的实现。</p>
<h3 id="方法-1-在高阶函数中使用函数作为对象">方法 1:在高阶函数中使用函数作为对象</h3>
<p>在 Python 中，我们甚至可以给变量分配一个给定的函数。将函数赋值到变量中不会调用实际函数，相反，它会创建对所创建函数的引用。因此，它使得这种将函数赋值为变量对象的赋值将在程序中创建一个高阶函数。</p>
<p>查看下面的示例程序，了解我们上面讨论的方法的实现:</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># a default function to take another function parameter</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spell</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="comment"># Making text in upper</span></span><br><span class="line">    <span class="keyword">return</span> text.upper() </span><br><span class="line"><span class="comment"># Taking text as user input</span></span><br><span class="line">text = <span class="built_in">input</span>(<span class="string">&quot;Enter a text to print it in uppercase and double: &quot;</span>)</span><br><span class="line"><span class="comment"># Spell function with text</span></span><br><span class="line"><span class="built_in">print</span>(spell(text)) </span><br><span class="line"><span class="comment"># Assigning variable with the default function</span></span><br><span class="line">scream = spell</span><br><span class="line"><span class="comment"># Scream with text variable</span></span><br><span class="line"><span class="built_in">print</span>(scream(text))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter a text to <span class="built_in">print</span> it <span class="keyword">in</span> uppercase <span class="keyword">and</span> double: JavaTPoint</span><br><span class="line">JAVATPOINT</span><br><span class="line">JAVATPOINT</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="方法-2-将函数作为另一个函数的参数">方法 2:将函数作为另一个函数的参数</h3>
<p>基本上，Python 函数就像 Python 对象，因此我们可以使用 Python 函数将它们作为参数传递给另一个函数，这将在程序中创建一个高阶函数。</p>
<p>看下面的程序来理解上面给出的方法的实现:</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Default function for making text uppercase</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scream</span>(<span class="params">word</span>): </span><br><span class="line">    <span class="keyword">return</span> word.upper() </span><br><span class="line"><span class="comment"># Default function for making text lowercase</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spell</span>(<span class="params">word</span>): </span><br><span class="line">    <span class="keyword">return</span> word.lower() </span><br><span class="line"><span class="comment"># A third function that work as a high order function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">funct</span>): </span><br><span class="line">    <span class="comment"># Storing the function in a variable in high order function </span></span><br><span class="line">    speaking = funct(<span class="string">&quot;Hello Python Developers! You are welcomed to JavaTpoint&quot;</span>) </span><br><span class="line">    <span class="built_in">print</span>(speaking)  </span><br><span class="line"><span class="comment"># Printing text in uppercase</span></span><br><span class="line">speak(scream)</span><br><span class="line"><span class="comment"># Printing text in lowercase</span></span><br><span class="line">speak(spell)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">HELLO PYTHON DEVELOPERS! YOU ARE WELCOMED TO JAVATPOINT</span><br><span class="line">hello python developers! you are welcomed to javatpoint</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="方法-3-返回函数作为高阶函数的结果">方法 3:返回函数作为高阶函数的结果</h3>
<p>我们还可以将一个函数作为另一个函数的结果作为一个对象返回，这使得该函数成为一个高阶函数。</p>
<p>查看下面的示例程序，了解我们上面讨论的方法的实现:</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># A default function for addition</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Adding</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="comment"># Nested function with second number </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Addition</span>(<span class="params">b</span>): </span><br><span class="line">            <span class="keyword">return</span> a + b <span class="comment"># addition of two numbers</span></span><br><span class="line">    <span class="keyword">return</span> Addition <span class="comment"># Result</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Taking both number variable as user input</span></span><br><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter First Number: &quot;</span>))</span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter Second Number: &quot;</span>))</span><br><span class="line"><span class="comment"># Assigning nested adding function to a variable</span></span><br><span class="line">AddVariable = Adding(a)</span><br><span class="line"><span class="comment"># Using variable as high order function</span></span><br><span class="line">Result = AddVariable(b)</span><br><span class="line"><span class="comment"># Printing result</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sum of Two numbers given by you is: &quot;</span>, Result)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Enter First Number: <span class="number">24</span></span><br><span class="line">Enter Second Number: <span class="number">26</span></span><br><span class="line">Sum of Two numbers given by you <span class="keyword">is</span>:  <span class="number">50</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="方法-4-装饰器作为高阶函数">方法 4:装饰器作为高阶函数</h3>
<p>我们可以使用装饰器作为 Python 中最常用的高阶函数。Python 中的装饰器允许我们修改我们在程序中定义的方法或函数的行为，它还允许我们将一个函数包装在另一个函数中，以扩展包装或父函数的行为。我们甚至可以将一个函数包装在另一个函数中，甚至不需要永久修改父函数。</p>
<p>在 Python 装饰器中，一个函数被作为另一个函数的参数，然后这些装饰器在包装的函数中被调用。请看下面 Python 程序中定义的装饰器的示例语法。</p>
<p><strong>语法</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Using a decorator</span></span><br><span class="line"><span class="meta">@JTP_Decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Python_Decorator</span>(): </span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>装饰器的上述语法相当于下面高阶函数的 Python 代码。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Using Python default function as Python decorators</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Python_Decorator</span>(): </span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">Python_Decorator = @JTP_Decorator(Python_Decorator)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面给出的代码中，我们将@JTP_Decorator 称为默认 Python_Decorator()函数中的一个可调用函数。我们将不得不在这个结构中添加一些额外的代码，我们将获得作为包装函数的输出。</p>
<p>看下面的程序来理解上面给定方法的实现:</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Using default function as Python decorators</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Python_Decorator</span>(<span class="params">funct</span>):</span><br><span class="line">       <span class="comment"># Inner nested function</span></span><br><span class="line">       <span class="keyword">def</span> <span class="title function_">inner</span>(): </span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&quot;This line of code will be printed before the execution of high order function&quot;</span>)</span><br><span class="line">              funct() </span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&quot;This line of code will be printed after the execution of high order function&quot;</span>)</span><br><span class="line">       <span class="keyword">return</span> inner </span><br><span class="line"><span class="comment"># A default function as decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">JTP_Decorator</span>(): </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This line of code will be printed inside the execution of high order function&quot;</span>)</span><br><span class="line">JTP_Decorator = Python_Decorator(JTP_Decorator) <span class="comment"># Python decorator as high order function </span></span><br><span class="line"><span class="comment"># Python decorator calling out as high order function </span></span><br><span class="line">JTP_Decorator()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">This line of code will be printed before the execution of high order function</span><br><span class="line">This line of code will be printed inside the execution of high order function</span><br><span class="line">This line of code will be printed after the execution of high order function</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>pyspark.mllib</title>
    <url>/posts/ca8c56c3.html</url>
    <content><![CDATA[<h1><code>pyspark.mllib</code></h1>
<p>机器学习是一种数据分析技术，它将数据与统计工具相结合来预测输出。这种预测被各种企业行业用来做出有利的决策。</p>
<p>PySpark 提供了一个名为 <strong>mllib</strong> 的机器学习 API。PySpark 的 mllib 支持各种机器学习算法，如分类、回归聚类、协同过滤和降维以及底层优化原语。下面给出了各种机器学习概念:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>分类</strong></p>
</li>
</ul>
<p><strong>pyspark.mllib</strong> 库支持多种分类方法，如二元分类、多类分类和回归分析。该对象可能属于不同的类。分类的目的是根据信息区分数据。<strong>随机森林、朴素贝叶斯、决策树</strong>是分类中最有用的算法。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>聚类</strong></p>
</li>
</ul>
<p>聚类是一个无监督的机器学习问题。当您不知道如何对数据进行分类时，会用到它；我们需要算法来找到模式，并相应地对数据进行分类。流行的聚类算法有 <strong>K 均值聚类、高斯混合模型、层次聚类。</strong></p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>fpm</strong></p>
</li>
</ul>
<p>fpm 是指频繁模式匹配，用于挖掘各种项目、项目集、子序列或其他子结构。它主要用于大规模数据集。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>pyspark-mllib</strong></p>
</li>
</ul>
<p><strong>mllib.linalg</strong> 实用程序用于线性代数。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>推荐</strong></p>
</li>
</ul>
<p>用于定义推荐的相关数据。它能够预测未来的偏好，并推荐最热门的项目。比如在线娱乐平台<strong>网飞</strong>电影收藏量巨大，有时候人们在挑选喜欢的项目时会面临困难。这是推荐发挥重要作用的领域。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>mllib 回归</strong></p>
</li>
</ul>
<p>回归用于寻找变量之间的关系和依赖关系。它发现数据的每个特征之间的相关性，并预测未来的值。</p>
<p>mllib 包支持许多其他算法、类和函数。在这里我们将了解 <strong>pyspak.mllib</strong> 的基本概念。</p>
<h2 id="MLlib-功能">MLlib 功能</h2>
<p><strong>PySpark mllib</strong> 对迭代算法很有用。特点如下:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>**提取:**从“行”数据中提取特征。</p>
</li>
<li class="lvl-4">
<p>**变换:**用于缩放、转换或修改要素。</p>
</li>
<li class="lvl-4">
<p>**选择:**从更大的特征集中选择有用的子集。</p>
</li>
<li class="lvl-4">
<p>**位置敏感哈希:**它将特征变换的各个方面与其他算法相结合。</p>
</li>
</ul>
<p>让我们来看看 PySpark MLlib 的基本库。</p>
<h3 id="线性回归">线性回归</h3>
<p>线性回归用于寻找变量之间的关系和依赖关系。考虑以下代码:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">frompyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line">spark = SparkSession.builder.appName(<span class="string">&#x27;Customer&#x27;</span>).getOrCreate()</span><br><span class="line">frompyspark.ml.regression <span class="keyword">import</span> LinearRegression</span><br><span class="line">dataset = spark.read.csv(<span class="string">r&#x27;C:\Users\DEVANSH SHARMA\Ecommerce-Customers.csv&#x27;</span>)</span><br><span class="line">dataset.show(<span class="number">10</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">+--------------------+--------------------+----------------+------------------+------------------+------------------+--------------------+-------------------+</span><br><span class="line">|                 _c0|                 _c1|             _c2|               _c3|               _c4|               _c5|                 _c6|                _c7|</span><br><span class="line">+--------------------+--------------------+----------------+------------------+------------------+------------------+--------------------+-------------------+</span><br><span class="line">|               Email|             Address|          Avatar|Avg Session Length|       Time on App|   Time on Website|Length of Membership|Yearly Amount Spent|</span><br><span class="line">|[email protected]|<span class="number">835</span> Frank TunnelW...|          Violet| <span class="number">34.49726772511229</span>| <span class="number">12.65565114916675</span>| <span class="number">39.57766801952616</span>|  <span class="number">4.0826206329529615</span>|  <span class="number">587.9510539684005</span>|</span><br><span class="line">|   [email protected]|<span class="number">4547</span> Archer Commo...|       DarkGreen| <span class="number">31.92627202636016</span>|<span class="number">11.109460728682564</span>|<span class="number">37.268958868297744</span>|    <span class="number">2.66403418213262</span>|  <span class="number">392.2049334443264</span>|</span><br><span class="line">|    [email protected]|<span class="number">24645</span> Valerie Uni...|          Bisque|<span class="number">33.000914755642675</span>|<span class="number">11.330278057777512</span>|<span class="number">37.110597442120856</span>|   <span class="number">4.104543202376424</span>| <span class="number">487.54750486747207</span>|</span><br><span class="line">|riverar[email protected]|<span class="number">1414</span> David Throug...|     SaddleBrown| <span class="number">34.30555662975554</span>|<span class="number">13.717513665142507</span>| <span class="number">36.72128267790313</span>|   <span class="number">3.120178782748092</span>|  <span class="number">581.8523440352177</span>|</span><br><span class="line">|[email protected]|<span class="number">14023</span> Rodriguez P...|MediumAquaMarine| <span class="number">33.33067252364639</span>|<span class="number">12.795188551078114</span>| <span class="number">37.53665330059473</span>|   <span class="number">4.446308318351434</span>|  <span class="number">599.4060920457634</span>|</span><br><span class="line">|[email protected]|<span class="number">645</span> Martha Park A...|     FloralWhite|<span class="number">33.871037879341976</span>|<span class="number">12.026925339755056</span>| <span class="number">34.47687762925054</span>|   <span class="number">5.493507201364199</span>|   <span class="number">637.102447915074</span>|</span><br><span class="line">|[email protected]|<span class="number">68388</span> Reyes Light...|   DarkSlateBlue| <span class="number">32.02159550138701</span>|<span class="number">11.366348309710526</span>| <span class="number">36.68377615286961</span>|   <span class="number">4.685017246570912</span>|  <span class="number">521.5721747578274</span>|</span><br><span class="line">|  [email protected]|Unit <span class="number">6538</span> Box <span class="number">898.</span>..|            Aqua|<span class="number">32.739142938380326</span>| <span class="number">12.35195897300293</span>| <span class="number">37.37335885854755</span>|  <span class="number">4.4342734348999375</span>|  <span class="number">549.9041461052942</span>|</span><br><span class="line">|[email protected]|<span class="number">860</span> Lee KeyWest D...|          Salmon| <span class="number">33.98777289568564</span>|<span class="number">13.386235275676436</span>|<span class="number">37.534497341555735</span>|  <span class="number">3.2734335777477144</span>|  <span class="number">570.2004089636196</span>|</span><br><span class="line">+--------------------+--------------------+----------------+------------------+------------------+------------------+--------------------+-------------------+</span><br><span class="line">only showing top <span class="number">10</span> rows</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在下面的代码中，我们正在导入 <strong>VectorAssembler</strong> 库来创建一个新的列独立特性:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">frompyspark.ml.linalg <span class="keyword">import</span> Vectors</span><br><span class="line">frompyspark.ml.feature <span class="keyword">import</span> VectorAssembler</span><br><span class="line">featureassembler = VectorAssembler(inputCols = [<span class="string">&quot;Avg Session Length&quot;</span>,<span class="string">&quot;Time on App&quot;</span>,<span class="string">&quot;Time on Website&quot;</span>],outputCol = <span class="string">&quot;Independent Features&quot;</span>)</span><br><span class="line">output = featureassembler.transform(dataset)</span><br><span class="line">output.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">+------------------+</span><br><span class="line">Independent Feature</span><br><span class="line">+------------------+</span><br><span class="line">|<span class="number">34.49726772511229</span> |</span><br><span class="line">|<span class="number">31.92627202636016</span> |</span><br><span class="line">|<span class="number">33.000914755642675</span>|</span><br><span class="line">|<span class="number">34.30555662975554</span> |</span><br><span class="line">|<span class="number">33.33067252364639</span> |</span><br><span class="line">|<span class="number">33.871037879341976</span>|</span><br><span class="line">|<span class="number">32.02159550138701</span> |</span><br><span class="line">|<span class="number">32.739142938380326</span>|</span><br><span class="line">|<span class="number">33.98777289568564</span> |</span><br><span class="line">+------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">z = featureassembler.transform(dataset)</span><br><span class="line">finlized_data = z.select(<span class="string">&quot;Indepenent feature&quot;</span>, <span class="string">&quot;Yearly Amount Spent&quot;</span>,)</span><br><span class="line">z.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">+--------------------++-------------------+</span><br><span class="line">|Independent Feature | Yearly Amount Spent|</span><br><span class="line">+--------------------++-------------------+</span><br><span class="line">|<span class="number">34.49726772511229</span>   | <span class="number">587.9510539684005</span>  |</span><br><span class="line">|<span class="number">31.92627202636016</span>   | <span class="number">392.2049334443264</span>  |</span><br><span class="line">|<span class="number">33.000914755642675</span>  | <span class="number">487.5475048674720</span>  |</span><br><span class="line">|<span class="number">34.30555662975554</span>   | <span class="number">581.8523440352177</span>  |</span><br><span class="line">|<span class="number">33.33067252364639</span>   | <span class="number">599.4060920457634</span>  |</span><br><span class="line">|<span class="number">33.871037879341976</span>  | <span class="number">637.102447915074</span>   |</span><br><span class="line">|<span class="number">32.02159550138701</span>   | <span class="number">521.5721747578274</span>  |</span><br><span class="line">|<span class="number">32.739142938380326</span>  | <span class="number">549.9041461052942</span>  |</span><br><span class="line">|<span class="number">33.98777289568564</span>   | <span class="number">570.2004089636196</span>  |</span><br><span class="line">+--------------------++-------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>PySpark 提供了**线性回归()**函数来查找任何给定数据集的预测。语法如下:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">regressor = LinearRegression(featureCol = <span class="string">&#x27;column_name1&#x27;</span>, labelCol = <span class="string">&#x27;column_name2 &#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="K-Mean-聚类算法">K- Mean 聚类算法</h2>
<p>K- Mean 聚类算法是最流行和最常用的算法之一。它用于将数据点聚类成预定义数量的聚类。下面的例子展示了 MLlib K-Means 集群库的使用:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyspark.ml.clustering <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">from</span> pyspark.ml.evaluation <span class="keyword">import</span> ClusteringEvaluator</span><br><span class="line"><span class="comment"># Loads data.</span></span><br><span class="line">dataset = spark.read.<span class="built_in">format</span>(<span class="string">&quot;libsvm&quot;</span>).load(<span class="string">r&quot;C:\Users\DEVANSH SHARMA\Iris.csv&quot;</span>)</span><br><span class="line"><span class="comment"># Trains a k-means model.</span></span><br><span class="line">kmeans = KMeans().setK(<span class="number">2</span>).setSeed(<span class="number">1</span>)</span><br><span class="line">model = kmeans.fit(dataset)</span><br><span class="line"><span class="comment"># Make predictions</span></span><br><span class="line">predictions = model.transform(dataset)</span><br><span class="line"><span class="comment"># Evaluate clustering by computing Silhouette score</span></span><br><span class="line">evaluator = ClusteringEvaluator()</span><br><span class="line">silhouette = evaluator.evaluate(predictions)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Silhouette with squared euclidean distance = &quot;</span> + <span class="built_in">str</span>(silhouette))</span><br><span class="line"><span class="comment"># Shows the result.</span></span><br><span class="line">centers = model.clusterCenters()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Cluster Centers: &quot;</span>)</span><br><span class="line"><span class="keyword">for</span> center <span class="keyword">in</span> centers:</span><br><span class="line">    <span class="built_in">print</span>(center)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="PySpark-MLlib-的参数">PySpark MLlib 的参数</h3>
<p><strong>PySpark MLlib</strong> 的几个重要参数如下:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Ratings</strong></p>
</li>
</ul>
<p>它是 RDD 的评级或(用户标识，产品标识，评级)元组。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Rank</strong></p>
</li>
</ul>
<p>它表示计算的特征矩阵的秩(特征的数量)。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Iterations</strong></p>
</li>
</ul>
<p>它代表 ALS 的迭代次数。(默认值:5)</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Lambda</strong></p>
</li>
</ul>
<p>它是正则化参数。(默认值:0.01)</p>
<ul class="lvl-0">
<li class="lvl-4">
<p><strong>Blocks</strong></p>
</li>
</ul>
<p>它用于并行计算一些块。</p>
<h3 id="协同过滤">协同过滤</h3>
<p>协同过滤是一种通常用于推荐系统的技术。这项技术的重点是填充用户项目中缺失的条目。关联矩阵 <strong><a href="http://spark.ml">spark.ml</a></strong> 目前支持基于模型的协同过滤。在协同过滤中，用户和产品由一小组隐藏因素描述，这些因素可用于预测缺失条目。</p>
<h3 id="正则化参数的缩放">正则化参数的缩放</h3>
<p>正则化参数<strong>正则化参数</strong>被缩放以解决最小二乘问题。最小二乘问题出现在用户在更新用户因素时生成的评分数，或产品在更新产品因素时收到的评分数。</p>
<h3 id="冷启动策略">冷启动策略</h3>
<p>**ALS 模型(替代最小二乘模型)**用于预测，同时进行常见的预测问题。测试数据集中的用户或项目在训练模型期间可能不存在时遇到的问题。它可能发生在下面给出的两种情况下:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>在预测中，模型不是针对没有评级历史的用户和项目进行训练的(称为冷启动策略)。</p>
</li>
<li class="lvl-4">
<p>在交叉验证过程中，数据在训练集和评估集之间进行分割。遇到不在训练集中的评估集中的用户和项目是很普遍的。</p>
</li>
</ul>
<p>Let’s consider the following example, where we load ratings data from the MovieLens dataset. Each row is containing a user, a movie, rating and a timestamp.</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#importing the libraries</span></span><br><span class="line">frompyspark.ml.evaluation <span class="keyword">import</span> RegressionEvaluator</span><br><span class="line">frompyspark.ml.recommendation <span class="keyword">import</span> ALS</span><br><span class="line">frompyspark.sql <span class="keyword">import</span> Row</span><br><span class="line">no_of_lines = spark.read.text(<span class="string">r&quot;C:\Users\DEVANSH SHARMA\MovieLens.csv&quot;</span>).rdd</span><br><span class="line">no_of_parts = no_of_lines.<span class="built_in">map</span>(<span class="keyword">lambda</span> row: row.value.split(<span class="string">&quot;::&quot;</span>))</span><br><span class="line">ratingsRDD = no_of_lines.<span class="built_in">map</span>(<span class="keyword">lambda</span> p: Row(userId=<span class="built_in">int</span>(p[<span class="number">0</span>]), movieId=<span class="built_in">int</span>(p[<span class="number">1</span>]),</span><br><span class="line">                                     rating=<span class="built_in">float</span>(p[<span class="number">2</span>]), timestamp=long(p[<span class="number">3</span>])))</span><br><span class="line">ratings = spark.createDataFrame(ratingsRDD)</span><br><span class="line">(training, test) = ratings.randomSplit([<span class="number">0.8</span>, <span class="number">0.2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Develop the recommendation model using ALS on the training data</span></span><br><span class="line"><span class="comment"># Note we set cold start strategy to make sure that we don&#x27;t get NaN evaluation metrics.</span></span><br><span class="line">als = ALS(maxIter=<span class="number">5</span>, regParam=<span class="number">0.01</span>, userCol=<span class="string">&quot;userId&quot;</span>, itemCol=<span class="string">&quot;movieId&quot;</span>, ratingCol=<span class="string">&quot;rating&quot;</span>,</span><br><span class="line">    coldStartStrategy=<span class="string">&quot;drop&quot;</span>)</span><br><span class="line">model = als.fit(training)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calculate the model by computing the RMSE on the test data</span></span><br><span class="line">predictions = model.transform(test)</span><br><span class="line">evaluator = RegressionEvaluator(metricName=<span class="string">&quot;rmse&quot;</span>, labelCol=<span class="string">&quot;rating&quot;</span>,</span><br><span class="line">predictionCol=<span class="string">&quot;prediction&quot;</span>)</span><br><span class="line">rmse = evaluator.evaluate(predictions)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Root-mean-square error = &quot;</span> + <span class="built_in">str</span>(rmse))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Evaluate top 10 movie recommendations for each user</span></span><br><span class="line">userRecs = model.recommendForAllUsers(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># Evaluate top 10 user recommendations for each movie</span></span><br><span class="line">movieRecs = model.recommendForAllItems(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># Evaluate top 10 movie recommendations for a specified set of users</span></span><br><span class="line">users = ratings.select(als.getUserCol()).distinct().limit(<span class="number">3</span>)</span><br><span class="line">userSubsetRecs = model.recommendForUserSubset(users, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># Evalute top 10 user recommendations for a specified set of movies</span></span><br><span class="line">movies = ratings.select(als.getItemCol()).distinct().limit(<span class="number">3</span>)</span><br><span class="line">movieSubSetRecs = model.recommendForItemSubset(movies, <span class="number">10</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/pyspark-mllib">https://www.javatpoint.com/pyspark-mllib</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>如何用GEOPY计算两点之间的距离</title>
    <url>/posts/477a984f.html</url>
    <content><![CDATA[<h1>如何用 GEOPY 计算两点之间的距离？</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/how-to-calculate-distance-between-two-points-using-geopy">https://www.javatpoint.com/how-to-calculate-distance-between-two-points-using-geopy</a></p>
</blockquote>
<p><strong>geopy</strong>是一个帮助计算地理距离的 Python 库。在本教程中，我们将讨论用户如何计算地球上两个地方之间距离的不同方法。</p>
<p>首先，用户必须使用以下命令安装<strong>geopy</strong>:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install geopy</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>安装成功后，我们准备与地质图书馆合作。</p>
<h2 id="计算两点之间的距离">计算两点之间的距离</h2>
<p>下面是用来计算两点之间距离的重要方法。</p>
<h3 id="方法-1-使用测地线距离">方法 1:使用测地线距离</h3>
<p>测地线距离是地球任何表面上两点之间最短路径的长度。在下面的示例中，我们将展示用户如何根据纬度和经度数据计算测地线距离。</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># First, import the geodesic module from the geopy library</span></span><br><span class="line"><span class="keyword">from</span> geopy.distance <span class="keyword">import</span> geodesic <span class="keyword">as</span> GD</span><br><span class="line"></span><br><span class="line"><span class="comment"># Then, load the latitude and longitude data for New York &amp; Texas</span></span><br><span class="line">New_York = (<span class="number">40.7128</span>, <span class="number">74.0060</span>)</span><br><span class="line">Texas = (<span class="number">31.9686</span>, <span class="number">99.9018</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># At last, print the distance between two points calculated in kilo-metre</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;The distance between New York and Texas is: &quot;</span>, GD(New_York, Texas).km)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The distance between New York <span class="keyword">and</span> Texas <span class="keyword">is</span>:  <span class="number">2507.14797665193</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="方法-2-使用大圆距离">方法 2:使用大圆距离</h3>
<p>大圆距离是球面上两点之间的最短路径。在这种情况下，我们将假设地球是完美的球体。以下示例显示了用户如何使用两点的经度和纬度数据来计算大圆距离。</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># First, import the great_circle module from the geopy library</span></span><br><span class="line"><span class="keyword">from</span> geopy.distance <span class="keyword">import</span> great_circle <span class="keyword">as</span> GC</span><br><span class="line"></span><br><span class="line"><span class="comment"># Then, load the latitude and longitude data for New York &amp; Texas</span></span><br><span class="line">New_York = (<span class="number">40.7128</span>, <span class="number">74.0060</span>)</span><br><span class="line">Texas = (<span class="number">31.9686</span>, <span class="number">99.9018</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># At last, print the distance between two points calculated in kilo-metre</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;The distance between New York and Texas is: &quot;</span>, GC(New_York, Texas).km)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The distance between New York <span class="keyword">and</span> Texas <span class="keyword">is</span>:  <span class="number">2503.045970189156</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="方法三-利用哈弗斯公式">方法三:利用哈弗斯公式</h3>
<p>正交距离用于计算地球表面两个纬度和经度点之间的最短距离。</p>
<p>使用这种方法，用户需要有两个点的坐标 <strong>(P 和 Q)。</strong></p>
<p>首先，他们必须将纬度和经度点的值从十进制度转换为弧度，然后将纬度和经度的值除以(180/π)。用户应该使用“π = 22/7”的值。那么，(180/π)的值将是“57.29577”。如果用户想要计算以英里为单位的距离，他们可以使用地球半径的值，即“3，963”。如果用户想以千米为单位计算距离，他们可以使用值“6，378.80”。</p>
<p><strong>公式:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">How to calculate the value of latitude <span class="keyword">in</span> radians:</span><br><span class="line">The value of Latitude <span class="keyword">in</span> Radian: Latitude (La1) = La1 / (<span class="number">180</span>/?)</span><br><span class="line">OR</span><br><span class="line">The value of Latitude <span class="keyword">in</span> Radian: Latitude (La1) = La1 / <span class="number">57.29577</span></span><br><span class="line">How to calculate the value of longitude <span class="keyword">in</span> radians:</span><br><span class="line">The value of Longitude <span class="keyword">in</span> Radian: Longitude (Lo1) = Lo1 / (<span class="number">180</span>/?)</span><br><span class="line">OR</span><br><span class="line">The value of Longitude <span class="keyword">in</span> Radian: Longitude (Lo1) = Lo1 / <span class="number">57.29577</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用户需要用经纬度表示 P 点和 Q 点的坐标，然后用上面的公式转换成弧度。</p>
<p>现在，使用以下公式计算两点之间的距离。</p>
<p><strong>公式:</strong></p>
<p><strong>英里:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Distance (D) = <span class="number">3963.0</span> * arccos[(sin(La1) * sin(La2)) + cos(La1) * cos(La2) * cos(Lo2 - Lo1)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>公里:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Distance (D) = <span class="number">3963.0</span> * arccos[(sin(La1) * sin(La2)) + cos(La1) * cos(La2) * cos(Lo2 - Lo1)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因此，用户可以使用哈弗辛公式计算地球上两个给定点之间的最短距离。</p>
<p><strong>示例:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> radians, cos, sin, asin, sqrt</span><br><span class="line"><span class="comment"># For calculating the distance in Kilometres </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">distance_1</span>(<span class="params">La1, La2, Lo1, Lo2</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The math module contains the function name &quot;radians&quot; which is used for converting the degrees value into radians.</span></span><br><span class="line">    Lo1 = radians(Lo1)</span><br><span class="line">    Lo2 = radians(Lo2)</span><br><span class="line">    La1 = radians(La1)</span><br><span class="line">    La2 = radians(La2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Using the &quot;Haversine formula&quot;</span></span><br><span class="line">    D_Lo = Lo2 - Lo1</span><br><span class="line">    D_La = La2 - La1</span><br><span class="line">    P = sin(D_La / <span class="number">2</span>)**<span class="number">2</span> + cos(La1) * cos(La2) * sin(D_Lo / <span class="number">2</span>)**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">    Q = <span class="number">2</span> * asin(sqrt(P))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The radius of earth in kilometres.</span></span><br><span class="line">    R_km = <span class="number">6371</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Then, we will calculate the result</span></span><br><span class="line">    <span class="keyword">return</span>(Q * R_km)</span><br><span class="line"></span><br><span class="line"><span class="comment"># driver code</span></span><br><span class="line">La1 = <span class="number">40.7128</span></span><br><span class="line">La2 = <span class="number">31.9686</span></span><br><span class="line">Lo1 = -<span class="number">74.0060</span></span><br><span class="line">Lo2 = -<span class="number">99.9018</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;The distance between New York and Texas is: &quot;</span>, distance_1(La1, La2, Lo1, Lo2), <span class="string">&quot;K.M&quot;</span>)</span><br><span class="line"><span class="comment"># For calculating the distance in Miles</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">distance_2</span>(<span class="params">La1, La2, Lo1, Lo2</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The math module contains the function name &quot;radians&quot; which is used for converting the degrees value into radians.</span></span><br><span class="line">    Lo1 = radians(Lo1)</span><br><span class="line">    Lo2 = radians(Lo2)</span><br><span class="line">    La1 = radians(La1)</span><br><span class="line">    La2 = radians(La2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Using the &quot;Haversine formula&quot;</span></span><br><span class="line">    D_Lo = Lo2 - Lo1</span><br><span class="line">    D_La = La2 - La1</span><br><span class="line">    P = sin(D_La / <span class="number">2</span>)**<span class="number">2</span> + cos(La1) * cos(La2) * sin(D_Lo / <span class="number">2</span>)**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">    Q = <span class="number">2</span> * asin(sqrt(P))</span><br><span class="line">    <span class="comment"># The radius of earth in Miles.</span></span><br><span class="line">    R_Mi = <span class="number">3963</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Then, we will calculate the result</span></span><br><span class="line">    <span class="keyword">return</span>(Q * R_Mi)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;The distance between New York and Texas is: &quot;</span>, distance_2(La1, La2, Lo1, Lo2), <span class="string">&quot;Miles&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">The distance between New York <span class="keyword">and</span> Texas <span class="keyword">is</span>:  <span class="number">2503.04243426357</span> K.M</span><br><span class="line">The distance between New York <span class="keyword">and</span> Texas <span class="keyword">is</span>:  <span class="number">1556.985899699659</span> Miles</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="结论-6">结论</h2>
<p>在本教程中，我们已经讨论了使用地质库计算地球表面两点之间距离的各种方法。我们已经展示了每种方法的示例。</p>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>如何用Python语言绘制谷歌地图</title>
    <url>/posts/9ac12a82.html</url>
    <content><![CDATA[<h1>如何用 Python 语言绘制谷歌地图</h1>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/how-to-plot-the-google-map-using-folium-package-in-python">https://www.javatpoint.com/how-to-plot-the-google-map-using-folium-package-in-python</a></p>
</blockquote>
<p>leaf 包建立在 Python 生态系统的<strong>数据争论</strong>优势和 JavaScript 语言的<strong>leaf.js 库</strong>的映射优势之上。用户可以使用 Python 操作他们的数据，然后通过叶包使用<strong>leaf.js</strong> 地图将其可视化。leaf package 是一种将数据可视化到 Leaflet.js 地图上的简单方法，该地图已经使用 Python 进行了操作。</p>
<h3 id="必需的模块和库">必需的模块和库</h3>
<p>**Folium:**用户可以使用以下命令安装叶包。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install folium</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>**Geopy:**Python 的 Geopy 模块让 <a href="https://www.javatpoint.com/python-tutorial">Python</a> 用户可以轻松定位地球表面的地标、城市、国家的坐标。要安装 geopy 模块，用户可以使用以下命令:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install geopy</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>成功安装两个库后，我们按照以下步骤绘制谷歌地图。</p>
<h3 id="步骤-1-创建基础地图">步骤 1:创建基础地图</h3>
<p>用户可以使用以下程序创建基础地图:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># First, import folium package</span></span><br><span class="line"><span class="keyword">import</span> folium</span><br><span class="line"><span class="keyword">from</span> geopy.geocoders <span class="keyword">import</span> Nominatim <span class="keyword">as</span> NT</span><br><span class="line"><span class="comment"># Initialize Nominatim API</span></span><br><span class="line">geo_locator = NT(user_agent = <span class="string">&quot;geoapiExercises&quot;</span>)</span><br><span class="line"><span class="comment"># write the place</span></span><br><span class="line">place_1 = <span class="string">&quot;Yemen&quot;</span></span><br><span class="line"></span><br><span class="line">location_1 = geo_locator.geocode(place_1)</span><br><span class="line"><span class="comment"># now, it will search for the location by using the latitude and longitude, with zoom_start = 15</span></span><br><span class="line">user_map1 = folium.Map(location = [location_1.longitude, location_1.latitude],</span><br><span class="line">                                        zoom_start = <span class="number">15</span> )</span><br><span class="line"><span class="comment"># At last, open the base map</span></span><br><span class="line">user_map1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<p><img src="/img/9ce219b58513c81edb50da5eeb4e666e.png" alt="How to Plot the Google Map using folium package in Python"></p>
<h3 id="步骤-2-添加圆形标记">步骤 2:添加圆形标记</h3>
<p>用户可以使用以下代码用圆圈和弹出文本标记该区域:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> folium</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> geopy.geocoders <span class="keyword">import</span> Nominatim <span class="keyword">as</span> NT</span><br><span class="line"></span><br><span class="line">geo_locator = NT(user_agent = <span class="string">&quot;geoapiExercises&quot;</span>)</span><br><span class="line"></span><br><span class="line">place_1 = <span class="string">&quot;Yemen&quot;</span></span><br><span class="line"></span><br><span class="line">location_1 = geo_locator.geocode(place_1)</span><br><span class="line"></span><br><span class="line">user_map1 = folium.Map(location = [location_1.longitude, location_1.latitude],</span><br><span class="line">                                        zoom_start = <span class="number">15</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># CircleMarker with radius</span></span><br><span class="line">folium.CircleMarker(location = [location_1.longitude, location_1.latitude],</span><br><span class="line">                    radius = <span class="number">45</span>, popup = <span class="string">&#x27; YEMEN &#x27;</span>).add_to(user_map1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now, open the Map with circular Mark</span></span><br><span class="line">user_map1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<p><img src="/img/33d6945ebb967444ba52f9c8a34fc6ad.png" alt="How to Plot the Google Map using folium package in Python"></p>
<h3 id="步骤-3-用弹出文本为降落伞样式标记添加简单标记">步骤 3:用弹出文本为降落伞样式标记添加简单标记</h3>
<p>用户可以使用以下代码。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> folium</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> geopy.geocoders <span class="keyword">import</span> Nominatim <span class="keyword">as</span> NT</span><br><span class="line"></span><br><span class="line">geo_locator = NT(user_agent = <span class="string">&quot;geoapiExercises&quot;</span>)</span><br><span class="line"></span><br><span class="line">place_1 = <span class="string">&quot;Yemen&quot;</span></span><br><span class="line"></span><br><span class="line">location_1 = geo_locator.geocode(place_1)</span><br><span class="line"></span><br><span class="line">user_map1 = folium.Map(location = [location_1.longitude, location_1.latitude],</span><br><span class="line">                                        zoom_start = <span class="number">15</span>)</span><br><span class="line"><span class="comment">#Now, we will pass the string in popup parameter</span></span><br><span class="line">folium.Marker([location_1.longitude, location_1.latitude],</span><br><span class="line">               popup = [<span class="string">&#x27;YEMEN&#x27;</span>]).add_to(user_map1)</span><br><span class="line"><span class="comment"># now, open the map </span></span><br><span class="line">user_map1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<p><img src="/img/bf2329cb858eae909fef6c0f04824c26.png" alt="How to Plot the Google Map using folium package in Python"></p>
<h3 id="第四步-在地图上添加线条">第四步:在地图上添加线条</h3>
<p>用户可以使用以下代码在地图上添加直线来连接两个坐标。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># First, import folium package</span></span><br><span class="line"><span class="keyword">import</span> folium</span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="keyword">from</span> geopy.geocoders <span class="keyword">import</span> Nominatim <span class="keyword">as</span> NT</span><br><span class="line"></span><br><span class="line">geo_locator = NT(user_agent = <span class="string">&quot;geoapiExercises&quot;</span>)</span><br><span class="line"></span><br><span class="line">place_1 = <span class="string">&quot;Aden&quot;</span></span><br><span class="line">place_2 = <span class="string">&quot;Yemen&quot;</span></span><br><span class="line">location_1 = geo_locator.geocode(place_1)</span><br><span class="line">location_2 = geo_locator.geocode(place_2)</span><br><span class="line">user_map1 = folium.Map(location = [location_1.longitude, location_1.latitude],</span><br><span class="line">                                        zoom_start = <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">folium.Marker([location_1.longitude, location_1.latitude],</span><br><span class="line">               popup = [<span class="string">&#x27;Aden&#x27;</span>]).add_to(user_map1)</span><br><span class="line"></span><br><span class="line">folium.Marker([location_2.longitude, location_2.latitude],</span><br><span class="line">              popup = <span class="string">&#x27;Yemen&#x27;</span>).add_to(user_map1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now, we will add the line on the map by using Polyline method .</span></span><br><span class="line"><span class="comment"># it will connect both coordinates by the line</span></span><br><span class="line"></span><br><span class="line">folium.PolyLine(locations = [[location_1.longitude, location_1.latitude], [location_2.longitude, location_2.latitude]],</span><br><span class="line">                line_opacity = <span class="number">0.5</span>).add_to(user_map1)</span><br><span class="line"><span class="comment"># now, open the map</span></span><br><span class="line">user_map1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<p><img src="/img/b0734cf6f0b1dee3903f0cde74586895.png" alt="How to Plot the Google Map using folium package in Python"></p>
<p><strong>解释</strong></p>
<p>我们使用<strong>geopy</strong>库来获取位置的经纬度。然后我们使用<strong>folium</strong>包的<strong>folium.map</strong>方法创建谷歌地图的基础。</p>
<p>在步骤 2 中，我们使用“<strong>folium.CircleMarker</strong>，用于用弹出文本在位置上标记圆形标记。在第三步中，我们使用了“<strong>folium.Marker</strong>，在所述位置添加降落伞样式标记。最后一步，我们用“<strong>folium.PolyLine</strong>“用于连接地图上两个不同位置的两个标记。</p>
<h2 id="结论-7">结论</h2>
<p>在本教程中，我们展示了用户如何绘制谷歌地图，并在地图上添加不同的所需功能，如圆形标记、降落伞标记、弹出文本以及连接地图上两个坐标的线条。</p>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>第一个 Python 程序</title>
    <url>/posts/ba17123e.html</url>
    <content><![CDATA[<h1>第一个 Python 程序</h1>
<p>在本节中，我们将讨论 Python 的基本语法，我们将运行一个简单的程序在控制台上打印 <strong>Hello World</strong> 。</p>
<p>Python 为我们提供了两种运行程序的方法:</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>使用交互式解释器提示</p>
</li>
<li class="lvl-4">
<p>使用脚本文件</p>
</li>
</ul>
<p>让我们详细讨论每一个。</p>
<h2 id="交互式解释器提示">交互式解释器提示</h2>
<p>Python 为我们提供了在交互提示下逐一执行 Python 语句的功能。最好是在关注我们的 Python 程序的每一行的输出的情况下。</p>
<p>要打开交互模式，请打开终端(或命令提示符)并键入 python(如果系统上同时安装了 Python2 和 python3，请键入 Python3)。</p>
<p>它将打开以下提示，我们可以在其中执行 Python 语句，并检查它们对控制台的影响。</p>
<p><img src="/img/b45b70cd8f3d59bcbc252417a190a6db.png" alt="First Python Program"></p>
<p>写完打印语句后，按<strong>进入</strong>键。</p>
<p><img src="/img/5fc64e68cf8744644243ee5b7fdf9bb3.png" alt="First Python Program"></p>
<p>在这里，我们得到消息**“Hello World！”**印在控制台上。</p>
<h2 id="使用脚本文件-脚本模式编程">使用脚本文件(脚本模式编程)</h2>
<p>解释器提示最好是运行代码的单行语句。然而，我们不能每次都在终端上写代码。不适合写多行代码。</p>
<p>使用脚本模式，我们可以将多行代码写入一个文件，稍后可以执行。为此，我们需要打开记事本这样的编辑器，创建一个名为的文件，用**.py** 扩展，代表**“Python”。**现在，我们将使用脚本模式实现上面的示例。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> (<span class="string">&quot;hello world&quot;</span>); <span class="comment">#here, we have used print() function to print the message on the console.  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要运行这个名为 <a href="http://first.py">first.py</a> 的文件，我们需要在终端上运行以下命令。</p>
<p><img src="/img/f19ed885a491edbfb873f83d2907bc55.png" alt="First Python Program"></p>
<p>**第一步:<strong>打开 Python 交互 Shell，点击</strong>【文件】<strong>然后选择</strong>【新建】**会打开一个新的空白脚本，我们可以在里面写代码。</p>
<p><img src="/img/0858ba1570404037dd8f10c1741dcedd.png" alt="First Python Program"></p>
<p>**第 2 步:<strong>现在写代码，按</strong>“Ctrl+S”**保存文件。</p>
<p><img src="/img/e66ce69a2ce386f6c6b489c90bc23742.png" alt="First Python Program"></p>
<p><strong>步骤- 3:</strong> 保存代码后，我们可以通过点击“运行”或“运行模块”来运行。它将向 Shell 显示输出。</p>
<p><img src="/img/020dad4b47a6767ed07a348d901f20bc.png" alt="First Python Program"></p>
<p>输出如下所示。</p>
<p><img src="/img/6a3877bf279f2292a4db17b383a8ec7b.png" alt="First Python Program"></p>
<p><strong>步骤- 4:</strong> 除此之外，我们还可以使用操作系统终端运行文件。但是，我们应该知道保存文件的目录的路径。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>打开命令行提示符并导航到目录。</p>
</li>
</ul>
<p><img src="/img/6f11cb17f8b541703857a0e8edce7014.png" alt="First Python Program"></p>
<ul class="lvl-0">
<li class="lvl-4">
<p>我们需要键入 <strong>python</strong> 关键字，后跟文件名，然后点击回车运行 python 文件。</p>
</li>
</ul>
<p><img src="/img/9ef6f35eaf4c763b0033d7ef3c9e6f02.png" alt="First Python Program"></p>
<h2 id="多行语句">多行语句</h2>
<p>多行语句像编辑器一样写入记事本，用**.py** 分机。在下面的例子中，我们已经使用 Python 脚本定义了多个代码行的执行。</p>
<p><strong>代码:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;Andrew Venis&quot;</span></span><br><span class="line">branch = <span class="string">&quot;Computer Science&quot;</span></span><br><span class="line">age = <span class="string">&quot;25&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My name is: &quot;</span>, name, )</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My age is: &quot;</span>, age)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>脚本文件:</strong></p>
<p><img src="/img/131fb000877205dbba7f512ded2fcb41.png" alt="First Python Program"><br>
<img src="/img/e44277f08e7ff3adf2813f5cf209d85c.png" alt="First Python Program"></p>
<h3 id="脚本模式的利弊">脚本模式的利弊</h3>
<p>脚本模式也没有什么优点和缺点。让我们了解以下在脚本模式下运行代码的优点。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>我们可以运行多行代码。</p>
</li>
<li class="lvl-4">
<p>在脚本模式下调试很容易。</p>
</li>
<li class="lvl-4">
<p>它适合初学者，也适合专家。</p>
</li>
</ul>
<p>让我们看看脚本模式的缺点。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>如果我们对代码进行任何更改，我们必须每次都保存代码。</p>
</li>
<li class="lvl-4">
<p>当我们运行一行或几行代码时，可能会很乏味。</p>
</li>
</ul>
<h2 id="开始使用-PyCharm">开始使用 PyCharm</h2>
<p>在我们的第一个程序中，我们在 CentOS 上使用了 gedit 作为编辑器。在 Windows 上，我们有记事本或记事本++这样的替代工具来编辑代码。但是，这些编辑器不能用作 python 的 IDE，因为它们不能显示语法相关的建议。</p>
<p>JetBrains 提供了最流行和广泛使用的跨平台 IDE <strong>PyCharm</strong> 来运行 python 程序。</p>
<h2 id="PyCharm-安装">PyCharm 安装</h2>
<p>正如我们已经说过的，PyCharm 是一个跨平台的 IDE，因此它可以安装在各种操作系统上。在本节教程中，我们将介绍 PyCharm 在 Windows、 MacOS、 CentOS 和 Ubuntu 上的安装过程。</p>
<h3 id="Windows-操作系统">Windows 操作系统</h3>
<p>在 Windows 上安装 PyCharm 非常简单。要在 Windows 操作系统上安装 PyCharm，请访问链接<a href="https://www.jetbrains.com/pycharm/download/download-thanks.html?platform=windows">https://www.jetbrains.com/pycharm/download/download-thanks.htmlplatform=windows</a> 下载可执行的安装程序。<strong>双击</strong>安装程序(.exe)文件，并通过在每一步单击“下一步”来安装 PyCharm。</p>
<p>要为 Pycharm 创建第一个程序，请执行以下步骤。</p>
<p>**第一步。**打开 Pycharm 编辑器。点击“创建新项目”选项创建新项目。</p>
<p><img src="/img/6c4a690a830fb7756898d1777ba07013.png" alt="First Python Program"></p>
<p>**第 2 步。**选择保存项目的位置。</p>
<ol>
<li class="lvl-4">
<p>我们可以将新创建的项目保存在所需的内存位置，也可以保持文件位置不变，但至少要将项目默认名称<strong>无标题</strong>更改为**“第一个项目”**或其他有意义的名称。</p>
</li>
<li class="lvl-4">
<p>Pycharm 自动找到安装的 Python 解释器。</p>
</li>
<li class="lvl-4">
<p>更改名称后，点击“创建”按钮。</p>
</li>
</ol>
<p><img src="/img/1254113c7e0bc5fbfff0ae27039a7215.png" alt="First Python Program"></p>
<p><strong>第三步。<strong>点击</strong>文件</strong>菜单，选择**【新增】**。通过点击“新建”选项，它将显示各种文件格式。选择“Python 文件”。</p>
<p><img src="/img/97ee94acbd380ae231054d316f737607.png" alt="First Python Program"></p>
<p>**第 4 步。**现在输入 Python 文件的名称，点击“确定”。我们已经编写了“第一个程序”。</p>
<p><img src="/img/f73fd80a7f51cedf5cbab514d090894e.png" alt="First Python Program"></p>
<p>**第 5 步。**现在输入第一个程序-打印(“你好世界”)，然后点击“运行”菜单运行程序。</p>
<p><img src="/img/753315c8a9172f1b605d0dde9d5a705c.png" alt="First Python Program"></p>
<p>**第 6 步。**输出将出现在屏幕底部。</p>
<p><img src="/img/3776fdd928ef18fb45916d3eb5014387.png" alt="First Python Program"></p>
<h2 id="Python-的基本语法">Python 的基本语法</h2>
<h3 id="Python-中的缩进和注释">Python 中的缩进和注释</h3>
<p>缩进是 Python 编程语言中最重要的概念。缩进使用不当会导致代码中出现**“缩进错误”**。</p>
<p>缩进只是在需要时在语句前添加空格。没有缩进，Python 不知道接下来要执行哪条语句。缩进还定义了哪些语句属于哪个块。如果没有缩进或者缩进不当，会显示“<strong>缩进错误”</strong>，中断我们的代码。</p>
<p><img src="/img/51c622414ab8177982d7b601b5abd9c3.png" alt="First Python Program"></p>
<p>Python 缩进定义了属于特定块的特定语句组。诸如 C 、 C++ 、 java 等编程语言使用花括号{}来定义代码块。</p>
<p>在 Python 中，右边同一级别的语句属于同一个块。我们可以用四个空格来定义缩进。让我们看看下面几行代码。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list1:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">4</span>:</span><br><span class="line">       <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;End of for loop&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">End of <span class="keyword">for</span> loop</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>在上面的代码中，<code>for</code>循环有一个代码块，如果语句的代码块在 <code>for</code>循环内部。都缩进了四个空格。最后一条 <strong>print()</strong> 语句不缩进；这意味着它不属于 <code>for</code>循环。</p>
<h3 id="Python-中的注释">Python 中的注释</h3>
<p>注释对于定义代码并帮助我们和其他人理解代码至关重要。通过查看注释，我们可以很容易地理解我们用代码写的每一行的意图。我们还可以非常容易地找到错误，修复它们，并在其他应用中使用。</p>
<p>在 Python 中，我们可以使用# hash 字符应用注释。Python 解释器完全忽略后跟哈希字符的行。一个好的程序员总是在稳定的情况下使用注释来编写代码。让我们看看下面的注释示例。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">name  = <span class="string">&quot;Thomas&quot;</span>   <span class="comment"># Assigning string value to the name variable </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以在 Python 代码的每一行添加注释。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Fees = <span class="number">10000</span>      <span class="comment"># defining course fees is 10000</span></span><br><span class="line">Fees = <span class="number">20000</span>      <span class="comment"># defining course fees is 20000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最好在目的不明显的代码的代码段的任何一行中添加代码。这是在编码时学习的最佳实践。</p>
<h3 id="注释的类型">注释的类型</h3>
<p>Python 提供了以两种方式编写注释的工具——单行注释和多行注释。</p>
<p><strong>单行注释-</strong> 单行注释以 hash #字符开始，后面是文本，以便进一步解释。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># defining the marks of a student </span></span><br><span class="line">Marks = <span class="number">90</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们也可以在代码语句旁边写一个注释。考虑下面的例子。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Name = <span class="string">&quot;James&quot;</span>   <span class="comment"># the name of a student is James</span></span><br><span class="line">Marks = <span class="number">90</span>            <span class="comment"># defining student&#x27;s marks</span></span><br><span class="line">Branch = <span class="string">&quot;Computer Science&quot;</span>   <span class="comment"># defining student branch</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>多行注释-</strong> Python 没有对多行注释的明确支持，但是我们可以对多行使用 hash #字符。<strong>例如-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># we are defining for loop</span></span><br><span class="line"><span class="comment"># To iterate the given list.</span></span><br><span class="line"><span class="comment"># run this code.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们也可以用另一种方式。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot; &quot;</span> <span class="string">&quot; </span></span><br><span class="line"><span class="string">This is an example</span></span><br><span class="line"><span class="string">Of multi-line comment</span></span><br><span class="line"><span class="string">Using triple-quotes </span></span><br><span class="line"><span class="string">&quot;</span> <span class="string">&quot; &quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Python-标识符">Python 标识符</h2>
<p>Python 标识符是指用于标识变量、函数、模块、类、模块或其他对象的名称。命名 Python 变量时，几乎没有什么规则可遵循。</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>变量名必须以英文字母或下划线（<code>_</code>）开头。</p>
</li>
<li class="lvl-4">
<p>变量名不能以数字开头。</p>
</li>
<li class="lvl-4">
<p>变量名中不允许有特殊字符。</p>
</li>
<li class="lvl-4">
<p>变量的名称区分大小写。</p>
</li>
</ul>
<p>让我们理解下面的例子。</p>
<p><strong>示例-</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">number = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line">_a = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(_a)</span><br><span class="line"></span><br><span class="line">x_y = <span class="number">1000</span></span><br><span class="line"><span class="built_in">print</span>(x_y)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">1000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们已经定义了 Python 编程语言的基本语法。我们必须熟悉任何编程语言的核心概念。一旦我们记住了上面提到的概念。学习 Python 的旅程将变得更加容易。</p>
<h3 id="CentOS">CentOS</h3>
<p>要在 CentOS 上安装 PyCharm，请访问链接<a href="how-to-install-pycharm-on-centos"><em>【https://www.javatpoint.com/how-to-install-pycharm-on-centos】</em></a>。该链接将指导您在 CentOS 上安装 PyCharm。</p>
<h3 id="Mac">Mac</h3>
<p>要在 MacOS 上安装 PyCharm，请访问链接<a href="how-to-install-pycharm-on-mac"><em>【https://www.javatpoint.com/how-to-install-pycharm-on-mac】</em></a>。该链接将指导您在 MacOS 上安装 PyCharm。</p>
<h3 id="ubuntu">ubuntu</h3>
<p>要在 Ubuntu 上安装 PyCharm，请访问链接<a href="how-to-install-pycharm-in-ubuntu"><em>【https://www.javatpoint.com/how-to-install-pycharm-in-ubuntu】</em></a>。该链接将指导您在 Ubuntu 上安装 PyCharm。</p>
<blockquote>
<p>原文：<a href="https://www.javatpoint.com/python-example">https://www.javatpoint.com/python-example</a></p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Python</category>
        <category>python-基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>EM算法</title>
    <url>/posts/27a0e22b.html</url>
    <content><![CDATA[<p>上篇主要介绍了贝叶斯分类器，从贝叶斯公式到贝叶斯决策论，再到通过极大似然法估计类条件概率，贝叶斯分类器的训练就是参数估计的过程。朴素贝叶斯则是“属性条件独立性假设”下的特例，它避免了假设属性联合分布过于经验性和训练集不足引起参数估计较大偏差两个大问题，最后介绍的拉普拉斯修正将概率值进行平滑处理。本篇将介绍另一个当选为数据挖掘十大算法之一的<strong>EM算法</strong>。</p>
<h1><strong>EM算法</strong></h1>
<p>EM（Expectation-Maximization）算法是一种常用的估计参数隐变量的利器，也称为“期望最大算法”，是数据挖掘的十大经典算法之一。EM算法主要应用于训练集样本不完整即存在隐变量时的情形（例如某个属性值未知），通过其独特的“两步走”策略能较好地估计出隐变量的值。</p>
<h2 id="EM算法思想"><strong>EM算法思想</strong></h2>
<p>EM是一种迭代式的方法，它的基本思想就是：若样本服从的分布参数θ已知，则可以根据已观测到的训练样本推断出隐变量Z的期望值（E步），若Z的值已知则运用最大似然法估计出新的θ值（M步）。重复这个过程直到Z和θ值不再发生变化。</p>
<p>简单来讲：假设我们想估计A和B这两个参数，在开始状态下二者都是未知的，但如果知道了A的信息就可以得到B的信息，反过来知道了B也就得到了A。可以考虑首先赋予A某种初值，以此得到B的估计值，然后从B的当前值出发，重新估计A的取值，这个过程一直持续到收敛为止。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc843bf53eb2.png" alt="1.png"></p>
<p>现在再来回想聚类的代表算法K-Means：【首先随机选择类中心=&gt;将样本点划分到类簇中=&gt;重新计算类中心=&gt;不断迭代直至收敛】，不难发现这个过程和EM迭代的方法极其相似，事实上，若将样本的类别看做为“隐变量”（latent variable）Z，类中心看作样本的分布参数θ，K-Means就是通过EM算法来进行迭代的，与我们这里不同的是，K-Means的目标是最小化样本点到其对应类中心的距离和，上述为极大化似然函数。</p>
<h2 id="EM算法数学推导"><strong>EM算法数学推导</strong></h2>
<p>在上篇极大似然法中，当样本属性值都已知时，我们很容易通过极大化对数似然，接着对每个参数求偏导计算出参数的值。但当存在隐变量时，就无法直接求解，此时我们通常最大化已观察数据的对数“边际似然”（marginal likelihood）。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc843bfd84d2.png" alt="2.png"></p>
<p>这时候，通过边缘似然将隐变量Z引入进来，对于参数估计，现在与最大似然不同的只是似然函数式中多了一个未知的变量Z，也就是说我们的目标是找到适合的θ和Z让L(θ)最大，这样我们也可以分别对未知的θ和Z求偏导，再令其等于0。</p>
<p>然而观察上式可以发现，和的对数（ln(x1+x2+x3)）求导十分复杂，那能否通过变换上式得到一种求导简单的新表达式呢？这时候 Jensen不等式就派上用场了，先回顾一下高等数学凸函数的内容：</p>
<p><strong>Jensen’s inequality</strong>：过一个凸函数上任意两点所作割线一定在这两点间的函数图象的上方。理解起来也十分简单，对于凸函数f(x)‘’&gt;0，即曲线的变化率是越来越大单调递增的，所以函数越到后面增长越厉害，这样在一个区间下，函数的均值就会大一些了。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc843c064c72.png" alt="3.png"></p>
<p>因为ln(*)函数为凹函数，故可以将上式“和的对数”变为“对数的和”，这样就很容易求导了。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc843c3490ad.png" alt="4.png"></p>
<p>接着求解Qi和θ：首先固定θ（初始值），通过求解Qi使得J（θ，Q）在θ处与L（θ）相等，即求出L（θ）的下界；然后再固定Qi，调整θ，最大化下界J（θ，Q）。不断重复两个步骤直到稳定。通过jensen不等式的性质，Qi的计算公式实际上就是后验概率：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc843c21276c.png" alt="5.png"></p>
<p>通过数学公式的推导，简单来理解这一过程：固定θ计算Q的过程就是在建立L（θ）的下界，即通过jenson不等式得到的下界（E步）；固定Q计算θ则是使得下界极大化（M步），从而不断推高边缘似然L（θ）。从而循序渐进地计算出L（θ）取得极大值时隐变量Z的估计值。</p>
<p>EM算法也可以看作一种“坐标下降法”，首先固定一个值，对另外一个值求极值，不断重复直到收敛。这时候也许大家就有疑问，问什么不直接这两个家伙求偏导用梯度下降呢？这时候就是坐标下降的优势，有些特殊的函数，例如曲线函数z=y<sup>2+x</sup>2+x^2y+xy+…，无法直接求导，这时如果先固定其中的一个变量，再对另一个变量求极值，则变得可行。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc843c34e7ff.png" alt="6.png"></p>
<h2 id="EM算法流程"><strong>EM算法流程</strong></h2>
<p>看完数学推导，算法的流程也就十分简单了，这里有两个版本，版本一来自西瓜书，周天使的介绍十分简洁；版本二来自于大牛的博客。结合着数学推导，自认为版本二更具有逻辑性，两者唯一的区别就在于版本二多出了红框的部分，这里我也没得到答案，欢迎骚扰讨论~</p>
<p><strong>版本一：</strong></p>
<p><img src="https://i.loli.net/2018/10/18/5bc843c0e19db.png" alt="7.png"></p>
<p><strong>版本二：</strong></p>
<p><img src="https://i.loli.net/2018/10/18/5bc843c34775b.png" alt="8.png"></p>
<blockquote>
<p>原文：<a href="https://github.com/Vay-keen/Machine-learning-learning-notes">https://github.com/Vay-keen/Machine-learning-learning-notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习笔记</category>
      </categories>
      <tags>
        <tag>EM算法</tag>
      </tags>
  </entry>
  <entry>
    <title>假设检验&amp;方差&amp;偏差</title>
    <url>/posts/67f3e69e.html</url>
    <content><![CDATA[<p>在上两篇中，我们介绍了多种常见的评估方法和性能度量标准，这样我们就可以根据数据集以及模型任务的特征，选择出最合适的评估和性能度量方法来计算出学习器的“测试误差“。但由于“测试误差”受到很多因素的影响，例如：算法随机性(例如常见的K-Means)或测试集本身的选择，使得同一模型每次得到的结果不尽相同，同时测试误差是作为泛化误差的近似，并不能代表学习器真实的泛化性能，那如何对单个或多个学习器在不同或相同测试集上的性能度量结果做比较呢？这就是比较检验。最后偏差与方差是解释学习器泛化性能的一种重要工具。本篇延续上一篇的内容，主要讨论了比较检验、方差与偏差。</p>
<h2 id="比较检验">比较检验</h2>
<p>在比较学习器泛化性能的过程中，统计假设检验（hypothesis test）为学习器性能比较提供了重要依据，即若A在某测试集上的性能优于B，那A学习器比B好的把握有多大。 为方便论述，本篇中都是以“错误率”作为性能度量的标准。</p>
<h3 id="假设检验">假设检验</h3>
<p>“假设”指的是对样本总体的分布或已知分布中某个参数值的一种猜想，例如：假设总体服从泊松分布，或假设正态总体的期望u=u0。回到本篇中，我们可以通过测试获得测试错误率，但直观上测试错误率和泛化错误率相差不会太远，因此可以通过测试错误率来推测泛化错误率的分布，这就是一种假设检验。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc7211aed8e3.png" alt="1.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc7211a5817d.png" alt="2.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc7211a336b5.png" alt="3.png"></p>
<h3 id="交叉验证t检验"><strong>交叉验证t检验</strong></h3>
<p><img src="https://i.loli.net/2018/10/17/5bc7211a68ef9.png" alt="4.png"></p>
<h3 id="McNemar检验"><strong>McNemar检验</strong></h3>
<p>MaNemar主要用于二分类问题，与成对t检验一样也是用于比较两个学习器的性能大小。主要思想是：若两学习器的性能相同，则A预测正确B预测错误数应等于B预测错误A预测正确数，即e01=e10，且|e01-e10|服从N（1，e01+e10）分布。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc7211a2c7f9.png" alt="5.png"></p>
<p>因此，如下所示的变量服从自由度为1的卡方分布，即服从标准正态分布N（0,1）的随机变量的平方和，下式只有一个变量，故自由度为1，检验的方法同上：做出假设–&gt;求出满足显著度的临界点–&gt;给出拒绝域–&gt;验证假设。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc7211a34e96.png" alt="6.png"></p>
<h3 id="Friedman检验与Nemenyi后续检验"><strong>Friedman检验与Nemenyi后续检验</strong></h3>
<p>上述的三种检验都只能在一组数据集上，F检验则可以在多组数据集进行多个学习器性能的比较，基本思想是在同一组数据集上，根据测试结果（例：测试错误率）对学习器的性能进行排序，赋予序值1,2,3…，相同则平分序值，如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc7211a2db45.png" alt="7.png"></p>
<p>若学习器的性能相同，则它们的平均序值应该相同，且第i个算法的平均序值ri服从正态分布N（（k+1）/2，（k+1）(k-1)/12），则有：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc7211a45349.png" alt="8.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc7211a2684c.png" alt="9.png"></p>
<p>服从自由度为k-1和(k-1)(N-1)的F分布。下面是F检验常用的临界值：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc7211a7e3f0.png" alt="10.png"></p>
<p>若“H0：所有算法的性能相同”这个假设被拒绝，则需要进行后续检验，来得到具体的算法之间的差异。常用的就是Nemenyi后续检验。Nemenyi检验计算出平均序值差别的临界值域，下表是常用的qa值，若两个算法的平均序值差超出了临界值域CD，则相应的置信度1-α拒绝“两个算法性能相同”的假设。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc722232932b.png" alt="11.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc7222348519.png" alt="12.png"></p>
<h2 id="偏差与方差"><strong>偏差与方差</strong></h2>
<p>偏差-方差分解是解释学习器泛化性能的重要工具。在学习算法中，偏差指的是预测的期望值与真实值的偏差，方差则是每一次预测值与预测值得期望之间的差均方。实际上，偏差体现了学习器预测的准确度，而方差体现了学习器预测的稳定性。通过对泛化误差的进行分解，可以得到：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>期望泛化误差=方差+偏差</strong></p>
</li>
<li class="lvl-2">
<p><strong>偏差刻画学习器的拟合能力</strong></p>
</li>
<li class="lvl-2">
<p><strong>方差体现学习器的稳定性</strong></p>
</li>
</ul>
<p>易知：方差和偏差具有矛盾性，这就是常说的偏差-方差窘境（bias-variance dilamma），随着训练程度的提升，期望预测值与真实值之间的差异越来越小，即偏差越来越小，但是另一方面，随着训练程度加大，学习算法对数据集的波动越来越敏感，方差值越来越大。换句话说：在欠拟合时，偏差主导泛化误差，而训练到一定程度后，偏差越来越小，方差主导了泛化误差。因此训练也不要贪杯，适度辄止。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc722234b09f.png" alt="13.png"></p>
<blockquote>
<p>原文：<a href="https://github.com/Vay-keen/Machine-learning-learning-notes">https://github.com/Vay-keen/Machine-learning-learning-notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>半监督学习</title>
    <url>/posts/d9967647.html</url>
    <content><![CDATA[<p>上篇主要介绍了机器学习的理论基础，首先从独立同分布引入泛化误差与经验误差，接着介绍了PAC可学习的基本概念，即以较大的概率学习出与目标概念近似的假设（泛化误差满足预设上限），对于有限假设空间：（1）可分情形时，假设空间都是PAC可学习的，即当样本满足一定的数量之后，总是可以在与训练集一致的假设中找出目标概念的近似；（2）不可分情形时，假设空间都是不可知PAC可学习的，即以较大概率学习出与当前假设空间中泛化误差最小的假设的有效近似（Hoeffding不等式）。对于无限假设空间，通过增长函数与VC维来描述其复杂度，若学习算法满足经验风险最小化原则，则任何VC维有限的假设空间都是（不可知）PAC可学习的，同时也给出了泛化误差界与样本复杂度。稳定性则考察的是输入发生变化时输出的波动，稳定性通过损失函数与假设空间的可学习理论联系在了一起。本篇将讨论一种介于监督与非监督学习之间的学习算法–半监督学习。</p>
<h1><strong>半监督学习</strong></h1>
<p>前面我们一直围绕的都是监督学习与无监督学习，监督学习指的是训练样本包含标记信息的学习任务，例如：常见的分类与回归算法；无监督学习则是训练样本不包含标记信息的学习任务，例如：聚类算法。在实际生活中，常常会出现一部分样本有标记和较多样本无标记的情形，例如：做网页推荐时需要让用户标记出感兴趣的网页，但是少有用户愿意花时间来提供标记。若直接丢弃掉无标记样本集，使用传统的监督学习方法，常常会由于训练样本的不充足，使得其刻画总体分布的能力减弱，从而影响了学习器泛化性能。那如何利用未标记的样本数据呢？</p>
<p>一种简单的做法是通过专家知识对这些未标记的样本进行打标，但随之而来的就是巨大的人力耗费。若我们先使用有标记的样本数据集训练出一个学习器，再基于该学习器对未标记的样本进行预测，从中<strong>挑选出不确定性高或分类置信度低的样本来咨询专家并进行打标</strong>，最后使用扩充后的训练集重新训练学习器，这样便能大幅度降低标记成本，这便是<strong>主动学习</strong>（active learning），其目标是<strong>使用尽量少的/有价值的咨询来获得更好的性能</strong>。</p>
<p>显然，<strong>主动学习需要与外界进行交互/查询/打标，其本质上仍然属于一种监督学习</strong>。事实上，无标记样本虽未包含标记信息，但它们与有标记样本一样都是从总体中独立同分布采样得到，因此<strong>它们所包含的数据分布信息对学习器的训练大有裨益</strong>。如何让学习过程不依赖外界的咨询交互，自动利用未标记样本所包含的分布信息的方法便是<strong>半监督学习</strong>（semi-supervised learning），<strong>即训练集同时包含有标记样本数据和未标记样本数据</strong>。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc856e39801d.png" alt="1.png"></p>
<p>此外，半监督学习还可以进一步划分为<strong>纯半监督学习</strong>和<strong>直推学习</strong>，两者的区别在于：前者假定训练数据集中的未标记数据并非待预测数据，而后者假定学习过程中的未标记数据就是待预测数据。主动学习、纯半监督学习以及直推学习三者的概念如下图所示：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwJFJS.png" alt="iwJFJS.png"></p>
<h2 id="生成式方法"><strong>生成式方法</strong></h2>
<p><strong>生成式方法</strong>（generative methods）是基于生成式模型的方法，即先对联合分布P（x,c）建模，从而进一步求解 P（c | x），<strong>此类方法假定样本数据服从一个潜在的分布，因此需要充分可靠的先验知识</strong>。例如：前面已经接触到的贝叶斯分类器与高斯混合聚类，都属于生成式模型。现假定总体是一个高斯混合分布，即由多个高斯分布组合形成，从而一个子高斯分布就代表一个类簇（类别）。高斯混合分布的概率密度函数如下所示：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc856e3b82dc.png" alt="3.png"></p>
<p>不失一般性，假设类簇与真实的类别按照顺序一一对应，即第i个类簇对应第i个高斯混合成分。与高斯混合聚类类似地，这里的主要任务也是估计出各个高斯混合成分的参数以及混合系数，不同的是：对于有标记样本，不再是可能属于每一个类簇，而是只能属于真实类标对应的特定类簇。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc856e431d30.png" alt="4.png"></p>
<p>直观上来看，<strong>基于半监督的高斯混合模型有机地整合了贝叶斯分类器与高斯混合聚类的核心思想</strong>，有效地利用了未标记样本数据隐含的分布信息，从而使得参数的估计更加准确。同样地，这里也要召唤出之前的EM大法进行求解，首先对各个高斯混合成分的参数及混合系数进行随机初始化，计算出各个PM（即γji，第i个样本属于j类，有标记样本则直接属于特定类），再最大化似然函数（即LL（D）分别对α、u和∑求偏导 ），对参数进行迭代更新。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc856e43ff08.png" alt="5.png"></p>
<p>当参数迭代更新收敛后，对于待预测样本x，便可以像贝叶斯分类器那样计算出样本属于每个类簇的后验概率，接着找出概率最大的即可：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc856e3dfb1c.png" alt="6.png"></p>
<p>可以看出：基于生成式模型的方法十分依赖于对潜在数据分布的假设，即假设的分布要能和真实分布相吻合，否则利用未标记的样本数据反倒会在错误的道路上渐行渐远，从而降低学习器的泛化性能。因此，<strong>此类方法要求极强的领域知识和掐指观天的本领</strong>。</p>
<h2 id="半监督SVM"><strong>半监督SVM</strong></h2>
<p>监督学习中的SVM试图找到一个划分超平面，使得两侧支持向量之间的间隔最大，即“<strong>最大划分间隔</strong>”思想。对于半监督学习，S3VM则考虑超平面需穿过数据低密度的区域。TSVM是半监督支持向量机中的最著名代表，其核心思想是：尝试为未标记样本找到合适的标记指派，使得超平面划分后的间隔最大化。TSVM采用局部搜索的策略来进行迭代求解，即首先使用有标记样本集训练出一个初始SVM，接着使用该学习器对未标记样本进行打标，这样所有样本都有了标记，并基于这些有标记的样本重新训练SVM，之后再寻找易出错样本不断调整。整个算法流程如下所示：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc856e427830.png" alt="7.png"></p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwJZss.png" alt="iwJZss.png"></p>
<h2 id="基于分歧的方法"><strong>基于分歧的方法</strong></h2>
<p>基于分歧的方法通过多个学习器之间的**分歧（disagreement）/多样性（diversity）**来利用未标记样本数据，协同训练就是其中的一种经典方法。<strong>协同训练最初是针对于多视图（multi-view）数据而设计的，多视图数据指的是样本对象具有多个属性集，每个属性集则对应一个试图</strong>。例如：电影数据中就包含画面类属性和声音类属性，这样画面类属性的集合就对应着一个视图。首先引入两个关于视图的重要性质：</p>
<blockquote>
<p><strong>相容性</strong>：即使用单个视图数据训练出的学习器的输出空间是一致的。例如都是{好，坏}、{+1,-1}等。<br>
<strong>互补性</strong>：即不同视图所提供的信息是互补/相辅相成的，实质上这里体现的就是集成学习的思想。</p>
</blockquote>
<p>协同训练正是很好地利用了多视图数据的“<strong>相容互补性</strong>”，其基本的思想是：首先基于有标记样本数据在每个视图上都训练一个初始分类器，然后让每个分类器去挑选分类置信度最高的样本并赋予标记，并将带有伪标记的样本数据传给另一个分类器去学习，从而<strong>你依我侬/共同进步</strong>。</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwJVMj.png" alt="iwJVMj.png"><br>
<img src="https://s1.ax1x.com/2018/10/18/iwJeLn.png" alt="iwJeLn.png"></p>
<h2 id="半监督聚类"><strong>半监督聚类</strong></h2>
<p>前面提到的几种方法都是借助无标记样本数据来辅助监督学习的训练过程，从而使得学习更加充分/泛化性能得到提升；半监督聚类则是借助已有的监督信息来辅助聚类的过程。一般而言，监督信息大致有两种类型：</p>
<blockquote>
<p><strong>必连与勿连约束</strong>：必连指的是两个样本必须在同一个类簇，勿连则是必不在同一个类簇。<br>
<strong>标记信息</strong>：少量的样本带有真实的标记。</p>
</blockquote>
<p>下面主要介绍两种基于半监督的K-Means聚类算法：第一种是数据集包含一些必连与勿连关系，另外一种则是包含少量带有标记的样本。两种算法的基本思想都十分的简单：对于带有约束关系的k-均值算法，在迭代过程中对每个样本划分类簇时，需要<strong>检测当前划分是否满足约束关系</strong>，若不满足则会将该样本划分到距离次小对应的类簇中，再继续检测是否满足约束关系，直到完成所有样本的划分。算法流程如下图所示：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwJAzQ.png" alt="iwJAzQ.png"></p>
<p>对于带有少量标记样本的k-均值算法，则可以<strong>利用这些有标记样本进行类中心的指定，同时在对样本进行划分时，不需要改变这些有标记样本的簇隶属关系</strong>，直接将其划分到对应类簇即可。算法流程如下所示：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwJkRg.png" alt="iwJkRg.png"></p>
<p>在此，半监督学习就介绍完毕。十分有趣的是：半监督学习将前面许多知识模块联系在了一起，足以体现了作者编排的用心。结合本篇的新知识再来回想之前自己做过的一些研究，发现还是蹚了一些浑水，也许越是觉得过去的自己傻，越就是好的兆头吧~</p>
<blockquote>
<p>原文：<a href="https://github.com/Vay-keen/Machine-learning-learning-notes">https://github.com/Vay-keen/Machine-learning-learning-notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习笔记</category>
      </categories>
      <tags>
        <tag>半监督学习</tag>
      </tags>
  </entry>
  <entry>
    <title>决策树</title>
    <url>/posts/8ddc7426.html</url>
    <content><![CDATA[<p>上篇主要介绍和讨论了线性模型。首先从最简单的最小二乘法开始，讨论输入属性有一个和多个的情形，接着通过广义线性模型延伸开来，将预测连续值的回归问题转化为分类问题，从而引入了对数几率回归，最后线性判别分析LDA将样本点进行投影，多分类问题实质上通过划分的方法转化为多个二分类问题进行求解。本篇将讨论另一种被广泛使用的分类算法–决策树（Decision Tree）。</p>
<h1><strong>决策树</strong></h1>
<h2 id="决策树基本概念"><strong>决策树基本概念</strong></h2>
<p>顾名思义，决策树是基于树结构来进行决策的，在网上看到一个例子十分有趣，放在这里正好合适。现想象一位捉急的母亲想要给自己的女娃介绍一个男朋友，于是有了下面的对话：</p>
<hr>
<pre><code>  女儿：多大年纪了？
  母亲：26。
  女儿：长的帅不帅？
  母亲：挺帅的。
  女儿：收入高不？
  母亲：不算很高，中等情况。
  女儿：是公务员不？
  母亲：是，在税务局上班呢。
  女儿：那好，我去见见。
</code></pre>
<hr>
<p>这个女孩的挑剔过程就是一个典型的决策树，即相当于通过年龄、长相、收入和是否公务员将男童鞋分为两个类别：见和不见。假设这个女孩对男人的要求是：30岁以下、长相中等以上并且是高收入者或中等以上收入的公务员，那么使用下图就能很好地表示女孩的决策逻辑（即一颗决策树）。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc728ec84a77.png" alt="1.png"></p>
<p>在上图的决策树中，决策过程的每一次判定都是对某一属性的“测试”，决策最终结论则对应最终的判定结果。一般一颗决策树包含：一个根节点、若干个内部节点和若干个叶子节点，易知：</p>
<pre><code>* 每个非叶节点表示一个特征属性测试。
* 每个分支代表这个特征属性在某个值域上的输出。
* 每个叶子节点存放一个类别。
* 每个节点包含的样本集合通过属性测试被划分到子节点中，根节点包含样本全集。
</code></pre>
<h2 id="决策树的构造"><strong>决策树的构造</strong></h2>
<p>决策树的构造是一个递归的过程，有三种情形会导致递归返回：(1) 当前结点包含的样本全属于同一类别，这时直接将该节点标记为叶节点，并设为相应的类别；(2) 当前属性集为空，或是所有样本在所有属性上取值相同，无法划分，这时将该节点标记为叶节点，并将其类别设为该节点所含样本最多的类别；(3) 当前结点包含的样本集合为空，不能划分，这时也将该节点标记为叶节点，并将其类别设为父节点中所含样本最多的类别。算法的基本流程如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc728ecc27fe.png" alt="2.png"></p>
<p>可以看出：决策树学习的关键在于如何选择划分属性，不同的划分属性得出不同的分支结构，从而影响整颗决策树的性能。属性划分的目标是让各个划分出来的子节点尽可能地“纯”，即属于同一类别。因此下面便是介绍量化纯度的具体方法，决策树最常用的算法有三种：ID3，C4.5和CART。</p>
<h3 id="ID3算法"><strong>ID3算法</strong></h3>
<p>ID3算法使用信息增益为准则来选择划分属性，“信息熵”(information entropy)是度量样本结合纯度的常用指标，假定当前样本集合D中第k类样本所占比例为pk，则样本集合D的信息熵定义为：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc728ec515a5.png" alt="3.png"></p>
<p>假定通过属性划分样本集D，产生了V个分支节点，v表示其中第v个分支节点，易知：分支节点包含的样本数越多，表示该分支节点的影响力越大。故可以计算出划分后相比原始数据集D获得的“信息增益”（information gain）。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc728ec3e067.png" alt="4.png"></p>
<p>信息增益越大，表示使用该属性划分样本集D的效果越好，因此ID3算法在递归过程中，每次选择最大信息增益的属性作为当前的划分属性。</p>
<h3 id="C4-5算法"><strong>C4.5算法</strong></h3>
<p>ID3算法存在一个问题，就是偏向于取值数目较多的属性，例如：如果存在一个唯一标识，这样样本集D将会被划分为|D|个分支，每个分支只有一个样本，这样划分后的信息熵为零，十分纯净，但是对分类毫无用处。因此C4.5算法使用了“增益率”（gain ratio）来选择划分属性，来避免这个问题带来的困扰。首先使用ID3算法计算出信息增益高于平均水平的候选属性，接着C4.5计算这些候选属性的增益率，增益率定义为：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc728ec69647.png" alt="5.png"></p>
<h3 id="CART算法"><strong>CART算法</strong></h3>
<p>CART决策树使用“基尼指数”（Gini index）来选择划分属性，基尼指数反映的是从样本集D中随机抽取两个样本，其类别标记不一致的概率，因此Gini(D)越小越好，基尼指数定义如下：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc728ec5a2ff.png" alt="6.png"></p>
<p>进而，使用属性α划分后的基尼指数为：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc728ec62eaf.png" alt="7.png"></p>
<h2 id="剪枝处理"><strong>剪枝处理</strong></h2>
<p>从决策树的构造流程中我们可以直观地看出：不管怎么样的训练集，决策树总是能很好地将各个类别分离开来，这时就会遇到之前提到过的问题：过拟合（overfitting），即太依赖于训练样本。剪枝（pruning）则是决策树算法对付过拟合的主要手段，剪枝的策略有两种如下：</p>
<pre><code>* 预剪枝（prepruning）：在构造的过程中先评估，再考虑是否分支。
* 后剪枝（post-pruning）：在构造好一颗完整的决策树后，自底向上，评估分支的必要性。
</code></pre>
<p>评估指的是性能度量，即决策树的泛化性能。之前提到：可以使用测试集作为学习器泛化性能的近似，因此可以将数据集划分为训练集和测试集。预剪枝表示在构造数的过程中，对一个节点考虑是否分支时，首先计算决策树不分支时在测试集上的性能，再计算分支之后的性能，若分支对性能没有提升，则选择不分支（即剪枝）。后剪枝则表示在构造好一颗完整的决策树后，从最下面的节点开始，考虑该节点分支对模型的性能是否有提升，若无则剪枝，即将该节点标记为叶子节点，类别标记为其包含样本最多的类别。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc728ec80d34.png" alt="8.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc728ec9e330.png" alt="9.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc728ec9d497.png" alt="10.png"></p>
<p>上图分别表示不剪枝处理的决策树、预剪枝决策树和后剪枝决策树。预剪枝处理使得决策树的很多分支被剪掉，因此大大降低了训练时间开销，同时降低了过拟合的风险，但另一方面由于剪枝同时剪掉了当前节点后续子节点的分支，因此预剪枝“贪心”的本质阻止了分支的展开，在一定程度上带来了欠拟合的风险。而后剪枝则通常保留了更多的分支，因此采用后剪枝策略的决策树性能往往优于预剪枝，但其自底向上遍历了所有节点，并计算性能，训练时间开销相比预剪枝大大提升。</p>
<h2 id="连续值与缺失值处理"><strong>连续值与缺失值处理</strong></h2>
<p>对于连续值的属性，若每个取值作为一个分支则显得不可行，因此需要进行离散化处理，常用的方法为二分法，基本思想为：给定样本集D与连续属性α，二分法试图找到一个划分点t将样本集D在属性α上分为≤t与＞t。</p>
<pre><code>* 首先将α的所有取值按升序排列，所有相邻属性的均值作为候选划分点（n-1个，n为α所有的取值数目）。
* 计算每一个划分点划分集合D（即划分为两个分支）后的信息增益。
* 选择最大信息增益的划分点作为最优划分点。
</code></pre>
<p><img src="https://i.loli.net/2018/10/17/5bc72a0968fad.png" alt="11.png"></p>
<p>现实中常会遇到不完整的样本，即某些属性值缺失。有时若简单采取剔除，则会造成大量的信息浪费，因此在属性值缺失的情况下需要解决两个问题：（1）如何选择划分属性。（2）给定划分属性，若某样本在该属性上缺失值，如何划分到具体的分支上。假定为样本集中的每一个样本都赋予一个权重，根节点中的权重初始化为1，则定义：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72a098f3be.png" alt="12.png"></p>
<p>对于（1）：通过在样本集D中选取在属性α上没有缺失值的样本子集，计算在该样本子集上的信息增益，最终的信息增益等于该样本子集划分后信息增益乘以样本子集占样本集的比重。即：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72a096ccc3.png" alt="13.png"></p>
<p>对于（2）：若该样本子集在属性α上的值缺失，则将该样本以不同的权重（即每个分支所含样本比例）划入到所有分支节点中。该样本在分支节点中的权重变为：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72a093ed3c.png" alt="14.png"></p>
<blockquote>
<p>原文：<a href="https://github.com/Vay-keen/Machine-learning-learning-notes">https://github.com/Vay-keen/Machine-learning-learning-notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习笔记</category>
      </categories>
      <tags>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title>强化学习</title>
    <url>/posts/748f0bbe.html</url>
    <content><![CDATA[<p>上篇主要介绍了概率图模型，首先从生成式模型与判别式模型的定义出发，引出了概率图模型的基本概念，即利用图结构来表达变量之间的依赖关系；接着分别介绍了隐马尔可夫模型、马尔可夫随机场、条件随机场、精确推断方法以及LDA话题模型：HMM主要围绕着评估/解码/学习这三个实际问题展开论述；MRF基于团和势函数的概念来定义联合概率分布；CRF引入两种特征函数对状态序列进行评价打分；变量消去与信念传播在给定联合概率分布后计算特定变量的边际分布；LDA话题模型则试图去推断给定文档所蕴含的话题分布。本篇将介绍最后一种学习算法–强化学习。</p>
<h1><strong>强化学习</strong></h1>
<p><strong>强化学习</strong>（Reinforcement Learning，简称<strong>RL</strong>）是机器学习的一个重要分支，前段时间人机大战的主角AlphaGo正是以强化学习为核心技术。在强化学习中，包含两种基本的元素：<strong>状态</strong>与<strong>动作</strong>，<strong>在某个状态下执行某种动作，这便是一种策略</strong>，学习器要做的就是通过不断地探索学习，从而获得一个好的策略。例如：在围棋中，一种落棋的局面就是一种状态，若能知道每种局面下的最优落子动作，那就攻无不克/百战不殆了~</p>
<p>若将状态看作为属性，动作看作为标记，易知：<strong>监督学习和强化学习都是在试图寻找一个映射，从已知属性/状态推断出标记/动作</strong>，这样强化学习中的策略相当于监督学习中的分类/回归器。但在实际问题中，<strong>强化学习并没有监督学习那样的标记信息</strong>，通常都是在<strong>尝试动作后才能获得结果</strong>，因此强化学习是通过反馈的结果信息不断调整之前的策略，从而算法能够学习到：在什么样的状态下选择什么样的动作可以获得最好的结果。</p>
<h2 id="基本要素"><strong>基本要素</strong></h2>
<p>强化学习任务通常使用<strong>马尔可夫决策过程</strong>（Markov Decision Process，简称<strong>MDP</strong>）来描述，具体而言：机器处在一个环境中，每个状态为机器对当前环境的感知；机器只能通过动作来影响环境，当机器执行一个动作后，会使得环境按某种概率转移到另一个状态；同时，环境会根据潜在的奖赏函数反馈给机器一个奖赏。综合而言，强化学习主要包含四个要素：状态、动作、转移概率以及奖赏函数。</p>
<blockquote>
<p><strong>状态（X）</strong>：机器对环境的感知，所有可能的状态称为状态空间；<br>
<strong>动作（A）</strong>：机器所采取的动作，所有能采取的动作构成动作空间；<br>
<strong>转移概率（P）</strong>：当执行某个动作后，当前状态会以某种概率转移到另一个状态；<br>
<strong>奖赏函数（R）</strong>：在状态转移的同时，环境给反馈给机器一个奖赏。</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYOud.png" alt="iwYOud.png"></p>
<p>因此，<strong>强化学习的主要任务就是通过在环境中不断地尝试，根据尝试获得的反馈信息调整策略，最终生成一个较好的策略π，机器根据这个策略便能知道在什么状态下应该执行什么动作</strong>。常见的策略表示方法有以下两种：</p>
<blockquote>
<p><strong>确定性策略</strong>：π（x）=a，即在状态x下执行a动作；<br>
<strong>随机性策略</strong>：P=π（x,a），即在状态x下执行a动作的概率。</p>
</blockquote>
<p><strong>一个策略的优劣取决于长期执行这一策略后的累积奖赏</strong>，换句话说：可以使用累积奖赏来评估策略的好坏，最优策略则表示在初始状态下一直执行该策略后，最后的累积奖赏值最高。长期累积奖赏通常使用下述两种计算方法：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYH3D.png" alt="iwYH3D.png"></p>
<h2 id="K摇摆赌博机"><strong>K摇摆赌博机</strong></h2>
<p>首先我们考虑强化学习最简单的情形：仅考虑一步操作，即在状态x下只需执行一次动作a便能观察到奖赏结果。易知：欲最大化单步奖赏，我们需要知道每个动作带来的期望奖赏值，这样便能选择奖赏值最大的动作来执行。若每个动作的奖赏值为确定值，则只需要将每个动作尝试一遍即可，但大多数情形下，一个动作的奖赏值来源于一个概率分布，因此需要进行多次的尝试。</p>
<p>单步强化学习实质上是<strong>K-摇臂赌博机</strong>（K-armed bandit）的原型，一般我们<strong>尝试动作的次数是有限的</strong>，那如何利用有限的次数进行有效地探索呢？这里有两种基本的想法：</p>
<blockquote>
<p><strong>仅探索法</strong>：将尝试的机会平均分给每一个动作，即轮流执行，最终将每个动作的平均奖赏作为期望奖赏的近似值。<br>
<strong>仅利用法</strong>：将尝试的机会分给当前平均奖赏值最大的动作，隐含着让一部分人先富起来的思想。</p>
</blockquote>
<p>可以看出：上述<strong>两种方法是相互矛盾的</strong>，仅探索法能较好地估算每个动作的期望奖赏，但是没能根据当前的反馈结果调整尝试策略；仅利用法在每次尝试之后都更新尝试策略，符合强化学习的思（tao）维（lu），但容易找不到最优动作。因此需要在这两者之间进行折中。</p>
<h3 id="ε-贪心"><strong>ε-贪心</strong></h3>
<p><strong>ε-贪心法基于一个概率来对探索和利用进行折中</strong>，具体而言：在每次尝试时，以ε的概率进行探索，即以均匀概率随机选择一个动作；以1-ε的概率进行利用，即选择当前最优的动作。ε-贪心法只需记录每个动作的当前平均奖赏值与被选中的次数，便可以增量式更新。</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYzUP.png" alt="iwYzUP.png"></p>
<h3 id="Softmax"><strong>Softmax</strong></h3>
<p><strong>Softmax算法则基于当前每个动作的平均奖赏值来对探索和利用进行折中，Softmax函数将一组值转化为一组概率</strong>，值越大对应的概率也越高，因此当前平均奖赏值越高的动作被选中的几率也越大。Softmax函数如下所示：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYbge.png" alt="iwYbge.png"><br>
<img src="https://s1.ax1x.com/2018/10/18/iwYqjH.png" alt="iwYqjH.png"></p>
<h2 id="有模型学习"><strong>有模型学习</strong></h2>
<p>若学习任务中的四个要素都已知，即状态空间、动作空间、转移概率以及奖赏函数都已经给出，这样的情形称为“<strong>有模型学习</strong>”。假设状态空间和动作空间均为有限，即均为离散值，这样我们不用通过尝试便可以对某个策略进行评估。</p>
<h3 id="策略评估"><strong>策略评估</strong></h3>
<p>前面提到：<strong>在模型已知的前提下，我们可以对任意策略的进行评估</strong>（后续会给出演算过程）。一般常使用以下两种值函数来评估某个策略的优劣：</p>
<blockquote>
<p><strong>状态值函数（V）</strong>：V（x），即从状态x出发，使用π策略所带来的累积奖赏；<br>
<strong>状态-动作值函数（Q）</strong>：Q（x,a），即从状态x出发，执行动作a后再使用π策略所带来的累积奖赏。</p>
</blockquote>
<p>根据累积奖赏的定义，我们可以引入T步累积奖赏与r折扣累积奖赏：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYjHI.png" alt="iwYjHI.png"><br>
<img src="https://s1.ax1x.com/2018/10/18/iwYXDA.png" alt="iwYXDA.png"></p>
<p>由于MDP具有马尔可夫性，即现在决定未来，将来和过去无关，我们很容易找到值函数的递归关系：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwtS4f.png" alt="iwtS4f.png"></p>
<p>类似地，对于r折扣累积奖赏可以得到：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYxEt.png" alt="iwYxEt.png"></p>
<p>易知：<strong>当模型已知时，策略的评估问题转化为一种动态规划问题</strong>，即以填表格的形式自底向上，先求解每个状态的单步累积奖赏，再求解每个状态的两步累积奖赏，一直迭代逐步求解出每个状态的T步累积奖赏。算法流程如下所示：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwt9C8.png" alt="iwt9C8.png"></p>
<p>对于状态-动作值函数，只需通过简单的转化便可得到：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwt3r9.png" alt="iwt3r9.png"></p>
<h3 id="策略改进"><strong>策略改进</strong></h3>
<p>理想的策略应能使得每个状态的累积奖赏之和最大，简单来理解就是：不管处于什么状态，只要通过该策略执行动作，总能得到较好的结果。因此对于给定的某个策略，我们需要对其进行改进，从而得到<strong>最优的值函数</strong>。</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwtm5V.png" alt="iwtm5V.png"><br>
<img src="https://s1.ax1x.com/2018/10/18/iwtZEq.png" alt="iwtZEq.png"></p>
<p>最优Bellman等式改进策略的方式为：<strong>将策略选择的动作改为当前最优的动作</strong>，而不是像之前那样对每种可能的动作进行求和。易知：选择当前最优动作相当于将所有的概率都赋给累积奖赏值最大的动作，因此每次改进都会使得值函数单调递增。</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwtEbn.png" alt="iwtEbn.png"></p>
<p>将策略评估与策略改进结合起来，我们便得到了生成最优策略的方法：先给定一个随机策略，现对该策略进行评估，然后再改进，接着再评估/改进一直到策略收敛、不再发生改变。这便是策略迭代算法，算法流程如下所示：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwteU0.png" alt="iwteU0.png"></p>
<p>可以看出：策略迭代法在每次改进策略后都要对策略进行重新评估，因此比较耗时。若从最优化值函数的角度出发，即先迭代得到最优的值函数，再来计算如何改变策略，这便是值迭代算法，算法流程如下所示：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwtuCT.png" alt="iwtuCT.png"></p>
<h2 id="蒙特卡罗强化学习"><strong>蒙特卡罗强化学习</strong></h2>
<p>在现实的强化学习任务中，<strong>环境的转移函数与奖赏函数往往很难得知</strong>，因此我们需要考虑在不依赖于环境参数的条件下建立强化学习模型，这便是<strong>免模型学习</strong>。蒙特卡罗强化学习便是其中的一种经典方法。</p>
<p>由于模型参数未知，状态值函数不能像之前那样进行全概率展开，从而运用动态规划法求解。一种直接的方法便是通过采样来对策略进行评估/估算其值函数，<strong>蒙特卡罗强化学习正是基于采样来估计状态-动作值函数</strong>：对采样轨迹中的每一对状态-动作，记录其后的奖赏值之和，作为该状态-动作的一次累积奖赏，通过多次采样后，使用累积奖赏的平均作为状态-动作值的估计，并<strong>引入ε-贪心策略保证采样的多样性</strong>。</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwt1KJ.png" alt="iwt1KJ.png"></p>
<p>在上面的算法流程中，被评估和被改进的都是同一个策略，因此称为<strong>同策略蒙特卡罗强化学习算法</strong>。引入ε-贪心仅是为了便于采样评估，而在使用策略时并不需要ε-贪心，那能否仅在评估时使用ε-贪心策略，而在改进时使用原始策略呢？这便是<strong>异策略蒙特卡罗强化学习算法</strong>。</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwtK8U.png" alt="iwtK8U.png"></p>
<h2 id="AlphaGo原理浅析"><strong>AlphaGo原理浅析</strong></h2>
<p>本篇一开始便提到强化学习是AlphaGo的核心技术之一，刚好借着这个东风将AlphaGo的工作原理了解一番。正如人类下棋那般“<strong>手下一步棋，心想三步棋</strong>”，Alphago也正是这个思想，<strong>当处于一个状态时，机器会暗地里进行多次的尝试/采样，并基于反馈回来的结果信息改进估值函数，从而最终通过增强版的估值函数来选择最优的落子动作。</strong></p>
<p>其中便涉及到了三个主要的问题：<strong>（1）如何确定估值函数（2）如何进行采样（3）如何基于反馈信息改进估值函数</strong>，这正对应着AlphaGo的三大核心模块：<strong>深度学习</strong>、<strong>蒙特卡罗搜索树</strong>、<strong>强化学习</strong>。</p>
<blockquote>
<p><strong>1.深度学习（拟合估值函数）</strong></p>
</blockquote>
<p>由于围棋的状态空间巨大，像蒙特卡罗强化学习那样通过采样来确定值函数就行不通了。在围棋中，<strong>状态值函数可以看作为一种局面函数，状态-动作值函数可以看作一种策略函数</strong>，若我们能获得这两个估值函数，便可以根据这两个函数来完成：(1)衡量当前局面的价值；(2)选择当前最优的动作。那如何精确地估计这两个估值函数呢？<strong>这就用到了深度学习，通过大量的对弈数据自动学习出特征，从而拟合出估值函数。</strong></p>
<blockquote>
<p><strong>2.蒙特卡罗搜索树（采样）</strong></p>
</blockquote>
<p>蒙特卡罗树是一种经典的搜索框架，它通过反复地采样模拟对局来探索状态空间。具体表现在：从当前状态开始，利用策略函数尽可能选择当前最优的动作，同时也引入随机性来减小估值错误带来的负面影响，从而模拟棋局运行，使得棋盘达到终局或一定步数后停止。</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwtM2F.png" alt="iwtM2F.png"></p>
<blockquote>
<p><strong>3.强化学习（调整估值函数）</strong></p>
</blockquote>
<p>在使用蒙特卡罗搜索树进行多次采样后，每次采样都会反馈后续的局面信息（利用局面函数进行评价），根据反馈回来的结果信息自动调整两个估值函数的参数，这便是强化学习的核心思想，最后基于改进后的策略函数选择出当前最优的落子动作。</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwtQv4.png" alt="iwtQv4.png"></p>
<p>在此，强化学习就介绍完毕。同时也意味着大口小口地啃完了这个西瓜，十分记得去年双11之后立下这个Flag，现在回想起来，大半年的时间里在嚼瓜上还是花费了不少功夫。有人说：当你阐述的能让别人看懂才算是真的理解，有人说：在写的过程中能发现那些只看书发现不了的东西，自己最初的想法十分简单：当健忘症发作的时候，如果能看到之前按照自己思路写下的文字，回忆便会汹涌澎湃一些~</p>
<p>最后，感谢自己这大半年以来的坚持~Get busy living, or get busy dying!</p>
<blockquote>
<p>原文：<a href="https://github.com/Vay-keen/Machine-learning-learning-notes">https://github.com/Vay-keen/Machine-learning-learning-notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习笔记</category>
      </categories>
      <tags>
        <tag>强化学习</tag>
      </tags>
  </entry>
  <entry>
    <title>性能度量</title>
    <url>/posts/26e86cb5.html</url>
    <content><![CDATA[<p>本篇主要是对第二章剩余知识的理解，包括：性能度量、比较检验和偏差与方差。在上一篇中，我们解决了评估学习器泛化性能的方法，即用测试集的“测试误差”作为“泛化误差”的近似，当我们划分好训练/测试集后，那如何计算“测试误差”呢？这就是性能度量，例如：均方差，错误率等，即“测试误差”的一个评价标准。有了评估方法和性能度量，就可以计算出学习器的“测试误差”，但由于“测试误差”受到很多因素的影响，例如：算法随机性或测试集本身的选择，那如何对两个或多个学习器的性能度量结果做比较呢？这就是比较检验。最后偏差与方差是解释学习器泛化性能的一种重要工具。写到后面发现冗长之后读起来十分没有快感，故本篇主要知识点为性能度量。</p>
<h1><strong>性能度量</strong></h1>
<p>性能度量（performance measure）是衡量模型泛化能力的评价标准，在对比不同模型的能力时，使用不同的性能度量往往会导致不同的评判结果。本节除2.5.1外，其它主要介绍分类模型的性能度量。</p>
<h2 id="最常见的性能度量"><strong>最常见的性能度量</strong></h2>
<p>在回归任务中，即预测连续值的问题，最常用的性能度量是“均方误差”（mean squared error）,很多的经典算法都是采用了MSE作为评价函数，想必大家都十分熟悉。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71daf76276.png" alt="1.png"></p>
<p>在分类任务中，即预测离散值的问题，最常用的是错误率和精度，错误率是分类错误的样本数占样本总数的比例，精度则是分类正确的样本数占样本总数的比例，易知：错误率+精度=1。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71daf4c704.png" alt="2.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc71daf6fb84.png" alt="3.png"></p>
<h2 id="查准率-查全率-F1"><strong>查准率/查全率/F1</strong></h2>
<p>错误率和精度虽然常用，但不能满足所有的需求，例如：在推荐系统中，我们只关心推送给用户的内容用户是否感兴趣（即查准率），或者说所有用户感兴趣的内容我们推送出来了多少（即查全率）。因此，使用查准/查全率更适合描述这类问题。对于二分类问题，分类结果混淆矩阵与查准/查全率定义如下：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71daf885a4.png" alt="4.png"></p>
<p>初次接触时，FN与FP很难正确的理解，按照惯性思维容易把FN理解成：False-&gt;Negtive，即将错的预测为错的，这样FN和TN就反了，后来找到一张图，描述得很详细，为方便理解，把这张图也贴在了下边：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71daf871a6.png" alt="5.png"></p>
<p>正如天下没有免费的午餐，查准率和查全率是一对矛盾的度量。例如我们想让推送的内容尽可能用户全都感兴趣，那只能推送我们把握高的内容，这样就漏掉了一些用户感兴趣的内容，查全率就低了；如果想让用户感兴趣的内容都被推送，那只有将所有内容都推送上，宁可错杀一千，不可放过一个，这样查准率就很低了。</p>
<p>“P-R曲线”正是描述查准/查全率变化的曲线，P-R曲线定义如下：根据学习器的预测结果（一般为一个实值或概率）对测试样本进行排序，将最可能是“正例”的样本排在前面，最不可能是“正例”的排在后面，按此顺序逐个把样本作为“正例”进行预测，每次计算出当前的P值和R值，如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71dafc4411.png" alt="6.png"></p>
<p>P-R曲线如何评估呢？若一个学习器A的P-R曲线被另一个学习器B的P-R曲线完全包住，则称：B的性能优于A。若A和B的曲线发生了交叉，则谁的曲线下的面积大，谁的性能更优。但一般来说，曲线下的面积是很难进行估算的，所以衍生出了“平衡点”（Break-Event Point，简称BEP），即当P=R时的取值，平衡点的取值越高，性能更优。</p>
<p>P和R指标有时会出现矛盾的情况，这样就需要综合考虑他们，最常见的方法就是F-Measure，又称F-Score。F-Measure是P和R的加权调和平均，即：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71daf40ff6.png" alt="7.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc71daf75407.png" alt="8.png"></p>
<p>特别地，当β=1时，也就是常见的F1度量，是P和R的调和平均，当F1较高时，模型的性能越好。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71daf20885.png" alt="9.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc71daf4b90a.png" alt="10.png"></p>
<p>有时候我们会有多个二分类混淆矩阵，例如：多次训练或者在多个数据集上训练，那么估算全局性能的方法有两种，分为宏观和微观。简单理解，宏观就是先算出每个混淆矩阵的P值和R值，然后取得平均P值macro-P和平均R值macro-R，在算出Fβ或F1，而微观则是计算出混淆矩阵的平均TP、FP、TN、FN，接着进行计算P、R，进而求出Fβ或F1。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71ed70230e.png" alt="11.png"></p>
<h2 id="ROC与AUC-2"><strong>ROC与AUC</strong></h2>
<p>如上所述：学习器对测试样本的评估结果一般为一个实值或概率，设定一个阈值，大于阈值为正例，小于阈值为负例，因此这个实值的好坏直接决定了学习器的泛化性能，若将这些实值排序，则排序的好坏决定了学习器的性能高低。ROC曲线正是从这个角度出发来研究学习器的泛化性能，ROC曲线与P-R曲线十分类似，都是按照排序的顺序逐一按照正例预测，不同的是ROC曲线以“真正例率”（True Positive Rate，简称TPR）为横轴，纵轴为“假正例率”（False Positive Rate，简称FPR），ROC偏重研究基于测试样本评估值的排序好坏。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71ed6bee91.png" alt="12.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc71ed75cefe.png" alt="13.png"></p>
<p>简单分析图像，可以得知：当FN=0时，TN也必须0，反之也成立，我们可以画一个队列，试着使用不同的截断点（即阈值）去分割队列，来分析曲线的形状，（0,0）表示将所有的样本预测为负例，（1,1）则表示将所有的样本预测为正例，（0,1）表示正例全部出现在负例之前的理想情况，（1,0）则表示负例全部出现在正例之前的最差情况。限于篇幅，这里不再论述。</p>
<p>现实中的任务通常都是有限个测试样本，因此只能绘制出近似ROC曲线。绘制方法：首先根据测试样本的评估值对测试样本排序，接着按照以下规则进行绘制。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71ed740a24.png" alt="14.png"></p>
<p>同样地，进行模型的性能比较时，若一个学习器A的ROC曲线被另一个学习器B的ROC曲线完全包住，则称B的性能优于A。若A和B的曲线发生了交叉，则谁的曲线下的面积大，谁的性能更优。ROC曲线下的面积定义为AUC（Area Uder ROC Curve），不同于P-R的是，这里的AUC是可估算的，即AOC曲线下每一个小矩形的面积之和。易知：AUC越大，证明排序的质量越好，AUC为1时，证明所有正例排在了负例的前面，AUC为0时，所有的负例排在了正例的前面。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71ed6e2c57.png" alt="15.png"></p>
<h2 id="代价敏感错误率与代价曲线"><strong>代价敏感错误率与代价曲线</strong></h2>
<p>上面的方法中，将学习器的犯错同等对待，但在现实生活中，将正例预测成假例与将假例预测成正例的代价常常是不一样的，例如：将无疾病–&gt;有疾病只是增多了检查，但有疾病–&gt;无疾病却是增加了生命危险。以二分类为例，由此引入了“代价矩阵”（cost matrix）。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71ed6ed582.png" alt="16.png"></p>
<p>在非均等错误代价下，我们希望的是最小化“总体代价”，这样“代价敏感”的错误率（2.5.1节介绍）为：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71ed70bebe.png" alt="17.png"></p>
<p>同样对于ROC曲线，在非均等错误代价下，演变成了“代价曲线”，代价曲线横轴是取值在[0,1]之间的正例概率代价，式中p表示正例的概率，纵轴是取值为[0,1]的归一化代价。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71ed6e952e.png" alt="18.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc71ed6eee7b.png" alt="19.png"></p>
<p>代价曲线的绘制很简单：设ROC曲线上一点的坐标为(TPR，FPR) ，则可相应计算出FNR，然后在代价平面上绘制一条从(0，FPR) 到(1，FNR) 的线段，线段下的面积即表示了该条件下的期望总体代价；如此将ROC 曲线土的每个点转化为代价平面上的一条线段，然后取所有线段的下界，围成的面积即为在所有条件下学习器的期望总体代价，如图所示：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71ed716e0d.png" alt="20.png"></p>
<p>在此模型的性能度量方法就介绍完了，以前一直以为均方误差和精准度就可以了，现在才发现天空如此广阔~</p>
<blockquote>
<p>原文：<a href="https://github.com/Vay-keen/Machine-learning-learning-notes">https://github.com/Vay-keen/Machine-learning-learning-notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习笔记</category>
      </categories>
      <tags>
        <tag>性能度量</tag>
      </tags>
  </entry>
  <entry>
    <title>支持向量机</title>
    <url>/posts/280b588e.html</url>
    <content><![CDATA[<p>写在前面的话：距离上篇博客竟过去快一个月了，写完神经网络博客正式进入考试模式，几次考试+几篇报告下来弄得心颇不宁静了，今日定下来看到一句鸡血：Tomorrow is another due！也许生活就需要一些deadline~~</p>
<p>上篇主要介绍了神经网络。首先从生物学神经元出发，引出了它的数学抽象模型–MP神经元以及由两层神经元组成的感知机模型，并基于梯度下降的方法描述了感知机模型的权值调整规则。由于简单的感知机不能处理线性不可分的情形，因此接着引入了含隐层的前馈型神经网络，BP神经网络则是其中最为成功的一种学习方法，它使用误差逆传播的方法来逐层调节连接权。最后简单介绍了局部/全局最小以及目前十分火热的深度学习的概念。本篇围绕的核心则是曾经一度取代过神经网络的另一种监督学习算法–<strong>支持向量机</strong>（Support Vector Machine），简称<strong>SVM</strong>。</p>
<h1><strong>支持向量机</strong></h1>
<p>支持向量机是一种经典的二分类模型，基本模型定义为特征空间中最大间隔的线性分类器，其学习的优化目标便是间隔最大化，因此支持向量机本身可以转化为一个凸二次规划求解的问题。</p>
<h2 id="函数间隔与几何间隔"><strong>函数间隔与几何间隔</strong></h2>
<p>对于二分类学习，假设现在的数据是线性可分的，这时分类学习最基本的想法就是找到一个合适的超平面，该超平面能够将不同类别的样本分开，类似二维平面使用ax+by+c=0来表示，超平面实际上表示的就是高维的平面，如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f6a2ec8a.png" alt="1.png"></p>
<p>对数据点进行划分时，易知：当超平面距离与它最近的数据点的间隔越大，分类的鲁棒性越好，即当新的数据点加入时，超平面对这些点的适应性最强，出错的可能性最小。因此需要让所选择的超平面能够最大化这个间隔Gap（如下图所示）， 常用的间隔定义有两种，一种称之为函数间隔，一种为几何间隔，下面将分别介绍这两种间隔，并对SVM为什么会选用几何间隔做了一些阐述。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f6a06d5a.png" alt="2.png"></p>
<h3 id="函数间隔"><strong>函数间隔</strong></h3>
<p>在超平面w’x+b=0确定的情况下，|w’x*+b|能够代表点x<em>距离超平面的远近，易知：当w’x</em>+b&gt;0时，表示x<em>在超平面的一侧（正类，类标为1），而当w’x</em>+b&lt;0时，则表示x<em>在超平面的另外一侧（负类，类别为-1），因此（w’x</em>+b）y* 的正负性恰能表示数据点x*是否被分类正确。于是便引出了<strong>函数间隔</strong>的定义（functional margin）:</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f690a14b.png" alt="3.png"></p>
<p>而超平面（w,b）关于所有样本点（Xi，Yi）的函数间隔最小值则为超平面在训练数据集T上的函数间隔：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f690ac26.png" alt="4.png"></p>
<p>可以看出：这样定义的函数间隔在处理SVM上会有问题，当超平面的两个参数w和b同比例改变时，函数间隔也会跟着改变，但是实际上超平面还是原来的超平面，并没有变化。例如：w1x1+w2x2+w3x3+b=0其实等价于2w1x1+2w2x2+2w3x3+2b=0，但计算的函数间隔却翻了一倍。从而引出了能真正度量点到超平面距离的概念–几何间隔（geometrical margin）。</p>
<h3 id="几何间隔"><strong>几何间隔</strong></h3>
<p><strong>几何间隔</strong>代表的则是数据点到超平面的真实距离，对于超平面w’x+b=0，w代表的是该超平面的法向量，设x<em>为超平面外一点x在法向量w方向上的投影点，x与超平面的距离为r，则有x</em>=x-r(w/||w||)，又x<em>在超平面上，即w’x</em>+b=0，代入即可得：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f697d499.png" alt="5.png"></p>
<p>为了得到r的绝对值，令r呈上其对应的类别y，即可得到几何间隔的定义：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f696fd10.png" alt="6.png"></p>
<p>从上述函数间隔与几何间隔的定义可以看出：实质上函数间隔就是|w’x+b|，而几何间隔就是点到超平面的距离。</p>
<h2 id="最大间隔与支持向量"><strong>最大间隔与支持向量</strong></h2>
<p>通过前面的分析可知：函数间隔不适合用来最大化间隔，因此这里我们要找的最大间隔指的是几何间隔，于是最大间隔分类器的目标函数定义为：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f69af163.png" alt="7.png"></p>
<p>一般地，我们令r^为1（这样做的目的是为了方便推导和目标函数的优化），从而上述目标函数转化为：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f697bb1d.png" alt="8.png"></p>
<p>对于y(w’x+b)=1的数据点，即下图中位于w’x+b=1或w’x+b=-1上的数据点，我们称之为<strong>支持向量</strong>（support vector），易知：对于所有的支持向量，它们恰好满足y*(w’x*+b)=1，而所有不是支持向量的点，有y*(w’x*+b)&gt;1。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f6a838c4.png" alt="9.png"></p>
<h2 id="从原始优化问题到对偶问题"><strong>从原始优化问题到对偶问题</strong></h2>
<p>对于上述得到的目标函数，求1/||w||的最大值相当于求||w||^2的最小值，因此很容易将原来的目标函数转化为：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f6978cbb.png" alt="10.png"></p>
<p>即变为了一个带约束的凸二次规划问题，按书上所说可以使用现成的优化计算包（QP优化包）求解，但由于SVM的特殊性，一般我们将原问题变换为它的<strong>对偶问题</strong>，接着再对其对偶问题进行求解。为什么通过对偶问题进行求解，有下面两个原因：</p>
<pre><code>* 一是因为使用对偶问题更容易求解；
* 二是因为通过对偶问题求解出现了向量内积的形式，从而能更加自然地引出核函数。
</code></pre>
<p>对偶问题，顾名思义，可以理解成优化等价的问题，更一般地，是将一个原始目标函数的最小化转化为它的对偶函数最大化的问题。对于当前的优化问题，首先我们写出它的朗格朗日函数：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f9332be7.png" alt="11.png"></p>
<p>上式很容易验证：当其中有一个约束条件不满足时，L的最大值为 ∞（只需令其对应的α为 ∞即可）；当所有约束条件都满足时，L的最大值为1/2||w||^2（此时令所有的α为0），因此实际上原问题等价于：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f93321c5.png" alt="12.png"></p>
<p>由于这个的求解问题不好做，因此一般我们将最小和最大的位置交换一下（需满足KKT条件） ，变成原问题的对偶问题：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f9330967.png" alt="13.png"></p>
<p>这样就将原问题的求最小变成了对偶问题求最大（用对偶这个词还是很形象），接下来便可以先求L对w和b的极小，再求L对α的极大。</p>
<p>（1）首先求L对w和b的极小，分别求L关于w和b的偏导，可以得出：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f9333e66.png" alt="14.png"></p>
<p>将上述结果代入L得到：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f935ae21.png" alt="15.png"></p>
<p>（2）接着L关于α极大求解α（通过SMO算法求解，此处不做深入）。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f9338a9d.png" alt="16.png"></p>
<p>（3）最后便可以根据求解出的α，计算出w和b，从而得到分类超平面函数。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f93419ca.png" alt="17.png"></p>
<p>在对新的点进行预测时，实际上就是将数据点x*代入分类函数f(x)=w’x+b中，若f(x)&gt;0，则为正类，f(x)&lt;0，则为负类，根据前面推导得出的w与b，分类函数如下所示，此时便出现了上面所提到的内积形式。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f9353166.png" alt="18.png"></p>
<p>这里实际上只需计算新样本与支持向量的内积，因为对于非支持向量的数据点，其对应的拉格朗日乘子一定为0，根据最优化理论（K-T条件），对于不等式约束y(w’x+b)-1≥0，满足：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f933c947.png" alt="19.png"></p>
<h2 id="核函数"><strong>核函数</strong></h2>
<p>由于上述的超平面只能解决线性可分的问题，对于线性不可分的问题，例如：异或问题，我们需要使用核函数将其进行推广。一般地，解决线性不可分问题时，常常采用<strong>映射</strong>的方式，将低维原始空间映射到高维特征空间，使得数据集在高维空间中变得线性可分，从而再使用线性学习器分类。如果原始空间为有限维，即属性数有限，那么总是存在一个高维特征空间使得样本线性可分。若∅代表一个映射，则在特征空间中的划分函数变为：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72f934303e.png" alt="20.png"></p>
<p>按照同样的方法，先写出新目标函数的拉格朗日函数，接着写出其对偶问题，求L关于w和b的极大，最后运用SOM求解α。可以得出：</p>
<p>（1）原对偶问题变为：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc730cc68b3b.png" alt="21.png"></p>
<p>（2）原分类函数变为：​    <img src="https://i.loli.net/2018/10/17/5bc730cc1b673.png" alt="22.png"></p>
<p>求解的过程中，只涉及到了高维特征空间中的内积运算，由于特征空间的维数可能会非常大，例如：若原始空间为二维，映射后的特征空间为5维，若原始空间为三维，映射后的特征空间将是19维，之后甚至可能出现无穷维，根本无法进行内积运算了，此时便引出了<strong>核函数</strong>（Kernel）的概念。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc730cc49adc.png" alt="23.png"></p>
<p>因此，核函数可以直接计算隐式映射到高维特征空间后的向量内积，而不需要显式地写出映射后的结果，它虽然完成了将特征从低维到高维的转换，但最终却是在低维空间中完成向量内积计算，与高维特征空间中的计算等效**（低维计算，高维表现）**，从而避免了直接在高维空间无法计算的问题。引入核函数后，原来的对偶问题与分类函数则变为：</p>
<p>（1）对偶问题：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc730cc173b2.png" alt="24.png"></p>
<p>（2）分类函数：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc730cc05959.png" alt="25.png"></p>
<p>因此，在线性不可分问题中，核函数的选择成了支持向量机的最大变数，若选择了不合适的核函数，则意味着将样本映射到了一个不合适的特征空间，则极可能导致性能不佳。同时，核函数需要满足以下这个必要条件：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc730ccc468c.png" alt="26.png"></p>
<p>由于核函数的构造十分困难，通常我们都是从一些常用的核函数中选择，下面列出了几种常用的核函数：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc730ccc541a.png" alt="27.png"></p>
<h2 id="软间隔支持向量机"><strong>软间隔支持向量机</strong></h2>
<p>前面的讨论中，我们主要解决了两个问题：当数据线性可分时，直接使用最大间隔的超平面划分；当数据线性不可分时，则通过核函数将数据映射到高维特征空间，使之线性可分。然而在现实问题中，对于某些情形还是很难处理，例如数据中有<strong>噪声</strong>的情形，噪声数据（<strong>outlier</strong>）本身就偏离了正常位置，但是在前面的SVM模型中，我们要求所有的样本数据都必须满足约束，如果不要这些噪声数据还好，当加入这些outlier后导致划分超平面被挤歪了，如下图所示，对支持向量机的泛化性能造成很大的影响。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc730ccce68e.png" alt="28.png"></p>
<p>为了解决这一问题，我们需要允许某一些数据点不满足约束，即可以在一定程度上偏移超平面，同时使得不满足约束的数据点尽可能少，这便引出了**“软间隔”支持向量机**的概念</p>
<pre><code>* 允许某些数据点不满足约束y(w'x+b)≥1；
* 同时又使得不满足约束的样本尽可能少。
</code></pre>
<p>这样优化目标变为：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc730cc6c9fe.png" alt="29.png"></p>
<p>如同阶跃函数，0/1损失函数虽然表示效果最好，但是数学性质不佳。因此常用其它函数作为“替代损失函数”。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc730cc5e5a9.png" alt="30.png"></p>
<p>支持向量机中的损失函数为<strong>hinge损失</strong>，引入**“松弛变量”**，目标函数与约束条件可以写为：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc7317aa3411.png" alt="31.png"></p>
<p>其中C为一个参数，控制着目标函数与新引入正则项之间的权重，这样显然每个样本数据都有一个对应的松弛变量，用以表示该样本不满足约束的程度，将新的目标函数转化为拉格朗日函数得到：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc7317a4c96e.png" alt="32.png"></p>
<p>按照与之前相同的方法，先让L求关于w，b以及松弛变量的极小，再使用SMO求出α，有：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc7317a6dff2.png" alt="33.png"></p>
<p>将w代入L化简，便得到其对偶问题：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc7317ab6646.png" alt="34.png"></p>
<p>将“软间隔”下产生的对偶问题与原对偶问题对比可以发现：新的对偶问题只是约束条件中的α多出了一个上限C，其它的完全相同，因此在引入核函数处理线性不可分问题时，便能使用与“硬间隔”支持向量机完全相同的方法。</p>
<blockquote>
<p>原文：<a href="https://github.com/Vay-keen/Machine-learning-learning-notes">https://github.com/Vay-keen/Machine-learning-learning-notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习笔记</category>
      </categories>
      <tags>
        <tag>支持向量机</tag>
      </tags>
  </entry>
  <entry>
    <title>概率图模型</title>
    <url>/posts/af2d2d3a.html</url>
    <content><![CDATA[<p>上篇主要介绍了半监督学习，首先从如何利用未标记样本所蕴含的分布信息出发，引入了半监督学习的基本概念，即训练数据同时包含有标记样本和未标记样本的学习方法；接着分别介绍了几种常见的半监督学习方法：生成式方法基于对数据分布的假设，利用未标记样本隐含的分布信息，使得对模型参数的估计更加准确；TSVM给未标记样本赋予伪标记，并通过不断调整易出错样本的标记得到最终输出；基于分歧的方法结合了集成学习的思想，通过多个学习器在不同视图上的协作，有效利用了未标记样本数据 ；最后半监督聚类则是借助已有的监督信息来辅助聚类的过程，带约束k-均值算法需检测当前样本划分是否满足约束关系，带标记k-均值算法则利用有标记样本指定初始类中心。本篇将讨论一种基于图的学习算法–概率图模型。</p>
<h1><strong>概率图模型</strong></h1>
<p>现在再来谈谈机器学习的核心价值观，可以更通俗地理解为：<strong>根据一些已观察到的证据来推断未知</strong>，更具哲学性地可以阐述为：未来的发展总是遵循着历史的规律。其中<strong>基于概率的模型将学习任务归结为计算变量的概率分布</strong>，正如之前已经提到的：生成式模型先对联合分布进行建模，从而再来求解后验概率，例如：贝叶斯分类器先对联合分布进行最大似然估计，从而便可以计算类条件概率；判别式模型则是直接对条件分布进行建模。</p>
<p><strong>概率图模型</strong>（probabilistic graphical model）是一类用<strong>图结构</strong>来表达各属性之间相关关系的概率模型，一般而言：<strong>图中的一个结点表示一个或一组随机变量，结点之间的边则表示变量间的相关关系</strong>，从而形成了一张“<strong>变量关系图</strong>”。若使用有向的边来表达变量之间的依赖关系，这样的有向关系图称为<strong>贝叶斯网</strong>（Bayesian nerwork）或有向图模型；若使用无向边，则称为<strong>马尔可夫网</strong>（Markov network）或无向图模型。</p>
<h2 id="隐马尔可夫模型-HMM"><strong>隐马尔可夫模型(HMM)</strong></h2>
<p>隐马尔可夫模型（Hidden Markov Model，简称HMM）是结构最简单的一种贝叶斯网，在语音识别与自然语言处理领域上有着广泛的应用。HMM中的变量分为两组：<strong>状态变量</strong>与<strong>观测变量</strong>，其中状态变量一般是未知的，因此又称为“<strong>隐变量</strong>”，观测变量则是已知的输出值。在隐马尔可夫模型中，变量之间的依赖关系遵循如下两个规则：</p>
<blockquote>
<p><strong>1. 观测变量的取值仅依赖于状态变量</strong>；<br>
<strong>2. 下一个状态的取值仅依赖于当前状态</strong>，通俗来讲：<strong>现在决定未来，未来与过去无关</strong>，这就是著名的<strong>马尔可夫性</strong>。</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYPmR.png" alt="iwYPmR.png"></p>
<p>基于上述变量之间的依赖关系，我们很容易写出隐马尔可夫模型中所有变量的联合概率分布：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwY9X9.png" alt="iwY9X9.png"></p>
<p>易知：<strong>欲确定一个HMM模型需要以下三组参数</strong>：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYi01.png" alt="iwYi01.png"></p>
<p>当确定了一个HMM模型的三个参数后，便按照下面的规则来生成观测值序列：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYFTx.png" alt="iwYFTx.png"></p>
<p>在实际应用中，HMM模型的发力点主要体现在下述三个问题上：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYEtK.png" alt="iwYEtK.png"></p>
<h3 id="HMM评估问题"><strong>HMM评估问题</strong></h3>
<p>HMM评估问题指的是：<strong>给定了模型的三个参数与观测值序列，求该观测值序列出现的概率</strong>。例如：对于赌场问题，便可以依据骰子掷出的结果序列来计算该结果序列出现的可能性，若小概率的事件发生了则可认为赌场的骰子有作弊的可能。解决该问题使用的是<strong>前向算法</strong>，即步步为营，自底向上的方式逐步增加序列的长度，直到获得目标概率值。在前向算法中，定义了一个<strong>前向变量</strong>，即给定观察值序列且t时刻的状态为Si的概率：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYVfO.png" alt="iwYVfO.png"></p>
<p>基于前向变量，很容易得到该问题的递推关系及终止条件：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYAk6.png" alt="iwYAk6.png"></p>
<p>因此可使用动态规划法，从最小的子问题开始，通过填表格的形式一步一步计算出目标结果。</p>
<h3 id="HMM解码问题"><strong>HMM解码问题</strong></h3>
<p>HMM解码问题指的是：<strong>给定了模型的三个参数与观测值序列，求可能性最大的状态序列</strong>。例如：在语音识别问题中，人说话形成的数字信号对应着观测值序列，对应的具体文字则是状态序列，从数字信号转化为文字正是对应着根据观测值序列推断最有可能的状态值序列。解决该问题使用的是<strong>Viterbi算法</strong>，与前向算法十分类似地，Viterbi算法定义了一个<strong>Viterbi变量</strong>，也是采用动态规划的方法，自底向上逐步求解。</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYepD.png" alt="iwYepD.png"></p>
<h3 id="HMM学习问题"><strong>HMM学习问题</strong></h3>
<p>HMM学习问题指的是：<strong>给定观测值序列，如何调整模型的参数使得该序列出现的概率最大</strong>。这便转化成了机器学习问题，即从给定的观测值序列中学习出一个HMM模型，<strong>该问题正是EM算法的经典案例之一</strong>。其思想也十分简单：对于给定的观测值序列，如果我们能够按照该序列潜在的规律来调整模型的三个参数，则可以使得该序列出现的可能性最大。假设状态值序列也已知，则很容易计算出与该序列最契合的模型参数：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYm1e.png" alt="iwYm1e.png"></p>
<p>但一般状态值序列都是不可观测的，且<strong>即使给定观测值序列与模型参数，状态序列仍然遭遇组合爆炸</strong>。因此上面这种简单的统计方法就行不通了，若将状态值序列看作为隐变量，这时便可以考虑使用EM算法来对该问题进行求解：</p>
<p>【1】首先对HMM模型的三个参数进行随机初始化；【2】根据模型的参数与观测值序列，计算t时刻状态为i且t+1时刻状态为j的概率以及t时刻状态为i的概率。</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYn6H.png" alt="iwYn6H.png"><br>
<img src="https://s1.ax1x.com/2018/10/18/iwYdns.png" alt="iwYdns.png"></p>
<p>【3】接着便可以对模型的三个参数进行重新估计：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYY9S.png" alt="iwYY9S.png"></p>
<p>【4】重复步骤2-3，直至三个参数值收敛，便得到了最终的HMM模型。</p>
<h2 id="马尔可夫随机场（MRF）"><strong>马尔可夫随机场（MRF）</strong></h2>
<p>马尔可夫随机场（Markov Random Field）是一种典型的马尔可夫网，即使用无向边来表达变量间的依赖关系。在马尔可夫随机场中，对于关系图中的一个子集，<strong>若任意两结点间都有边连接，则称该子集为一个团；若再加一个结点便不能形成团，则称该子集为极大团</strong>。MRF使用<strong>势函数</strong>来定义多个变量的概率分布函数，其中<strong>每个（极大）团对应一个势函数</strong>，一般团中的变量关系也体现在它所对应的极大团中，因此常常基于极大团来定义变量的联合概率分布函数。具体而言，若所有变量构成的极大团的集合为C，则MRF的联合概率函数可以定义为：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYGh8.png" alt="iwYGh8.png"></p>
<p>对于条件独立性，<strong>马尔可夫随机场通过分离集来实现条件独立</strong>，若A结点集必须经过C结点集才能到达B结点集，则称C为分离集。书上给出了一个简单情形下的条件独立证明过程，十分贴切易懂，此处不再展开。基于分离集的概念，得到了MRF的三个性质：</p>
<blockquote>
<p><strong>全局马尔可夫性</strong>：给定两个变量子集的分离集，则这两个变量子集条件独立。<br>
<strong>局部马尔可夫性</strong>：给定某变量的邻接变量，则该变量与其它变量条件独立。<br>
<strong>成对马尔可夫性</strong>：给定所有其他变量，两个非邻接变量条件独立。</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2018/10/18/iwY07q.png" alt="iwY07q.png"></p>
<p>对于MRF中的势函数，势函数主要用于描述团中变量之间的相关关系，且要求为非负函数，直观来看：势函数需要在偏好的变量取值上函数值较大，例如：若x1与x2成正相关，则需要将这种关系反映在势函数的函数值中。一般我们常使用指数函数来定义势函数：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwY8tf.png" alt="iwY8tf.png"></p>
<h2 id="条件随机场（CRF）"><strong>条件随机场（CRF）</strong></h2>
<p>前面所讲到的<strong>隐马尔可夫模型和马尔可夫随机场都属于生成式模型，即对联合概率进行建模，条件随机场则是对条件分布进行建模</strong>。CRF试图在给定观测值序列后，对状态序列的概率分布进行建模，即P(y | x)。直观上看：CRF与HMM的解码问题十分类似，都是在给定观测值序列后，研究状态序列可能的取值。CRF可以有多种结构，只需保证状态序列满足马尔可夫性即可，一般我们常使用的是<strong>链式条件随机场</strong>：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYt1g.png" alt="iwYt1g.png"></p>
<p>与马尔可夫随机场定义联合概率类似地，CRF也通过团以及势函数的概念来定义条件概率P(y | x)。在给定观测值序列的条件下，链式条件随机场主要包含两种团结构：单个状态团及相邻状态团，通过引入两类特征函数便可以定义出目标条件概率：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYNcQ.png" alt="iwYNcQ.png"></p>
<p>以词性标注为例，如何判断给出的一个标注序列靠谱不靠谱呢？<strong>转移特征函数主要判定两个相邻的标注是否合理</strong>，例如：动词+动词显然语法不通；<strong>状态特征函数则判定观测值与对应的标注是否合理</strong>，例如： ly结尾的词–&gt;副词较合理。因此我们可以定义一个特征函数集合，用这个特征函数集合来为一个标注序列打分，并据此选出最靠谱的标注序列。也就是说，每一个特征函数（对应一种规则）都可以用来为一个标注序列评分，把集合中所有特征函数对同一个标注序列的评分综合起来，就是这个标注序列最终的评分值。可以看出：<strong>特征函数是一些经验的特性</strong>。</p>
<h2 id="学习与推断"><strong>学习与推断</strong></h2>
<p>对于生成式模型，通常我们都是先对变量的联合概率分布进行建模，接着再求出目标变量的<strong>边际分布</strong>（marginal distribution），那如何从联合概率得到边际分布呢？这便是学习与推断。下面主要介绍两种精确推断的方法：<strong>变量消去</strong>与<strong>信念传播</strong>。</p>
<h3 id="变量消去"><strong>变量消去</strong></h3>
<p>变量消去利用条件独立性来消减计算目标概率值所需的计算量，它通过运用<strong>乘法与加法的分配率</strong>，将对变量的积的求和问题转化为对部分变量交替进行求积与求和的问题，从而将每次的<strong>运算控制在局部</strong>，达到简化运算的目的。</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYUXj.png" alt="iwYUXj.png"><br>
<img src="https://s1.ax1x.com/2018/10/18/iwYwBn.png" alt="iwYwBn.png"></p>
<h3 id="信念传播"><strong>信念传播</strong></h3>
<p>若将变量求和操作看作是一种消息的传递过程，信念传播可以理解成：<strong>一个节点在接收到所有其它节点的消息后才向另一个节点发送消息</strong>，同时当前节点的边际概率正比于他所接收的消息的乘积：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYDA0.png" alt="iwYDA0.png"></p>
<p>因此只需要经过下面两个步骤，便可以完成所有的消息传递过程。利用动态规划法的思想记录传递过程中的所有消息，当计算某个结点的边际概率分布时，只需直接取出传到该结点的消息即可，从而避免了计算多个边际分布时的冗余计算问题。</p>
<blockquote>
<p>1.指定一个根节点，从所有的叶节点开始向根节点传递消息，直到根节点收到所有邻接结点的消息**（从叶到根）<strong>；<br>
2.从根节点开始向叶节点传递消息，直到所有叶节点均收到消息</strong>（从根到叶）**。</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYgc4.png" alt="iwYgc4.png"></p>
<h2 id="LDA话题模型"><strong>LDA话题模型</strong></h2>
<p>话题模型主要用于处理文本类数据，其中<strong>隐狄利克雷分配模型</strong>（Latent Dirichlet Allocation，简称LDA）是话题模型的杰出代表。在话题模型中，有以下几个基本概念：词（word）、文档（document）、话题（topic）。</p>
<blockquote>
<p><strong>词</strong>：最基本的离散单元；<br>
<strong>文档</strong>：由一组词组成，词在文档中不计顺序；<br>
<strong>话题</strong>：由一组特定的词组成，这组词具有较强的相关关系。</p>
</blockquote>
<p>在现实任务中，一般我们可以得出一个文档的词频分布，但不知道该文档对应着哪些话题，LDA话题模型正是为了解决这个问题。具体来说：<strong>LDA认为每篇文档包含多个话题，且其中每一个词都对应着一个话题</strong>。因此可以假设文档是通过如下方式生成：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwY2jJ.png" alt="iwY2jJ.png"></p>
<p>这样一个文档中的所有词都可以认为是通过话题模型来生成的，当已知一个文档的词频分布后（即一个N维向量，N为词库大小），则可以认为：<strong>每一个词频元素都对应着一个话题，而话题对应的词频分布则影响着该词频元素的大小</strong>。因此很容易写出LDA模型对应的联合概率函数：</p>
<p><img src="https://s1.ax1x.com/2018/10/18/iwYc3F.png" alt="iwYc3F.png"><br>
<img src="https://s1.ax1x.com/2018/10/18/iwYWu9.png" alt="iwYWu9.png"></p>
<p>从上图可以看出，LDA的三个表示层被三种颜色表示出来：</p>
<blockquote>
<p><strong>corpus-level（红色）：</strong> α和β表示语料级别的参数，也就是每个文档都一样，因此生成过程只采样一次。<br>
<strong>document-level（橙色）：</strong> θ是文档级别的变量，每个文档对应一个θ。<br>
<strong>word-level（绿色）：</strong> z和w都是单词级别变量，z由θ生成，w由z和β共同生成，一个单词w对应一个主题z。</p>
</blockquote>
<p>通过上面对LDA生成模型的讨论，可以知道<strong>LDA模型主要是想从给定的输入语料中学习训练出两个控制参数α和β</strong>，当学习出了这两个控制参数就确定了模型，便可以用来生成文档。其中α和β分别对应以下各个信息：</p>
<blockquote>
<p><strong>α</strong>：分布p(θ)需要一个向量参数，即Dirichlet分布的参数，用于生成一个主题θ向量；<br>
<strong>β</strong>：各个主题对应的单词概率分布矩阵p(w|z)。</p>
</blockquote>
<p>把w当做观察变量，θ和z当做隐藏变量，就可以通过EM算法学习出α和β，求解过程中遇到后验概率p(θ,z|w)无法直接求解，需要找一个似然函数下界来近似求解，原作者使用基于分解（factorization）假设的变分法（varialtional inference）进行计算，用到了EM算法。每次E-step输入α和β，计算似然函数，M-step最大化这个似然函数，算出α和β，不断迭代直到收敛。</p>
<p>在此，概率图模型就介绍完毕。上周受到协同训练的启发，让实验的小伙伴做了一个HMM的slides，结果扩充了好多知识，所以完成这篇笔记还是花费了不少功夫，还刚好赶上实验室没空调回到解放前的日子，可谓汗流之作…</p>
<blockquote>
<p>原文：<a href="https://github.com/Vay-keen/Machine-learning-learning-notes">https://github.com/Vay-keen/Machine-learning-learning-notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习笔记</category>
      </categories>
      <tags>
        <tag>概率图模型</tag>
      </tags>
  </entry>
  <entry>
    <title>特征选择与稀疏学习</title>
    <url>/posts/ca07ce0f.html</url>
    <content><![CDATA[<p>上篇主要介绍了经典的降维方法与度量学习，首先从“维数灾难”导致的样本稀疏以及距离难计算两大难题出发，引出了降维的概念，即通过某种数学变换将原始高维空间转变到一个低维的子空间，接着分别介绍了kNN、MDS、PCA、KPCA以及两种经典的流形学习方法，k近邻算法的核心在于k值的选取以及距离的度量，MDS要求原始空间样本之间的距离在降维后的低维空间中得以保持，主成分分析试图找到一个低维超平面来表出原空间样本点，核化主成分分析先将样本点映射到高维空间，再在高维空间中使用线性降维的方法，从而解决了原空间样本非线性分布的情形，基于流形学习的降维则是一种“邻域保持”的思想，最后度量学习试图去学习出一个距离度量来等效降维的效果。本篇将讨论另一种常用方法–特征选择与稀疏学习。</p>
<h1><strong>特征选择与稀疏学习</strong></h1>
<p>最近在看论文的过程中，发现对于数据集行和列的叫法颇有不同，故在介绍本篇之前，决定先将最常用的术语罗列一二，以后再见到了不管它脚扑朔还是眼迷离就能一眼识破真身了~对于数据集中的一个对象及组成对象的零件元素：</p>
<blockquote>
<p>统计学家常称它们为<strong>观测</strong>（<strong>observation</strong>）和<strong>变量</strong>（<strong>variable</strong>）；数据库分析师则称其为<strong>记录</strong>（<strong>record</strong>）和<strong>字段</strong>（<strong>field</strong>）；数据挖掘/机器学习学科的研究者则习惯把它们叫做<strong>样本</strong>/<strong>示例</strong>（<strong>example</strong>/<strong>instance</strong>）和<strong>属性</strong>/<strong>特征</strong>（<strong>attribute</strong>/<strong>feature</strong>）。</p>
</blockquote>
<p>回归正题，在机器学习中特征选择是一个重要的“<strong>数据预处理</strong>”（<strong>data</strong> <strong>preprocessing</strong>）过程，即试图从数据集的所有特征中挑选出与当前学习任务相关的特征子集，接着再利用数据子集来训练学习器；稀疏学习则是围绕着稀疏矩阵的优良性质，来完成相应的学习任务。</p>
<h2 id="子集搜索与评价"><strong>子集搜索与评价</strong></h2>
<p>一般地，我们可以用很多属性/特征来描述一个示例，例如对于一个人可以用性别、身高、体重、年龄、学历、专业、是否吃货等属性来描述，那现在想要训练出一个学习器来预测人的收入。根据生活经验易知：并不是所有的特征都与学习任务相关，例如年龄/学历/专业可能很大程度上影响了收入，身高/体重这些外貌属性也有较小的可能性影响收入，但像是否是一个地地道道的吃货这种属性就八杆子打不着了。因此我们只需要那些与学习任务紧密相关的特征，<strong>特征选择便是从给定的特征集合中选出相关特征子集的过程</strong>。</p>
<p>与上篇中降维技术有着异曲同工之处的是，特征选择也可以有效地解决维数灾难的难题。具体而言：<strong>降维从一定程度起到了提炼优质低维属性和降噪的效果，特征选择则是直接剔除那些与学习任务无关的属性而选择出最佳特征子集</strong>。若直接遍历所有特征子集，显然当维数过多时遭遇指数爆炸就行不通了；若采取从候选特征子集中不断迭代生成更优候选子集的方法，则时间复杂度大大减小。这时就涉及到了两个关键环节：<strong>1.如何生成候选子集；2.如何评价候选子集的好坏</strong>，这便是早期特征选择的常用方法。书本上介绍了贪心算法，分为三种策略：</p>
<blockquote>
<p><strong>前向搜索</strong>：初始将每个特征当做一个候选特征子集，然后从当前所有的候选子集中选择出最佳的特征子集；接着在上一轮选出的特征子集中添加一个新的特征，同样地选出最佳特征子集；最后直至选不出比上一轮更好的特征子集。<br>
<strong>后向搜索</strong>：初始将所有特征作为一个候选特征子集；接着尝试去掉上一轮特征子集中的一个特征并选出当前最优的特征子集；最后直到选不出比上一轮更好的特征子集。<br>
<strong>双向搜索</strong>：将前向搜索与后向搜索结合起来，即在每一轮中既有添加操作也有剔除操作。</p>
</blockquote>
<p>对于特征子集的评价，书中给出了一些想法及基于信息熵的方法。假设数据集的属性皆为离散属性，这样给定一个特征子集，便可以通过这个特征子集的取值将数据集合划分为V个子集。例如：A1={男,女}，A2={本科,硕士}就可以将原数据集划分为2*2=4个子集，其中每个子集的取值完全相同。这时我们就可以像决策树选择划分属性那样，通过计算信息增益来评价该属性子集的好坏。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc853eca1a43.png" alt="1.png"></p>
<p>此时，信息增益越大表示该属性子集包含有助于分类的特征越多，使用上述这种<strong>子集搜索与子集评价相结合的机制，便可以得到特征选择方法</strong>。值得一提的是若将前向搜索策略与信息增益结合在一起，与前面我们讲到的ID3决策树十分地相似。事实上，决策树也可以用于特征选择，树节点划分属性组成的集合便是选择出的特征子集。</p>
<h2 id="过滤式选择（Relief）"><strong>过滤式选择（Relief）</strong></h2>
<p>过滤式方法是一种将特征选择与学习器训练相分离的特征选择技术，即首先将相关特征挑选出来，再使用选择出的数据子集来训练学习器。Relief是其中著名的代表性算法，它使用一个“<strong>相关统计量</strong>”来度量特征的重要性，该统计量是一个向量，其中每个分量代表着相应特征的重要性，因此我们最终可以根据这个统计量各个分量的大小来选择出合适的特征子集。</p>
<p>易知Relief算法的核心在于如何计算出该相关统计量。对于数据集中的每个样例xi，Relief首先找出与xi同类别的最近邻与不同类别的最近邻，分别称为<strong>猜中近邻（near-hit）<strong>与</strong>猜错近邻（near-miss）</strong>，接着便可以分别计算出相关统计量中的每个分量。对于j分量：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc853ec70c88.png" alt="2.png"></p>
<p>直观上理解：对于猜中近邻，两者j属性的距离越小越好，对于猜错近邻，j属性距离越大越好。更一般地，若xi为离散属性，diff取海明距离，即相同取0，不同取1；若xi为连续属性，则diff为曼哈顿距离，即取差的绝对值。分别计算每个分量，最终取平均便得到了整个相关统计量。</p>
<p>标准的Relief算法只用于二分类问题，后续产生的拓展变体Relief-F则解决了多分类问题。对于j分量，新的计算公式如下：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc853ec93042.png" alt="3.png"></p>
<p>其中pl表示第l类样本在数据集中所占的比例，易知两者的不同之处在于：<strong>标准Relief 只有一个猜错近邻，而Relief-F有多个猜错近邻</strong>。</p>
<h2 id="包裹式选择（LVW）"><strong>包裹式选择（LVW）</strong></h2>
<p>与过滤式选择不同的是，包裹式选择将后续的学习器也考虑进来作为特征选择的评价准则。因此包裹式选择可以看作是为某种学习器<strong>量身定做</strong>的特征选择方法，由于在每一轮迭代中，包裹式选择都需要训练学习器，因此在获得较好性能的同时也产生了较大的开销。下面主要介绍一种经典的包裹式特征选择方法 --LVW（Las Vegas Wrapper），它在拉斯维加斯框架下使用随机策略来进行特征子集的搜索。拉斯维加斯？怎么听起来那么耳熟，不是那个声名显赫的赌场吗？歪果仁真会玩。怀着好奇科普一下，结果又顺带了一个赌场：</p>
<blockquote>
<p><strong>蒙特卡罗算法</strong>：采样越多，越近似最优解，一定会给出解，但给出的解不一定是正确解；<br>
<strong>拉斯维加斯算法</strong>：采样越多，越有机会找到最优解，不一定会给出解，且给出的解一定是正确解。</p>
</blockquote>
<p>举个例子，假如筐里有100个苹果，让我每次闭眼拿1个，挑出最大的。于是我随机拿1个，再随机拿1个跟它比，留下大的，再随机拿1个……我每拿一次，留下的苹果都至少不比上次的小。拿的次数越多，挑出的苹果就越大，但我除非拿100次，否则无法肯定挑出了最大的。这个挑苹果的算法，就属于蒙特卡罗算法——尽量找较好的，但不保证是最好的。</p>
<p>而拉斯维加斯算法，则是另一种情况。假如有一把锁，给我100把钥匙，只有1把是对的。于是我每次随机拿1把钥匙去试，打不开就再换1把。我试的次数越多，打开（正确解）的机会就越大，但在打开之前，那些错的钥匙都是没有用的。这个试钥匙的算法，就是拉斯维加斯的——尽量找最好的，但不保证能找到。</p>
<p>LVW算法的具体流程如下所示，其中比较特别的是停止条件参数T的设置，即在每一轮寻找最优特征子集的过程中，若随机T次仍没找到，算法就会停止，从而保证了算法运行时间的可行性。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc853ed5e08e.png" alt="4.png"></p>
<h2 id="嵌入式选择与正则化"><strong>嵌入式选择与正则化</strong></h2>
<p>前面提到了的两种特征选择方法：<strong>过滤式中特征选择与后续学习器完全分离，包裹式则是使用学习器作为特征选择的评价准则；嵌入式是一种将特征选择与学习器训练完全融合的特征选择方法，即将特征选择融入学习器的优化过程中</strong>。在之前《经验风险与结构风险》中已经提到：经验风险指的是模型与训练数据的契合度，结构风险则是模型的复杂程度，机器学习的核心任务就是：<strong>在模型简单的基础上保证模型的契合度</strong>。例如：岭回归就是加上了L2范数的最小二乘法，有效地解决了奇异矩阵、过拟合等诸多问题，下面的嵌入式特征选择则是在损失函数后加上了L1范数。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc853ec8b203.png" alt="5.png"></p>
<p>L1范数美名又约<strong>Lasso Regularization</strong>，指的是向量中每个元素的绝对值之和，这样在优化目标函数的过程中，就会使得w尽可能地小，在一定程度上起到了防止过拟合的作用，同时与L2范数（Ridge Regularization ）不同的是，L1范数会使得部分w变为0， 从而达到了特征选择的效果。</p>
<p>总的来说：<strong>L1范数会趋向产生少量的特征，其他特征的权值都是0；L2会选择更多的特征，这些特征的权值都会接近于0</strong>。这样L1范数在特征选择上就十分有用，而L2范数则具备较强的控制过拟合能力。可以从下面两个方面来理解：</p>
<p>（1）<strong>下降速度</strong>：L1范数按照绝对值函数来下降，L2范数按照二次函数来下降。因此在0附近，L1范数的下降速度大于L2范数，故L1范数能很快地下降到0，而L2范数在0附近的下降速度非常慢，因此较大可能收敛在0的附近。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc853ed0aaf5.png" alt="6.png"></p>
<p>（2）<strong>空间限制</strong>：L1范数与L2范数都试图在最小化损失函数的同时，让权值W也尽可能地小。我们可以将原优化问题看做为下面的问题，即让后面的规则则都小于某个阈值。这样从图中可以看出：L1范数相比L2范数更容易得到稀疏解。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc853ecc223e.png" alt="7.png"></p>
<p><img src="https://i.loli.net/2018/10/18/5bc853ed51aa1.png" alt="8.png"></p>
<h2 id="稀疏表示与字典学习"><strong>稀疏表示与字典学习</strong></h2>
<p>当样本数据是一个稀疏矩阵时，对学习任务来说会有不少的好处，例如很多问题变得线性可分，储存更为高效等。这便是稀疏表示与字典学习的基本出发点。稀疏矩阵即矩阵的每一行/列中都包含了大量的零元素，且这些零元素没有出现在同一行/列，对于一个给定的稠密矩阵，若我们能<strong>通过某种方法找到其合适的稀疏表示</strong>，则可以使得学习任务更加简单高效，我们称之为<strong>稀疏编码（sparse coding）<strong>或</strong>字典学习（dictionary learning）</strong>。</p>
<p>给定一个数据集，字典学习/稀疏编码指的便是通过一个字典将原数据转化为稀疏表示，因此最终的目标就是求得字典矩阵B及稀疏表示α，书中使用变量交替优化的策略能较好地求得解，深感陷进去短时间无法自拔，故先不进行深入…</p>
<p><img src="https://i.loli.net/2018/10/18/5bc853ed0ca43.png" alt="9.png"></p>
<h2 id="压缩感知"><strong>压缩感知</strong></h2>
<p>压缩感知在前些年也是风风火火，与特征选择、稀疏表示不同的是：它关注的是通过欠采样信息来恢复全部信息。在实际问题中，为了方便传输和存储，我们一般将数字信息进行压缩，这样就有可能损失部分信息，如何根据已有的信息来重构出全部信号，这便是压缩感知的来历，压缩感知的前提是已知的信息具有稀疏表示。下面是关于压缩感知的一些背景：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc853ed431c6.png" alt="10.png"></p>
<p>在此，特征选择与稀疏学习就介绍完毕。在很多实际情形中，选了好的特征比选了好的模型更为重要，这也是为什么厉害的大牛能够很快地得出一些结论的原因，谓：吾昨晚夜观天象，星象云是否吃货乃无用也~</p>
<blockquote>
<p>原文：<a href="https://github.com/Vay-keen/Machine-learning-learning-notes">https://github.com/Vay-keen/Machine-learning-learning-notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习笔记</category>
      </categories>
      <tags>
        <tag>特征选择与稀疏学习</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络</title>
    <url>/posts/7ca31f7.html</url>
    <content><![CDATA[<p>上篇主要讨论了决策树算法。首先从决策树的基本概念出发，引出决策树基于树形结构进行决策，进一步介绍了构造决策树的递归流程以及其递归终止条件，在递归的过程中，划分属性的选择起到了关键作用，因此紧接着讨论了三种评估属性划分效果的经典算法，介绍了剪枝策略来解决原生决策树容易产生的过拟合问题，最后简述了属性连续值/缺失值的处理方法。本篇将讨论现阶段十分热门的另一个经典监督学习算法–神经网络（neural network）。</p>
<h1><strong>神经网络</strong></h1>
<p>在机器学习中，神经网络一般指的是“神经网络学习”，是机器学习与神经网络两个学科的交叉部分。所谓神经网络，目前用得最广泛的一个定义是“神经网络是由具有适应性的简单单元组成的广泛并行互连的网络，它的组织能够模拟生物神经系统对真实世界物体所做出的交互反应”。</p>
<h2 id="神经元模型"><strong>神经元模型</strong></h2>
<p>神经网络中最基本的单元是神经元模型（neuron）。在生物神经网络的原始机制中，每个神经元通常都有多个树突（dendrite），一个轴突（axon）和一个细胞体（cell body），树突短而多分支，轴突长而只有一个；在功能上，树突用于传入其它神经元传递的神经冲动，而轴突用于将神经冲动传出到其它神经元，当树突或细胞体传入的神经冲动使得神经元兴奋时，该神经元就会通过轴突向其它神经元传递兴奋。神经元的生物学结构如下图所示，不得不说高中的生化知识大学忘得可是真干净…</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72cbb6cc11.png" alt="1.png"></p>
<p>一直沿用至今的“M-P神经元模型”正是对这一结构进行了抽象，也称“阈值逻辑单元“，其中树突对应于输入部分，每个神经元收到n个其他神经元传递过来的输入信号，这些信号通过带权重的连接传递给细胞体，这些权重又称为连接权（connection weight）。细胞体分为两部分，前一部分计算总输入值（即输入信号的加权和，或者说累积电平），后一部分先计算总输入值与该神经元阈值的差值，然后通过激活函数（activation function）的处理，产生输出从轴突传送给其它神经元。M-P神经元模型如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72cbb7be44.png" alt="2.png"></p>
<p>与线性分类十分相似，神经元模型最理想的激活函数也是阶跃函数，即将神经元输入值与阈值的差值映射为输出值1或0，若差值大于零输出1，对应兴奋；若差值小于零则输出0，对应抑制。但阶跃函数不连续，不光滑，故在M-P神经元模型中，也采用Sigmoid函数来近似， Sigmoid函数将较大范围内变化的输入值挤压到 (0,1) 输出值范围内，所以也称为挤压函数（squashing function）。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72cbb40dc5.png" alt="3.png"></p>
<p>将多个神经元按一定的层次结构连接起来，就得到了神经网络。它是一种包含多个参数的模型，比方说10个神经元两两连接，则有100个参数需要学习（每个神经元有9个连接权以及1个阈值），若将每个神经元都看作一个函数，则整个神经网络就是由这些函数相互嵌套而成。</p>
<h2 id="感知机与多层网络"><strong>感知机与多层网络</strong></h2>
<p>感知机（Perceptron）是由两层神经元组成的一个简单模型，但只有输出层是M-P神经元，即只有输出层神经元进行激活函数处理，也称为功能神经元（functional neuron）；输入层只是接受外界信号（样本属性）并传递给输出层（输入层的神经元个数等于样本的属性数目），而没有激活函数。这样一来，感知机与之前线性模型中的对数几率回归的思想基本是一样的，都是通过对属性加权与另一个常数求和，再使用sigmoid函数将这个输出值压缩到0-1之间，从而解决分类问题。不同的是感知机的输出层应该可以有多个神经元，从而可以实现多分类问题，同时两个模型所用的参数估计方法十分不同。</p>
<p>给定训练集，则感知机的n+1个参数（n个权重+1个阈值）都可以通过学习得到。阈值Θ可以看作一个输入值固定为-1的哑结点的权重ωn+1，即假设有一个固定输入xn+1=-1的输入层神经元，其对应的权重为ωn+1，这样就把权重和阈值统一为权重的学习了。简单感知机的结构如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72cbb3fdf0.png" alt="4.png"></p>
<p>感知机权重的学习规则如下：对于训练样本（x，y），当该样本进入感知机学习后，会产生一个输出值，若该输出值与样本的真实标记不一致，则感知机会对权重进行调整，若激活函数为阶跃函数，则调整的方法为（基于梯度下降法）：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72cbb3ba63.png" alt="5.png"></p>
<p>其中 η∈（0，1）称为学习率，可以看出感知机是通过逐个样本输入来更新权重，首先设定好初始权重（一般为随机），逐个地输入样本数据，若输出值与真实标记相同则继续输入下一个样本，若不一致则更新权重，然后再重新逐个检验，直到每个样本数据的输出值都与真实标记相同。容易看出：感知机模型总是能将训练数据的每一个样本都预测正确，和决策树模型总是能将所有训练数据都分开一样，感知机模型很容易产生过拟合问题。</p>
<p>由于感知机模型只有一层功能神经元，因此其功能十分有限，只能处理线性可分的问题，对于这类问题，感知机的学习过程一定会收敛（converge），因此总是可以求出适当的权值。但是对于像书上提到的异或问题，只通过一层功能神经元往往不能解决，因此要解决非线性可分问题，需要考虑使用多层功能神经元，即神经网络。多层神经网络的拓扑结构如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72cbb58ec6.png" alt="6.png"></p>
<p>在神经网络中，输入层与输出层之间的层称为隐含层或隐层（hidden layer），隐层和输出层的神经元都是具有激活函数的功能神经元。只需包含一个隐层便可以称为多层神经网络，常用的神经网络称为“多层前馈神经网络”（multi-layer feedforward neural network），该结构满足以下几个特点：</p>
<pre><code>* 每层神经元与下一层神经元之间完全互连
* 神经元之间不存在同层连接
* 神经元之间不存在跨层连接
</code></pre>
<p><img src="https://i.loli.net/2018/10/17/5bc72cbb47ff8.png" alt="7.png"></p>
<p>根据上面的特点可以得知：这里的“前馈”指的是网络拓扑结构中不存在环或回路，而不是指该网络只能向前传播而不能向后传播（下节中的BP神经网络正是基于前馈神经网络而增加了反馈调节机制）。神经网络的学习过程就是根据训练数据来调整神经元之间的“连接权”以及每个神经元的阈值，换句话说：神经网络所学习到的东西都蕴含在网络的连接权与阈值中。</p>
<h2 id="BP神经网络算法"><strong>BP神经网络算法</strong></h2>
<p>由上面可以得知：神经网络的学习主要蕴含在权重和阈值中，多层网络使用上面简单感知机的权重调整规则显然不够用了，BP神经网络算法即误差逆传播算法（error BackPropagation）正是为学习多层前馈神经网络而设计，BP神经网络算法是迄今为止最成功的的神经网络学习算法。</p>
<p>一般而言，只需包含一个足够多神经元的隐层，就能以任意精度逼近任意复杂度的连续函数[Hornik et al.,1989]，故下面以训练单隐层的前馈神经网络为例，介绍BP神经网络的算法思想。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72cbb92ff5.png" alt="8.png"></p>
<p>上图为一个单隐层前馈神经网络的拓扑结构，BP神经网络算法也使用梯度下降法（gradient descent），以单个样本的均方误差的负梯度方向对权重进行调节。可以看出：BP算法首先将误差反向传播给隐层神经元，调节隐层到输出层的连接权重与输出层神经元的阈值；接着根据隐含层神经元的均方误差，来调节输入层到隐含层的连接权值与隐含层神经元的阈值。BP算法基本的推导过程与感知机的推导过程原理是相同的，下面给出调整隐含层到输出层的权重调整规则的推导过程：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72cbb86229.png" alt="9.png"></p>
<p>学习率η∈（0，1）控制着沿反梯度方向下降的步长，若步长太大则下降太快容易产生震荡，若步长太小则收敛速度太慢，一般地常把η设置为0.1，有时更新权重时会将输出层与隐含层设置为不同的学习率。BP算法的基本流程如下所示：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72cbb59e99.png" alt="10.png"></p>
<p>BP算法的更新规则是基于每个样本的预测值与真实类标的均方误差来进行权值调节，即BP算法每次更新只针对于单个样例。需要注意的是：BP算法的最终目标是要最小化整个训练集D上的累积误差，即：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72ce222a96.png" alt="11.png"></p>
<p>如果基于累积误差最小化的更新规则，则得到了累积误差逆传播算法（accumulated error backpropagation），即每次读取全部的数据集一遍，进行一轮学习，从而基于当前的累积误差进行权值调整，因此参数更新的频率相比标准BP算法低了很多，但在很多任务中，尤其是在数据量很大的时候，往往标准BP算法会获得较好的结果。另外对于如何设置隐层神经元个数的问题，至今仍然没有好的解决方案，常使用“试错法”进行调整。</p>
<p>前面提到，BP神经网络强大的学习能力常常容易造成过拟合问题，有以下两种策略来缓解BP网络的过拟合问题：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>早停：将数据分为训练集与测试集，训练集用于学习，测试集用于评估性能，若在训练过程中，训练集的累积误差降低，而测试集的累积误差升高，则停止训练。</p>
</li>
<li class="lvl-2">
<p>引入正则化（regularization）：基本思想是在累积误差函数中增加一个用于描述网络复杂度的部分，例如所有权值与阈值的平方和，其中λ∈（0,1）用于对累积经验误差与网络复杂度这两项进行折中，常通过交叉验证法来估计。</p>
</li>
</ul>
<p><img src="https://i.loli.net/2018/10/17/5bc72ce227ff1.png" alt="12.png"></p>
<h2 id="全局最小与局部最小"><strong>全局最小与局部最小</strong></h2>
<p>模型学习的过程实质上就是一个寻找最优参数的过程，例如BP算法试图通过最速下降来寻找使得累积经验误差最小的权值与阈值，在谈到最优时，一般会提到局部极小（local minimum）和全局最小（global minimum）。</p>
<pre><code>* 局部极小解：参数空间中的某个点，其邻域点的误差函数值均不小于该点的误差函数值。
* 全局最小解：参数空间中的某个点，所有其他点的误差函数值均不小于该点的误差函数值。
</code></pre>
<p><img src="https://i.loli.net/2018/10/17/5bc72ce2803dc.png" alt="13.png"></p>
<p>要成为局部极小点，只要满足该点在参数空间中的梯度为零。局部极小可以有多个，而全局最小只有一个。全局最小一定是局部极小，但局部最小却不一定是全局最小。显然在很多机器学习算法中，都试图找到目标函数的全局最小。梯度下降法的主要思想就是沿着负梯度方向去搜索最优解，负梯度方向是函数值下降最快的方向，若迭代到某处的梯度为0，则表示达到一个局部最小，参数更新停止。因此在现实任务中，通常使用以下策略尽可能地去接近全局最小。</p>
<pre><code>* 以多组不同参数值初始化多个神经网络，按标准方法训练，迭代停止后，取其中误差最小的解作为最终参数。
* 使用“模拟退火”技术，这里不做具体介绍。
* 使用随机梯度下降，即在计算梯度时加入了随机因素，使得在局部最小时，计算的梯度仍可能不为0，从而迭代可以继续进行。
</code></pre>
<h2 id="深度学习"><strong>深度学习</strong></h2>
<p>理论上，参数越多，模型复杂度就越高，容量（capability）就越大，从而能完成更复杂的学习任务。深度学习（deep learning）正是一种极其复杂而强大的模型。</p>
<p>怎么增大模型复杂度呢？两个办法，一是增加隐层的数目，二是增加隐层神经元的数目。前者更有效一些，因为它不仅增加了功能神经元的数量，还增加了激活函数嵌套的层数。但是对于多隐层神经网络，经典算法如标准BP算法往往会在误差逆传播时发散（diverge），无法收敛达到稳定状态。</p>
<p>那要怎么有效地训练多隐层神经网络呢？一般来说有以下两种方法：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>无监督逐层训练（unsupervised layer-wise training）：每次训练一层隐节点，把上一层隐节点的输出当作输入来训练，本层隐结点训练好后，输出再作为下一层的输入来训练，这称为预训练（pre-training）。全部预训练完成后，再对整个网络进行微调（fine-tuning）训练。一个典型例子就是深度信念网络（deep belief network，简称DBN）。这种做法其实可以视为把大量的参数进行分组，先找出每组较好的设置，再基于这些局部最优的结果来训练全局最优。</p>
</li>
<li class="lvl-2">
<p>权共享（weight sharing）：令同一层神经元使用完全相同的连接权，典型的例子是卷积神经网络（Convolutional Neural Network，简称CNN）。这样做可以大大减少需要训练的参数数目。</p>
</li>
</ul>
<p><img src="https://i.loli.net/2018/10/17/5bc72ce28d756.png" alt="14.png"></p>
<p>深度学习可以理解为一种特征学习（feature learning）或者表示学习（representation learning），无论是DBN还是CNN，都是通过多个隐层来把与输出目标联系不大的初始输入转化为与输出目标更加密切的表示，使原来只通过单层映射难以完成的任务变为可能。即通过多层处理，逐渐将初始的“低层”特征表示转化为“高层”特征表示，从而使得最后可以用简单的模型来完成复杂的学习任务。</p>
<p>传统任务中，样本的特征需要人类专家来设计，这称为特征工程（feature engineering）。特征好坏对泛化性能有至关重要的影响。而深度学习为全自动数据分析带来了可能，可以自动产生更好的特征。</p>
<blockquote>
<p>原文：<a href="https://github.com/Vay-keen/Machine-learning-learning-notes">https://github.com/Vay-keen/Machine-learning-learning-notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习笔记</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>线性模型</title>
    <url>/posts/5206f73f.html</url>
    <content><![CDATA[<p>笔记的前一部分主要是对机器学习预备知识的概括，包括机器学习的定义/术语、学习器性能的评估/度量以及比较，本篇之后将主要对具体的学习算法进行理解总结，本篇则主要是第3章的内容–线性模型。</p>
<h1><strong>线性模型</strong></h1>
<p>谈及线性模型，其实我们很早就已经与它打过交道，还记得高中数学必修3课本中那个顽皮的“最小二乘法”吗？这就是线性模型的经典算法之一：根据给定的（x，y）点对，求出一条与这些点拟合效果最好的直线y=ax+b，之前我们利用下面的公式便可以计算出拟合直线的系数a,b（3.1中给出了具体的计算过程），从而对于一个新的x，可以预测它所对应的y值。前面我们提到：在机器学习的术语中，当预测值为连续值时，称为“回归问题”，离散值时为“分类问题”。本篇先从线性回归任务开始，接着讨论分类和多分类问题。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc722b068e48.png" alt="1.png"></p>
<h2 id="线性回归-2"><strong>线性回归</strong></h2>
<p>线性回归问题就是试图学到一个线性模型尽可能准确地预测新样本的输出值，例如：通过历年的人口数据预测2017年人口数量。在这类问题中，往往我们会先得到一系列的有标记数据，例如：2000–&gt;13亿…2016–&gt;15亿，这时输入的属性只有一个，即年份；也有输入多属性的情形，假设我们预测一个人的收入，这时输入的属性值就不止一个了，例如：（学历，年龄，性别，颜值，身高，体重）–&gt;15k。</p>
<p>有时这些输入的属性值并不能直接被我们的学习模型所用，需要进行相应的处理，对于连续值的属性，一般都可以被学习器所用，有时会根据具体的情形作相应的预处理，例如：归一化等；对于离散值的属性，可作下面的处理：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>若属性值之间存在“序关系”，则可以将其转化为连续值，例如：身高属性分为“高”“中等”“矮”，可转化为数值：{1， 0.5， 0}。</p>
</li>
<li class="lvl-2">
<p>若属性值之间不存在“序关系”，则通常将其转化为向量的形式，例如：性别属性分为“男”“女”，可转化为二维向量：{（1，0），（0，1）}。</p>
</li>
</ul>
<p>（1）当输入属性只有一个的时候，就是最简单的情形，也就是我们高中时最熟悉的“最小二乘法”（Euclidean distance），首先计算出每个样本预测值与真实值之间的误差并求和，通过最小化均方误差MSE，使用求偏导等于零的方法计算出拟合直线y=wx+b的两个参数w和b，计算过程如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc722b0ccec4.png" alt="2.png"></p>
<p>（2）当输入属性有多个的时候，例如对于一个样本有d个属性{（x1,x2…xd）,y}，则y=wx+b需要写成：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc72567b8bcd.png" alt="0.png"></p>
<p>通常对于多元问题，常常使用矩阵的形式来表示数据。在本问题中，将具有m个样本的数据集表示成矩阵X，将系数w与b合并成一个列向量，这样每个样本的预测值以及所有样本的均方误差最小化就可以写成下面的形式：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc722b0ad8f7.png" alt="3.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc722b0af652.png" alt="4.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc722b090543.png" alt="5.png"></p>
<p>同样地，我们使用最小二乘法对w和b进行估计，令均方误差的求导等于0，需要注意的是，当一个矩阵的行列式不等于0时，我们才可能对其求逆，因此对于下式，我们需要考虑矩阵（X的转置*X）的行列式是否为0，若不为0，则可以求出其解，若为0，则需要使用其它的方法进行计算，书中提到了引入正则化，此处不进行深入。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc722b0cde33.png" alt="6.png"></p>
<p>另一方面，有时像上面这种原始的线性回归可能并不能满足需求，例如：y值并不是线性变化，而是在指数尺度上变化。这时我们可以采用线性模型来逼近y的衍生物，例如lny，这时衍生的线性模型如下所示，实际上就是相当于将指数曲线投影在一条直线上，如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc722b103cbf.png" alt="7.png"></p>
<p>更一般地，考虑所有y的衍生物的情形，就得到了“广义的线性模型”（generalized linear model），其中，g（*）称为联系函数（link function）。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc722b0a2841.png" alt="8.png"></p>
<h2 id="线性几率回归"><strong>线性几率回归</strong></h2>
<p>回归就是通过输入的属性值得到一个预测值，利用上述广义线性模型的特征，是否可以通过一个联系函数，将预测值转化为离散值从而进行分类呢？线性几率回归正是研究这样的问题。对数几率引入了一个对数几率函数（logistic function）,将预测值投影到0-1之间，从而将线性回归问题转化为二分类问题。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc722b0c7748.png" alt="9.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc722b0a655d.png" alt="10.png"></p>
<p>若将y看做样本为正例的概率，（1-y）看做样本为反例的概率，则上式实际上使用线性回归模型的预测结果器逼近真实标记的对数几率。因此这个模型称为“对数几率回归”（logistic regression），也有一些书籍称之为“逻辑回归”。下面使用最大似然估计的方法来计算出w和b两个参数的取值，下面只列出求解的思路，不列出具体的计算过程。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc723b824f0c.png" alt="11.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc723b817961.png" alt="12.png"></p>
<h2 id="线性判别分析"><strong>线性判别分析</strong></h2>
<p>线性判别分析（Linear Discriminant Analysis，简称LDA）,其基本思想是：将训练样本投影到一条直线上，使得同类的样例尽可能近，不同类的样例尽可能远。如图所示：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc723b863ebb.png" alt="13.png"><img src="https://i.loli.net/2018/10/17/5bc723b85bfa9.png" alt="14.png"></p>
<p>想让同类样本点的投影点尽可能接近，不同类样本点投影之间尽可能远，即：让各类的协方差之和尽可能小，不用类之间中心的距离尽可能大。基于这样的考虑，LDA定义了两个散度矩阵。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>类内散度矩阵（within-class scatter matrix）</p>
</li>
</ul>
<p><img src="https://i.loli.net/2018/10/17/5bc723b8156e1.png" alt="15.png"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>类间散度矩阵(between-class scaltter matrix)</p>
</li>
</ul>
<p><img src="https://i.loli.net/2018/10/17/5bc723b7e9db3.png" alt="16.png"></p>
<p>因此得到了LDA的最大化目标：“广义瑞利商”（generalized Rayleigh quotient）。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc723b7e8a61.png" alt="17.png"></p>
<p>从而分类问题转化为最优化求解w的问题，当求解出w后，对新的样本进行分类时，只需将该样本点投影到这条直线上，根据与各个类别的中心值进行比较，从而判定出新样本与哪个类别距离最近。求解w的方法如下所示，使用的方法为λ乘子。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc723b83d5e0.png" alt="18.png"></p>
<p>若将w看做一个投影矩阵，类似PCA的思想，则LDA可将样本投影到N-1维空间（N为类簇数），投影的过程使用了类别信息（标记信息），因此LDA也常被视为一种经典的监督降维技术。<br>
​</p>
<h2 id="多分类学习"><strong>多分类学习</strong></h2>
<p>现实中我们经常遇到不只两个类别的分类问题，即多分类问题，在这种情形下，我们常常运用“拆分”的策略，通过多个二分类学习器来解决多分类问题，即将多分类问题拆解为多个二分类问题，训练出多个二分类学习器，最后将多个分类结果进行集成得出结论。最为经典的拆分策略有三种：“一对一”（OvO）、“一对其余”（OvR）和“多对多”（MvM），核心思想与示意图如下所示。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>OvO：给定数据集D，假定其中有N个真实类别，将这N个类别进行两两配对（一个正类/一个反类），从而产生N（N-1）/2个二分类学习器，在测试阶段，将新样本放入所有的二分类学习器中测试，得出N（N-1）个结果，最终通过投票产生最终的分类结果。</p>
</li>
<li class="lvl-2">
<p>OvM：给定数据集D，假定其中有N个真实类别，每次取出一个类作为正类，剩余的所有类别作为一个新的反类，从而产生N个二分类学习器，在测试阶段，得出N个结果，若仅有一个学习器预测为正类，则对应的类标作为最终分类结果。</p>
</li>
<li class="lvl-2">
<p>MvM：给定数据集D，假定其中有N个真实类别，每次取若干个类作为正类，若干个类作为反类（通过ECOC码给出，编码），若进行了M次划分，则生成了M个二分类学习器，在测试阶段（解码），得出M个结果组成一个新的码，最终通过计算海明/欧式距离选择距离最小的类别作为最终分类结果。</p>
</li>
</ul>
<p><img src="https://i.loli.net/2018/10/17/5bc723b862bfb.png" alt="19.png"></p>
<p><img src="https://i.loli.net/2018/10/17/5bc723b8300d5.png" alt="20.png"></p>
<h2 id="类别不平衡问题"><strong>类别不平衡问题</strong></h2>
<p>类别不平衡（class-imbanlance）就是指分类问题中不同类别的训练样本相差悬殊的情况，例如正例有900个，而反例只有100个，这个时候我们就需要进行相应的处理来平衡这个问题。常见的做法有三种：</p>
<ol>
<li class="lvl-4">
<p>在训练样本较多的类别中进行“欠采样”（undersampling）,比如从正例中采出100个，常见的算法有：EasyEnsemble。</p>
</li>
<li class="lvl-4">
<p>在训练样本较少的类别中进行“过采样”（oversampling）,例如通过对反例中的数据进行插值，来产生额外的反例，常见的算法有SMOTE。</p>
</li>
<li class="lvl-4">
<p>直接基于原数据集进行学习，对预测值进行“再缩放”处理。其中再缩放也是代价敏感学习的基础。<img src="https://i.loli.net/2018/10/17/5bc726fe87ae2.png" alt="21.png"></p>
</li>
</ol>
<blockquote>
<p>原文：<a href="https://github.com/Vay-keen/Machine-learning-learning-notes">https://github.com/Vay-keen/Machine-learning-learning-notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习笔记</category>
      </categories>
      <tags>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>绪论</title>
    <url>/posts/43830010.html</url>
    <content><![CDATA[<p>机器学习是目前信息技术中最激动人心的方向之一，其应用已经深入到生活的各个层面且与普通人的日常生活密切相关。本文为清华大学最新出版的《机器学习》教材的Learning Notes，书作者是南京大学周志华教授，多个大陆首位彰显其学术奢华。本篇主要介绍了该教材前两个章节的知识点以及自己一点浅陋的理解。</p>
<h2 id="绪论"><strong>绪论</strong></h2>
<p>傍晚小街路面上沁出微雨后的湿润，和熙的细风吹来，抬头看看天边的晚霞，嗯，明天又是一个好天气。走到水果摊旁，挑了个根蒂蜷缩、敲起来声音浊响的青绿西瓜，一边满心期待着皮薄肉厚瓢甜的爽落感，一边愉快地想着，这学期狠下了工夫，基础概念弄得清清楚楚，算法作业也是信手拈来，这门课成绩一定差不了！哈哈，也希望自己这学期的machine learning课程取得一个好成绩！</p>
<h3 id="机器学习的定义"><strong>机器学习的定义</strong></h3>
<p>正如我们根据过去的经验来判断明天的天气，吃货们希望从购买经验中挑选一个好瓜，那能不能让计算机帮助人类来实现这个呢？机器学习正是这样的一门学科，人的“经验”对应计算机中的“数据”，让计算机来学习这些经验数据，生成一个算法模型，在面对新的情况中，计算机便能作出有效的判断，这便是机器学习。</p>
<p>另一本经典教材的作者Mitchell给出了一个形式化的定义，假设：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>P：计算机程序在某任务类T上的性能。</p>
</li>
<li class="lvl-2">
<p>T：计算机程序希望实现的任务类。</p>
</li>
<li class="lvl-2">
<p>E：表示经验，即历史的数据集。</p>
</li>
</ul>
<p>若该计算机程序通过利用经验E在任务T上获得了性能P的改善，则称该程序对E进行了学习。</p>
<h3 id="机器学习的一些基本术语"><strong>机器学习的一些基本术语</strong></h3>
<p>假设我们收集了一批西瓜的数据，例如：（色泽=青绿;根蒂=蜷缩;敲声=浊响)， (色泽=乌黑;根蒂=稍蜷;敲声=沉闷)， (色泽=浅自;根蒂=硬挺;敲声=清脆)……每对括号内是一个西瓜的记录，定义：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>所有记录的集合为：数据集。</p>
</li>
<li class="lvl-2">
<p>每一条记录为：一个实例（instance）或样本（sample）。</p>
</li>
<li class="lvl-2">
<p>例如：色泽或敲声，单个的特点为特征（feature）或属性（attribute）。</p>
</li>
<li class="lvl-2">
<p>对于一条记录，如果在坐标轴上表示，每个西瓜都可以用坐标轴中的一个点表示，一个点也是一个向量，例如（青绿，蜷缩，浊响），即每个西瓜为：一个特征向量（feature vector）。</p>
</li>
<li class="lvl-2">
<p>一个样本的特征数为：维数（dimensionality），该西瓜的例子维数为3，当维数非常大时，也就是现在说的“维数灾难”。</p>
</li>
</ul>
<p>计算机程序学习经验数据生成算法模型的过程中，每一条记录称为一个“训练样本”，同时在训练好模型后，我们希望使用新的样本来测试模型的效果，则每一个新的样本称为一个“测试样本”。定义：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>所有训练样本的集合为：训练集（trainning set），[特殊]。</p>
</li>
<li class="lvl-2">
<p>所有测试样本的集合为：测试集（test set），[一般]。</p>
</li>
<li class="lvl-2">
<p>机器学习出来的模型适用于新样本的能力为：泛化能力（generalization），即从特殊到一般。</p>
</li>
</ul>
<p>西瓜的例子中，我们是想计算机通过学习西瓜的特征数据，训练出一个决策模型，来判断一个新的西瓜是否是好瓜。可以得知我们预测的是：西瓜是好是坏，即好瓜与差瓜两种，是离散值。同样地，也有通过历年的人口数据，来预测未来的人口数量，人口数量则是连续值。定义：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>预测值为离散值的问题为：分类（classification）。</p>
</li>
<li class="lvl-2">
<p>预测值为连续值的问题为：回归（regression）。</p>
</li>
</ul>
<p>我们预测西瓜是否是好瓜的过程中，很明显对于训练集中的西瓜，我们事先已经知道了该瓜是否是好瓜，学习器通过学习这些好瓜或差瓜的特征，从而总结出规律，即训练集中的西瓜我们都做了标记，称为标记信息。但也有没有标记信息的情形，例如：我们想将一堆西瓜根据特征分成两个小堆，使得某一堆的西瓜尽可能相似，即都是好瓜或差瓜，对于这种问题，我们事先并不知道西瓜的好坏，样本没有标记信息。定义：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>训练数据有标记信息的学习任务为：监督学习（supervised learning），容易知道上面所描述的分类和回归都是监督学习的范畴。</p>
</li>
<li class="lvl-2">
<p>训练数据没有标记信息的学习任务为：无监督学习（unsupervised learning），常见的有聚类和关联规则。</p>
</li>
</ul>
<h2 id="模型的评估与选择"><strong>模型的评估与选择</strong></h2>
<h3 id="误差与过拟合"><strong>误差与过拟合</strong></h3>
<p>我们将学习器对样本的实际预测结果与样本的真实值之间的差异成为：误差（error）。定义：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在训练集上的误差称为训练误差（training error）或经验误差（empirical error）。</p>
</li>
<li class="lvl-2">
<p>在测试集上的误差称为测试误差（test error）。</p>
</li>
<li class="lvl-2">
<p>学习器在所有新样本上的误差称为泛化误差（generalization error）。</p>
</li>
</ul>
<p>显然，我们希望得到的是在新样本上表现得很好的学习器，即泛化误差小的学习器。因此，我们应该让学习器尽可能地从训练集中学出普适性的“一般特征”，这样在遇到新样本时才能做出正确的判别。然而，当学习器把训练集学得“太好”的时候，即把一些训练样本的自身特点当做了普遍特征；同时也有学习能力不足的情况，即训练集的基本特征都没有学习出来。我们定义：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>学习能力过强，以至于把训练样本所包含的不太一般的特性都学到了，称为：过拟合（overfitting）。</p>
</li>
<li class="lvl-2">
<p>学习能太差，训练样本的一般性质尚未学好，称为：欠拟合（underfitting）。</p>
</li>
</ul>
<p>可以得知：在过拟合问题中，训练误差十分小，但测试误差教大；在欠拟合问题中，训练误差和测试误差都比较大。目前，欠拟合问题比较容易克服，例如增加迭代次数等，但过拟合问题还没有十分好的解决方案，过拟合是机器学习面临的关键障碍。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc7181172996.png" alt=""></p>
<h3 id="评估方法"><strong>评估方法</strong></h3>
<p>在现实任务中，我们往往有多种算法可供选择，那么我们应该选择哪一个算法才是最适合的呢？如上所述，我们希望得到的是泛化误差小的学习器，理想的解决方案是对模型的泛化误差进行评估，然后选择泛化误差最小的那个学习器。但是，泛化误差指的是模型在所有新样本上的适用能力，我们无法直接获得泛化误差。</p>
<p>因此，通常我们采用一个“测试集”来测试学习器对新样本的判别能力，然后以“测试集”上的“测试误差”作为“泛化误差”的近似。显然：我们选取的测试集应尽可能与训练集互斥，下面用一个小故事来解释why：</p>
<p>假设老师出了10 道习题供同学们练习，考试时老师又用同样的这10道题作为试题，可能有的童鞋只会做这10 道题却能得高分，很明显：这个考试成绩并不能有效地反映出真实水平。回到我们的问题上来，我们希望得到泛化性能好的模型，好比希望同学们课程学得好并获得了对所学知识&quot;举一反三&quot;的能力；训练样本相当于给同学们练习的习题，测试过程则相当于考试。显然，若测试样本被用作训练了，则得到的将是过于&quot;乐观&quot;的估计结果。</p>
<h3 id="训练集与测试集的划分方法"><strong>训练集与测试集的划分方法</strong></h3>
<p>如上所述：我们希望用一个“测试集”的“测试误差”来作为“泛化误差”的近似，因此我们需要对初始数据集进行有效划分，划分出互斥的“训练集”和“测试集”。下面介绍几种常用的划分方法：</p>
<h4 id="留出法"><strong>留出法</strong></h4>
<p>将数据集D划分为两个互斥的集合，一个作为训练集S，一个作为测试集T，满足D=S∪T且S∩T=∅，常见的划分为：大约2/3-4/5的样本用作训练，剩下的用作测试。需要注意的是：训练/测试集的划分要尽可能保持数据分布的一致性，以避免由于分布的差异引入额外的偏差，常见的做法是采取分层抽样。同时，由于划分的随机性，单次的留出法结果往往不够稳定，一般要采用若干次随机划分，重复实验取平均值的做法。</p>
<h4 id="交叉验证法"><strong>交叉验证法</strong></h4>
<p>将数据集D划分为k个大小相同的互斥子集，满足D=D1∪D2∪…∪Dk，Di∩Dj=∅（i≠j），同样地尽可能保持数据分布的一致性，即采用分层抽样的方法获得这些子集。交叉验证法的思想是：每次用k-1个子集的并集作为训练集，余下的那个子集作为测试集，这样就有K种训练集/测试集划分的情况，从而可进行k次训练和测试，最终返回k次测试结果的均值。交叉验证法也称“k折交叉验证”，k最常用的取值是10，下图给出了10折交叉验证的示意图。</p>
<p><img src="https://i.loli.net/2018/10/17/5bc718115d224.png" alt=""></p>
<p>与留出法类似，将数据集D划分为K个子集的过程具有随机性，因此K折交叉验证通常也要重复p次，称为p次k折交叉验证，常见的是10次10折交叉验证，即进行了100次训练/测试。特殊地当划分的k个子集的每个子集中只有一个样本时，称为“留一法”，显然，留一法的评估结果比较准确，但对计算机的消耗也是巨大的。</p>
<h4 id="自助法"><strong>自助法</strong></h4>
<p>我们希望评估的是用整个D训练出的模型。但在留出法和交叉验证法中，由于保留了一部分样本用于测试，因此实际评估的模型所使用的训练集比D小，这必然会引入一些因训练样本规模不同而导致的估计偏差。留一法受训练样本规模变化的影响较小，但计算复杂度又太高了。“自助法”正是解决了这样的问题。</p>
<p>自助法的基本思想是：给定包含m个样本的数据集D，每次随机从D 中挑选一个样本，将其拷贝放入D’，然后再将该样本放回初始数据集D 中，使得该样本在下次采样时仍有可能被采到。重复执行m 次，就可以得到了包含m个样本的数据集D’。可以得知在m次采样中，样本始终不被采到的概率取极限为：</p>
<p><img src="https://i.loli.net/2018/10/17/5bc71811246dd.png" alt=""></p>
<p>这样，通过自助采样，初始样本集D中大约有36.8%的样本没有出现在D’中，于是可以将D’作为训练集，D-D’作为测试集。自助法在数据集较小，难以有效划分训练集/测试集时很有用，但由于自助法产生的数据集（随机抽样）改变了初始数据集的分布，因此引入了估计偏差。在初始数据集足够时，留出法和交叉验证法更加常用。</p>
<h3 id="调参"><strong>调参</strong></h3>
<p>大多数学习算法都有些参数(parameter) 需要设定，参数配置不同，学得模型的性能往往有显著差别，这就是通常所说的&quot;参数调节&quot;或简称&quot;调参&quot; (parameter tuning)。</p>
<p>学习算法的很多参数是在实数范围内取值，因此，对每种参数取值都训练出模型来是不可行的。常用的做法是：对每个参数选定一个范围和步长λ，这样使得学习的过程变得可行。例如：假定算法有3 个参数，每个参数仅考虑5 个候选值，这样对每一组训练/测试集就有5<em>5</em>5= 125 个模型需考察，由此可见：拿下一个参数（即经验值）对于算法人员来说是有多么的happy。</p>
<p>最后需要注意的是：当选定好模型和调参完成后，我们需要使用初始的数据集D重新训练模型，即让最初划分出来用于评估的测试集也被模型学习，增强模型的学习效果。用上面考试的例子来比喻：就像高中时大家每次考试完，要将考卷的题目消化掉（大多数题目都还是之前没有见过的吧？），这样即使考差了也能开心的玩耍了~。</p>
<blockquote>
<p>原文：<a href="https://github.com/Vay-keen/Machine-learning-learning-notes">https://github.com/Vay-keen/Machine-learning-learning-notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习笔记</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>聚类算法</title>
    <url>/posts/35f08535.html</url>
    <content><![CDATA[<p>上篇主要介绍了一种机器学习的通用框架–集成学习方法，首先从准确性和差异性两个重要概念引出集成学习“<strong>好而不同</strong>”的四字真言，接着介绍了现阶段主流的三种集成学习方法：AdaBoost、Bagging及Random Forest，AdaBoost采用最小化指数损失函数迭代式更新样本分布权重和计算基学习器权重，Bagging通过自助采样引入样本扰动增加了基学习器之间的差异性，随机森林则进一步引入了属性扰动，最后简单概述了集成模型中的三类结合策略：平均法、投票法及学习法，其中Stacking是学习法的典型代表。本篇将讨论无监督学习中应用最为广泛的学习算法–聚类。</p>
<h1><strong>聚类算法</strong></h1>
<p>聚类是一种经典的<strong>无监督学习</strong>方法，<strong>无监督学习的目标是通过对无标记训练样本的学习，发掘和揭示数据集本身潜在的结构与规律</strong>，即不依赖于训练数据集的类标记信息。聚类则是试图将数据集的样本划分为若干个互不相交的类簇，从而每个簇对应一个潜在的类别。</p>
<p>聚类直观上来说是将相似的样本聚在一起，从而形成一个<strong>类簇（cluster）</strong>。那首先的问题是如何来<strong>度量相似性</strong>（similarity measure）呢？这便是<strong>距离度量</strong>，在生活中我们说差别小则相似，对应到多维样本，每个样本可以对应于高维空间中的一个数据点，若它们的距离相近，我们便可以称它们相似。那接着如何来评价聚类结果的好坏呢？这便是<strong>性能度量</strong>，性能度量为评价聚类结果的好坏提供了一系列有效性指标。</p>
<h2 id="距离度量"><strong>距离度量</strong></h2>
<p>谈及距离度量，最熟悉的莫过于欧式距离了，从年头一直用到年尾的距离计算公式：即对应属性之间相减的平方和再开根号。度量距离还有其它的很多经典方法，通常它们需要满足一些基本性质：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84ed4c0390.png" alt="1.png"></p>
<p>最常用的距离度量方法是**“闵可夫斯基距离”（Minkowski distance)**：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84ed49e31f.png" alt="2.png"></p>
<p>当p=1时，闵可夫斯基距离即<strong>曼哈顿距离（Manhattan distance）</strong>：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84ed49c31f.png" alt="3.png"></p>
<p>当p=2时，闵可夫斯基距离即<strong>欧氏距离（Euclidean distance）</strong>：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84ed497613.png" alt="4.png"></p>
<p>我们知道属性分为两种：<strong>连续属性</strong>和<strong>离散属性</strong>（有限个取值）。对于连续值的属性，一般都可以被学习器所用，有时会根据具体的情形作相应的预处理，例如：归一化等；而对于离散值的属性，需要作下面进一步的处理：</p>
<blockquote>
<p>若属性值之间<strong>存在序关系</strong>，则可以将其转化为连续值，例如：身高属性“高”“中等”“矮”，可转化为{1, 0.5, 0}。若属性值之间<strong>不存在序关系</strong>，则通常将其转化为向量的形式，例如：性别属性“男”“女”，可转化为{（1,0），（0,1）}。</p>
</blockquote>
<p>在进行距离度量时，易知<strong>连续属性和存在序关系的离散属性都可以直接参与计算</strong>，因为它们都可以反映一种程度，我们称其为“<strong>有序属性</strong>”；而对于不存在序关系的离散属性，我们称其为：“<strong>无序属性</strong>”，显然无序属性再使用闵可夫斯基距离就行不通了。</p>
<p><strong>对于无序属性，我们一般采用VDM进行距离的计算</strong>，例如：对于离散属性的两个取值a和b，定义：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84ed4e9560.png" alt="5.png"></p>
<p>于是，在计算两个样本之间的距离时，我们可以将闵可夫斯基距离和VDM混合在一起进行计算：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84ed507bc7.png" alt="6.png"></p>
<p>若我们定义的距离计算方法是用来度量相似性，例如下面将要讨论的聚类问题，即距离越小，相似性越大，反之距离越大，相似性越小。这时距离的度量方法并不一定需要满足前面所说的四个基本性质，这样的方法称为：<strong>非度量距离（non-metric distance）</strong>。</p>
<h2 id="性能度量"><strong>性能度量</strong></h2>
<p>由于聚类算法不依赖于样本的真实类标，就不能像监督学习的分类那般，通过计算分对分错（即精确度或错误率）来评价学习器的好坏或作为学习过程中的优化目标。一般聚类有两类性能度量指标：<strong>外部指标</strong>和<strong>内部指标</strong>。</p>
<h3 id="外部指标"><strong>外部指标</strong></h3>
<p>即将聚类结果与某个参考模型的结果进行比较，<strong>以参考模型的输出作为标准，来评价聚类好坏</strong>。假设聚类给出的结果为λ，参考模型给出的结果是λ*，则我们将样本进行两两配对，定义：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84ed59160e.png" alt="7.png"></p>
<p>显然a和b代表着聚类结果好坏的正能量，b和c则表示参考结果和聚类结果相矛盾，基于这四个值可以导出以下常用的外部评价指标：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84ed587438.png" alt="8.png"></p>
<h3 id="内部指标"><strong>内部指标</strong></h3>
<p>内部指标即不依赖任何外部模型，直接对聚类的结果进行评估，聚类的目的是想将那些相似的样本尽可能聚在一起，不相似的样本尽可能分开，直观来说：<strong>簇内高内聚紧紧抱团，簇间低耦合老死不相往来</strong>。定义：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84ed581852.png" alt="9.png"></p>
<p>基于上面的四个距离，可以导出下面这些常用的内部评价指标：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84ed582854.png" alt="10.png"></p>
<h2 id="原型聚类"><strong>原型聚类</strong></h2>
<p>原型聚类即“<strong>基于原型的聚类</strong>”（prototype-based clustering），原型表示模板的意思，就是通过参考一个模板向量或模板分布的方式来完成聚类的过程，常见的K-Means便是基于簇中心来实现聚类，混合高斯聚类则是基于簇分布来实现聚类。</p>
<h3 id="K-Means"><strong>K-Means</strong></h3>
<p>K-Means的思想十分简单，<strong>首先随机指定类中心，根据样本与类中心的远近划分类簇，接着重新计算类中心，迭代直至收敛</strong>。但是其中迭代的过程并不是主观地想象得出，事实上，若将样本的类别看做为“隐变量”（latent variable），类中心看作样本的分布参数，这一过程正是通过<strong>EM算法</strong>的两步走策略而计算出，其根本的目的是为了最小化平方误差函数E：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84fb82b5d3.png" alt="11.png"></p>
<p>K-Means的算法流程如下所示：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84fb9c0817.png" alt="12.png"></p>
<h3 id="学习向量量化（LVQ）"><strong>学习向量量化（LVQ）</strong></h3>
<p>LVQ也是基于原型的聚类算法，与K-Means不同的是，<strong>LVQ使用样本真实类标记辅助聚类</strong>，首先LVQ根据样本的类标记，从各类中分别随机选出一个样本作为该类簇的原型，从而组成了一个<strong>原型特征向量组</strong>，接着从样本集中随机挑选一个样本，计算其与原型向量组中每个向量的距离，并选取距离最小的原型向量所在的类簇作为它的划分结果，再与真实类标比较。</p>
<blockquote>
<p><strong>若划分结果正确，则对应原型向量向这个样本靠近一些</strong><br>
<strong>若划分结果不正确，则对应原型向量向这个样本远离一些</strong></p>
</blockquote>
<p>LVQ算法的流程如下所示：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84fb9d59f2.png" alt="13.png"></p>
<h3 id="高斯混合聚类"><strong>高斯混合聚类</strong></h3>
<p>现在可以看出K-Means与LVQ都试图以类中心作为原型指导聚类，高斯混合聚类则采用高斯分布来描述原型。现假设<strong>每个类簇中的样本都服从一个多维高斯分布，那么空间中的样本可以看作由k个多维高斯分布混合而成</strong>。</p>
<p>对于多维高斯分布，其概率密度函数如下所示：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84fb870d98.png" alt="14.png"></p>
<p>其中u表示均值向量，∑表示协方差矩阵，可以看出一个多维高斯分布完全由这两个参数所确定。接着定义高斯混合分布为：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84fb876794.png" alt="15.png"></p>
<p>α称为混合系数，这样空间中样本的采集过程则可以抽象为：<strong>（1）先选择一个类簇（高斯分布），（2）再根据对应高斯分布的密度函数进行采样</strong>，这时候贝叶斯公式又能大展身手了：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84fb9191d9.png" alt="16.png"></p>
<p>此时只需要选择PM最大时的类簇并将该样本划分到其中，看到这里很容易发现：这和那个传说中的贝叶斯分类不是神似吗，都是通过贝叶斯公式展开，然后计算类先验概率和类条件概率。但遗憾的是：<strong>这里没有真实类标信息，对于类条件概率，并不能像贝叶斯分类那样通过最大似然法美好地计算出来</strong>，因为这里的样本可能属于所有的类簇，这里的似然函数变为：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84fb871d4a.png" alt="17.png"></p>
<p>可以看出：简单的最大似然法根本无法求出所有的参数，这样PM也就没法计算。<strong>这里就要召唤出之前的EM大法，首先对高斯分布的参数及混合系数进行随机初始化，计算出各个PM（即γji，第i个样本属于j类），再最大化似然函数（即LL（D）分别对α、u和∑求偏导 ），对参数进行迭代更新</strong>。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84fb8a6f32.png" alt="18.png"></p>
<p>高斯混合聚类的算法流程如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84fb9c4fa4.png" alt="19.png"></p>
<h2 id="密度聚类"><strong>密度聚类</strong></h2>
<p>密度聚类则是基于密度的聚类，它从样本分布的角度来考察样本之间的可连接性，并基于可连接性（密度可达）不断拓展疆域（类簇）。其中最著名的便是<strong>DBSCAN</strong>算法，首先定义以下概念：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84fb9bd69c.png" alt="20.png"></p>
<p><img src="https://i.loli.net/2018/10/18/5bc8509f8d619.png" alt="21.png"></p>
<p>简单来理解DBSCAN便是：<strong>找出一个核心对象所有密度可达的样本集合形成簇</strong>。首先从数据集中任选一个核心对象A，找出所有A密度可达的样本集合，将这些样本形成一个密度相连的类簇，直到所有的核心对象都遍历完。DBSCAN算法的流程如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc8509feb587.png" alt="22.png"></p>
<h2 id="层次聚类"><strong>层次聚类</strong></h2>
<p>层次聚类是一种基于树形结构的聚类方法，常用的是<strong>自底向上</strong>的结合策略（<strong>AGNES算法</strong>）。假设有N个待聚类的样本，其基本步骤是：</p>
<blockquote>
<p>1.初始化–&gt;把每个样本归为一类，计算每两个类之间的距离，也就是样本与样本之间的相似度；<br>
2.寻找各个类之间最近的两个类，把他们归为一类（这样类的总数就少了一个）；<br>
3.重新计算新生成的这个<strong>类与各个旧类之间的相似度</strong>；<br>
4.重复2和3直到所有样本点都归为一类，结束。</p>
</blockquote>
<p>可以看出其中最关键的一步就是<strong>计算两个类簇的相似度</strong>，这里有多种度量方法：</p>
<pre><code>* 单链接（single-linkage）:取类间最小距离。
</code></pre>
<p><img src="https://i.loli.net/2018/10/18/5bc8509ebb022.png" alt="23.png"></p>
<pre><code>* 全链接（complete-linkage）:取类间最大距离
</code></pre>
<p><img src="https://i.loli.net/2018/10/18/5bc8509eb2b30.png" alt="24.png"></p>
<pre><code>* 均链接（average-linkage）:取类间两两的平均距离
</code></pre>
<p><img src="https://i.loli.net/2018/10/18/5bc8509f089a7.png" alt="25.png"></p>
<p>很容易看出：<strong>单链接的包容性极强，稍微有点暧昧就当做是自己人了，全链接则是坚持到底，只要存在缺点就坚决不合并，均连接则是从全局出发顾全大局</strong>。层次聚类法的算法流程如下所示：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc8509f9d4a0.png" alt="26.png"></p>
<blockquote>
<p>在此聚类算法就介绍完毕，分类/聚类都是机器学习中最常见的任务，我实验室的大Boss也是靠着聚类起家，从此走上人生事业钱途…之巅峰，在书最后的阅读材料还看见Boss的名字，所以这章也是必读不可了…</p>
</blockquote>
<blockquote>
<p>原文：<a href="https://github.com/Vay-keen/Machine-learning-learning-notes">https://github.com/Vay-keen/Machine-learning-learning-notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习笔记</category>
      </categories>
      <tags>
        <tag>聚类算法</tag>
      </tags>
  </entry>
  <entry>
    <title>计算学习理论</title>
    <url>/posts/7b842c65.html</url>
    <content><![CDATA[<p>上篇主要介绍了常用的特征选择方法及稀疏学习。首先从相关/无关特征出发引出了特征选择的基本概念，接着分别介绍了子集搜索与评价、过滤式、包裹式以及嵌入式四种类型的特征选择方法。子集搜索与评价使用的是一种优中生优的贪婪算法，即每次从候选特征子集中选出最优子集；过滤式方法计算一个相关统计量来评判特征的重要程度；包裹式方法将学习器作为特征选择的评价准则；嵌入式方法则是通过L1正则项将特征选择融入到学习器参数优化的过程中。最后介绍了稀疏表示与压缩感知的核心思想：稀疏表示利用稀疏矩阵的优良性质，试图通过某种方法找到原始稠密矩阵的合适稀疏表示；压缩感知则试图利用可稀疏表示的欠采样信息来恢复全部信息。本篇将讨论一种为机器学习提供理论保证的学习方法–计算学习理论。</p>
<h1><strong>计算学习理论</strong></h1>
<p>计算学习理论（computational learning theory）是通过“计算”来研究机器学习的理论，简而言之，其目的是分析学习任务的本质，例如：<strong>在什么条件下可进行有效的学习，需要多少训练样本能获得较好的精度等，从而为机器学习算法提供理论保证</strong>。</p>
<p>首先我们回归初心，再来谈谈经验误差和泛化误差。假设给定训练集D，其中所有的训练样本都服从一个未知的分布T，且它们都是在总体分布T中独立采样得到，即<strong>独立同分布</strong>（independent and identically distributed，i.i.d.），在《贝叶斯分类器》中我们已经提到：独立同分布是很多统计学习算法的基础假设，例如最大似然法，贝叶斯分类器，高斯混合聚类等，简单来理解独立同分布：每个样本都是从总体分布中独立采样得到，而没有拖泥带水。例如现在要进行问卷调查，要从总体人群中随机采样，看到一个美女你高兴地走过去，结果她男票突然冒了出来，说道：you jump，i jump，于是你本来只想调查一个人结果被强行撒了一把狗粮得到两份问卷，这样这两份问卷就不能称为独立同分布了，因为它们的出现具有强相关性。</p>
<p>回归正题，<strong>泛化误差指的是学习器在总体上的预测误差，经验误差则是学习器在某个特定数据集D上的预测误差</strong>。在实际问题中，往往我们并不能得到总体且数据集D是通过独立同分布采样得到的，因此我们常常使用经验误差作为泛化误差的近似。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc854f38d4fe.png" alt="1.png"></p>
<h2 id="PAC学习"><strong>PAC学习</strong></h2>
<p>在高中课本中，我们将<strong>函数定义为：从自变量到因变量的一种映射；对于机器学习算法，学习器也正是为了寻找合适的映射规则</strong>，即如何从条件属性得到目标属性。从样本空间到标记空间存在着很多的映射，我们将每个映射称之为<strong>概念</strong>（concept），定义：</p>
<blockquote>
<p>若概念c对任何样本x满足c(x)=y，则称c为<strong>目标概念</strong>，即最理想的映射，所有的目标概念构成的集合称为**“概念类”<strong>；给定学习算法，它所有可能映射/概念的集合称为</strong>“假设空间”<strong>，其中单个的概念称为</strong>“假设”<strong>（hypothesis）；若一个算法的假设空间包含目标概念，则称该数据集对该算法是</strong>可分**（separable）的，亦称<strong>一致</strong>（consistent）的；若一个算法的假设空间不包含目标概念，则称该数据集对该算法是<strong>不可分</strong>（non-separable）的，或称<strong>不一致</strong>（non-consistent）的。</p>
</blockquote>
<p>举个简单的例子：对于非线性分布的数据集，若使用一个线性分类器，则该线性分类器对应的假设空间就是空间中所有可能的超平面，显然假设空间不包含该数据集的目标概念，所以称数据集对该学习器是不可分的。给定一个数据集D，我们希望模型学得的假设h尽可能地与目标概念一致，这便是<strong>概率近似正确</strong> (Probably Approximately Correct，简称PAC)的来源，即以较大的概率学得模型满足误差的预设上限。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc854f446f97.png" alt="2.png"></p>
<p><img src="https://i.loli.net/2018/10/18/5bc854f482d0b.png" alt="3.png"></p>
<p><img src="https://i.loli.net/2018/10/18/5bc854f47d006.png" alt="4.png"></p>
<p><img src="https://i.loli.net/2018/10/18/5bc854f46ad91.png" alt="5.png"></p>
<p>上述关于PAC的几个定义层层相扣：定义12.1表达的是对于某种学习算法，如果能以一个置信度学得假设满足泛化误差的预设上限，则称该算法能PAC辨识概念类，即该算法的输出假设已经十分地逼近目标概念。定义12.2则将样本数量考虑进来，当样本超过一定数量时，学习算法总是能PAC辨识概念类，则称概念类为PAC可学习的。定义12.3将学习器运行时间也考虑进来，若运行时间为多项式时间，则称PAC学习算法。</p>
<p>显然，PAC学习中的一个关键因素就是<strong>假设空间的复杂度</strong>，对于某个学习算法，<strong>若假设空间越大，则其中包含目标概念的可能性也越大，但同时找到某个具体概念的难度也越大</strong>，一般假设空间分为有限假设空间与无限假设空间。</p>
<h2 id="有限假设空间"><strong>有限假设空间</strong></h2>
<h3 id="可分情形"><strong>可分情形</strong></h3>
<p>可分或一致的情形指的是：<strong>目标概念包含在算法的假设空间中</strong>。对于目标概念，在训练集D中的经验误差一定为0，因此首先我们可以想到的是：不断地剔除那些出现预测错误的假设，直到找到经验误差为0的假设即为目标概念。但<strong>由于样本集有限，可能会出现多个假设在D上的经验误差都为0，因此问题转化为：需要多大规模的数据集D才能让学习算法以置信度的概率从这些经验误差都为0的假设中找到目标概念的有效近似</strong>。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc854f484f30.png" alt="6.png"></p>
<p>通过上式可以得知：<strong>对于可分情形的有限假设空间，目标概念都是PAC可学习的，即当样本数量满足上述条件之后，在与训练集一致的假设中总是可以在1-σ概率下找到目标概念的有效近似。</strong></p>
<h3 id="不可分情形"><strong>不可分情形</strong></h3>
<p>不可分或不一致的情形指的是：<strong>目标概念不存在于假设空间中</strong>，这时我们就不能像可分情形时那样从假设空间中寻找目标概念的近似。但<strong>当假设空间给定时，必然存一个假设的泛化误差最小，若能找出此假设的有效近似也不失为一个好的目标，这便是不可知学习(agnostic learning)的来源。</strong></p>
<p><img src="https://i.loli.net/2018/10/18/5bc854f485f2e.png" alt="7.png"></p>
<p>这时候便要用到<strong>Hoeffding不等式</strong>：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc854f46970a.png" alt="8.png"></p>
<p>对于假设空间中的所有假设，出现泛化误差与经验误差之差大于e的概率和为：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc854f4114fd.png" alt="9.png"></p>
<p>因此，可令不等式的右边小于（等于）σ，便可以求出满足泛化误差与经验误差相差小于e所需的最少样本数，同时也可以求出泛化误差界。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc854f440a02.png" alt="10.png"></p>
<h2 id="VC维"><strong>VC维</strong></h2>
<p>现实中的学习任务通常都是无限假设空间，例如d维实数域空间中所有的超平面等，因此要对此种情形进行可学习研究，需要度量<strong>假设空间的复杂度</strong>。这便是<strong>VC维</strong>（Vapnik-Chervonenkis dimension）的来源。在介绍VC维之前，需要引入两个概念：</p>
<blockquote>
<p><strong>增长函数</strong>：对于给定数据集D，假设空间中的每个假设都能对数据集的样本赋予标记，因此一个假设对应着一种打标结果，不同假设对D的打标结果可能是相同的，也可能是不同的。随着样本数量m的增大，假设空间对样本集D的打标结果也会增多，增长函数则表示假设空间对m个样本的数据集D打标的最大可能结果数，因此<strong>增长函数描述了假设空间的表示能力与复杂度。</strong></p>
<p><img src="https://i.loli.net/2018/10/18/5bc855ba970cd.png" alt="11.png"></p>
</blockquote>
<blockquote>
<p><strong>打散</strong>：例如对二分类问题来说，m个样本最多有2^m个可能结果，每种可能结果称为一种**“对分”**，若假设空间能实现数据集D的所有对分，则称数据集能被该假设空间打散。</p>
</blockquote>
<p><strong>因此尽管假设空间是无限的，但它对特定数据集打标的不同结果数是有限的，假设空间的VC维正是它能打散的最大数据集大小</strong>。通常这样来计算假设空间的VC维：若存在大小为d的数据集能被假设空间打散，但不存在任何大小为d+1的数据集能被假设空间打散，则其VC维为d。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc855bb20c1e.png" alt="12.png"></p>
<p>同时书中给出了假设空间VC维与增长函数的两个关系：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc855ba83eb8.png" alt="13.png"></p>
<p>直观来理解（1）式也十分容易： 首先假设空间的VC维是d，说明当m&lt;=d时，增长函数与2<sup>m相等，例如：当m=d时，右边的组合数求和刚好等于2</sup>d；而当m=d+1时，右边等于2^(d+1)-1，十分符合VC维的定义，同时也可以使用数学归纳法证明；（2）式则是由（1）式直接推导得出。</p>
<p>在有限假设空间中，根据Hoeffding不等式便可以推导得出学习算法的泛化误差界；但在无限假设空间中，由于假设空间的大小无法计算，只能通过增长函数来描述其复杂度，因此无限假设空间中的泛化误差界需要引入增长函数。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc855babc890.png" alt="14.png"></p>
<p><img src="https://i.loli.net/2018/10/18/5bc855ba5b2c3.png" alt="15.png"></p>
<p>上式给出了基于VC维的泛化误差界，同时也可以计算出满足条件需要的样本数（样本复杂度）。若学习算法满足<strong>经验风险最小化原则（ERM）</strong>，即学习算法的输出假设h在数据集D上的经验误差最小，可证明：<strong>任何VC维有限的假设空间都是（不可知）PAC可学习的，换而言之：若假设空间的最小泛化误差为0即目标概念包含在假设空间中，则是PAC可学习，若最小泛化误差不为0，则称为不可知PAC可学习。</strong></p>
<h2 id="稳定性"><strong>稳定性</strong></h2>
<p>稳定性考察的是当算法的输入发生变化时，输出是否会随之发生较大的变化，输入的数据集D有以下两种变化：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc855badc5a8.png" alt="16.png"></p>
<p>若对数据集中的任何样本z，满足：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc855ba59b06.png" alt="17.png"></p>
<p>即原学习器和剔除一个样本后生成的学习器对z的损失之差保持β稳定，称学习器关于损失函数满足<strong>β-均匀稳定性</strong>。同时若损失函数有上界，即原学习器对任何样本的损失函数不超过M，则有如下定理：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc855babe7c3.png" alt="18.png"></p>
<p>事实上，<strong>若学习算法符合经验风险最小化原则（ERM）且满足β-均匀稳定性，则假设空间是可学习的</strong>。稳定性通过损失函数与假设空间的可学习联系在了一起，区别在于：假设空间关注的是经验误差与泛化误差，需要考虑到所有可能的假设；而稳定性只关注当前的输出假设。</p>
<p>在此，计算学习理论就介绍完毕，一看这个名字就知道这一章比较偏底层理论了，最终还是咬着牙看完了它，这里引用一段小文字来梳理一下现在的心情：“孤岂欲卿治经为博士邪？但当涉猎，见往事耳”，就当扩充知识体系吧~</p>
<blockquote>
<p>原文：<a href="https://github.com/Vay-keen/Machine-learning-learning-notes">https://github.com/Vay-keen/Machine-learning-learning-notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>贝叶斯分类器</title>
    <url>/posts/79f15ca6.html</url>
    <content><![CDATA[<p>上篇主要介绍和讨论了支持向量机。从最初的分类函数，通过最大化分类间隔，max(1/||w||)，min(1/2||w||^2)，凸二次规划，朗格朗日函数，对偶问题，一直到最后的SMO算法求解，都为寻找一个最优解。接着引入核函数将低维空间映射到高维特征空间，解决了非线性可分的情形。最后介绍了软间隔支持向量机，解决了outlier挤歪超平面的问题。本篇将讨论一个经典的统计学习算法–<strong>贝叶斯分类器</strong>。</p>
<h1><strong>贝叶斯分类器</strong></h1>
<p>贝叶斯分类器是一种概率框架下的统计学习分类器，对分类任务而言，假设在相关概率都已知的情况下，贝叶斯分类器考虑如何基于这些概率为样本判定最优的类标。在开始介绍贝叶斯决策论之前，我们首先来回顾下概率论委员会常委–贝叶斯公式。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc83fd7a2575.png" alt="1.png"></p>
<h2 id="贝叶斯决策论"><strong>贝叶斯决策论</strong></h2>
<p>若将上述定义中样本空间的划分Bi看做为类标，A看做为一个新的样本，则很容易将条件概率理解为样本A是类别Bi的概率。在机器学习训练模型的过程中，往往我们都试图去优化一个风险函数，因此在概率框架下我们也可以为贝叶斯定义“<strong>条件风险</strong>”（conditional risk）。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc83fd15db94.png" alt="2.png"></p>
<p>我们的任务就是寻找一个判定准则最小化所有样本的条件风险总和，因此就有了<strong>贝叶斯判定准则</strong>（Bayes decision rule）:为最小化总体风险，只需在每个样本上选择那个使得条件风险最小的类标。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc83fd308600.png" alt="3.png"></p>
<p>若损失函数λ取0-1损失，则有：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc83fd37c502.png" alt="4.png"></p>
<p>即对于每个样本x，选择其后验概率P（c | x）最大所对应的类标，能使得总体风险函数最小，从而将原问题转化为估计后验概率P（c | x）。一般这里有两种策略来对后验概率进行估计：</p>
<pre><code>* 判别式模型：直接对 P（c | x）进行建模求解。例我们前面所介绍的决策树、神经网络、SVM都是属于判别式模型。
* 生成式模型：通过先对联合分布P（x,c）建模，从而进一步求解 P（c | x）。
</code></pre>
<p>贝叶斯分类器就属于生成式模型，基于贝叶斯公式对后验概率P（c | x） 进行一项神奇的变换，巴拉拉能量… P（c | x）变身：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc83fd501ad3.png" alt="5.png"></p>
<p>对于给定的样本x，P（x）与类标无关，P（c）称为类先验概率，p（x | c ）称为类条件概率。这时估计后验概率P（c | x）就变成为估计类先验概率和类条件概率的问题。对于先验概率和后验概率，在看这章之前也是模糊了我好久，这里普及一下它们的基本概念。</p>
<pre><code>* 先验概率： 根据以往经验和分析得到的概率。
* 后验概率：后验概率是基于新的信息，修正原来的先验概率后所获得的更接近实际情况的概率估计。
</code></pre>
<p>实际上先验概率就是在没有任何结果出来的情况下估计的概率，而后验概率则是在有一定依据后的重新估计，直观意义上后验概率就是条件概率。下面直接上Wiki上的一个例子，简单粗暴快速完事…</p>
<p><img src="https://i.loli.net/2018/10/18/5bc83fd799610.png" alt="6.png"></p>
<p>回归正题，对于类先验概率P（c），p（c）就是样本空间中各类样本所占的比例，根据大数定理（当样本足够多时，频率趋于稳定等于其概率），这样当训练样本充足时，p©可以使用各类出现的频率来代替。因此只剩下类条件概率p（x | c ），它表达的意思是在类别c中出现x的概率，它涉及到属性的联合概率问题，若只有一个离散属性还好，当属性多时采用频率估计起来就十分困难，因此这里一般采用极大似然法进行估计。</p>
<h2 id="极大似然法"><strong>极大似然法</strong></h2>
<p>极大似然估计（Maximum Likelihood Estimation，简称MLE），是一种根据数据采样来估计概率分布的经典方法。常用的策略是先假定总体具有某种确定的概率分布，再基于训练样本对概率分布的参数进行估计。运用到类条件概率p（x | c ）中，假设p（x | c ）服从一个参数为θ的分布，问题就变为根据已知的训练样本来估计θ。极大似然法的核心思想就是：估计出的参数使得已知样本出现的概率最大，即使得训练数据的似然最大。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc83fd70fb73.png" alt="7.png"></p>
<p>所以，贝叶斯分类器的训练过程就是参数估计。总结最大似然法估计参数的过程，一般分为以下四个步骤：</p>
<pre><code>* 1.写出似然函数；
* 2.对似然函数取对数，并整理；
* 3.求导数，令偏导数为0，得到似然方程组；
* 4.解似然方程组，得到所有参数即为所求。
</code></pre>
<p>例如：假设样本属性都是连续值，p（x | c ）服从一个多维高斯分布，则通过MLE计算出的参数刚好分别为：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc83fd705729.png" alt="8.png"></p>
<p>上述结果看起来十分合乎实际，但是采用最大似然法估计参数的效果很大程度上依赖于作出的假设是否合理，是否符合潜在的真实数据分布。这就需要大量的经验知识，搞统计越来越值钱也是这个道理，大牛们掐指一算比我们搬砖几天更有效果。</p>
<h2 id="朴素贝叶斯分类器"><strong>朴素贝叶斯分类器</strong></h2>
<p>不难看出：原始的贝叶斯分类器最大的问题在于联合概率密度函数的估计，首先需要根据经验来假设联合概率分布，其次当属性很多时，训练样本往往覆盖不够，参数的估计会出现很大的偏差。为了避免这个问题，朴素贝叶斯分类器（naive Bayes classifier）采用了“属性条件独立性假设”，即样本数据的所有属性之间相互独立。这样类条件概率p（x | c ）可以改写为：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc83fd55e102.png" alt="9.png"></p>
<p>这样，为每个样本估计类条件概率变成为每个样本的每个属性估计类条件概率。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc83fd6678cd.png" alt="10.png"></p>
<p>相比原始贝叶斯分类器，朴素贝叶斯分类器基于单个的属性计算类条件概率更加容易操作，需要注意的是：若某个属性值在训练集中和某个类别没有一起出现过，这样会抹掉其它的属性信息，因为该样本的类条件概率被计算为0。因此在估计概率值时，常常用进行平滑（smoothing）处理，拉普拉斯修正（Laplacian correction）就是其中的一种经典方法，具体计算方法如下：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc83fe54aaed.png" alt="11.png"></p>
<p>当训练集越大时，拉普拉斯修正引入的影响越来越小。对于贝叶斯分类器，模型的训练就是参数估计，因此可以事先将所有的概率储存好，当有新样本需要判定时，直接查表计算即可。</p>
<p>针对朴素贝叶斯，人们觉得它too sample，sometimes too naive！因此又提出了半朴素的贝叶斯分类器，具体有SPODE、TAN、贝叶斯网络等来刻画属性之间的依赖关系，此处不进行深入，等哪天和贝叶斯邂逅了再回来讨论。在此鼎鼎大名的贝叶斯介绍完毕，下一篇将介绍这一章剩下的内容–EM算法，朴素贝叶斯和EM算法同为数据挖掘的十大经典算法，想着还是单独介绍吧~</p>
<blockquote>
<p>原文：<a href="https://github.com/Vay-keen/Machine-learning-learning-notes">https://github.com/Vay-keen/Machine-learning-learning-notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习笔记</category>
      </categories>
      <tags>
        <tag>贝叶斯</tag>
      </tags>
  </entry>
  <entry>
    <title>降维与度量学习</title>
    <url>/posts/c7795c7c.html</url>
    <content><![CDATA[<p>上篇主要介绍了几种常用的聚类算法，首先从距离度量与性能评估出发，列举了常见的距离计算公式与聚类评价指标，接着分别讨论了K-Means、LVQ、高斯混合聚类、密度聚类以及层次聚类算法。K-Means与LVQ都试图以类簇中心作为原型指导聚类，其中K-Means通过EM算法不断迭代直至收敛，LVQ使用真实类标辅助聚类；高斯混合聚类采用高斯分布来描述类簇原型；密度聚类则是将一个核心对象所有密度可达的样本形成类簇，直到所有核心对象都遍历完；最后层次聚类是一种自底向上的树形聚类方法，不断合并最相近的两个小类簇。本篇将讨论机器学习常用的方法–降维与度量学习。</p>
<h1><strong>降维与度量学习</strong></h1>
<p>样本的特征数称为<strong>维数</strong>（dimensionality），当维数非常大时，也就是现在所说的“<strong>维数灾难</strong>”，具体表现在：在高维情形下，<strong>数据样本将变得十分稀疏</strong>，因为此时要满足训练样本为“<strong>密采样</strong>”的总体样本数目是一个触不可及的天文数字，谓可远观而不可亵玩焉…<strong>训练样本的稀疏使得其代表总体分布的能力大大减弱，从而消减了学习器的泛化能力</strong>；同时当维数很高时，<strong>计算距离也变得十分复杂</strong>，甚至连计算内积都不再容易，这也是为什么支持向量机（SVM）使用核函数**“低维计算，高维表现”**的原因。</p>
<p>缓解维数灾难的一个重要途径就是<strong>降维，即通过某种数学变换将原始高维空间转变到一个低维的子空间</strong>。在这个子空间中，样本的密度将大幅提高，同时距离计算也变得容易。这时也许会有疑问，这样降维之后不是会丢失原始数据的一部分信息吗？这是因为在很多实际的问题中，虽然训练数据是高维的，但是与学习任务相关也许仅仅是其中的一个低维子空间，也称为一个<strong>低维嵌入</strong>，例如：数据属性中存在噪声属性、相似属性或冗余属性等，<strong>对高维数据进行降维能在一定程度上达到提炼低维优质属性或降噪的效果</strong>。</p>
<h2 id="K近邻学习"><strong>K近邻学习</strong></h2>
<p>k近邻算法简称<strong>kNN（k-Nearest Neighbor）</strong>，是一种经典的监督学习方法，同时也实力担当入选数据挖掘十大算法。其工作机制十分简单粗暴：给定某个测试样本，kNN基于某种<strong>距离度量</strong>在训练集中找出与其距离最近的k个带有真实标记的训练样本，然后给基于这k个邻居的真实标记来进行预测，类似于前面集成学习中所讲到的基学习器结合策略：分类任务采用投票法，回归任务则采用平均法。接下来本篇主要就kNN分类进行讨论。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851a43873a.png" alt="1.png"></p>
<p>从上图【来自Wiki】中我们可以看到，图中有两种类型的样本，一类是蓝色正方形，另一类是红色三角形。而那个绿色圆形是我们待分类的样本。基于kNN算法的思路，我们很容易得到以下结论：</p>
<blockquote>
<p>如果K=3，那么离绿色点最近的有2个红色三角形和1个蓝色的正方形，这3个点投票，于是绿色的这个待分类点属于红色的三角形。如果K=5，那么离绿色点最近的有2个红色三角形和3个蓝色的正方形，这5个点投票，于是绿色的这个待分类点属于蓝色的正方形。</p>
</blockquote>
<p>可以发现：<strong>kNN虽然是一种监督学习方法，但是它却没有显式的训练过程</strong>，而是当有新样本需要预测时，才来计算出最近的k个邻居，因此<strong>kNN是一种典型的懒惰学习方法</strong>，再来回想一下朴素贝叶斯的流程，训练的过程就是参数估计，因此朴素贝叶斯也可以懒惰式学习，此类技术在<strong>训练阶段开销为零</strong>，待收到测试样本后再进行计算。相应地我们称那些一有训练数据立马开工的算法为“<strong>急切学习</strong>”，可见前面我们学习的大部分算法都归属于急切学习。</p>
<p>很容易看出：<strong>kNN算法的核心在于k值的选取以及距离的度量</strong>。k值选取太小，模型很容易受到噪声数据的干扰，例如：极端地取k=1，若待分类样本正好与一个噪声数据距离最近，就导致了分类错误；若k值太大， 则在更大的邻域内进行投票，此时模型的预测能力大大减弱，例如：极端取k=训练样本数，就相当于模型根本没有学习，所有测试样本的预测结果都是一样的。<strong>一般地我们都通过交叉验证法来选取一个适当的k值</strong>。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851a47db9a.png" alt="2.png"></p>
<p>对于距离度量，<strong>不同的度量方法得到的k个近邻不尽相同，从而对最终的投票结果产生了影响</strong>，因此选择一个合适的距离度量方法也十分重要。在上一篇聚类算法中，在度量样本相似性时介绍了常用的几种距离计算方法，包括<strong>闵可夫斯基距离，曼哈顿距离，VDM</strong>等。在实际应用中，<strong>kNN的距离度量函数一般根据样本的特性来选择合适的距离度量，同时应对数据进行去量纲/归一化处理来消除大量纲属性的强权政治影响</strong>。</p>
<h2 id="MDS算法"><strong>MDS算法</strong></h2>
<p>不管是使用核函数升维还是对数据降维，我们都希望<strong>原始空间样本点之间的距离在新空间中基本保持不变</strong>，这样才不会使得原始空间样本之间的关系及总体分布发生较大的改变。**“多维缩放”（MDS）**正是基于这样的思想，<strong>MDS要求原始空间样本之间的距离在降维后的低维空间中得以保持</strong>。</p>
<p>假定m个样本在原始空间中任意两两样本之间的距离矩阵为D∈R(m*m)，我们的目标便是获得样本在低维空间中的表示Z∈R(d’*m , d’&lt; d)，且任意两个样本在低维空间中的欧式距离等于原始空间中的距离，即||zi-zj||=Dist(ij)。因此接下来我们要做的就是根据已有的距离矩阵D来求解出降维后的坐标矩阵Z。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851a4b664e.png" alt="3.png"></p>
<p>令降维后的样本坐标矩阵Z被中心化，<strong>中心化是指将每个样本向量减去整个样本集的均值向量，故所有样本向量求和得到一个零向量</strong>。这样易知：矩阵B的每一列以及每一列求和均为0，因为提取公因子后都有一项为所有样本向量的和向量。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851a4a4ee2.png" alt="4.png"></p>
<p>根据上面矩阵B的特征，我们很容易得到等式（2）、（3）以及（4）：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851a4a777b.png" alt="5.png"></p>
<p>这时根据(1)–(4)式我们便可以计算出bij，即<strong>bij=(1)-(2)<em>(1/m)-(3)</em>(1/m)+(4)*(1/(m^2))</strong>，再逐一地计算每个b(ij)，就得到了降维后低维空间中的内积矩阵B(B=Z’*Z)，只需对B进行特征值分解便可以得到Z。MDS的算法流程如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851a5340dd.png" alt="6.png"></p>
<h2 id="主成分分析（PCA）"><strong>主成分分析（PCA）</strong></h2>
<p>不同于MDS采用距离保持的方法，<strong>主成分分析（PCA）直接通过一个线性变换，将原始空间中的样本投影到新的低维空间中</strong>。简单来理解这一过程便是：<strong>PCA采用一组新的基来表示样本点，其中每一个基向量都是原来基向量的线性组合，通过使用尽可能少的新基向量来表出样本，从而达到降维的目的。</strong></p>
<p>假设使用d’个新基向量来表示原来样本，实质上是将样本投影到一个由d’个基向量确定的一个<strong>超平面</strong>上（<strong>即舍弃了一些维度</strong>），要用一个超平面对空间中所有高维样本进行恰当的表达，最理想的情形是：<strong>若这些样本点都能在超平面上表出且这些表出在超平面上都能够很好地分散开来</strong>。但是一般使用较原空间低一些维度的超平面来做到这两点十分不容易，因此我们退一步海阔天空，要求这个超平面应具有如下两个性质：</p>
<blockquote>
<p><strong>最近重构性</strong>：样本点到超平面的距离足够近，即尽可能在超平面附近；<br>
<strong>最大可分性</strong>：样本点在超平面上的投影尽可能地分散开来，即投影后的坐标具有区分性。</p>
</blockquote>
<p>这里十分神奇的是：<strong>最近重构性与最大可分性虽然从不同的出发点来定义优化问题中的目标函数，但最终这两种特性得到了完全相同的优化问题</strong>：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851a5213c1.png" alt="7.png"></p>
<p>接着使用拉格朗日乘子法求解上面的优化问题，得到：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851a4a102a.png" alt="8.png"></p>
<p>因此只需对协方差矩阵进行特征值分解即可求解出W，PCA算法的整个流程如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851a540eb3.png" alt="9.png"></p>
<p>另一篇博客给出更通俗更详细的理解：<a href="http://blog.csdn.net/u011826404/article/details/57472730">主成分分析解析（基于最大方差理论）</a></p>
<h2 id="核化线性降维"><strong>核化线性降维</strong></h2>
<p>说起机器学习你中有我/我中有你/水乳相融…在这里能够得到很好的体现。正如SVM在处理非线性可分时，通过引入核函数将样本投影到高维特征空间，接着在高维空间再对样本点使用超平面划分。这里也是相同的问题：若我们的样本数据点本身就不是线性分布，那还如何使用一个超平面去近似表出呢？因此也就引入了核函数，<strong>即先将样本映射到高维空间，再在高维空间中使用线性降维的方法</strong>。下面主要介绍**核化主成分分析（KPCA）**的思想。</p>
<p>若核函数的形式已知，即我们知道如何将低维的坐标变换为高维坐标，这时我们只需先将数据映射到高维特征空间，再在高维空间中运用PCA即可。但是一般情况下，我们并不知道核函数具体的映射规则，例如：Sigmoid、高斯核等，我们只知道如何计算高维空间中的样本内积，这时就引出了KPCA的一个重要创新之处：<strong>即空间中的任一向量，都可以由该空间中的所有样本线性表示</strong>。证明过程也十分简单：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851a51bd2a.png" alt="10.png"></p>
<p>这样我们便可以将高维特征空间中的投影向量wi使用所有高维样本点线性表出，接着代入PCA的求解问题，得到：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851b74b083.png" alt="11.png"></p>
<p>化简到最后一步，发现结果十分的美妙，只需对核矩阵K进行特征分解，便可以得出投影向量wi对应的系数向量α，因此选取特征值前d’大对应的特征向量便是d’个系数向量。这时对于需要降维的样本点，只需按照以下步骤便可以求出其降维后的坐标。可以看出：KPCA在计算降维后的坐标表示时，需要与所有样本点计算核函数值并求和，因此该算法的计算开销十分大。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851b735754.png" alt="12.png"></p>
<h2 id="流形学习"><strong>流形学习</strong></h2>
<p><strong>流形学习（manifold learning）是一种借助拓扑流形概念的降维方法</strong>，<strong>流形是指在局部与欧式空间同胚的空间</strong>，即在局部与欧式空间具有相同的性质，能用欧氏距离计算样本之间的距离。这样即使高维空间的分布十分复杂，但是在局部上依然满足欧式空间的性质，基于流形学习的降维正是这种**“邻域保持”<strong>的思想。其中</strong>等度量映射（Isomap）试图在降维前后保持邻域内样本之间的距离，而局部线性嵌入（LLE）则是保持邻域内样本之间的线性关系**，下面将分别对这两种著名的流行学习方法进行介绍。</p>
<h3 id="等度量映射（Isomap）"><strong>等度量映射（Isomap）</strong></h3>
<p>等度量映射的基本出发点是：高维空间中的直线距离具有误导性，因为有时高维空间中的直线距离在低维空间中是不可达的。<strong>因此利用流形在局部上与欧式空间同胚的性质，可以使用近邻距离来逼近测地线距离</strong>，即对于一个样本点，它与近邻内的样本点之间是可达的，且距离使用欧式距离计算，这样整个样本空间就形成了一张近邻图，高维空间中两个样本之间的距离就转为最短路径问题。可采用著名的<strong>Dijkstra算法</strong>或<strong>Floyd算法</strong>计算最短距离，得到高维空间中任意两点之间的距离后便可以使用MDS算法来其计算低维空间中的坐标。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851b731a1e.png" alt="13.png"></p>
<p>从MDS算法的描述中我们可以知道：MDS先求出了低维空间的内积矩阵B，接着使用特征值分解计算出了样本在低维空间中的坐标，但是并没有给出通用的投影向量w，因此对于需要降维的新样本无从下手，书中给出的权宜之计是利用已知高/低维坐标的样本作为训练集学习出一个“投影器”，便可以用高维坐标预测出低维坐标。Isomap算法流程如下图：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851b6c7e37.png" alt="14.png"></p>
<p>对于近邻图的构建，常用的有两种方法：<strong>一种是指定近邻点个数</strong>，像kNN一样选取k个最近的邻居；<strong>另一种是指定邻域半径</strong>，距离小于该阈值的被认为是它的近邻点。但两种方法均会出现下面的问题：</p>
<blockquote>
<p>若<strong>邻域范围指定过大，则会造成“短路问题”</strong>，即本身距离很远却成了近邻，将距离近的那些样本扼杀在摇篮。若<strong>邻域范围指定过小，则会造成“断路问题”</strong>，即有些样本点无法可达了，整个世界村被划分为互不可达的小部落。</p>
</blockquote>
<h3 id="局部线性嵌入-LLE"><strong>局部线性嵌入(LLE)</strong></h3>
<p>不同于Isomap算法去保持邻域距离，LLE算法试图去保持邻域内的线性关系，假定样本xi的坐标可以通过它的邻域样本线性表出：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851b64236f.png" alt="15.png"></p>
<p><img src="https://i.loli.net/2018/10/18/5bc851b6a7b9a.png" alt="16.png"></p>
<p>LLE算法分为两步走，<strong>首先第一步根据近邻关系计算出所有样本的邻域重构系数w</strong>：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851b662815.png" alt="17.png"></p>
<p><strong>接着根据邻域重构系数不变，去求解低维坐标</strong>：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851b648b98.png" alt="18.png"></p>
<p>这样利用矩阵M，优化问题可以重写为：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851b6948d7.png" alt="19.png"></p>
<p>M特征值分解后最小的d’个特征值对应的特征向量组成Z，LLE算法的具体流程如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851b757d8c.png" alt="20.png"></p>
<h2 id="度量学习"><strong>度量学习</strong></h2>
<p>本篇一开始就提到维数灾难，即在高维空间进行机器学习任务遇到样本稀疏、距离难计算等诸多的问题，因此前面讨论的降维方法都试图将原空间投影到一个合适的低维空间中，接着在低维空间进行学习任务从而产生较好的性能。事实上，不管高维空间还是低维空间都潜在对应着一个距离度量，那可不可以直接学习出一个距离度量来等效降维呢？例如：<strong>咋们就按照降维后的方式来进行距离的计算，这便是度量学习的初衷</strong>。</p>
<p><strong>首先要学习出距离度量必须先定义一个合适的距离度量形式</strong>。对两个样本xi与xj，它们之间的平方欧式距离为：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851d3ca3d5.png" alt="21.png"></p>
<p>若各个属性重要程度不一样即都有一个权重，则得到加权的平方欧式距离：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851d3d82c5.png" alt="22.png"></p>
<p>此时各个属性之间都是相互独立无关的，但现实中往往会存在属性之间有关联的情形，例如：身高和体重，一般人越高，体重也会重一些，他们之间存在较大的相关性。这样计算距离就不能分属性单独计算，于是就引入经典的<strong>马氏距离(Mahalanobis distance)</strong>:</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851d3dc303.png" alt="23.png"></p>
<p><strong>标准的马氏距离中M是协方差矩阵的逆，马氏距离是一种考虑属性之间相关性且尺度无关（即无须去量纲）的距离度量</strong>。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc851d3e17c0.png" alt="24.png"></p>
<p><strong>矩阵M也称为“度量矩阵”，为保证距离度量的非负性与对称性，M必须为(半)正定对称矩阵</strong>，这样就为度量学习定义好了距离度量的形式，换句话说：<strong>度量学习便是对度量矩阵进行学习</strong>。现在来回想一下前面我们接触的机器学习不难发现：<strong>机器学习算法几乎都是在优化目标函数，从而求解目标函数中的参数</strong>。同样对于度量学习，也需要设置一个优化目标，书中简要介绍了错误率和相似性两种优化目标，此处限于篇幅不进行展开。</p>
<p>在此，降维和度量学习就介绍完毕。<strong>降维是将原高维空间嵌入到一个合适的低维子空间中，接着在低维空间中进行学习任务；度量学习则是试图去学习出一个距离度量来等效降维的效果</strong>，两者都是为了解决维数灾难带来的诸多问题。也许大家最后心存疑惑，那kNN呢，为什么一开头就说了kNN算法，但是好像和后面没有半毛钱关系？正是因为在降维算法中，低维子空间的维数d’通常都由人为指定，因此我们需要使用一些低开销的学习器来选取合适的d’，<strong>kNN这家伙懒到家了根本无心学习，在训练阶段开销为零，测试阶段也只是遍历计算了距离，因此拿kNN来进行交叉验证就十分有优势了~同时降维后样本密度增大同时距离计算变易，更为kNN来展示它独特的十八般手艺提供了用武之地。</strong></p>
<blockquote>
<p>原文：<a href="https://github.com/Vay-keen/Machine-learning-learning-notes">https://github.com/Vay-keen/Machine-learning-learning-notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习笔记</category>
      </categories>
      <tags>
        <tag>降维</tag>
      </tags>
  </entry>
  <entry>
    <title>集成学习</title>
    <url>/posts/72fab9d8.html</url>
    <content><![CDATA[<p>上篇主要介绍了鼎鼎大名的EM算法，从算法思想到数学公式推导（边际似然引入隐变量，Jensen不等式简化求导），EM算法实际上可以理解为一种坐标下降法，首先固定一个变量，接着求另外变量的最优解，通过其优美的“两步走”策略能较好地估计隐变量的值。本篇将继续讨论下一类经典算法–集成学习。</p>
<h1><strong>集成学习</strong></h1>
<p>顾名思义，集成学习（ensemble learning）指的是将多个学习器进行有效地结合，组建一个“学习器委员会”，其中每个学习器担任委员会成员并行使投票表决权，使得委员会最后的决定更能够四方造福普度众生<sub>…</sub>，即其泛化性能要能优于其中任何一个学习器。</p>
<h2 id="个体与集成"><strong>个体与集成</strong></h2>
<p>集成学习的基本结构为：先产生一组个体学习器，再使用某种策略将它们结合在一起。集成模型如下图所示：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84d0c15683.png" alt="1.png"></p>
<p>在上图的集成模型中，若个体学习器都属于同一类别，例如都是决策树或都是神经网络，则称该集成为同质的（homogeneous）;若个体学习器包含多种类型的学习算法，例如既有决策树又有神经网络，则称该集成为异质的（heterogenous）。</p>
<blockquote>
<p><strong>同质集成</strong>：个体学习器称为“基学习器”（base learner），对应的学习算法为“基学习算法”（base learning algorithm）。<br>
<strong>异质集成</strong>：个体学习器称为“组件学习器”（component learner）或直称为“个体学习器”。</p>
</blockquote>
<p>上面我们已经提到要让集成起来的泛化性能比单个学习器都要好，虽说团结力量大但也有木桶短板理论调皮捣蛋，那如何做到呢？这就引出了集成学习的两个重要概念：<strong>准确性</strong>和<strong>多样性</strong>（diversity）。准确性指的是个体学习器不能太差，要有一定的准确度；多样性则是个体学习器之间的输出要具有差异性。通过下面的这三个例子可以很容易看出这一点，准确度较高，差异度也较高，可以较好地提升集成性能。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84d0d23e13.png" alt="2.png"></p>
<p>现在考虑二分类的简单情形，假设基分类器之间相互独立（能提供较高的差异度），且错误率相等为 ε，则可以将集成器的预测看做一个伯努利实验，易知当所有基分类器中不足一半预测正确的情况下，集成器预测错误，所以集成器的错误率可以计算为：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84d0cce0bb.png" alt="3.png"></p>
<p>此时，集成器错误率随着基分类器的个数的增加呈指数下降，但前提是基分类器之间相互独立，在实际情形中显然是不可能的，假设训练有A和B两个分类器，对于某个测试样本，显然满足：P（A=1 | B=1）&gt; P（A=1），因为A和B为了解决相同的问题而训练，因此在预测新样本时存在着很大的联系。因此，<strong>个体学习器的“准确性”和“差异性”本身就是一对矛盾的变量</strong>，准确性高意味着牺牲多样性，所以产生“<strong>好而不同</strong>”的个体学习器正是集成学习研究的核心。现阶段有三种主流的集成学习方法：Boosting、Bagging以及随机森林（Random Forest），接下来将进行逐一介绍。</p>
<h2 id="Boosting"><strong>Boosting</strong></h2>
<p>Boosting是一种串行的工作机制，即个体学习器的训练存在依赖关系，必须一步一步序列化进行。其基本思想是：增加前一个基学习器在训练训练过程中预测错误样本的权重，使得后续基学习器更加关注这些打标错误的训练样本，尽可能纠正这些错误，一直向下串行直至产生需要的T个基学习器，Boosting最终对这T个学习器进行加权结合，产生学习器委员会。</p>
<p>Boosting族算法最著名、使用最为广泛的就是AdaBoost，因此下面主要是对AdaBoost算法进行介绍。AdaBoost使用的是<strong>指数损失函数</strong>，因此AdaBoost的权值与样本分布的更新都是围绕着最小化指数损失函数进行的。看到这里回想一下之前的机器学习算法，<strong>不难发现机器学习的大部分带参模型只是改变了最优化目标中的损失函数</strong>：如果是Square loss，那就是最小二乘了；如果是Hinge Loss，那就是著名的SVM了；如果是log-Loss，那就是Logistic Regression了。</p>
<p>定义基学习器的集成为加权结合，则有：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84d0ca2ca5.png" alt="4.png"></p>
<p>AdaBoost算法的指数损失函数定义为：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84d0d10461.png" alt="5.png"></p>
<p>具体说来，整个Adaboost 迭代算法分为3步：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>初始化训练数据的权值分布。如果有N个样本，则每一个训练样本最开始时都被赋予相同的权值：1/N。</p>
</li>
<li class="lvl-2">
<p>训练弱分类器。具体训练过程中，如果某个样本点已经被准确地分类，那么在构造下一个训练集中，它的权值就被降低；相反，如果某个样本点没有被准确地分类，那么它的权值就得到提高。然后，权值更新过的样本集被用于训练下一个分类器，整个训练过程如此迭代地进行下去。</p>
</li>
<li class="lvl-2">
<p>将各个训练得到的弱分类器组合成强分类器。各个弱分类器的训练过程结束后，加大分类误差率小的弱分类器的权重，使其在最终的分类函数中起着较大的决定作用，而降低分类误差率大的弱分类器的权重，使其在最终的分类函数中起着较小的决定作用。</p>
</li>
</ul>
<p>整个AdaBoost的算法流程如下所示：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84d0d7c057.png" alt="6.png"></p>
<p>可以看出：<strong>AdaBoost的核心步骤就是计算基学习器权重和样本权重分布</strong>，那为何是上述的计算公式呢？这就涉及到了我们之前为什么说大部分带参机器学习算法只是改变了损失函数，就是因为<strong>大部分模型的参数都是通过最优化损失函数（可能还加个规则项）而计算（梯度下降，坐标下降等）得到</strong>，这里正是通过最优化指数损失函数从而得到这两个参数的计算公式，具体的推导过程此处不进行展开。</p>
<p>Boosting算法要求基学习器能对特定分布的数据进行学习，即每次都更新样本分布权重，这里书上提到了两种方法：“重赋权法”（re-weighting）和“重采样法”（re-sampling），书上的解释有些晦涩，这里进行展开一下：</p>
<blockquote>
<p><strong>重赋权法</strong> : 对每个样本附加一个权重，这时涉及到样本属性与标签的计算，都需要乘上一个权值。<br>
<strong>重采样法</strong> : 对于一些无法接受带权样本的及学习算法，适合用“重采样法”进行处理。方法大致过程是，根据各个样本的权重，对训练数据进行重采样，初始时样本权重一样，每个样本被采样到的概率一致，每次从N个原始的训练样本中按照权重有放回采样N个样本作为训练集，然后计算训练集错误率，然后调整权重，重复采样，集成多个基学习器。</p>
</blockquote>
<p>从偏差-方差分解来看：Boosting算法主要关注于降低偏差，每轮的迭代都关注于训练过程中预测错误的样本，将弱学习提升为强学习器。从AdaBoost的算法流程来看，标准的AdaBoost只适用于二分类问题。在此，当选为数据挖掘十大算法之一的AdaBoost介绍到这里，能够当选正是说明这个算法十分婀娜多姿，背后的数学证明和推导充分证明了这一点，限于篇幅不再继续展开。</p>
<h2 id="Bagging与Random-Forest"><strong>Bagging与Random Forest</strong></h2>
<p>相比之下，Bagging与随机森林算法就简洁了许多，上面已经提到产生“好而不同”的个体学习器是集成学习研究的核心，即在保证基学习器准确性的同时增加基学习器之间的多样性。而这两种算法的基本思（tao）想（lu）都是通过“自助采样”的方法来增加多样性。</p>
<h3 id="Bagging"><strong>Bagging</strong></h3>
<p>Bagging是一种并行式的集成学习方法，即基学习器的训练之间没有前后顺序可以同时进行，Bagging使用“有放回”采样的方式选取训练集，对于包含m个样本的训练集，进行m次有放回的随机采样操作，从而得到m个样本的采样集，这样训练集中有接近36.8%的样本没有被采到。按照相同的方式重复进行，我们就可以采集到T个包含m个样本的数据集，从而训练出T个基学习器，最终对这T个基学习器的输出进行结合。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84d0ce62fc.png" alt="7.png"></p>
<p>Bagging算法的流程如下所示：</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84d0d0e761.png" alt="8.png"></p>
<p>可以看出Bagging主要通过<strong>样本的扰动</strong>来增加基学习器之间的多样性，因此Bagging的基学习器应为那些对训练集十分敏感的不稳定学习算法，例如：神经网络与决策树等。从偏差-方差分解来看，Bagging算法主要关注于降低方差，即通过多次重复训练提高稳定性。不同于AdaBoost的是，Bagging可以十分简单地移植到多分类、回归等问题。总的说起来则是：<strong>AdaBoost关注于降低偏差，而Bagging关注于降低方差。</strong></p>
<h3 id="随机森林"><strong>随机森林</strong></h3>
<p>随机森林（Random Forest）是Bagging的一个拓展体，它的基学习器固定为决策树，多棵树也就组成了森林，而“随机”则在于选择划分属性的随机，随机森林在训练基学习器时，也采用有放回采样的方式添加样本扰动，同时它还引入了一种<strong>属性扰动</strong>，即在基决策树的训练过程中，在选择划分属性时，RF先从候选属性集中随机挑选出一个包含K个属性的子集，再从这个子集中选择最优划分属性，一般推荐K=log2（d）。</p>
<p>这样随机森林中基学习器的多样性不仅来自样本扰动，还来自属性扰动，从而进一步提升了基学习器之间的差异度。相比决策树的Bagging集成，随机森林的起始性能较差（由于属性扰动，基决策树的准确度有所下降），但随着基学习器数目的增多，随机森林往往会收敛到更低的泛化误差。同时不同于Bagging中决策树从所有属性集中选择最优划分属性，随机森林只在属性集的一个子集中选择划分属性，因此训练效率更高。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84d0d7a4fd.png" alt="9.png"></p>
<h2 id="结合策略"><strong>结合策略</strong></h2>
<p>结合策略指的是在训练好基学习器后，如何将这些基学习器的输出结合起来产生集成模型的最终输出，下面将介绍一些常用的结合策略：</p>
<h3 id="平均法（回归问题）"><strong>平均法（回归问题）</strong></h3>
<p><img src="https://i.loli.net/2018/10/18/5bc84d0d07983.png" alt="10.png"></p>
<p><img src="https://i.loli.net/2018/10/18/5bc84de1b74ff.png" alt="11.png"></p>
<p>易知简单平均法是加权平均法的一种特例，加权平均法可以认为是集成学习研究的基本出发点。由于各个基学习器的权值在训练中得出，<strong>一般而言，在个体学习器性能相差较大时宜使用加权平均法，在个体学习器性能相差较小时宜使用简单平均法</strong>。</p>
<h3 id="投票法（分类问题）"><strong>投票法（分类问题）</strong></h3>
<p><img src="https://i.loli.net/2018/10/18/5bc84de2629c4.png" alt="12.png"></p>
<p><img src="https://i.loli.net/2018/10/18/5bc84de25a74b.png" alt="13.png"></p>
<p><img src="https://i.loli.net/2018/10/18/5bc84de1bacc4.png" alt="14.png"></p>
<p>绝对多数投票法（majority voting）提供了拒绝选项，这在可靠性要求很高的学习任务中是一个很好的机制。同时，对于分类任务，各个基学习器的输出值有两种类型，分别为类标记和类概率。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84de2768c1.png" alt="15.png"></p>
<p>一些在产生类别标记的同时也生成置信度的学习器，置信度可转化为类概率使用，<strong>一般基于类概率进行结合往往比基于类标记进行结合的效果更好</strong>，需要注意的是对于异质集成，其类概率不能直接进行比较，此时需要将类概率转化为类标记输出，然后再投票。</p>
<h3 id="学习法"><strong>学习法</strong></h3>
<p>学习法是一种更高级的结合策略，即学习出一种“投票”的学习器，Stacking是学习法的典型代表。Stacking的基本思想是：首先训练出T个基学习器，对于一个样本它们会产生T个输出，将这T个基学习器的输出与该样本的真实标记作为新的样本，m个样本就会产生一个m*T的样本集，来训练一个新的“投票”学习器。投票学习器的输入属性与学习算法对Stacking集成的泛化性能有很大的影响，书中已经提到：<strong>投票学习器采用类概率作为输入属性，选用多响应线性回归（MLR）一般会产生较好的效果</strong>。</p>
<p><img src="https://i.loli.net/2018/10/18/5bc84de25cbaf.png" alt="16.png"></p>
<h2 id="多样性（diversity）"><strong>多样性（diversity）</strong></h2>
<p>在集成学习中，基学习器之间的多样性是影响集成器泛化性能的重要因素。因此增加多样性对于集成学习研究十分重要，一般的思路是在学习过程中引入随机性，常见的做法主要是对数据样本、输入属性、输出表示、算法参数进行扰动。</p>
<blockquote>
<p><strong>数据样本扰动</strong>，即利用具有差异的数据集来训练不同的基学习器。例如：有放回自助采样法，但此类做法只对那些不稳定学习算法十分有效，例如：决策树和神经网络等，训练集的稍微改变能导致学习器的显著变动。<br>
<strong>输入属性扰动</strong>，即随机选取原空间的一个子空间来训练基学习器。例如：随机森林，从初始属性集中抽取子集，再基于每个子集来训练基学习器。但若训练集只包含少量属性，则不宜使用属性扰动。<br>
<strong>输出表示扰动</strong>，此类做法可对训练样本的类标稍作变动，或对基学习器的输出进行转化。<br>
<strong>算法参数扰动</strong>，通过随机设置不同的参数，例如：神经网络中，随机初始化权重与随机设置隐含层节点数。</p>
</blockquote>
<p>在此，集成学习就介绍完毕，看到这里，大家也会发现集成学习实质上是一种通用框架，可以使用任何一种基学习器，从而改进单个学习器的泛化性能。据说数据挖掘竞赛KDDCup历年的冠军几乎都使用了集成学习，看来的确是个好东西~</p>
<blockquote>
<p>原文：<a href="https://github.com/Vay-keen/Machine-learning-learning-notes">https://github.com/Vay-keen/Machine-learning-learning-notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习笔记</category>
      </categories>
      <tags>
        <tag>集成学习</tag>
      </tags>
  </entry>
  <entry>
    <title>BP神经网络</title>
    <url>/posts/4f98a72.html</url>
    <content><![CDATA[<h2 id="BP神经网络">BP神经网络</h2>
<p>人工神经网络 （Artificial Neural Network，ANN）简称神经网络(NN)，是基于生物学中神经网络的基本原理，在理解和抽象了人脑结构和外界刺激响应机制后，以网络拓扑知识为理论基础，模拟人脑的神经系统对复杂信息的处理机制的一种数学模型，根植于神经科学、数学、思维科学、人工智能、统计学、物理学、计算机科学以及工程科学的一门技术，通常用于解决分类和回归问题。具有并行分布的处理能力、高容错性、智能化和自学习等能力的特征，本质上是一个有大量简单元件相互连接而成的复杂网络，具有高度的非线性，能够进行复杂的逻辑操作和非线性关系实现的系统。</p>
<p>神经网络由大量的节点（或称神经元）之间相互联接构成，每个节点代表一种特定的输出函数，称为激活函数（activation function）；每两个节点间的连接都代表一个对于通过该连接信号的加权值，称之为权重（weight），神经网络就是通过这种方式来模拟人类的记忆。网络的输出则取决于网络的结构、网络的连接方式、权重和激活函数。而网络自身通常都是对自然界某种算法或者函数的逼近，也可能是对一种逻辑策略的表达，是对传统逻辑学演算的进一步延伸。</p>
<p align="center">
<img width="300" align="center" src="/img/images/1.jpg" />
</p>
<p>人工神经网络中，神经元处理单元可表示不同的对象，例如特征、字母、概念，或者一些有意义的抽象模式。网络中处理单元的类型分为三类：输入单元、输出单元和隐单元。输入单元接受外部世界的信号与数据；输出单元实现系统处理结果的输出；隐单元是处在输入和输出单元之间，不能由系统外部观察的单元。神经元间的连接权值反映了单元间的连接强度，信息的表示和处理体现在网络处理单元的连接关系中。</p>
<h3 id="算法描述">算法描述</h3>
<p>反向传播模型也称B-P模型，是一种用于前向多层的反向传播学习算法。之所以称它是一种学习方法，是因为用它可以对组成前向多层网络的各人工神经元之间的连接权值进行不断的修改，从而使该前向多层网络能够将输入它的信息变换成所期望的输出信息。之所以将其称作为反向学习算法，是因为在修改各人工神经元的连接权值时，所依据的是该网络的实际输出与其期望的输出之差，将这一差值反向一层一层的向回传播，来决定连接权值的修改。</p>
<p>B-P算法的网络结构是一个前向多层网络,其基本思想是，学习过程由信号的正向传播与误差的反向传播两个过程组成。正向传播时，输入样本从输入层传入，经隐含层逐层处理后，传向输出层。若输出层的实际输出与期望输出不符，则转向误差的反向传播阶段。误差的反向传播是将输出误差以某种形式通过隐层向输入层逐层反传，并将误差分摊给各层的所有单元，从而获得各层单元的误差信号，此误差信号即作为修正各单元权值的依据。这种信号正向传播与误差反向传播的各层权值调整过程，是周而复始地进行。权值不断调整过程，也就是网络的学习训练过程。此过程一直进行到网络输出的误差减少到可以接受的程度，或进行到预先设定的学习次数为止。</p>
<p>BP网络的拓扑结构包括输入层、隐层和输出层，它能够在事先不知道输入输出具体数学表达式的情况下，通过学习来存储这种复杂的映射关系．其网络中参数的学习通常采用反向传播的策略，借助最速梯度信息来寻找使网络误差最小化的参数组合．常见的3层BP网络模型如图所示</p>
<p align="center">
<img width="300" align="center" src="/img/images/2.jpg" />
</p>
<p>其中，各节点的传递函数f必须满足处处可导的条件，最常用的为Sigmoid函数，第i个神经元的净输入为nwti，输出为Oi．如果网络输出层第k个神经元的期望输出为yk*，则网络的平方型误差函数为</p>
<p align="center">
<img width="300" align="center" src="/img/images/3.jpg" />
</p>
<p>由于BP算法按照误差函数E的负梯度修改权值，故权值的更新公式可表示为:</p>
<p align="center">
<img width="100" align="center" src="/img/images/4.jpg" />
</p>
<p>其中，t表示迭代次数， 对于输出层神经元权值的更新公式为：</p>
<p align="center">
<img width="300" align="center" src="/img/images/5.jpg" />
</p>
<p>其中，δk称作输出层第k 个神经元的学习误差．对隐含层神经元权值的更新公式为：</p>
<p align="center">
<img width="300" align="center" src="/img/images/6.jpg" />
</p>
<p>其中，δj称作隐含层第j个神经元的学习误差．BP的误差反向传播思想可以概括为：利用输出层的误差来估计出其直接前导层的误差，再借助于这个新的误差来计算更前一层的误差，按照这样的方式逐层反传下去便可以得到所有各层的误差估计。</p>
<div style="font-size:16px;">应用领域：神经网络克服了传统人工智能方法对于直觉的缺陷，因而在神经专家系统、模式识别、智能控制、组合优化、预测等领域有成功的应用。</div>
<div style="font-size:16px;">优点：理论基础牢固，推导过程严谨，物理概念清晰，通用性好等。所以，它是目前用来训练前向多层网络较好的算法。</div>
<div style="font-size:16px;">缺点：(1)该学习算法的收敛速度慢；(2)网络中隐节点个数的选取尚无理论上的指导；(3)从数学角度看，B-P算法是一种梯度最速下降法，这就可能出现局部极小的问题。当出现局部极小时，从表面上看，误差符合要求，但这时所得到的解并不一定是问题的真正解。所以B-P算法是不完备的。</div>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
      </categories>
  </entry>
  <entry>
    <title>关联规则</title>
    <url>/posts/42e73f05.html</url>
    <content><![CDATA[<h2 id="关联规则">关联规则</h2>
<p>“关联规则”（Association Rules）是数据挖掘的主要技术之一，用于从庞大的数据库中寻找有用或有趣的模式和规则。关联规则最初产生于购物篮分析，它通过发现顾客放入其购物篮中不同商品之间的联系，分析顾客购买行为中隐含的有趣模式，从而指导销售商制订营销策略。单维关联规则特指只涉及单个属性项的关联规则。</p>
<p>设 I = { i1 , i2 ,…, im }是项的集合。设任务相关的数据D 是数据库事务的集合，其中每个事务T是项的集合，使得T ⊆ I。每一个事务有一个标识符，称作TID。设A 是一个项集，事务T 包含A当且仅当A ⊆ T。关联规则是形如A ⇒ B 的蕴涵式，其中A ⊂ I，B ⊂ I，并且A ∩ B =∅。规则A ⇒B 在事务集D 中成立，具有支持度s，其中s 是D 中事务包含A ∪ B（即A 和B 二者）的百分比。它是概率P(A ∪ B)。规则A ⇒ B 在事务集D 中具有置信度c，如果D 中包含A 的事务同时也包含B的百分比是c。这是条件概率P(B |A)。即 support (A ⇒ B ) = P(A ∪ B) confidence (A ⇒ B ) = P(B |A)</p>
<p>同时满足最小支持度阈值(min_sup)和最小置信度阈值(min_conf)的规则称作强规则。为方便计，我们用0%和100%之间的值，而不是用0 到1 之间的值表示支持度和置信度。项的集合称为项集。包含k 个项的项集称为k-项集。集合{computer, financial_management_software}是一个2-项集。项集的出现频率是包含项集的事务数，简称为项集的频率、支持计数或计数。项集满足最小支持度min_sup，如果项集的出现频率大于或等于min_sup 与D 中事务总数的乘积。如果项集满足最小支持度，则称它为频繁项集。频繁k -项集的集合通常记作Lk。关联规则的挖掘是一个两步的过程：</p>
<ol>
<li class="lvl-3">
<p>找出所有频繁项集：根据定义，这些项集出现的频繁性至少和预定义的最小支持计数一样。</p>
</li>
<li class="lvl-3">
<p>由频繁项集产生强关联规则：根据定义，这些规则必须满足最小支持度和最小置信度。</p>
</li>
</ol>
<p>如果愿意，也可以使用附加的兴趣度度量。这两步中，第二步最容易。挖掘关联规则的总体性能由第一步决定。</p>
<h3 id="算法背景">算法背景</h3>
<p>关联规则挖掘发现大量数据中项集之间有趣的关联或相关联系。随着大量数据不停地收集和存储，许多业界人士对于从他们的数据库中挖掘关联规则越来越感兴趣。从大量商务事务记录中发现有趣的关联关系，可以帮助许多商务决策的制定，如分类设计、交叉购物和贱卖分析。关联规则挖掘的一个典型例子是购物篮分析。该过程通过发现顾客放入其购物篮中不同商品之间联系，分析顾客的购买习惯。通过了解哪些商品频繁地被顾客同时购买，这种关联的发现可以帮助零售商制定营销策略。例如，在同一次去超级市场，如果顾客购买牛奶，他也购买面包（和什么类型的面包）的可能性有多大？通过帮助零售商有选择地经销和安排货架，这种信息可以引导销售。例如，将牛奶和面包尽可能放近一些，可以进一步刺激一次去商店同时购买这些商品。</p>
<p align="center">
<img width="300" align="center" src="/img/images/120.jpg" />
</p>
<h3 id="应用领域">应用领域</h3>
<p>关联分类算法是继贝叶斯( Bayes) 、支持向量机( SVM) 等机器学习方法之后的又一重要分类技术，广泛应用于文本分类、Web文档分类、医学图像分类。经典的关联分类算法有CBA、CMAR、CPAR；</p>
<p>网络入侵检测技术作为防火墙技术强有力的助手，有效弥补了防火墙策略处理黑客攻击、信息窃取问题时出现的不足，成为网络安全监控系统可靠的保障。传统的入侵检测系统(IDS) 运用关联规则生成入侵检测标准规则库，通过判断网络数据与规则库的匹配度产生告警数据流。</p>
<p>隐私保护数据挖掘是指在数据挖掘的过程中通过采用数据干扰和查询限制的基本策略对原始数据进行保护，避免商业敏感数据、个人隐私数据泄露。</p>
<p>利用关联规则进行蛋白质结构预测，根据蛋白质序列的特点可以对这些序列数据进行量化和处理，再将关联规则算法用于序列数据集上寻找蛋白质序列中的关联关系。</p>
<p>随着遥感导航定位、地球物理等卫星数量的增加，空间地球大数据为地球科学研究带来新机遇。传统数据分析方法以统计分析、非线性拟合为主，其在处理多维、海量数据时存在明显不足。基于关联规则的挖掘模式可以揭示海洋、陆地、大气等地球数据之间的关系，从而推动全球变化、灾害科学领域的发展。</p>
<h3 id="优缺点">优缺点</h3>
<p>优点：</p>
<ol>
<li class="lvl-3">
<p>可以产生清晰有用的结果；</p>
</li>
<li class="lvl-3">
<p>支持间接数据挖掘；</p>
</li>
<li class="lvl-3">
<p>可以处理变长的数据；</p>
</li>
<li class="lvl-3">
<p>它的计算的消耗量是可以预见的。</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li class="lvl-3">
<p>当问题变大时，计算量增长得厉害；</p>
</li>
<li class="lvl-3">
<p>难以决定正确的数据；</p>
</li>
<li class="lvl-3">
<p>容易忽略稀有的数据。</p>
</li>
</ol>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
      </categories>
  </entry>
  <entry>
    <title>分类回归树</title>
    <url>/posts/c1d8530.html</url>
    <content><![CDATA[<h2 id="CART">CART</h2>
<p>CART:分类回归树(Classification And Regression Tree, CART)模型是决策树学习方法的一种，CART既可以用于分类计算，也可以用于回归。<br>
CART本质是对特征空间进行二元划分（即CART生成的决策树是一棵二叉树），并能够对标量属性（nominal attribute）与连续属性（continuous attribute）进行分裂。</p>
<p>CART算法原理:CART决策树是结构简洁的二叉树，采用一种二分递归分割的技术，将当前的样本集分为两个子样本集，使得生成的每个非叶子的节点都有两个分支。与普通的决策树算法一样，CART算法包括两个过程：1）决策树的生成：基于训练数据集生成决策树，生成的决策树要尽量的大；2）决策树的剪枝：用验证数据集对以生成的树进行剪枝并选择最优子树，此时用损失函数最小作为剪枝的标准。</p>
<p>1.决策树的生成决策树的生成就是递归的构建二叉决策树的过程。对回归树用平方误差最小化准则，对分类树用基尼指数最小化原则，进行特征选择，生成二叉树。主要的原理如下：(1)分类树原理：分类树采用基尼指数（Gini index, Gini）选择最优特征，同时决定该特征的最优二值切分点。基尼指数定义为：</p>
<p align="center">
<img width="200" align="center" src="/img/images/56.jpg" />
</p>
<p>对于给定样本集合D，其基尼指数的计算为：</p>
<p align="center">
<img width="200" align="center" src="/img/images/57.jpg" />
</p>
<p>如果样本集合D根据特征A是否取某一可能值a被分割成D1和D2两部分，即：<img width="300" align="center" src="/img/images/60.jpg" />,D2=D-D1<br>
则在特征A的条件下，集合D的基尼指数计算公式为：</p>
<p align="center">
<img width="200" align="center" src="/img/images/58.jpg" />
</p>
<p>基尼指数Gini(D)表示集合D的不确定性，基尼指数Gini(D,A)表示经A=a分割后集合D的不确定性。基尼指数值越大，样本集合的不确定性也就越大。</p>
<p>(2)回归树原理：回归树用平方误差最小化准则，进行特征选择，生成二叉树。将输入空间划分为M个区域R1，R2，…，Rm，则生成的回归树模型表示为：</p>
<p align="center">
<img width="200" align="center" src="/img/images/59.jpg" />
</p>
<p>其中cm表示单元Rm上的最小误差平方的最优解.</p>
<p>2、决策树的剪枝</p>
<p>CART算法对于决策树剪枝方法，采用代价复杂度模型，通过交叉验证来估计对预测样本集的误分类损失，产生最小交叉验证误分类估计树。</p>
<p>CART剪枝算法主要由两步组成：首先从生成算法产生的决策树T0底端开始不断剪枝，直到T0的根节点，形成一个子树序列{T0，T1，… ，Tn}；然后通过交叉验证法在独立的验证数据集上对子树序列进行测试，从中选择最优子树。</p>
<h3 id="相关应用">相关应用</h3>
<p>分类回归树本质上也是一种决策树算法；而决策树分类器具有很好的准确性，已被成功的应用于许多的应用领域的分类，如医学、制造和生产、金融分析、天文学与分子生物学等；具体的包括欺诈监测、针对销售、性能预测、制造和医疗整段。决策树是许多商业规则归纳系统的基础。</p>
<h3 id="优缺点-2">优缺点</h3>
<p>优点：可以生成易于理解的规则；计算量相对来说不大；可处理连续和离散字段；最终结果可清晰显示字段的重要性程度。缺点：对连续字段难以预测；处理时间序列数据，前期预处理步骤多；当类别太多，错误可能增加的较快。</p>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
      </categories>
  </entry>
  <entry>
    <title>协同过滤</title>
    <url>/posts/73e45c68.html</url>
    <content><![CDATA[<h2 id="协同过滤-2">协同过滤</h2>
<p>协同过滤算法的主要功能是预测和推荐。协同过滤推荐算法分为两类，分别是基于用户的协同过滤算法(user-based CF)，和基于物品的协同过滤算法(item-based CF)。</p>
<p>协同过滤作为一种经典的推荐算法种类，在工业界应用广泛，它的优点很多，模型通用性强，不需要太多对应数据领域的专业知识，工程实现简单，效果也不错。这些都是它流行的原因。</p>
<p>基于用户的协同过滤算法是通过用户的历史行为数据发现用户对物品喜爱程度，并对这些喜好进行度量打分。通过不同用户对商品态度和偏好程度计算用户之间的关系，对有相同喜好的用户间进行商品推荐。</p>
<p>基于物品的协同过滤算法是通过计算不同用户对不同物品的评分获得物品间的相关关系。基于物品间的相关性对用户进行相似物品的推荐。</p>
<p>相似性度量标准：常用的相似性度量标准采用欧几里德距离和皮尔逊相关系数。</p>
<p>欧几里德距离：</p>
<p align="center">
<img width="400" align="center" src="/img/images/69.jpg" />
</p>
<p>皮尔逊相关系数：</p>
<p align="center">
<img width="400" align="center" src="/img/images/70.jpg" />
</p>
<h3 id="相关应用-2">相关应用</h3>
<p>协同过滤算法的主要功能是预测和推荐。经常被用来分辨某位特定顾客可能感兴趣的东西，并给他推荐相应的产品，而这些结论主要来自于对其他相似顾客对哪些产品感兴趣的分析。协同过滤以其出色的速度和健壮性，广泛应用于互联网等领域。</p>
<h3 id="优缺点-3">优缺点</h3>
<p>优点：能够过滤基于内容的机器难以进行分析的信息；能对一些复杂、难以表达的概念进行过滤；推荐的新颖性。</p>
<p>缺点：存在稀疏性问题，如用户对商品的评价特别少，使得基于用户评价的用户间相似性计算可能不够准确；随着用户和商品的增多，系统的性能会越来越低；存在最初评价问题，即没有用户对某一商品加以评价，则这个商品便不能被推荐。</p>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
      </categories>
  </entry>
  <entry>
    <title>孤立点分析</title>
    <url>/posts/7532aa0d.html</url>
    <content><![CDATA[<h2 id="孤立点分析">孤立点分析</h2>
<p>机器学习是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。主要研究计算机怎样模拟或实现人类的学习行为，以获取新的知识和技能，重新组织已有的知识结构，不断的改善自身的性能。</p>
<p>机器学习理论主要是设计和分析一些让计算机可以自动“学习”的算法。这些算法是一类能从数据中自动分析获得规律，并利用规律对未知数据进行预测的算法。简而言之，机器学习主要以数据为基础，通过大数据本身，运用计算机自我学习来寻找数据本身的规律，而这是机器学习与统计分析的基本区别。</p>
<p>机器学习主要有三种方式：监督学习，无监督学习与半监督学习。</p>
<p>（1）监督学习：从给定的训练数据集中学习出一个函数，当新的数据输入时，可以根据函数预测相应的结果。监督学习的训练集要求是包括输入和输出，也就是特征和目标。训练集中的目标是有标注的。如今机器学习已固有的监督学习算法有可以进行分类的，例如贝叶斯分类，<code>SVM</code>，ID3，<code>C4.5</code> 以及分类决策树，以及现在最火热的人工神经网络，例如BP神经网络，RBF神经网络，Hopfield神经网络、深度信念网络和卷积神经网络等。人工神经网络是模拟人大脑的思考方式来进行分析，在人工神经网络中有显层，隐层以及输出层，而每一层都会有神经元，神经元的状态或开启或关闭，这取决于大数据。同样监督机器学习算法也可以作回归，最常用便是逻辑回归。</p>
<p>（2）无监督学习：与有监督学习相比，无监督学习的训练集的类标号是未知的，并且要学习的类的个数或集合可能事先不知道。常见的无监督学习算法包括聚类和关联，例如K均值法、Apriori算法。</p>
<p>（3）半监督学习：介于监督学习和无监督学习之间,例如EM算法。</p>
<p>如今的机器学习领域主要的研究工作在三个方面进行：1）面向任务的研究，研究和分析改进一组预定任务的执行性能的学习系统；2）认知模型，研究人类学习过程并进行计算模拟；3）理论的分析，从理论的层面探索可能的算法和独立的应用领域算法。</p>
<h3 id="算法描述-2">算法描述</h3>
<p>1.算法摘要</p>
<p>孤立点分析是数据挖掘中一个重要方面，用来发现“小的模式”(相对于聚类而言)，即数据集中显著不同于其它数据的对象。孤立点又叫离群点。</p>
<p>Hawkins(1980)给出孤立点（outlier）的定义：孤立点是在数据集中与众不同的数据，使人怀疑这些数据并非随机孤立点，而是产生于完全不同的机制。孤立点可能在聚集运行或者检测的时候被发现，比如一个人的年龄是999，这在对数据库进行检测的时候就会被发现。还有就是outlier可能是本身就固有的，而不是一个错误，比如CEO的工资就比一般员工的工资高出很多。</p>
<p>2.算法原理</p>
<p align="center">
<img width="300" align="center" src="/img/images/50.jpg" />
</p>
<p>孤立点的挖掘方法主要有：基于统计学的、基于距离的、基于密度的局部离群点方法和基于深度偏差的方法。</p>
<p>马克威孤立点算法是基于距离的：设<img width="50" align="center" src="/img/images/51.jpg" />表示p点和它的第k个最近邻居的距离。直观地看，<img width="50" align="center" src="/img/images/52.jpg" />越大，p越有可能成为孤立点。</p>
<p>给定d维空间中包含N个点的数据集、参数N（孤立点个数）和k（偏差距离）,如果满足<img width="50" align="center" src="/img/images/55.jpg" />的点<img width="20" align="center" src="/img/images/53.jpg" />不超过n-1个,那么称p为<img width="20" align="center" src="/img/images/54.jpg" />孤立点。</p>
<p>如果对所有数据点根据其<img width="50" align="center" src="/img/images/51.jpg" />距离进行从大到小排序，那么前n个点就被看作是孤立点。</p>
<p>算法步骤如下，对每个p点，计算它的第k个最近邻居的距离<img width="50" align="center" src="/img/images/51.jpg" />，把具有极大<img width="50" align="center" src="/img/images/54.jpg" />值的前个n点作为孤立点。该算法每次处理一个点p，就需要扫描一遍数据库，总共需要扫描N遍（N为数据点数）。</p>
<h3 id="算法应用">算法应用</h3>
<p>孤立点分析被广泛地应用于各种行业，如电信和信用卡欺骗（如检查购买金额或购买次数异常等）、贷款审批、药物研究（如用于发现对多种治疗方式的不寻常的反应）、气象预报、金融领域（如检查洗钱等异常行为）、客户分类（如确定极低或极高收入的客户的消费行为）、网络入侵检测等。</p>
<h3 id="相关应用-3">相关应用</h3>
<p>聚类分析、异常监测、异常欺诈、行为异常</p>
<h3 id="优点和缺点">优点和缺点</h3>
<p>优点：应用领域广泛，对异常检测、极端情况的事件发生尤其有用。</p>
<p>缺点：孤立点分析时，有时候得到的结果并不是我们想要的，是数据本身固有的一种属性，如总经理的工资待遇比员工高很多；在时间序列中寻找孤立点时，难度比较大，因为时间序列的数据可能隐藏在趋势、季节性或者其他循环规则变化中。对非整型的数值型数据，孤立点定义及分析需要特殊考虑。</p>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
      </categories>
  </entry>
  <entry>
    <title>聚类分析</title>
    <url>/posts/8e5c6000.html</url>
    <content><![CDATA[<h2 id="聚类分析">聚类分析</h2>
<p>聚类分析（Cluster analysis，亦称为群集分析）是对于统计数据分析的一门技术，在许多领域受到广泛应用，包括机器学习，数据挖掘，模式识别，图像分析以及生物信息。聚类是把相似的对象通过静态分类的方法分成不同的组别或者更多的子集（subset），这样让在同一个子集中的成员对象都有相似的一些属性，常见的包括在坐标系中更短的空间距离等。</p>
<p>一般把数据聚类归纳为一种非监督学习。</p>
<p>数据聚类算法可以分为结构性或者分散性。结构性算法利用以前成功使用过的聚类器进行分类，而分散型算法则是一次确定所有分类。结构性算法可以从上至下或者从下至上双向进行计算。从下至上算法从每个对象作为单独分类开始，不断融合其中相近的对象。而从上至下算法则是把所有对象作为一个整体分类，然后逐渐分小。</p>
<p>分割式聚类算法，是一次性确定要产生的类别，这种算法也已应用于从下至上聚类算法。</p>
<p>基于密度的聚类算法，是为了挖掘有任意形状特性的类别而发明的。此算法把一个类别视为数据集中大于某阈值的一个区域。DBSCAN和OPTICS是两个典型的算法。</p>
<p>许多聚类算法在执行之前，需要指定从输入数据集中产生的分类个数。除非事先准备好一个合适的值，否则必须决定一个大概值，关于这个问题已经有一些现成的技术。</p>
<p>在已经得到距离值之后，元素间可以被联系起来。通过分离和融合可以构建一个结构。传统上，表示的方法是树形数据结构， 然后对该结构进行修剪。树的根节点表示一个包含所有项目的类别，树叶表示与个别的项目相关的类别。</p>
<p>层次聚类算法，要么是自下向上聚集型的，即从叶子节点开始，最终汇聚到根节点；要么是自顶向下分裂型的，即从根节点开始，递归的向下分裂。</p>
<p>任意非负值的函数都可以用于衡量一对观测值之间的相似度。决定一个类别是否分裂或者合并的是一个连动的标准，它是两两观测值之间距离的函数。</p>
<p>在一个指定高度上切割此树，可以得到一个相应精度的分类。</p>
<p>主要可分为：划分方法（partitioning method），层次方法(hierarchical method)，基于密度的方法(density-basedmethod)，基于网格的方法(grid-based method)，和基于模型的方法(model-based method)。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>分层聚类算法原理</p>
</li>
</ul>
<p>开始时将N个观测量（变量）视为N类；规定相似性统计量的测度，并计算相似系数矩阵；</p>
<p>找出最大相似系数的观测量（变量）组：Sij为类Gi与类Gj的相似系数，S为相似系数矩阵或不相似系数矩阵，若S为相似系数矩阵，则依据Spq最小者挑选Gp与Gq (p&gt;q)，若S为不相似系数（距离）矩阵，则依据Spq最大者挑选Gp与Gq进行聚类，即将Gp与Gq合并成一个新类Gt（t=q）；</p>
<p>计算新类Gt与当前各类的相似性系数，更新相似系数矩阵S：将得到的新的系数代换与q相关的行与列，删除与p有关的行与列；</p>
<p>重复过程：寻找最大相似系数观测变量组和计算相似系数矩阵，直至聚为一类；</p>
<p>一共有六种分层聚类的方法，五种距离尺度标准。如：明考斯基距离、马氏距离、匹配距离等。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>快速聚类算法原理</p>
</li>
</ul>
<p>快速聚类以距离衡量样本间的亲疏程度，但其最终结果不是聚成一类，而是根据各聚类中心，将所有样本点聚成指定的类数。</p>
<p>首先设置K个聚类的初始类中心点，计算所有样本点到K个类中心点的距离，按照距离最短的原则，将所有样本分派到各中心点所在的类中，形成一个新的K类，完成一次迭代过程。在下一次迭代过程中，重新计算K个类的类中心点，重复上述过程，直到达到指定的迭代次数或达到终止迭代的判断要求为止。</p>
<p>其中K个聚类初始中心点的选取有以下方法：</p>
<p>1.可以选取前K个观测变量值为初始中心点；</p>
<p>2.最小最大原则：先选择所有样本数据中距离最远的两个值；并且选择第三个值，使得与前两个聚点的距离最小者等于所有其余数据的较小距离中最大的，依次按这个原则选取，直到最终确定K个中心点；用公式可以表示为：</p>
<p align="center">
<img width="500" align="center" src="/img/images/111.jpg" />
</p>
<p>3.模糊聚类算法原理</p>
<p>糊聚类算法根据研究对象本身的属性来构造模糊矩阵，在此基础上根据一定的隶属度来确定其分类系。系统的模糊聚类分析功能根据专家对研究对象的各指标进行打分得出原始数据。通过对原始数据进行变换、计算模糊相似矩阵、利用传递闭包法建立模糊等价矩阵，并根据给定不同的置信水平，求截阵等一系列过程对研究对象进行聚类得出模糊相似阵、分类关系阵和分类关系表。模糊聚类的具体算法过程如下：</p>
<p>a.对原始数据进行变换。变换方法通常有标准化变换、极差变换、对数变换等。<br>
b.计算模糊相似矩阵。选取在[-1，1]区间中的普通相似系数rij*=cosθ构成相似系数矩阵</p>
<p align="center">
<img width="200" align="center" src="/img/images/117.jpg" />
</p>
<p>在此基础上做如下变换：</p>
<p align="center">
<img width="50" align="center" src="/img/images/112.jpg" />
</p>
<p>使得rij*被压缩到[0,1]区间内，R=rij构成了一个模糊矩阵。</p>
<p>c.建立模糊等价矩阵。对模糊矩阵进行褶积计算: R→R2→R3→…→Rn,经过有限次褶积后使得Rn。R=Rn,由此得到模糊分类关系Rn。模糊褶积的运算法则：设A和B是n×p和p×m的模糊矩阵，则乘积C=A*B为n×m阵，其元素为：</p>
<p align="center">
<img width="300" align="center" src="/img/images/113.jpg" />
</p>
<p>符号<img width="30" align="center" src="/img/images/114.jpg" />和<img width="30" align="center" src="/img/images/119.jpg" />的含义是：</p>
<p align="center">
<img width="150" align="center" src="/img/images/115.jpg" />
</p>
<p align="center">
<img width="150" align="center" src="/img/images/116.jpg" />
</p>
<p>d.进行聚类。给定不同的置信水平λ，求Rλ截阵，找出R的λ显示，得到普通的分类关系Rλ。当λ=1时，每个样品自成一类，随λ值的降低，由细到粗逐渐并类。</p>
<p>4…基于密度的聚类为了发现任意形状的聚类结果，提出了基于密度的聚类方法。这类方法将簇看作是数据空间中由低密度区域分割开的高密度对象区域。</p>
<p>DBSCAN(Density-Based Spatial Clustering of Applications with Noise)是一个基于密度的聚类算法。该算法将具有足够高密度的区域划分为簇，并可以在带有“噪音”的空间数据库中发现任意形状的聚类。它定义簇为密度相连的点的最大集合。基于密度的聚类的基本想法涉及一些新的定义。</p>
<p>n 一个给定对象周围半径ε内的区域称为该对象的ε-邻域。</p>
<p>n 如果一个对象的ε-邻域至少包含最小数目MinPts 的对象，那么该对象称为核心对象。</p>
<p>n 给定一个对象集合D，如果p是在q 的ε–邻域内，而q是一个核心对象，我们说对象p从对象q出发是直接密度可达的。</p>
<p>n 如果存在一个对象链p1,p2,…,pn，p1=q，pn=p，对pi∈ D，1≤i≤n，pi+1 是从pi关于ε和 MinPts直接密度可达的，则对象p是从对象q关于ε和MinPts 密度可达的(density-reachable)。</p>
<p>n 如果对象集合D中存在一个对象o，使得对象p和q是从o关于ε和MinPts 密度可达的，那么对象p和q是关于ε和MinPts 密度相连的（density-connected）。</p>
<p>DBSCAN 通过检查数据库中每个点的ε-邻域来寻找聚类。如果一个点p的ε-邻域包含多于MinPts个点，则创建一个以p作为核心对象的新簇。DBSCAN 然后反复地寻找从这些核心对象直接密度可达的对象，这个过程可能涉及几个密度可达簇的合并。当没有新的点可以被添加到任何簇时，该过程结束。</p>
<h3 id="应用领域-2">应用领域</h3>
<p>在商业上，聚类能帮助市场分析人员从客户基本库中发现不同的客户群，并且用购买模式来刻画不同的客户群的特征。在生物学上，聚类能用于推导植物和动物的分类，对基因进行分类，获得对种群中固有结构的认识。聚类在地球观测数据库中相似地区的确定，汽车保险持有者的分组，及根据房子的类型，价值，和地理位置对一个城市中房屋的分组上也可以发挥作用。聚类也能用于对Web 上的文档进行分类，以发现信息。作为一个数据挖掘的功能，聚类分析能作为一个独立的工具来获得数据分布的情况，观察每个簇的特点，集中对特定的某些簇作进一步的分析。此外，聚类分析可以作为其他算法（如分类等）的预处理步骤，这些算法再在生成的簇上进行处理。</p>
<h3 id="优缺点-4">优缺点</h3>
<p>优点：</p>
<p>聚类分析模型的优点就是直观，结论形式简明</p>
<p>缺点：</p>
<ol>
<li class="lvl-3">
<p>收敛太慢</p>
</li>
<li class="lvl-3">
<p>算法复杂度高</p>
</li>
<li class="lvl-3">
<p>不能发现非凸形状的簇，或大小差别很大的簇</p>
</li>
<li class="lvl-3">
<p>需样本存在均值（限定数据种类）</p>
</li>
<li class="lvl-3">
<p>需先确定聚类中心点的个数</p>
</li>
<li class="lvl-3">
<p>对噪声和离群点敏感</p>
</li>
<li class="lvl-3">
<p>最重要是结果不一定是全局最优，只能保证局部最优</p>
</li>
</ol>
<p>不同的聚类方法，也有一定的差异性，但总体表现为：K均值稳定，谱聚类效果好， 层次聚类快。</p>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
      </categories>
  </entry>
  <entry>
    <title>自组织特征映射网络算法</title>
    <url>/posts/a0ad5c02.html</url>
    <content><![CDATA[<h2 id="SOM神经网络">SOM神经网络</h2>
<p>芬兰Helsink大学Kohonen T.教授提出一种自组织特征映射网络SOM(Self-organizing feature Map)，又称Kohonen网络。Kohonen认为，一个神经网络接受外界输入模式时，将会分为不同的对应区域，各区域对输入模式有不同的响应特征，而这个过程是自动完成的。SOM网络正是根据这一看法提出的，其特点与人脑的自组织特性相类似。</p>
<p>A.自组织神经网络结构</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>(1)定义：自组织神经网络是无导师学习网络。它通过自动寻找样本中的内在规律和本质属性，自组织、自适应地改变网络参数与结构。</p>
</li>
<li class="lvl-2">
<p>(2)结构：层次型结构，具有竞争层。典型结构：输入层+竞争层。输入层：接受外界信息，将输入模式向竞争层传递，起“观察”作用。竞争层：负责对输入模式进行分析比较，寻找规律，并归类。</p>
</li>
</ul>
<p>B.自组织神经网络的原理</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>(1)分类与输入模式的相似性：分类是在类别知识等导师信号的指导下，将待识别的输入模式分配到各自的模式类中，无导师指导的分类称为聚类，聚类的目的是将相似的模式样本划归一类，而将不相似的分离开来，实现模式样本的类内相似性和类间分离性。由于无导师学习的训练样本中不含期望输出，因此对于某一输入模式样本应属于哪一类并没有任何先验知识。对于一组输入模式，只能根据它们之间的相似程度来分为若干类，因此，相似性是输入模式的聚类依据。</p>
</li>
<li class="lvl-2">
<p>(2)相似性测量：神经网络的输入模式向量的相似性测量可用向量之间的距离来衡量。常用的方法有欧氏距离法和余弦法两种。</p>
</li>
<li class="lvl-2">
<p>(3)竞争学习原理:竞争学习规则的生理学基础是神经细胞的侧抑制现象：当一个神经细胞兴奋后，会对其周围的神经细胞产生抑制作用。最强的抑制作用是竞争获胜的“唯我独兴”，这种做法称为“胜者为王”（Winner-Take-All）。竞争学习规则就是从神经细胞的侧抑制现象获得的。它的学习步骤为：A、向量归一化；B、寻找获胜神经元；C、网络输出与权调整；D、重新归一化处理。</p>
</li>
</ul>
<p>SOM网络的拓扑结构：SOM网络共有两层。即：输入层和输出层。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>(1)输入层：通过权向量将外界信息汇集到输出层各神经元。输入层的形式与BP网相同，节点数与样本维数相同。</p>
</li>
<li class="lvl-2">
<p>(2)输出层：输出层也是竞争层。其神经元的排列有多种形式。分为一维线阵,二维平面阵和三维栅格阵。最典型的结构是二维形式。它更具大脑皮层的形象。输出层的每个神经元同它周围的其他神经元侧向连接，排列成棋盘状平面；输入层为单层神经元排列。</p>
</li>
</ul>
<p>C.SOM权值调整域</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>SOM网采用的算法，称为Kohonen算法，它是在胜者为王WTA(Winner-Take-All)学习规则基础上加以改进的，主要区别是调整权向量与侧抑制的方式不同，侧抑制是“封杀”式的。只有获胜神经元可以调整其权值，其他神经元都无权调整。Kohonen算法：获胜神经元对其邻近神经元的影响是由近及远，由兴奋逐渐变为抑制。换句话说，不仅获胜神经元要调整权值，它周围神经元也要不同程度调整权向量。</p>
</li>
</ul>
<p>d.SOM网络运行原理</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>SOM网络的运行分训练和工作两个阶段。在训练阶段，网络随机输入训练集中的样本，对某个特定的输入模式，输出层会有某个节点产生最大响应而获胜，而在训练开始阶段，输出层哪个位置的节点将对哪类输入模式产生最大响应是不确定的。当输入模式的类别改变时，二维平面的获胜节点也会改变。获胜节点周围的节点因侧向相互兴奋作用也产生较大影响，于是获胜节点及其优胜邻域内的所有节点所连接的权向量均向输入方向作不同程度的调整，调整力度依邻域内各节点距离获胜节点的远近而逐渐减小。网络通过自组织方式，用大量训练样本调整网络权值，最后使输出层各节点成为对特定模式类敏感的神经元，相应的权向量成为各输入模式的中心向量。并且当两个模式类的特征接近时，代表这两类的节点在位置上也接近。从而在输出层形成能反应样本模式类分布情况的有序特征图。</p>
</li>
</ul>
<p>自组织映射网络（Kohonen）结构见图所示，图中上层为输出层，假定有个节点，输出层中的节点是以二维形式排成一个节点矩阵，输出节点之间也可能实现局部连接，它们中的每个节点是一个输入样本的代表。输入层处于下方，若输入向量为n维，那么输入节点有n个，输入节点与输出层的所有节点通过权值实现全互联。在输出层竞争是这样进行的，对于获胜的节点，在其周围Nj区域内的节点在不同的程度上得到兴奋，而在Nj区域以外的节点都被抑制，这个趋于Nj可以是正方形也可以是六角形，如图所示。区域Nj是时间t的函数，随着的增加，Nj的面积成比例缩小，最后剩下一个节点或一组节点，它们反映一类样本的属性。自组织映射网络为一个无教师指导的、自适应、自组织的网络。</p>
<p align="center">
<img width="100" align="center" src="/img/images/10.jpg" />
</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Kohonen 网络结构</p>
</li>
<li class="lvl-2">
<p>对于任意一个输入节点i和输出节点j有：</p>
</li>
</ul>
<p align="center">
<img width="100" align="center" src="/img/images/11.jpg" />
</p>
<p align="center">
<img width="100" align="center" src="/img/images/18.jpg" />
</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Nj(t)的形状变化情况</p>
</li>
</ul>
<p>自组织映射学习算法：假定共有K个输入模式，对于某个输入模式通过竞争，逐渐收敛到样本空间所划分的K个子集的中心。当某一模式输入时，对某一输出节点给予最大的刺激，以指示该类模式的所属区域，而同时对获胜周围的一些节点给予较大的刺激。当另一输入模式输入时，获胜区域移到其它区域。</p>
<p>在训练过程中定义获胜节点的邻域为Nj(t)，表示在时刻t以节点Nj为中心的某一半径内的所有节点，随着训练过程的进行Nj(t)的半径将逐渐缩小，最后只剩Nj(t)本身。即在初始阶段不但对获胜节点Nj(t)调整权值，也对其周围节点调整权值，直到最后仅对Nj(t)调整权值。保证对于某一类输入模式，获胜节点做出最大的响应，而相邻节点做出较大的响应。几何上相邻的节点代表特征相近的模式。Kohonen网络的具体算法为：</p>
<p>① 连接权值的初始化</p>
<p align="center">
<img width="200" align="center" src="/img/images/19.jpg" />
</p>
② 对网络输入一个样本模式。
<p align="center">
<img width="200" align="center" src="/img/images/20.jpg" />
</p>
<p>③ 计算Xk与全部输出节点间的权值向量W的距离</p>
<p align="center">
<img width="200" align="center" src="/img/images/21.jpg" />
</p>
<p>④ 选择有最小距离的节点Nj*为竞争获胜节点</p>
<p align="center">
<img width="200" align="center" src="/img/images/22.jpg" />
</p>
<p>⑤ 调整权值</p>
<p align="center">
<img width="100" align="center" src="/img/images/23.jpg" />
</p>
其中，0＜α(t)＜1，为增益函数，随着时间t而递减。β(Nj,Nj*)，随着Nj*距离递减。
⑥ 若还有输入样本则转②，当所有的样本输入完，且满足：
<p align="center">
<img width="100" align="center" src="/img/images/24.jpg" />
</p>
<p>或者完成指定的学习次数后算法结束，否则转②。</p>
<p>α(t)和Nj*(t)没有一般化数学方法，凭经验选取。初始时，Nj*(t)选取较大，后逐渐变小，α(t)开始时较大，后逐渐变为0。</p>
<h3 id="相关应用-4">相关应用</h3>
<p>SOM网络是自组织竞争型神经网络的一种，该网络为无监督学习网络，能够识别环境特征并自动聚类。</p>
<h3 id="优点-3">优点</h3>
<ol>
<li class="lvl-3">
<p>对输入模式的自动聚类；</p>
</li>
<li class="lvl-3">
<p>网络结构简单，具有很好的生物神经元作用；</p>
</li>
<li class="lvl-3">
<p>容错性；</p>
</li>
<li class="lvl-3">
<p>具有特征映射的能力；</p>
</li>
<li class="lvl-3">
<p>具有可视化的优点；</p>
</li>
<li class="lvl-3">
<p>网络具有自稳定性；</p>
</li>
<li class="lvl-3">
<p>具有自联想性，</p>
</li>
</ol>
<h3 id="缺点：">缺点：</h3>
<ol>
<li class="lvl-3">
<p>聚类数目和初始网络结构固定，需要用户预先制定聚类数目和初始的权值矩阵；</p>
</li>
<li class="lvl-3">
<p>可能会出现一些始终不能获胜的”死神经元“，和一些因为经常获胜被过度利用的神经元，不能充分利用所有神经元信息而影响聚类质量；</p>
</li>
<li class="lvl-3">
<p>要想往SOM网络中加入新的类别必须先完整的重新学习之后方可进行；</p>
</li>
<li class="lvl-3">
<p>数据的输入顺序会影响甚至决定了输出的结果，数据量少时尤为明显；</p>
</li>
<li class="lvl-3">
<p>连接权值初始值、计算策略，参数选择不当时会导致网络收敛时间过长，甚至不能收敛。</p>
</li>
</ol>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
      </categories>
  </entry>
  <entry>
    <title>自适应共振</title>
    <url>/posts/515ae7e0.html</url>
    <content><![CDATA[<h2 id="ART-Adaptive-Resonance-Theory-神经网络">ART(Adaptive Resonance Theory)神经网络</h2>
<p>在神经网络学习中，当网络规模给定后，由权矩阵所能记忆的模式类别信息量总是有限的，新输入的模式样本必然会对已经记忆的模式样本产生抵消或遗忘，从而使网络的分类能力受到影响。靠无限扩大网络规模解决上述问题是不现实的。如何保证在适当增加网络规模的同时，在过去记忆的模式和新输入的训练模式之间作出某种折中，既能最大限度地接收新的模式信息，同时又能保证较少地影响过去的样本模式呢？ ART网络在一定程度上能较好解决此问题。</p>
<p>1976年，美国Boston大学CarpenterG.A.教授提出了自适应共振理论ART(Adaptive Resonance Theory). 自适应共振理论(Adaptive Resonance Theory, ART)神经网络模型用于数据聚类。它在学习过程中实现了稳定性与可塑性的统一,这一特性使ART网络成为在入侵检测环境下数据聚类的一个非常合适的选择。随后Carpenter G.A.又与他的学生GrossbergS.合作提出了ART神经网络。</p>
<p>经过多年的研究和发展，ART 网络已有几种基本形式：</p>
<p>(1) ART1型神经网络：处理双极性和二进制信号；</p>
<p>(2) ART2型神经网络：它是ART1型的扩展，用于处理连续型模拟信号；</p>
<p>(3) ART综合系统：将ART1和ART2综合在一起，系统具有识别﹑补充和撤消等综合功能。即所谓的3R（Recognition﹑Reinforcement﹑Recall）功能。</p>
<p>(4) ART3型神经网络：它是一种分级搜索模型，兼容前两种结构的功能并将两层神经网络扩大为任意多层神经元网络，由于ART3型在神经元的模型中纳入了生物神经元的生物电－化学反应机制，因而它具备了很强的功能和扩展能力。</p>
<h3 id="算法应用-2">算法应用</h3>
<p>ART1神经网络可以根据输入的数据，作无监督或无教师归纳，自动形成和自动确定数据类别。该算法主要对布尔类型的数据聚类。</p>
<h3 id="优点和缺点-2">优点和缺点</h3>
<p>主要优点</p>
<ol>
<li class="lvl-3">
<p>可完成实时学习，且可适应非平稳的环境；</p>
</li>
<li class="lvl-3">
<p>对已学习过的对象具有稳定的快速识别能力，同时又能迅速适应学习的新对象；</p>
</li>
<li class="lvl-3">
<p>具有自归一能力，根据某些特征在全体中所占的比例，有时作为关键特征，有时又被当做噪音处理；</p>
</li>
<li class="lvl-3">
<p>不需要事先已知结果，可非监督学习；</p>
</li>
<li class="lvl-3">
<p>此系统可以完全避免陷入局部最小点的问题</p>
</li>
</ol>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
      </categories>
  </entry>
  <entry>
    <title>自适应提升算法</title>
    <url>/posts/ce4446e7.html</url>
    <content><![CDATA[<h2 id="AdaBoost">AdaBoost</h2>
<p>自适应提升（AdaBoost：Adaptive Boosting）算法是基于概率近似正确的学习模型下提出的一种提升算法。在分类问题中，AdaBoost通过修改训练样本的权值分布，学习多个弱分类器，并将这些分类器进行线性组合，构成一个强分类器，提高分类性能。其中强分类器可理解为分类精确度高的算法，弱分类器可理解为分类精度低的算法，一般AdaBoost算法是弱分类器的线性组合为：</p>
<p align="center">
<img width="160" align="center" src="/img/images/74.jpg" />
</p>
<p>AdaBoost算法的特点是通过迭代每次学习一个基本分类器(即弱分类器)。每次迭代中，提高那些被前一轮分类器错误分类数据样本的权值，而降低那些被正确分类的数据样本的权值。最后算法将基本分类器的线性组合作为强分类器，其中给分类误差率小的基本分类器以大的权值，给分类误差率大的基本分类器以小的权值。其中极小化损失函数表达式为：</p>
<p align="center">
<img width="300" align="center" src="/img/images/75.jpg" />
</p>
<h3 id="算法原理">算法原理</h3>
<p>假设给定一个二分类的训练数据集T={(x1,y1),(x2,y2),…,(xn,yn)}；其中，每个样本点由实例与标记组成。实例<img width="=50" align="center" src="/img/images/76.jpg" /><img width="100" align="center" src="/img/images/77.jpg" />其中X是实例空间，Y是标记集合。AdaBoost算法的原理如下：</p>
<p>输入：训练数据集T={(x1,y1),(x2,y2),…,(xn,yn)}；其中<img width="=50" align="center" src="/img/images/76.jpg" /><img width="100" align="center" src="/img/images/77.jpg" /></p>
<p>输出：最终的分类器G(x)</p>
<p>(1)初始化训练数据集的权值分布</p>
<p align="center">
<img width="300" align="center" src="/img/images/78.jpg" />
</p>
<p>(2)对于m=1,2,…,M<br>
(a)使用具有权值分布Dm的训练数据集学习，得到基本分类器</p>
<p align="center">
<img width="100" align="center" src="/img/images/79.jpg" />
</p>
<p>(b)计算Gm(x)在训练数据集上的分类误差率</p>
<p align="center">
<img width="300" align="center" src="/img/images/80.jpg" />
</p>
<p>©计算Gm(x)的系数</p>
<p align="center">
<img width="100" align="center" src="/img/images/84.jpg" />
</p>
<p>(d)更新训练数据集的权值分布</p>
<p align="center">
<img width="300" align="center" src="/img/images/81.jpg" />
</p>
<p align="center">
<img width="300" align="center" src="/img/images/86.jpg" />
</p>
<p>其中Zm是规范化因子</p>
<p align="center">
<img width="200" align="center" src="/img/images/82.jpg" />
</p>
<p>(3)构建基本分类器的线性组合</p>
<p align="center">
<img width="200" align="center" src="/img/images/83.jpg" />
</p>
<p>得到最终分类器为</p>
<p align="center">
<img width="200" align="center" src="/img/images/85.jpg" />
</p>
<h3 id="相关应用-5">相关应用</h3>
<p>AdaBoost算法主要用于分类问题。它是通过改变训练样本的权重，学习多个分类器，并将这些分类器线性组合，以提高分类的性能。它的应用范围非常广泛，可用于二分类或多分类的应用场景，可用于特征选择等。</p>
<h3 id="优点-4">优点</h3>
<p>优点：分类精度很高的分类器；弱分类器容易构造；算法简单，不用做特征筛选；不用担心过拟合</p>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
      </categories>
  </entry>
  <entry>
    <title>canal 基础入门(基于1.1.4)</title>
    <url>/posts/249c59e6.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="27b5fcb1739495f52fc766fd51b50417359da9db0b0f640b85652e41763eaa75">a8cefacc35a4b9cc130a23421f1e88bcd3da19bc85c03fe1ed0e9e63bbb759353c16dbc78f2aef8cc1d17774c43cfdafd82c229b72143c11fd6134bd3c1ecabcc3dfbbbba1b1b226f372f12094b387b3b7b78ac12a9c893a10da4dd077db42b8a9833ec73d59624f6d36730c080ff2b40442804e3f83b7607dc86e35862665fad9d3874f3eb174bb2cfd17a00a42ab6dbee3208a026140b55cbd2f356674adfab174028cd4710249bdbfcbc52c8b6def79f4f4a80906e4e7b1602d7eb3f64da57bc61b62e4c3f78604f4a80bfe34a053873e85b406124d006fcd0e426391d6ad313c4529595f8a7b0f529e0528fd1891b9a3689e073a0a27111066aa4877e136fab7df74b6d365b9bfff7fd28e8092cd368750a579e2a7f30cc8e3779adf1fd2e6888bfa2baf03ff1e69b0aa7b340d809eaf603db86760a0a145a6cf8e0dcc295935933456dce67a158c30b1aca409ad6a738727293ec06a4909892d5c807d70223a154b76ae42b73a87dfd34f7c4121fd398cb06a8f8fc1f1a6e0692b3fe9409f1f833269cee20b9a774a62a1aa0b3539d62967d385f452428f716d573d11a9f9d4a2b7204a1bbf8935c75fe2d122ea1ff8477efc1670b1fca48fd27c56529b3fa15ead629d34b8fb46a0eb877a16e1a73d61da5a6dc385f944ea4a698b0ffa6dc92ebaf13c7a11cc6658e8d8f385cd196bcc7ddd0e724b95c746b58828af422869cd661499dae22ac864a87ab18371cff542bc49d62d09ae23bbd6614d422aadc5e54bc311f1e4293022536940bd20872b9ea775df2f27332e96cd61ac30fb1c482cb35d9ad2141cddb6c948002863d9efb58f31cda81b2ab755f71fab34db4e5ae2bbccc6646545aa83e31d4f46f82d6ca93a69f9e4b7e76e2f0395b4a8304d69120408e1e2867ecfcbaae09f2e1ec3f91b5d13791dd55a67638ab4f860b010af585c0848b09f3bb522a524ec654db012d7bbd79c4d4735f20e8d0c521a4a38f676068e687fc8a1097f3f814e9fe8a196316d90ea65dd64b0476a8d6888d93eaf6862f03053fc163794c63004041d2b56ad682353b26e5b36698bcb8e0145d8413cf8cccc9d6530669edfc2d2f9ffc1a4f24eef6af0c42434e9da531b4637d526f6e3d6d83e2c84ba0aea4380801f98dbd1ec70f45edb8475f6dbdadcdeb9402f71cf1c2fa6a0cd2c45b3d48613d8261afd93b39d2c88dd4df11ca462a850f2424c287f3a9316828a6d1440fdd41df8077ac9d3db21a175d68bca3219cc4f360c42450bfb735ca5a161e0c44097eec26c444e3c436ec32a2a663c27b230a11d5de1b572423462749469ad8043ac627ea71cab177ca3877c8e30eb502a03d2c0d4244873627b2ab827540e89b298bfb42d5cc6834cb43f895c8f3282586fa27e54363f8a99361b96819243b2f45a56d63ce466f348991530a636471baf9591af4142c423c2f5fefdc5a1d6862d22e1422e9c1db312d1fe8d6341c76891b970b7e6fd023d9feb6a9befdd2af325c131567a3ec42dfa558743fb1e7ec1999da7a107d02a79968a9ba69bdfb45a987248c5274e3dcb33c809deeb530b02bab584ff515c880b42b154c329a9a3d4ee19237cdfdad6fdff4992dd4bb67c191a48fc325e56df1c4f45cb2ada4c4b70d4d0c374c44cb0984b832e8f495296883db707c590b2d361aabe3a27f395b05cb1d77fc91c48fa203cf2c82fe11cf2af8da90159d6c698fe1eb6887f971583fac9da5b72cdf6771a38edde76f6fe682f8f6257ed97c99b283f02b458b50d6aae67ab39e1ac3c5862fc787576696650c63b529d643f790b07c55580aa4cf5770b887ec274e5359d19010b77d15504b8d7bdd8074114a818cf09a5a8bee242667cc8e81b120bee675f83e8f51cb39c0f267cfbb4c89658898106e7124bb58e68d6ea325f78e8bb5bbccfd2051219d52c1ee4e0d2c0241e48b766a552c3fdba47b3451d4e8da42fd7476cc720df2f6ecd3f72fedb2446782a7c8fa8fc85271a5390d25ea2d979802e7a6c821fe7893978e48cdddba0ea97064aaf756b6036ed690de0517f72942d9c266cf9fa0722621011324275403e3e11c049327e5067327393dc72b9c262ff5437bbd4423dd4f15ce3024209c79f509054d3cb423d77b39b426203a80824fc517b215ba2a068e1ae520973b616f2263812ff4728b7d7da970940aaf02a9bc8d550e097d9c27b177e00d46a7587d8476fd15edb5c48bd96b38b4dcf6ebea5fcaddbb9f77b71d3e793584e37d1d131cf7280d5e242fb246e27856ccc4d030a74306e2990763cae664dc6fcd8c4244c6e47767754fad68cf4276ee617f7ca4df8e95ae174f74efb257b03af0f5b60da6a6f52947103c2dd8df52bcdedb21861ce39553f18c8bae693bb5953973a62838af927f10d775b3cf1afb52404a2e0cb8a229baefa8c518c1016db91674433122893d19b5d90f08431ee8a1a989f545cbbce2c3722919b8c476291c9b1c293fec545feb059ab6ae1dc2c12f0e8c04ad2f2a0ad8af90387cdde23a04f0d1628e479c030fb09b0263f979cc9944627e2cb978b313444e5672b0f9fdaa41e624b23692556839f1ffe336a4fd664fcf4a8bb2285ac9fe4c13cf30beffb3a895f8b53430cbedffa89b6734f0b701c2fc980287d9c30ac9dca73d98e4fc26f5cb976d19c9cbafd4f5ef4ba89ec1d274d420ff7563c0714841e24be589f37de028718dfc22ef7a551b6685d7408ab82d7ddc9acd36e5f33b75b604ffbb033113a87b79dfd3164858fbeba5ed18c0fc83f4b14f1c775eef584ca1481e1ab3da4f355330f3a83c05e0ecd681064a3554c97aa2a873109a3564881c70298535c3a0035d6adeb8c3300960e314639e1973e30f52c1d7b14cb76dbdbd140afa375bb02b7ed4e527cd0cc87254ba70cc94499a0b5964c51875c4132233b303b0a61adb5545952505c5c611cf41fa802da11d164f49550c17beb5ed0f634a5392c74b93e70334d84f1141344eb203cb9018af3937f484e6c4b714536cea440e3235effe17a27dc997f40ac5b04b8693356e6d70cf6e91698e6e621e2e9a804b448ab5699207d36b54ebd1e45458eb74c8c6d38c12cb2d28ecf772b873d98bc3c5bc0ac5809c99d320adeb1271f1b1f64e6ec9d95a97f5700fc47948d9c9c991791d849c774198d345d5818d03c48fcc732583ab4c2f7b39ef4100454dff4a8940258e792ad4604caf2520bfba3eb0eadfc203a300b357474097213eed4a5bef20557eeb8cf51e1c429d5391f2215bc8d505a45c65f8ee3de39a66f3863b3e6429e47d1a784702b105552236fb19ea419fd03e8dfe20635f62d8aab5dda7b5175f7a8fd8cf1ea991944b6237a35335a87cc1f874406c54f29929171bc5535ae033cde6c94f89d4db7eb0eb4034053194454b9bd7bf1ea4a9ba382e0cb002b6ca6d31a7fc9a0cd6d566acf02c3d7e98e2628cb58a1f1fc1ed82218ac4e8d01911dab442987cc4eedd6bd40cc8bc2d8cac8e2aeb33c78ace436895798d9770e9d2bd3fc309be3214b584770b46995ffc9115df1e09ae67a90f25bb550eb3b6f803fdbbdf309ad966b2bb7e4723f62c141d1fceac5f98d183da7e3f7cf8f26187daa9e4d1ed155686045ac92abfff6889e50a6a851c22f2a973a0f6d66710f018120b46302f819e697f1d33e52978d78815107926ba50d14db06d0f46f4ffc25d33a20181dcbd0105cd668aeb408a1da3a3c0e287e111d608eae976c781d846ba0349ccc5d2956c18678a0cf7cd483dd47ecd249c4ad2f8fc4d42c50f3a6054e9d528fb6934eaacc5d3f120a3ba031a4aa8d485c792d1997ab641877f799458cfd8d6f1683d62389c5e605e969a7e1259d10131cdcc59a3b4563d8e9a24c90ec03a8cfd5f3c5f3181589fc0734fa471d9109b1758e1513797ebbbc34d4970bf9c61e434bd1a7783a00ba3be3180e7b87c39f3fedb0e083b074ee31f4cdcb983ed1c874d2dec41ca6dff7289a65afe573e64ad365a0aafdd190ad6ebd67021d581d514a34600d7f98874edf31274042965865bf57d0ef72e86d43b63ea8b66f9495a53efb5bcfbe3747204c4335717f49330936399a4c8a7e1b9f05c7e6f43d5986d04d5560d629c7c71eb27ccb7603ce0ce795006de5c9d24c2735cbcb2bd2b2e92e65210afd37ee089d384df95aaf397af75cec82c0f32e3fcb54abc43fce0f3e8101c8127a46a08c0bf01b761fefc03bade95f4b18cc2b2297eb853df63abc24bd49984beaaedd7afbc7958da6031175ad909e1c703815ee5dd14c7ed057a71dff413da17a425dff3ce90c2e3ca476c2960a077f86b4df687f2bb0b7cfdaa093efd94d30f94fc523647d5d12ecdf87064ee9cfee0e62169d8e2bd8545d14552a6e02bbe56baa4134f5ecf0ad1e71e84d77eaff320caf8bd8c40f1c0c9eca585d225de47e1db54d0b6a0a02354e8a3f3b28531c84e0558c2485516606733c3f35c88243959c8e48eeada7d8076326ad1af038373367c376eba9e668468ab001321f535f22d4d3b653e050ca646d711a0571ef69a5239455b3b4b8b707db35c8fab66f0fbc413d3de387f242a1f78cea80343e25d18baffb41f03990a7b33c9214dfc1caa02d125aa586fb4f90dd76e2df6d48d59bf351cc1667e5f68b6c920fedb08f37f01cd801de7dc70d1f016cf2a322c0f4a0ff390aa8b3349a3c61bdf61091ee9caadac6dba91a885346bff785adefefa3972c8b884018fa030b50a126966183c34d6cd9d1a6b04863270a8295691e96e12e4f0b67794fe6d1af606d7e24d3ae1ee8856866c67d0e2a521ed92d634f51e9ed7c4926378c412344fe00a3a799aa89102ac085e40bb9136d9d94a57cd73623ae915b87b91c8039570f0abe4da4a60d172df521351faaf16bf6d9d42f8eb1509ecf31cc1b02b6838a011c31b97ee9cc0686a0805110bd6123056c0354a9596a47bcd5042cbfd232528cef2eab6a17913299687aecaf9349f868e7041897d3a3cb324d0fe656b1c4cee3a14fd32c8c1594af95345345d355217195b204da21b235ef87bb4f2954007acdc80cd09c3d8d6343b6c92fb33b3f9726e6ea1bdfdac501947cc41871cd48a744741ed5107bb69272a129ee53a384294185ce7002bce301c851efdbd288fce60b11b224960022b220ddcf5730300a74a1ef465217525ae3aad9a1cdced7af463322cc313c20f6fb998212dde91a5802338ae68662e8d9d7cc6699330f28c2bd53d655bead7e3742e1e4612f01266e9cf34d5c0bef29c7982b107412cf21c2eb01f89dbd4517b6f9f6b62a518faddc83966e24a7f154dbf01e6de35538f8bec93620c82118e3d6f2ad25a4867e9ae5cc02341352938a62d379bbb19e0eb4f29b36e0cb4c120920ea58a4fc574be21c0ca25b3e15fa486ad855cf1bfeabc5074c99656307a7e90a2c594fe12594e57d365c642b29e1ab79a373be9f297e80a00567a0a4f508787d3f693f2e5a3a433ed7a81ac84835ac8be1b815b85fd99040172c2d1c7a2c35c7079cf171f727a91cc5c64b2f4da2134bb5a694c244786ef33a4feb12c2a8872e88cb1a9c6ea462edac7be2cf0ab6a7bb5df4e0f045d4b60243e552781a15a7d2cbc60d2c7888eee8add3c46835abfb13cb175be0f1878e48fdcceebb02d0df21edcac222cb93e775cb1287cfb83fb5c9701e7c91c5b3cc845a85c4579f7a5d54c29a4f1939ea6cc860601f7d9e17fd032ed3a07c6dcef46a55a709cf5bdb3d12c77bb843562b39e5c43772d42d9a5040415d90da53522ba1e9294c535ef8cfa46c5dedb4994ef7613d6d81757d3153191eaa340f70622f3c9aee1a4ec669b9cc89e19e8b5fc08114f3603c1bfe305cdeebf9918b44cf75b4c84308becef404189e635eea7a32c49cbeef2c0d720eaaab6a1406762c75534daa576be94e8d37cee32df216df23351430e16ccb9ca45ede53cd716accc23ebc4fa53f426eb927c6194198fcd81c5682ec084c08f8396e4f3a726decc68fe3ee731437b213894cc597492c5df7f886470affc9990983145e5f447fcff0fd7cb6bbb81d4e83343f54aa1be51ded2b59477559d402164fbfa5ab3cb259650c5e5cb7fc69d60ac35e97c0b477015489624f0fa07d408ccd3e7f86c8c461c99402adaf70f0b06b3384206247388c04eea34a8d59943c332c98dc1c0654a99782fee837cf746b8899e60b380fbae7b6b9598f5dd2400dc4c5612e915608c67a9864e9640403a7fdd388db93663e8407352f84472acb87bfceb9da1c7bfafe2dc9d06b8d6507339fa327546aa10a6afe7ae78a86eb51bb55da5f19be8b2d872bc2fafa8229e14b494e45fb7914d296d9ff401456ed1884ca63b12386c7de127d5a5c869ed2dc7050b418e8e1f940cdd8ecf14a10d408b4e4582bfdd3982704b98d96c8c28a3827d718ad6af0c82b7f4017b2ba04adae0fc708b056351d28a9aa57cd2252ec31f58b849ac871fba9c0050619f2a50a4c67c1dc7f527243cfab6f634cb4e71d069785d5e50289d09949df76e2902f894b6990df2581e4188d6259f1e207b9d3abd7a519d6f5d4f14e49553e68b88a24b435eb6076cbfbc7d40914362e9719794bec689b670e3af3da35cbbe707953a5b8fc6b17ab2eb22839f9020c3af87f295d6761cb0befae5cc2c2f482979c907d9eea02fb0031f351020144809cecf6c984d53298a805ed1ff442e29c673235af78de09463c6c5e1ae0a81d405687d93bfe6ee1743f88ff49517a91af7420704f47f40ebd3ec8aeb43fa6ac94f3cbd7c9303f6e2e1e30cd26ee792629ac43afad061bbc70bc9c4fc2ee9975e5333f24c0a0dd3c94b9772eec14dd3237abd70f989f1930982bc0991e8f358e93b97173ec122a3e74ef73b470feeb255cc7e18b59f6649285e3e0c5ef121edbaa68e98a69984fbf859a31b96f3e4acfc3727f3ae64d780c824ff45968653a4c0ac1254df28df688dcf5318473cb5a87e453fceba1e0c74cbf2d3b86922cdd75a00aa435f088afd8bd3faf5887a46626341b0ef0655162ece67071908cbe1046ecc71e63e888be78c862ac0fdbfe56cd8a79377d63cf606665eea4ec52b2f0eae2f96b3582f97ed4eebb8636eba391c5d18760f7b3fa6fcb313200669b9b4c048e5acb9915f3a395ea758f5ef68f11bd6d1cf42478de839a46b9178ade0c8ac61bc4e703d2503df345ab7fc4dccaa0ea1006d02c30a57f01bf175d6120a8deb8626e5131ae832637fd1672ab9314ccbb4c86fef12f349c77e075c4abeb3207e5a6172f8f7108651c4cc5466865293c6bc49cd6d6d1b996c53fc502cb085f21dc25371becccb18728876e2102c71f9724d3b603b7c7115185940d0dcb30071327ae80845cf89a6422210eaedd2d5ca6615867afae7c7583608d3d105e9d03d74c14a22947e3f346e0f322f7e2abf1c8a5ab4eddac7b4159788f02df6ebea1d640b10fe6ec65e1307ca0fe6999c1070f6c8244fe38ea2366ecf74f94c89fe2c73b3cf11e7ad66529dc5a11dcc7fdd076db434c533c9221a55b3f1784704dacccc004915ee0dc0fd3e5d4f59d11f7dcde6047f0620c8f6bb1a112fcdfb7debbde21d63ac0e30dcdd7cf54146c15fe6df14b9ef20356d8a2de48856fff958dc7cfc25142f41de9d5d0a3963e43bc9fc142f51c4521dca271665505a1c9e53a7440547d74ae207d2278b1e15401f10a23ba356293eda1aa1e85c1bceb889e7f888e1ee767ce46a38e635a5927ab395b98c720807e2a697d54944f95234dafb3131d15fc495b6e50bdc841b48716d66466cac7a1c0deae4d9a6166a4109ac2860657abcf277374364fd7ea4126d940a57e7d7fbc7a95afd15629751dad13e84a601b5d2b86b59e8ae6bcdde5ab26a7617296512aac7bd135f101ba76a41830bd64453c08597b9163d43af69c62c867dc9c76acb6677cc2bd4c633a97c7ee499c5519af65abce9793eb83ab21b5218f7b54c52148ef4934c95d2d6a748e47b26f9d0592bb55d888e48beafcda544a7952fc8d06bae57820cff85d568560bc565d0a61f37793fdfc482351bbed939d092970cf26e3a7c7e2af9f6ea49085e8883260d1c75521f71fbb8be8ef70a0075b64a3935233994550cee34d30bfab6bf698c93f2f27bcfabd43da85130554c69ed39f6cb73ae481f31d8f07d7b3c2ab1c0f6e785344715f13fe471baacb42172cea5dd843726bc78b405a95e53565ca6a9a834a39d0bffe78ba0063e0e0aecfc839c38e99e75c84dd7f1988e35aa558e108c36aba50c773d9dfb521031ac22713f57b111762fddb24eb9d2478a8aa673c950001c51eee85e3600e043816d81c8e543731226ae4cd76a7126af26d3a3841fc2e56bfe118206fa03f730358059b239963295800420af6b3506838bd69402629c887f9bcf3bf44c5efa21773fe9156825102ccfa71268141ae57fca14e09b4145ac78178428c9725a49b4227a6ef479c865c8a1486ff43178eb05fddb230cb36315f6cff0a9891a0b78a6ded0f81fc25dcdbf8cd2fa5df4ff1154ce6785d292b57023be5d2511661ddb58c211273afe0fa5b2d9d856df7910cb5c257eebe306ef8715dbb1dc5be0a4945ca700d3f1c5b9fb6d0e0e9c800ee41e750de1f33b9b870a18153d3e84ce19c689b819e3e6d4a38c64f7712d612df2da08e4b0e4da98a4ca063f1b80eca146a5d991371f407feadf7e28a85435746940af201338dec139a801ac6be18c3dce7cd3d5d536b5ea82e75a00bd0721679a0e796ad56ae811b57d443e7e3d497dc5f073669506c3b50b423a78e9e4ff341bb96a0ceb22cdbee2ae32df0d6f78efb31f19b9a9a6119bcdd590222476037bafb2ddcb104ca92959f1d3d90fb4355e47a2448453e17020d2d65124186a495272a0a377c83b2f62a93631287083270e0dce816097f96e7654066b0e798331bcb96e8b5e0aad8d873f410c3db63c6aca20427650eb540398c0d6942bd12fff231529356b4ef5a4ed96bb714570a1447b3359783bc7caba6c770db4f385d1ad7c1465624f590605bb6eef4224695d48368d74ef863bcacfa40c82cc202cab5c50b9c908aeddb3ad106f81369d12ae13aba7b24509bccfa3d7a6939ee61212130fdbf6216545ce8938d2170d8b0876eeb11560ea29df095b6ef66e2a0e81892c8a4c9388b687f01dc554601fbd798b7741215e7df085031f8368cd1afaafc01f4c0c69db0864f9916e904c0a62616dac672010f55a08c44db1cfdbd64ee967559cd55632adc24a64bfc264882a2750d1df648a140e7da9c59a1ad8a6450d26eb290050a83f6cc34faef38eef9f30cf0eeed842d6a6c5a938c690dac49f4828c9e42d40310f274760342b3458cdee9dc6074ba938b45c5ce767a5db012d702517e23baf1f967ce8a2f5bac20a7fb742cbcc550b7a9ca7f397eda6b4ffbe55c96fecea60d28595e57fe112e6c59f64e6a288f555986540146225a311ed85a7ac4ae55eb1edfc8294cd79734cf4fc4fb5094c48b3dc82b99b8efd06ab38afd63b45c947e5d0c64a20f79d1c091d3274c68bbf215a0a020b52ab6556f7e41cdbc0ad47d4012e04d81b6d8da3bef3768fec56a380f8f0392770c650f958223aecdff12cc132ac19f9afdd9cee3b7b27c0dc186cdb7bdcfa8be6e05d64a87819f6c26b53d469ec858fea0470b37913a15ae920fe6cbd84b98a6f03780c6faabc4586035050a748ee5e46cff7e6c10ed9bce498a391d6bc9f64496e3397114fd8a3772051de10681626979bb18cb695b02ee67ec19bdc457190a5b911237766c4c3432f8e7b17dfb79d2aec03d1409dc83e3d6ecd6d2232321a04da5ffd33eb1571cf122b8620475eb6f1bd981e4b0f3ca1c7537523998631915b119c699d4f141bbacf0cb3b71bb1fabbc900b98a42618f4098df89b0f146f298402ef206d2b981d3d88b8a1f6c3083194643f928d3f5901b8fd450fd0fd59ce5c094cd40235a4e748b8dc2a11c102aeba0b356ebd3fcfccb027226dbb50bbd0a4ff52b8cf1e9199e56f34cac28e21af01fab855d4d12483f77f7fc592681e2cb21ee5fc31aed72772c1d232183717e9863d82881c8505b5c50c0e0943718d0b2f6b10bb253046de4ecbe2acf11eb0d035b2b4b657bd1d7a9acb67fad522f24fcdb81713e55ebebbcc1c7b0afe15332cce8662f911a4e1e21fe1a7e3ea5f87ee71ec466a82f5cb94b2b2066db845df8d5be8a87e6873e0c7744a884ef3d185252dcf9320adb8690f483cdee5484b974096a7a328cb30b990fe1627f67122f011702f6d9e3a001c4118065829147d1ad540da2e8bfec73ae8ce9541dc5cabd1e0d828988d74a0fc82271176fe9945aa1e8270e9a010e6e79c35d3e3e34bb4b46dd4f23a49c55dcd4159ff72298d8e82102a82e7ad1b66ea197d22565be444fbc13d3c6de4d24c3a77307d260dbbf61da9882dc56f97475483ddea581730cfbfb013ff26088a69f497d9c511d1cd5e21f33f688fe2fafd3fc45940594a6026a1d52449074d938bbe6398b5c00ad3ee5feb04807bb53754a146eb6810a11bf98f1570234810c0e41d27402460aac455d0f194e33800e355ca583325825b6f1055ac5684e134cb840aba2c90efe57cf5f74706dcd0742ddb82a64e2942212b2f1ba786325258b89af264d7a5e0e853c22a08645d4b953633fb01f11e2377f576dd709ae3aa2c282a1ab335b4bbdb6a38e0bd27ab55804a86f178b69f0a998737505103be0db0825a6e1cb6bebc4946f1aa4606efea3d197bdb02b142fa712b9fc9e904eee3c84106a7d7aabd6745358893e0ac98790cacf6e2fb77a8155aa22965db7bc15e7dba54203a49b0b63f2411d6b954a6a64dbadad7f6c264cc285442092d95e21768cc48ee0471b0b89452b7ad69d90f04dafbe964fb7c833cf620b9865d26695bb6bc464a0fe8463b6dd22c172c595421e10d3ef1210a1d3170f1b78525656af849101cb984b8cb8e90aafbaf8a12e1bd315ed350efe6e3c799b2b6ead59b51800397d5e8aa7d69919d0ba4ceb2b80dd05b2e815b8e68eb0c968cd29e8bb628d5563719b618dfd73f17775eb6e990fa145f6664a5c4b637eb886c4685680e2d7970263a47aed6b012d1351f0741c125fd3ad55d13cc5d0fc85936ddc9d65d797d2986043c0f19eee21d46d2ffab9c2ee7820ad01e24d0ec6de967419ba44a64c215b8815a8348a61bfca9f6773331895547746fed13162439fa1df741ee6d4968dbb503b01db14d29a4998a2b2cfcea452542bc0a41531c75fa7265c0f61ce0850705365afd013da6ed8893b0b2d3e40b379f9e94a63af005f8f5195835853322cdbbdab7524a4c4e5ec5da92980bc33eb779ff1a8f7c18b3e3d7ccd4f04ef4d5d8aa91af998c907dddf5124fef230a75545433001c28d967524f9fbf0f864d0c470c6f1234f1d0f230b3353eaed8bfa24b016946933532f0f13843ab1ad2ce3159a06e2c2626373aa0769833fc7da44ae6ce925df216aaf63cb97824c74dbb8f80be50bcdb3cf4a60251df1ee920a8281f91b887725a3e6fdec9a370a46bdf328aef0659e1a990cfd21683d765608dcbf70d4302fd30637714ef7553e1825a70a0bb5d4b2c2ac769f90cc32798bbd029d47a9d9b9db0dc2e638d64af89a414ce29fd96326dac1090a771263d96c2a50e9223008919b87eedd6f9b40c70db7e61cdd695676a0f10bcb7b7a15427991f788d3c6142eb93d1908029f6e895b68eb65b899eac514c0fca555b16ef5c47f23d96b041d8ff57f55777df30fa8e143cdf9eb23269682aa12911c73f24dee94aa2331521cc0e132a42dcfbe16e45d3cbaf7195b52097cae57866df5236fbde8d6b1b42f8f4dc2226e42eba0900423cf11cb3869981e45f13f7cc59ea84c51f70a0dec66183188c6f975aad5fe94749eb47454cf4e719da1c6c2b6d84b7271a6409bfa8ead35fdb42e25ef7fb34820a3c0df4b5456159c65379c4af37eb5845ff116f1319824fdcd027a715a6e15570d4efcd52962442682c079e43f143970b2153020eb5e2b6a37660a8b880e1efcbaad722b57408e93480d09cd660a0ebd6e0751f0bc84d006b4358f1126367e821863b7137c86122ff70415850af33351af1fcfd2f2fc48115b1efc0d8776250b6ec44a5586280cffade2043caa75a467606f9378396b69ab133467880ab6006681e0ca31ce9775fc1fbf1980f0d4290f38e7efc8be9ab88e99c034a65df9c70fd24960c55000999351d802c216de534b02b7845ae688931f409142148146623ddc6101d2a6ee40a29ae54e8c24a4c621286fc03cecf096950b3e7d012e5f883abe390d685334d2dbe94709c5ee2e27f719b62a4d1e353aba6ab481f1a2c60daee840584ba5e449d3916ea78f8383ae9e7d58abc062041dc319b633716253517e10cb78269be0ae4dd3c109eac557470f806c8a3b082ee9dfb1b0ca95f46c72ef119f091080d331c38fabd532e61bc5c2b38c9b205e401730fef3b40dc3000c35bfbb28e46446bc1e40c828520dd348b0a0ede95583522f1fd6a7ebec9c1c397c39315ecc7c20677d8a6354aa0684188e36b786d6341c7b06dfaf32fd28cc11d31d246d79628aee1808b6f1c5394365343d9da0061999c87b63cb86ecbc7d4a54df3ecb6f68eef32269dc88536b0a8029b0430dba36f26d1f2679e47bb6ca9e6d91360745b12434adf25f24f1a01598aba8dac57d9ce6d954613cecc0d7ffeb0a75ddc08de948028e3ac1eb67bad55ddc09b3c9118a23ae095b9773b03dd80d4b6e54db9be5c66de29a31ec4c26fbe5765f991e8b3815c60e68175fb9691cc22bd208d5696a45d454ba63744707890193e47b892b19c8525b6a7a229e1b6cfc6d08a929f6ace188e3330bba21501dc6462aef6501943b2400e496388ed52e6ddd3668327dd17e6cb4e7c6a89e9b2f931ed490309b6bffc51ce79345bfae9c19458558155f2bbc287c54c7c8051f46a5c347a9a19b326211106a7faac33a0163d12c71e32a53601d87131e6ca173db4b9b02836380b0905404628c96434b01842f75f94deef3c885f933aa5f7b58d9fbb2a352de7ce375ccb3d33b71d39e4ef923703eba092bfeab22ea7c2b394baf140ebe9b1b09fec97e8f39c0f54a520466006401e8e953fc035dd2d88256eb0fcebcd0c5651f2efdf4f07f5ea8ce26f75d3402269762f47c306cfa7d9cc5c04f66e9df9733aaac049870fd5b335e12ac4658540bb11b6daf46bda5b057cb9a789e26ba5aebb5adde77cd4c5f8f66e8c8487e81f2f1f021f387c9cfb2ee3315cd9b87cc3539264e336c2b958f40b90f43097c578062847a29439bbe43471aff9d3b26963c6f5176011e069bab73f7de998f8fd08921ec1cb6cfddca69daeb769761209c67e7c1ae0324e13446ba4142c38dd6e1a42cf5a4d7cfda3f7eb7e85cdc75cb421d8b1b3d5669c107e144f9ae257e921e864a40bdb9dfac6a6d8933865339937ef1d3a26076e83ea99275a4d729917b36f776206a8455d2b9ae0289735e1b757b84cf33950a89a83d23cf669cd019a127707ebce1a95ded7ad9763cccda34ef24af76ab3c0ea424ae54127c1c408500af9bb89ca733472b22606b3d53a862cf283d875d136aa363d16e1af30bbeb27b244795531e271372301b816eba67b7d429b89fb66c98592e309d3df1816bfbfe3e02025e51f7daa975c96a1fe6facd119624bdb4796daccc0d71cc55f3c6e610f3c11197072f35fc452b14c990f46b1d58b5dcbef211537d1f875f135f0895d8db0d7c2fa08ec1c6b2ff5f94545ce92b254fa76f516262834165f987e5f75617d00e662f2a59cf0bc0e18585bb16d2aa78e3d8d3343206f16a2c32ce5a2d45c43832f057f868e373bbd8080d850b15f698e4bda092b66e325e01ca8667cd4118c1b369af60fb3580dce3af545218d6d2e834257217a155b1594b5e36d9560efca962c6e1f3de296becd9b0b5b8d085235894e4c26564f020b40c65e3bd221659fdb5fce668b74d56f366c4b3280325ca98e8f0ecc3957a813d9c6a5b41f9174d11671989d93dfcce47e7a2cd36f12ca859ddf5a9211d5754deac18ecb090710c27c048ac71ce3515f4d54e067ec360150928cc7e40449ec69dd823359feb6b5e7c3ac8ea8c41f5fc248f6c66672b427e29678ed4a4744b4970641a4665f1c1e498010271c4e174b1707f0d054d5033c230558282f6316f9ee07a7ad0db01f11bfa9e34b92c89973a70e54815e8fea84ac2bde3ef6b62ff88a18d750eaaebf54b9e667d70c3a61c487a9dcdac5c0d7f304792715c20b932ff421172c9eabe8752c47458104d061db323a6dbfd96a463b7736052fc7d3620e16b6bb69b4c2ae34dc82183059a8fc439e9b866a6ffbaed2ba0ce4764657689f2fcb1ae861d8e462098eb2771d005759cce1cf06d208e2257d8710feda86620699c0d2c064dfb9a0271a1f093ecd9dd89a16f3260cd786c9ccb0bd1d2cf93d9d00823f5ddc3772ee70c288130a7b42afda98571ca72ce775ca34a17aff980d0a23e489a4056c3692887e08e067ec86ffef9846fe0d5f24c6a1efdc79b37abfc25b249e1c7db7f370302072dcf0ceb387ec73796aa462060aeb12e371b4ca295e714761c744d60e810429785d7716195a4e2a37cd5e5bcacded5d771f69e1d0fbaafa66b9ea41622aa462e8d064b6dfe8bfc2e1cdd2ba72b68c207630d52beb2ceea4571fcf5fa66c6f2422367722fab0848ee86264f73e74dcf572dda40dbe68108d168fa25658ed4ed5559e91122ceadddfab5052c4bedc48c80330</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>中间件</category>
        <category>canal</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka消费者详解</title>
    <url>/posts/ba56d3ed.html</url>
    <content><![CDATA[<h2 id="一、消费者和消费者群组">一、消费者和消费者群组</h2>
<p>在 Kafka 中，消费者通常是消费者群组的一部分，多个消费者群组共同读取同一个主题时，彼此之间互不影响。Kafka 之所以要引入消费者群组这个概念是因为 Kafka 消费者经常会做一些高延迟的操作，比如把数据写到数据库或 HDFS ，或者进行耗时的计算，在这些情况下，单个消费者无法跟上数据生成的速度。此时可以增加更多的消费者，让它们分担负载，分别处理部分分区的消息，这就是 Kafka 实现横向伸缩的主要手段。</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka-consumer01.png"/> </div>
<p>需要注意的是：同一个分区只能被同一个消费者群组里面的一个消费者读取，不可能存在同一个分区被同一个消费者群里多个消费者共同读取的情况，如图：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka-consumer02.png"/> </div>
<p>可以看到即便消费者 Consumer5 空闲了，但是也不会去读取任何一个分区的数据，这同时也提醒我们在使用时应该合理设置消费者的数量，以免造成闲置和额外开销。</p>
<h2 id="二、分区再均衡">二、分区再均衡</h2>
<p>因为群组里的消费者共同读取主题的分区，所以当一个消费者被关闭或发生崩溃时，它就离开了群组，原本由它读取的分区将由群组里的其他消费者来读取。同时在主题发生变化时 ， 比如添加了新的分区，也会发生分区与消费者的重新分配，分区的所有权从一个消费者转移到另一个消费者，这样的行为被称为再均衡。正是因为再均衡，所以消费费者群组才能保证高可用性和伸缩性。</p>
<p>消费者通过向群组协调器所在的 broker 发送心跳来维持它们和群组的从属关系以及它们对分区的所有权。只要消费者以正常的时间间隔发送心跳，就被认为是活跃的，说明它还在读取分区里的消息。消费者会在轮询消息或提交偏移量时发送心跳。如果消费者停止发送心跳的时间足够长，会话就会过期，群组协调器认为它已经死亡，就会触发再均衡。</p>
<h2 id="三、创建Kafka消费者">三、创建Kafka消费者</h2>
<p>在创建消费者的时候以下以下三个选项是必选的：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>bootstrap.servers</strong> ：指定 broker 的地址清单，清单里不需要包含所有的 broker 地址，生产者会从给定的 broker 里查找 broker 的信息。不过建议至少要提供两个 broker 的信息作为容错；</p>
</li>
<li class="lvl-2">
<p><strong>key.deserializer</strong> ：指定键的反序列化器；</p>
</li>
<li class="lvl-2">
<p><strong>value.deserializer</strong> ：指定值的反序列化器。</p>
</li>
</ul>
<p>除此之外你还需要指明你需要想订阅的主题，可以使用如下两个 API :</p>
<ul class="lvl-0">
<li class="lvl-3">
<p><strong>consumer.subscribe(Collection&lt;String&gt; topics)</strong>  ：指明需要订阅的主题的集合；</p>
</li>
<li class="lvl-2">
<p><strong>consumer.subscribe(Pattern pattern)</strong>  ：使用正则来匹配需要订阅的集合。</p>
</li>
</ul>
<p>最后只需要通过轮询 API(<code>poll</code>) 向服务器定时请求数据。一旦消费者订阅了主题，轮询就会处理所有的细节，包括群组协调、分区再均衡、发送心跳和获取数据，这使得开发者只需要关注从分区返回的数据，然后进行业务处理。 示例如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> topic = <span class="string">&quot;Hello-Kafka&quot;</span>;</span><br><span class="line"><span class="type">String</span> group = <span class="string">&quot;group1&quot;</span>;</span><br><span class="line"><span class="type">Properties</span> props = <span class="keyword">new</span> <span class="type">Properties</span>();</span><br><span class="line">props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;hadoop001:9092&quot;</span>);</span><br><span class="line"><span class="comment">/*指定分组 ID*/</span></span><br><span class="line">props.put(<span class="string">&quot;group.id&quot;</span>, group);</span><br><span class="line">props.put(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line"><span class="type">KafkaConsumer</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; consumer = <span class="keyword">new</span> <span class="type">KafkaConsumer</span>&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*订阅主题 (s)*/</span></span><br><span class="line">consumer.subscribe(<span class="type">Collections</span>.singletonList(topic));</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">/*轮询获取数据*/</span></span><br><span class="line">        <span class="type">ConsumerRecords</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; records = consumer.poll(<span class="type">Duration</span>.of(<span class="number">100</span>, <span class="type">ChronoUnit</span>.<span class="type">MILLIS</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">ConsumerRecord</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; record : records) &#123;</span><br><span class="line">            <span class="type">System</span>.out.printf(<span class="string">&quot;topic = %s,partition = %d, key = %s, value = %s, offset = %d,\n&quot;</span>,</span><br><span class="line">           record.topic(), record.partition(), record.key(), record.value(), record.offset());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本篇文章的所有示例代码可以从 Github 上进行下载：<a href="https://gitee.com/oicio/BigData-Notes/tree/master/code/Kafka/kafka-basis">kafka-basis</a></p>
</blockquote>
<h2 id="三、-自动提交偏移量">三、 自动提交偏移量</h2>
<h3 id="3-1-偏移量的重要性">3.1 偏移量的重要性</h3>
<p>Kafka 的每一条消息都有一个偏移量属性，记录了其在分区中的位置，偏移量是一个单调递增的整数。消费者通过往一个叫作 <code>＿consumer_offset</code> 的特殊主题发送消息，消息里包含每个分区的偏移量。 如果消费者一直处于运行状态，那么偏移量就没有什么用处。不过，如果有消费者退出或者新分区加入，此时就会触发再均衡。完成再均衡之后，每个消费者可能分配到新的分区，而不是之前处理的那个。为了能够继续之前的工作，消费者需要读取每个分区最后一次提交的偏移量，然后从偏移量指定的地方继续处理。 因为这个原因，所以如果不能正确提交偏移量，就可能会导致数据丢失或者重复出现消费，比如下面情况：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果提交的偏移量小于客户端处理的最后一个消息的偏移量 ，那么处于两个偏移量之间的消息就会被重复消费；</p>
</li>
<li class="lvl-2">
<p>如果提交的偏移量大于客户端处理的最后一个消息的偏移量，那么处于两个偏移量之间的消息将会丢失。</p>
</li>
</ul>
<h3 id="3-2-自动提交偏移量">3.2 自动提交偏移量</h3>
<p>Kafka 支持自动提交和手动提交偏移量两种方式。这里先介绍比较简单的自动提交：</p>
<p>只需要将消费者的 <code>enable.auto.commit</code> 属性配置为 <code>true</code> 即可完成自动提交的配置。 此时每隔固定的时间，消费者就会把 <code>poll()</code> 方法接收到的最大偏移量进行提交，提交间隔由 <code>auto.commit.interval.ms</code> 属性进行配置，默认值是 5s。</p>
<p>使用自动提交是存在隐患的，假设我们使用默认的 5s 提交时间间隔，在最近一次提交之后的 3s 发生了再均衡，再均衡之后，消费者从最后一次提交的偏移量位置开始读取消息。这个时候偏移量已经落后了 3s ，所以在这 3s 内到达的消息会被重复处理。可以通过修改提交时间间隔来更频繁地提交偏移量，减小可能出现重复消息的时间窗，不过这种情况是无法完全避免的。基于这个原因，Kafka 也提供了手动提交偏移量的 API，使得用户可以更为灵活的提交偏移量。</p>
<h2 id="四、手动提交偏移量">四、手动提交偏移量</h2>
<p>用户可以通过将 <code>enable.auto.commit</code> 设为 <code>false</code>，然后手动提交偏移量。基于用户需求手动提交偏移量可以分为两大类：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>手动提交当前偏移量：即手动提交当前轮询的最大偏移量；</p>
</li>
<li class="lvl-2">
<p>手动提交固定偏移量：即按照业务需求，提交某一个固定的偏移量。</p>
</li>
</ul>
<p>而按照 Kafka API，手动提交偏移量又可以分为同步提交和异步提交。</p>
<h3 id="4-1-同步提交">4.1 同步提交</h3>
<p>通过调用 <code>consumer.commitSync()</code> 来进行同步提交，不传递任何参数时提交的是当前轮询的最大偏移量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.of(<span class="number">100</span>, ChronoUnit.MILLIS));</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.println(record);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*同步提交*/</span></span><br><span class="line">    consumer.commitSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果某个提交失败，同步提交还会进行重试，这可以保证数据能够最大限度提交成功，但是同时也会降低程序的吞吐量。基于这个原因，Kafka 还提供了异步提交的 API。</p>
<h3 id="4-2-异步提交">4.2 异步提交</h3>
<p>异步提交可以提高程序的吞吐量，因为此时你可以尽管请求数据，而不用等待 Broker 的响应。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.of(<span class="number">100</span>, ChronoUnit.MILLIS));</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.println(record);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*异步提交并定义回调*/</span></span><br><span class="line">    consumer.commitAsync(<span class="keyword">new</span> <span class="title class_">OffsetCommitCallback</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, Exception exception)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;错误处理&quot;</span>);</span><br><span class="line">             offsets.forEach((x, y) -&gt; System.out.printf(<span class="string">&quot;topic = %s,partition = %d, offset = %s \n&quot;</span>,</span><br><span class="line">                                                            x.topic(), x.partition(), y.offset()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异步提交存在的问题是，在提交失败的时候不会进行自动重试，实际上也不能进行自动重试。假设程序同时提交了 200 和 300 的偏移量，此时 200 的偏移量失败的，但是紧随其后的 300 的偏移量成功了，此时如果重试就会存在 200 覆盖 300 偏移量的可能。同步提交就不存在这个问题，因为在同步提交的情况下，300 的提交请求必须等待服务器返回 200 提交请求的成功反馈后才会发出。基于这个原因，某些情况下，需要同时组合同步和异步两种提交方式。</p>
<blockquote>
<p>注：虽然程序不能在失败时候进行自动重试，但是我们是可以手动进行重试的，你可以通过一个 Map&lt;TopicPartition, Integer&gt; offsets 来维护你提交的每个分区的偏移量，然后当失败时候，你可以判断失败的偏移量是否小于你维护的同主题同分区的最后提交的偏移量，如果小于则代表你已经提交了更大的偏移量请求，此时不需要重试，否则就可以进行手动重试。</p>
</blockquote>
<h3 id="4-3-同步加异步提交">4.3  同步加异步提交</h3>
<p>下面这种情况，在正常的轮询中使用异步提交来保证吞吐量，但是因为在最后即将要关闭消费者了，所以此时需要用同步提交来保证最大限度的提交成功。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">ConsumerRecords</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; records = consumer.poll(<span class="type">Duration</span>.of(<span class="number">100</span>, <span class="type">ChronoUnit</span>.<span class="type">MILLIS</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">ConsumerRecord</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; record : records) &#123;</span><br><span class="line">            <span class="type">System</span>.out.println(record);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 异步提交</span></span><br><span class="line">        consumer.commitAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="type">Exception</span> e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 因为即将要关闭消费者，所以要用同步提交保证提交成功</span></span><br><span class="line">        consumer.commitSync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        consumer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-4-提交特定偏移量">4.4 提交特定偏移量</h3>
<p>在上面同步和异步提交的 API 中，实际上我们都没有对 commit 方法传递参数，此时默认提交的是当前轮询的最大偏移量，如果你需要提交特定的偏移量，可以调用它们的重载方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*同步提交特定偏移量*/</span></span><br><span class="line">commitSync(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets) </span><br><span class="line"><span class="comment">/*异步提交特定偏移量*/</span>    </span><br><span class="line">commitAsync(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, OffsetCommitCallback callback)</span><br></pre></td></tr></table></figure>
<p>需要注意的是，因为你可以订阅多个主题，所以 <code>offsets</code> 中必须要包含所有主题的每个分区的偏移量，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.of(<span class="number">100</span>, ChronoUnit.MILLIS));</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">            System.out.println(record);</span><br><span class="line">            <span class="comment">/*记录每个主题的每个分区的偏移量*/</span></span><br><span class="line">            <span class="type">TopicPartition</span> <span class="variable">topicPartition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TopicPartition</span>(record.topic(), record.partition());</span><br><span class="line">            <span class="type">OffsetAndMetadata</span> <span class="variable">offsetAndMetadata</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OffsetAndMetadata</span>(record.offset()+<span class="number">1</span>, <span class="string">&quot;no metaData&quot;</span>);</span><br><span class="line">            <span class="comment">/*TopicPartition 重写过 hashCode 和 equals 方法，所以能够保证同一主题和分区的实例不会被重复添加*/</span></span><br><span class="line">            offsets.put(topicPartition, offsetAndMetadata);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*提交特定偏移量*/</span></span><br><span class="line">        consumer.commitAsync(offsets, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、监听分区再均衡">五、监听分区再均衡</h2>
<p>因为分区再均衡会导致分区与消费者的重新划分，有时候你可能希望在再均衡前执行一些操作：比如提交已经处理但是尚未提交的偏移量，关闭数据库连接等。此时可以在订阅主题时候，调用 <code>subscribe</code> 的重载方法传入自定义的分区再均衡监听器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/*订阅指定集合内的所有主题*/</span></span><br><span class="line">subscribe(Collection&lt;String&gt; topics, ConsumerRebalanceListener listener)</span><br><span class="line"> <span class="comment">/*使用正则匹配需要订阅的主题*/</span>    </span><br><span class="line">subscribe(Pattern pattern, ConsumerRebalanceListener listener)    </span><br></pre></td></tr></table></figure>
<p>代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">consumer.subscribe(Collections.singletonList(topic), <span class="keyword">new</span> <span class="title class_">ConsumerRebalanceListener</span>() &#123;</span><br><span class="line">    <span class="comment">/*该方法会在消费者停止读取消息之后，再均衡开始之前就调用*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPartitionsRevoked</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;再均衡即将触发&quot;</span>);</span><br><span class="line">        <span class="comment">// 提交已经处理的偏移量</span></span><br><span class="line">        consumer.commitSync(offsets);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*该方法会在重新分配分区之后，消费者开始读取消息之前被调用*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPartitionsAssigned</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.of(<span class="number">100</span>, ChronoUnit.MILLIS));</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">            System.out.println(record);</span><br><span class="line">            <span class="type">TopicPartition</span> <span class="variable">topicPartition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TopicPartition</span>(record.topic(), record.partition());</span><br><span class="line">            <span class="type">OffsetAndMetadata</span> <span class="variable">offsetAndMetadata</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OffsetAndMetadata</span>(record.offset() + <span class="number">1</span>, <span class="string">&quot;no metaData&quot;</span>);</span><br><span class="line">            <span class="comment">/*TopicPartition 重写过 hashCode 和 equals 方法，所以能够保证同一主题和分区的实例不会被重复添加*/</span></span><br><span class="line">            offsets.put(topicPartition, offsetAndMetadata);</span><br><span class="line">        &#125;</span><br><span class="line">        consumer.commitAsync(offsets, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六-、退出轮询">六 、退出轮询</h2>
<p>Kafka 提供了 <code>consumer.wakeup()</code> 方法用于退出轮询，它通过抛出 <code>WakeupException</code> 异常来跳出循环。需要注意的是，在退出线程时最好显示的调用 <code>consumer.close()</code> , 此时消费者会提交任何还没有提交的东西，并向群组协调器发送消息，告知自己要离开群组，接下来就会触发再均衡 ，而不需要等待会话超时。</p>
<p>下面的示例代码为监听控制台输出，当输入 <code>exit</code> 时结束轮询，关闭消费者并退出程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*调用 wakeup 优雅的退出*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">mainThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;exit&quot;</span>.equals(sc.next())) &#123;</span><br><span class="line">            consumer.wakeup();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/*等待主线程完成提交偏移量、关闭消费者等操作*/</span></span><br><span class="line">                mainThread.join();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.of(<span class="number">100</span>, ChronoUnit.MILLIS));</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; rd : records) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;topic = %s,partition = %d, key = %s, value = %s, offset = %d,\n&quot;</span>,</span><br><span class="line">                              rd.topic(), rd.partition(), rd.key(), rd.value(), rd.offset());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (WakeupException e) &#123;</span><br><span class="line">    <span class="comment">//对于 wakeup() 调用引起的 WakeupException 异常可以不必处理</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    consumer.close();</span><br><span class="line">    System.out.println(<span class="string">&quot;consumer 关闭&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="七、独立的消费者">七、独立的消费者</h2>
<p>因为 Kafka 的设计目标是高吞吐和低延迟，所以在 Kafka 中，消费者通常都是从属于某个群组的，这是因为单个消费者的处理能力是有限的。但是某些时候你的需求可能很简单，比如可能只需要一个消费者从一个主题的所有分区或者某个特定的分区读取数据，这个时候就不需要消费者群组和再均衡了， 只需要把主题或者分区分配给消费者，然后开始读取消息井提交偏移量即可。</p>
<p>在这种情况下，就不需要订阅主题， 取而代之的是消费者为自己分配分区。 一个消费者可以订阅主题（井加入消费者群组），或者为自己分配分区，但不能同时做这两件事情。 分配分区的示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;TopicPartition&gt; partitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;PartitionInfo&gt; partitionInfos = consumer.partitionsFor(topic);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*可以指定读取哪些分区 如这里假设只读取主题的 0 分区*/</span></span><br><span class="line"><span class="keyword">for</span> (PartitionInfo partition : partitionInfos) &#123;</span><br><span class="line">    <span class="keyword">if</span> (partition.partition()==<span class="number">0</span>)&#123;</span><br><span class="line">        partitions.add(<span class="keyword">new</span> <span class="title class_">TopicPartition</span>(partition.topic(), partition.partition()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为消费者指定分区</span></span><br><span class="line">consumer.assign(partitions);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;Integer, String&gt; records = consumer.poll(Duration.of(<span class="number">100</span>, ChronoUnit.MILLIS));</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;Integer, String&gt; record : records) &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;partition = %s, key = %d, value = %s\n&quot;</span>,</span><br><span class="line">                          record.partition(), record.key(), record.value());</span><br><span class="line">    &#125;</span><br><span class="line">    consumer.commitSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="附录-Kafka消费者可选属性">附录 : Kafka消费者可选属性</h2>
<h3 id="1-fetch-min-byte">1. fetch.min.byte</h3>
<p>消费者从服务器获取记录的最小字节数。如果可用的数据量小于设置值，broker 会等待有足够的可用数据时才会把它返回给消费者。</p>
<h3 id="2-fetch-max-wait-ms">2. <a href="http://fetch.max.wait.ms">fetch.max.wait.ms</a></h3>
<p>broker 返回给消费者数据的等待时间，默认是 500ms。</p>
<h3 id="3-max-partition-fetch-bytes">3. max.partition.fetch.bytes</h3>
<p>该属性指定了服务器从每个分区返回给消费者的最大字节数，默认为 1MB。</p>
<h3 id="4-session-timeout-ms">4. <a href="http://session.timeout.ms">session.timeout.ms</a></h3>
<p>消费者在被认为死亡之前可以与服务器断开连接的时间，默认是 3s。</p>
<h3 id="5-auto-offset-reset">5. auto.offset.reset</h3>
<p>该属性指定了消费者在读取一个没有偏移量的分区或者偏移量无效的情况下该作何处理：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>latest (默认值) ：在偏移量无效的情况下，消费者将从最新的记录开始读取数据（在消费者启动之后生成的最新记录）;</p>
</li>
<li class="lvl-2">
<p>earliest ：在偏移量无效的情况下，消费者将从起始位置读取分区的记录。</p>
</li>
</ul>
<h3 id="6-enable-auto-commit">6. enable.auto.commit</h3>
<p>是否自动提交偏移量，默认值是 true。为了避免出现重复消费和数据丢失，可以把它设置为 false。</p>
<h3 id="7-client-id">7. <a href="http://client.id">client.id</a></h3>
<p>客户端 id，服务器用来识别消息的来源。</p>
<h3 id="8-max-poll-records">8. max.poll.records</h3>
<p>单次调用 <code>poll()</code> 方法能够返回的记录数量。</p>
<h3 id="9-receive-buffer-bytes-send-buffer-byte">9. receive.buffer.bytes &amp; send.buffer.byte</h3>
<p>这两个参数分别指定 TCP socket 接收和发送数据包缓冲区的大小，-1 代表使用操作系统的默认值。</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka生产者详解</title>
    <url>/posts/88c8c32e.html</url>
    <content><![CDATA[<h2 id="一、生产者发送消息的过程">一、生产者发送消息的过程</h2>
<p>首先介绍一下 Kafka 生产者发送消息的过程：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Kafka 会将发送消息包装为 ProducerRecord 对象， ProducerRecord 对象包含了目标主题和要发送的内容，同时还可以指定键和分区。在发送 ProducerRecord 对象前，生产者会先把键和值对象序列化成字节数组，这样它们才能够在网络上传输。</p>
</li>
<li class="lvl-2">
<p>接下来，数据被传给分区器。如果之前已经在 ProducerRecord 对象里指定了分区，那么分区器就不会再做任何事情。如果没有指定分区 ，那么分区器会根据 ProducerRecord 对象的键来选择一个分区，紧接着，这条记录被添加到一个记录批次里，这个批次里的所有消息会被发送到相同的主题和分区上。有一个独立的线程负责把这些记录批次发送到相应的 broker 上。</p>
</li>
<li class="lvl-2">
<p>服务器在收到这些消息时会返回一个响应。如果消息成功写入 Kafka，就返回一个 RecordMetaData 对象，它包含了主题和分区信息，以及记录在分区里的偏移量。如果写入失败，则会返回一个错误。生产者在收到错误之后会尝试重新发送消息，如果达到指定的重试次数后还没有成功，则直接抛出异常，不再重试。</p>
</li>
</ul>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka-send-messgaes.png"/> </div>
<h2 id="二、创建生产者">二、创建生产者</h2>
<h3 id="2-1-项目依赖">2.1 项目依赖</h3>
<p>本项目采用 Maven 构建，想要调用 Kafka 生产者 API，需要导入 <code>kafka-clients</code> 依赖，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-创建生产者">2.2 创建生产者</h3>
<p>创建 Kafka 生产者时，以下三个属性是必须指定的：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>bootstrap.servers</strong> ：指定 broker 的地址清单，清单里不需要包含所有的 broker 地址，生产者会从给定的 broker 里查找 broker 的信息。不过建议至少要提供两个 broker 的信息作为容错；</p>
</li>
<li class="lvl-2">
<p><strong>key.serializer</strong> ：指定键的序列化器；</p>
</li>
<li class="lvl-2">
<p><strong>value.serializer</strong> ：指定值的序列化器。</p>
</li>
</ul>
<p>创建的示例代码如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SimpleProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    public static void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> topicName = <span class="string">&quot;Hello-Kafka&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Properties</span> props = <span class="keyword">new</span> <span class="type">Properties</span>();</span><br><span class="line">        props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;hadoop001:9092&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        <span class="comment">/*创建生产者*/</span></span><br><span class="line">        <span class="type">Producer</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; producer = <span class="keyword">new</span> <span class="type">KafkaProducer</span>&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">ProducerRecord</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; record = <span class="keyword">new</span> <span class="type">ProducerRecord</span>&lt;&gt;(topicName, <span class="string">&quot;hello&quot;</span> + i, </span><br><span class="line">                                                                         <span class="string">&quot;world&quot;</span> + i);</span><br><span class="line">            <span class="comment">/* 发送消息*/</span></span><br><span class="line">            producer.send(record);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*关闭生产者*/</span></span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本篇文章的所有示例代码可以从 Github 上进行下载：<a href="https://gitee.com/oicio/BigData-Notes/tree/master/code/Kafka/kafka-basis">kafka-basis</a></p>
</blockquote>
<h3 id="2-3-测试">2.3 测试</h3>
<h4 id="1-启动Kakfa">1. 启动Kakfa</h4>
<p>Kafka 的运行依赖于 zookeeper，需要预先启动，可以启动 Kafka 内置的 zookeeper，也可以启动自己安装的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">zookeeper启动命令</span></span><br><span class="line">bin/zkServer.sh start</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">内置zookeeper启动命令</span></span><br><span class="line">bin/zookeeper-server-start.sh config/zookeeper.properties</span><br></pre></td></tr></table></figure>
<p>启动单节点 kafka 用于测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">bin/kafka-server-start.sh config/server.properties</span></span><br></pre></td></tr></table></figure>
<h4 id="2-创建topic">2. 创建topic</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">创建用于测试主题</span></span><br><span class="line">bin/kafka-topics.sh --create \</span><br><span class="line">                    --bootstrap-server hadoop001:9092 \</span><br><span class="line">                     --replication-factor 1 --partitions 1 \</span><br><span class="line">                     --topic Hello-Kafka</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看所有主题</span></span><br><span class="line"> bin/kafka-topics.sh --list --bootstrap-server hadoop001:9092</span><br></pre></td></tr></table></figure>
<h4 id="3-启动消费者">3. 启动消费者</h4>
<p>启动一个控制台消费者用于观察写入情况，启动命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">bin/kafka-console-consumer.sh --bootstrap-server hadoop001:9092 --topic Hello-Kafka --from-beginning</span></span><br></pre></td></tr></table></figure>
<h4 id="4-运行项目">4. 运行项目</h4>
<p>此时可以看到消费者控制台，输出如下，这里 <code>kafka-console-consumer</code> 只会打印出值信息，不会打印出键信息。</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka-simple-producer.png"/> </div>
<h3 id="2-4-可能出现的问题">2.4 可能出现的问题</h3>
<p>在这里可能出现的一个问题是：生产者程序在启动后，一直处于等待状态。这通常出现在你使用默认配置启动 Kafka 的情况下，此时需要对 <code>server.properties</code> 文件中的 <code>listeners</code> 配置进行更改：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">hadoop001 为我启动kafka服务的主机名，你可以换成自己的主机名或者ip地址</span></span><br><span class="line">listeners=PLAINTEXT://hadoop001:9092</span><br></pre></td></tr></table></figure>
<h2 id="二、发送消息">二、发送消息</h2>
<p>上面的示例程序调用了 <code>send</code> 方法发送消息后没有做任何操作，在这种情况下，我们没有办法知道消息发送的结果。想要知道消息发送的结果，可以使用同步发送或者异步发送来实现。</p>
<h3 id="2-1-同步发送">2.1 同步发送</h3>
<p>在调用 <code>send</code> 方法后可以接着调用 <code>get()</code> 方法，<code>send</code> 方法的返回值是一个 Future&lt;RecordMetadata&gt;对象，RecordMetadata 里面包含了发送消息的主题、分区、偏移量等信息。改写后的代码如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ProducerRecord</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; record = <span class="keyword">new</span> <span class="type">ProducerRecord</span>&lt;&gt;(topicName, <span class="string">&quot;k&quot;</span> + i, <span class="string">&quot;world&quot;</span> + i);</span><br><span class="line">        <span class="comment">/*同步发送消息*/</span></span><br><span class="line">        <span class="type">RecordMetadata</span> metadata = producer.send(record).get();</span><br><span class="line">        <span class="type">System</span>.out.printf(<span class="string">&quot;topic=%s, partition=%d, offset=%s \n&quot;</span>,</span><br><span class="line">                metadata.topic(), metadata.partition(), metadata.offset());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="type">InterruptedException</span> | <span class="type">ExecutionException</span> e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时得到的输出如下：偏移量和调用次数有关，所有记录都分配到了 0 分区，这是因为在创建 <code>Hello-Kafka</code> 主题时候，使用 <code>--partitions</code> 指定其分区数为 1，即只有一个分区。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">topic=Hello-Kafka, partition=0, offset=40 </span><br><span class="line">topic=Hello-Kafka, partition=0, offset=41 </span><br><span class="line">topic=Hello-Kafka, partition=0, offset=42 </span><br><span class="line">topic=Hello-Kafka, partition=0, offset=43 </span><br><span class="line">topic=Hello-Kafka, partition=0, offset=44 </span><br><span class="line">topic=Hello-Kafka, partition=0, offset=45 </span><br><span class="line">topic=Hello-Kafka, partition=0, offset=46 </span><br><span class="line">topic=Hello-Kafka, partition=0, offset=47 </span><br><span class="line">topic=Hello-Kafka, partition=0, offset=48 </span><br><span class="line">topic=Hello-Kafka, partition=0, offset=49 </span><br></pre></td></tr></table></figure>
<h3 id="2-2-异步发送">2.2 异步发送</h3>
<p>通常我们并不关心发送成功的情况，更多关注的是失败的情况，因此 Kafka 提供了异步发送和回调函数。 代码如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="type">ProducerRecord</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; record = <span class="keyword">new</span> <span class="type">ProducerRecord</span>&lt;&gt;(topicName, <span class="string">&quot;k&quot;</span> + i, <span class="string">&quot;world&quot;</span> + i);</span><br><span class="line">    <span class="comment">/*异步发送消息，并监听回调*/</span></span><br><span class="line">    producer.send(record, <span class="keyword">new</span> <span class="type">Callback</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        public void onCompletion(<span class="type">RecordMetadata</span> metadata, <span class="type">Exception</span> exception) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">System</span>.out.println(<span class="string">&quot;进行异常处理&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">System</span>.out.printf(<span class="string">&quot;topic=%s, partition=%d, offset=%s \n&quot;</span>,</span><br><span class="line">                        metadata.topic(), metadata.partition(), metadata.offset());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、自定义分区器">三、自定义分区器</h2>
<p>Kafka 有着默认的分区机制：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果键值为 null， 则使用轮询 (Round Robin) 算法将消息均衡地分布到各个分区上；</p>
</li>
<li class="lvl-2">
<p>如果键值不为 null，那么 Kafka 会使用内置的散列算法对键进行散列，然后分布到各个分区上。</p>
</li>
</ul>
<p>某些情况下，你可能有着自己的分区需求，这时候可以采用自定义分区器实现。这里给出一个自定义分区器的示例：</p>
<h3 id="3-1-自定义分区器">3.1 自定义分区器</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义分区器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomPartitioner</span> <span class="keyword">implements</span> <span class="title class_">Partitioner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> passLine;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(Map&lt;String, ?&gt; configs)</span> &#123;</span><br><span class="line">        <span class="comment">/*从生产者配置中获取分数线*/</span></span><br><span class="line">        passLine = (Integer) configs.get(<span class="string">&quot;pass.line&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(String topic, Object key, <span class="type">byte</span>[] keyBytes, Object value, </span></span><br><span class="line"><span class="params">                         <span class="type">byte</span>[] valueBytes, Cluster cluster)</span> &#123;</span><br><span class="line">        <span class="comment">/*key 值为分数，当分数大于分数线时候，分配到 1 分区，否则分配到 0 分区*/</span></span><br><span class="line">        <span class="keyword">return</span> (Integer) key &gt;= passLine ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;分区器关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要在创建生产者时指定分区器，和分区器所需要的配置参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerWithPartitioner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">topicName</span> <span class="operator">=</span> <span class="string">&quot;Kafka-Partitioner-Test&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;hadoop001:9092&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.IntegerSerializer&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*传递自定义分区器*/</span></span><br><span class="line">        props.put(<span class="string">&quot;partitioner.class&quot;</span>, <span class="string">&quot;com.oicio.producers.partitioners.CustomPartitioner&quot;</span>);</span><br><span class="line">        <span class="comment">/*传递分区器所需的参数*/</span></span><br><span class="line">        props.put(<span class="string">&quot;pass.line&quot;</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        Producer&lt;Integer, String&gt; producer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">score</span> <span class="operator">=</span> <span class="string">&quot;score:&quot;</span> + i;</span><br><span class="line">            ProducerRecord&lt;Integer, String&gt; record = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(topicName, i, score);</span><br><span class="line">            <span class="comment">/*异步发送消息*/</span></span><br><span class="line">            producer.send(record, (metadata, exception) -&gt;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%s, partition=%d, \n&quot;</span>, score, metadata.partition()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-测试">3.2 测试</h3>
<p>需要创建一个至少有两个分区的主题：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --create \</span><br><span class="line">                   --bootstrap-server hadoop001:9092 \</span><br><span class="line">                    --replication-factor 1 --partitions 2 \</span><br><span class="line">                    --topic Kafka-Partitioner-Test</span><br></pre></td></tr></table></figure>
<p>此时输入如下，可以看到分数大于等于 6 分的都被分到 1 分区，而小于 6 分的都被分到了 0 分区。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">score:6, partition=1, </span><br><span class="line">score:7, partition=1, </span><br><span class="line">score:8, partition=1, </span><br><span class="line">score:9, partition=1, </span><br><span class="line">score:10, partition=1, </span><br><span class="line">score:0, partition=0, </span><br><span class="line">score:1, partition=0, </span><br><span class="line">score:2, partition=0, </span><br><span class="line">score:3, partition=0, </span><br><span class="line">score:4, partition=0, </span><br><span class="line">score:5, partition=0, </span><br><span class="line">分区器关闭</span><br></pre></td></tr></table></figure>
<h2 id="四、生产者其他属性">四、生产者其他属性</h2>
<p>上面生产者的创建都仅指定了服务地址，键序列化器、值序列化器，实际上 Kafka 的生产者还有很多可配置属性，如下：</p>
<h3 id="1-acks">1. acks</h3>
<p>acks 参数指定了必须要有多少个分区副本收到消息，生产者才会认为消息写入是成功的：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>acks=0</strong> ： 消息发送出去就认为已经成功了，不会等待任何来自服务器的响应；</p>
</li>
<li class="lvl-2">
<p><strong>acks=1</strong> ： 只要集群的首领节点收到消息，生产者就会收到一个来自服务器成功响应；</p>
</li>
<li class="lvl-2">
<p><strong>acks=all</strong> ：只有当所有参与复制的节点全部收到消息时，生产者才会收到一个来自服务器的成功响应。</p>
</li>
</ul>
<h3 id="2-buffer-memory">2. buffer.memory</h3>
<p>设置生产者内存缓冲区的大小。</p>
<h3 id="3-compression-type">3. compression.type</h3>
<p>默认情况下，发送的消息不会被压缩。如果想要进行压缩，可以配置此参数，可选值有 snappy，gzip，lz4。</p>
<h3 id="4-retries">4. retries</h3>
<p>发生错误后，消息重发的次数。如果达到设定值，生产者就会放弃重试并返回错误。</p>
<h3 id="5-batch-size">5. batch.size</h3>
<p>当有多个消息需要被发送到同一个分区时，生产者会把它们放在同一个批次里。该参数指定了一个批次可以使用的内存大小，按照字节数计算。</p>
<h3 id="6-linger-ms">6. <a href="http://linger.ms">linger.ms</a></h3>
<p>该参数制定了生产者在发送批次之前等待更多消息加入批次的时间。</p>
<h3 id="7-clent-id">7. <a href="http://clent.id">clent.id</a></h3>
<p>客户端 id,服务器用来识别消息的来源。</p>
<h3 id="8-max-in-flight-requests-per-connection">8. max.in.flight.requests.per.connection</h3>
<p>指定了生产者在收到服务器响应之前可以发送多少个消息。它的值越高，就会占用越多的内存，不过也会提升吞吐量，把它设置为 1 可以保证消息是按照发送的顺序写入服务器，即使发生了重试。</p>
<h3 id="9-timeout-ms-request-timeout-ms-metadata-fetch-timeout-ms">9. <a href="http://timeout.ms">timeout.ms</a>, <a href="http://request.timeout.ms">request.timeout.ms</a> &amp; <a href="http://metadata.fetch.timeout.ms">metadata.fetch.timeout.ms</a></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="http://timeout.ms">timeout.ms</a> 指定了 borker 等待同步副本返回消息的确认时间；</p>
</li>
<li class="lvl-2">
<p><a href="http://request.timeout.ms">request.timeout.ms</a> 指定了生产者在发送数据时等待服务器返回响应的时间；</p>
</li>
<li class="lvl-2">
<p><a href="http://metadata.fetch.timeout.ms">metadata.fetch.timeout.ms</a> 指定了生产者在获取元数据（比如分区首领是谁）时等待服务器返回响应的时间。</p>
</li>
</ul>
<h3 id="10-max-block-ms">10. <a href="http://max.block.ms">max.block.ms</a></h3>
<p>指定了在调用 <code>send()</code> 方法或使用 <code>partitionsFor()</code> 方法获取元数据时生产者的阻塞时间。当生产者的发送缓冲区已满，或者没有可用的元数据时，这些方法会阻塞。在阻塞时间达到 <a href="http://max.block.ms">max.block.ms</a> 时，生产者会抛出超时异常。</p>
<h3 id="11-max-request-size">11. max.request.size</h3>
<p>该参数用于控制生产者发送的请求大小。它可以指发送的单个消息的最大值，也可以指单个请求里所有消息总的大小。例如，假设这个值为 1000K ，那么可以发送的单个最大消息为 1000K ，或者生产者可以在单个请求里发送一个批次，该批次包含了 1000 个消息，每个消息大小为 1K。</p>
<h3 id="12-receive-buffer-bytes-send-buffer-byte">12. receive.buffer.bytes &amp; send.buffer.byte</h3>
<p>这两个参数分别指定 TCP socket 接收和发送数据包缓冲区的大小，-1 代表使用操作系统的默认值。</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka简介</title>
    <url>/posts/d54daaca.html</url>
    <content><![CDATA[<h2 id="一、简介">一、简介</h2>
<p>ApacheKafka 是一个分布式的流处理平台。它具有以下特点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>支持消息的发布和订阅，类似于 RabbtMQ、ActiveMQ 等消息队列；</p>
</li>
<li class="lvl-2">
<p>支持数据实时处理；</p>
</li>
<li class="lvl-2">
<p>能保证消息的可靠性投递；</p>
</li>
<li class="lvl-2">
<p>支持消息的持久化存储，并通过多副本分布式的存储方案来保证消息的容错；</p>
</li>
<li class="lvl-2">
<p>高吞吐率，单 Broker 可以轻松处理数千个分区以及每秒百万级的消息量。</p>
</li>
</ul>
<h2 id="二、基本概念">二、基本概念</h2>
<h3 id="2-1-Messages-And-Batches">2.1 Messages And Batches</h3>
<p>Kafka 的基本数据单元被称为 message(消息)，为减少网络开销，提高效率，多个消息会被放入同一批次 (Batch) 中后再写入。</p>
<h3 id="2-2-Topics-And-Partitions">2.2 Topics And Partitions</h3>
<p>Kafka 的消息通过 Topics(主题) 进行分类，一个主题可以被分为若干个 Partitions(分区)，一个分区就是一个提交日志 (commit log)。消息以追加的方式写入分区，然后以先入先出的顺序读取。Kafka 通过分区来实现数据的冗余和伸缩性，分区可以分布在不同的服务器上，这意味着一个 Topic 可以横跨多个服务器，以提供比单个服务器更强大的性能。</p>
<p>由于一个 Topic 包含多个分区，因此无法在整个 Topic 范围内保证消息的顺序性，但可以保证消息在单个分区内的顺序性。</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka-topic.png"/> </div>
<h3 id="2-3-Producers-And-Consumers">2.3 Producers And Consumers</h3>
<h4 id="1-生产者">1. 生产者</h4>
<p>生产者负责创建消息。一般情况下，生产者在把消息均衡地分布到在主题的所有分区上，而并不关心消息会被写到哪个分区。如果我们想要把消息写到指定的分区，可以通过自定义分区器来实现。</p>
<h4 id="2-消费者">2. 消费者</h4>
<p>消费者是消费者群组的一部分，消费者负责消费消息。消费者可以订阅一个或者多个主题，并按照消息生成的顺序来读取它们。消费者通过检查消息的偏移量 (offset) 来区分读取过的消息。偏移量是一个不断递增的数值，在创建消息时，Kafka 会把它添加到其中，在给定的分区里，每个消息的偏移量都是唯一的。消费者把每个分区最后读取的偏移量保存在 Zookeeper 或 Kafka 上，如果消费者关闭或者重启，它还可以重新获取该偏移量，以保证读取状态不会丢失。</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka-producer-consumer.png"/> </div>
<p>一个分区只能被同一个消费者群组里面的一个消费者读取，但可以被不同消费者群组中所组成的多个消费者共同读取。多个消费者群组中消费者共同读取同一个主题时，彼此之间互不影响。</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka消费者.png"/> </div>
<h3 id="2-4-Brokers-And-Clusters">2.4 Brokers And Clusters</h3>
<p>一个独立的 Kafka 服务器被称为 Broker。Broker 接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存。Broker 为消费者提供服务，对读取分区的请求做出响应，返回已经提交到磁盘的消息。</p>
<p>Broker 是集群 (Cluster) 的组成部分。每一个集群都会选举出一个 Broker 作为集群控制器 (Controller)，集群控制器负责管理工作，包括将分区分配给 Broker 和监控 Broker。</p>
<p>在集群中，一个分区 (Partition) 从属一个 Broker，该 Broker 被称为分区的首领 (Leader)。一个分区可以分配给多个 Brokers，这个时候会发生分区复制。这种复制机制为分区提供了消息冗余，如果有一个 Broker 失效，其他 Broker 可以接管领导权。</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka-cluster.png"/> </div>
]]></content>
      <categories>
        <category>中间件</category>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka分区</title>
    <url>/posts/33744480.html</url>
    <content><![CDATA[<h2 id="设置topic下的分区数">设置topic下的分区数</h2>
<ol>
<li class="lvl-3">在 config/server.properties 配置文件中, 可以设置一个全局的分区数量, 这个分区数量的含义是: <strong>每个主题下的分区数量</strong>, 默认为 1</li>
</ol>
<img src="https://img2018.cnblogs.com/blog/1629331/201911/1629331-20191129230058746-945280798.png" referrerpolicy="no-referrer">
<ol start="2">
<li class="lvl-3">
<p>也可以在创建主题的时候, 使用 --partitions 参数指定分区数量</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --zookeeper localhost:2181 --create --topic my_topic --partitions 2 --replication-factor 1 </span><br></pre></td></tr></table></figure>
<p>3.查看已创建主题的分区数量:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic my_topic </span><br></pre></td></tr></table></figure>
<img src="https://img2018.cnblogs.com/blog/1629331/201911/1629331-20191129230212246-1072040750.png" referrerpolicy="no-referrer">
<h2 id="生产者与分区">生产者与分区</h2>
<p><strong>org.apache.kafka.clients.producer.internals.DefaultPartitioner</strong></p>
<p>默认的分区策略是：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果在发消息的时候指定了分区，则消息投递到指定的分区</p>
</li>
<li class="lvl-2">
<p>如果没有指定分区，但是消息的key不为空，则基于key的哈希值来选择一个分区</p>
</li>
<li class="lvl-2">
<p>如果既没有指定分区，且消息的key也是空，则用轮询的方式选择一个分区</p>
</li>
</ul>
<h2 id="消费者与分区">消费者与分区</h2>
<p>首先需要了解的是:</p>
<ol>
<li class="lvl-3">
<p>消费者是以组的名义订阅主题消息, 消费者组里边包含多个消费者实例.</p>
</li>
<li class="lvl-3">
<p>主题下边包含多个分区</p>
</li>
</ol>
<p>消费者实例与主题下分区的分配关系</p>
<img src="https://img2018.cnblogs.com/blog/1629331/201911/1629331-20191129230325655-792813000.png" referrerpolicy="no-referrer">
<p>kafka 集群上有两个节点, 4 个分区</p>
<p>A组有 2 个消费者实例 (两个消费线程)</p>
<p>B组有 4 个消费者实例</p>
<p>由图可以看出, A组的消费者C1, C2 平均要消费两个分区的数据, 而 B 组的消费者平均消费 一 个分区的数据 ( 最理想的状态 ), 得到的结论是 : <strong>一条消息只能被一个消费组中的一个消费者实例消费到</strong>, (换句话说, 不可能出现组中的两个消费者负责同一个分区, 同组内消费者不会重复消费 )</p>
<p>等等, 考虑的场景还不够, 下边再提些问题 :</p>
<p>如果分区数大于或等于组中的消费者实例数, 那就没有问题, 但是如果消费者实例的数量 &gt; 主题下分区数量, 那么按照默认的策略 ( 之所以强调默认策略是因为可以自定义策略 ), 有一些消费者是多余的, 一直接不到消息而处于空闲状态.</p>
<p>但是假设有消费者实例就是不安分, 就造成了多个消费者负责同一个分区, 这样会造成什么 ? (重复消费就太可怕了)</p>
<p>我们知道，Kafka它在设计的时候就是要保证分区下消息的顺序，也就是说消息在一个分区中的顺序是怎样的，那么消费者在消费的时候看到的就是什么样的顺序，那么要做到这一点就首先要保证消息是由消费者主动拉取的（pull），其次还要保证一个分区只能由一个消费者负责。倘若，两个消费者负责同一个分区，那么就意味着两个消费者同时读取分区的消息，由于消费者自己可以控制读取消息的offset (偏移量)，就有可能C1才读到2，而C2读到1，C1还没提交 offset，这时C2读到2了，相当于多线程读取同一个消息，会造成消息处理的重复，且不能保证消息的顺序，这就跟主动推送（push）无异。</p>
<h2 id="消费者分区分配策略-两种">消费者分区分配策略 (两种)</h2>
<p>range策略是基于每个主题的，对于每个主题，我们以数字顺序排列可用分区，以字典顺序排列消费者。然后，将分区数量除以消费者总数，以确定分配给每个消费者的分区数量。如果没有平均划分（PS：除不尽），那么最初的几个消费者将有一个额外的分区。</p>
<p>简而言之:</p>
<ol>
<li class="lvl-3">
<p>range分配策略针对的是主题（也就是说，这里所说的分区指的某个主题的分区，消费者值的是订阅这个主题的消费者组中的消费者实例）</p>
</li>
<li class="lvl-3">
<p>首先，将分区按数字顺序排行序，消费者按消费者名称的字典顺序排好序.</p>
</li>
<li class="lvl-3">
<p>然后，用分区总数除以消费者总数。如果能够除尽，则皆大欢喜，平均分配；若除不尽，则位于排序前面的消费者将多负责一个分区.</p>
</li>
</ol>
<p>例如，假设有两个消费者C0和C1，两个主题t0和t1，并且每个主题有3个分区，分区的情况是这样的：t0p0，t0p1，t0p2，t1p0，t1p1，t1p2</p>
<p>那么，基于以上信息，最终消费者分配分区的情况是这样的：</p>
<p>C0: [t0p0, t0p1, t1p0, t1p1]</p>
<p>C1: [t0p2, t1p2]</p>
<p>因为，对于主题t0，分配的结果是C0负责P0和P1，C1负责P2；对于主题t2，也是如此，综合起来就是这个结果</p>
<p>上面的过程用图形表示的话大概是这样的 :</p>
<img src="https://img2018.cnblogs.com/blog/1629331/201911/1629331-20191129230609350-1656648320.png" referrerpolicy="no-referrer">
<p>roundrobin (轮询)</p>
<p>roundronbin分配策略的具体实现是org.apache.kafka.clients.consumer.RoundRobinAssignor</p>
<p>轮询分配策略是基于所有可用的消费者和所有可用的分区的</p>
<p>与前面的range策略最大的不同就是它不再局限于某个主题</p>
<p>如果所有的消费者实例的订阅都是相同的，那么这样最好了，可用统一分配，均衡分配</p>
<p>例如，假设有两个消费者C0和C1，两个主题t0和t1，每个主题有3个分区，分别是t0p0，t0p1，t0p2，t1p0，t1p1，t1p2</p>
<p>那么，最终分配的结果是这样的：</p>
<p>C0: [t0p0, t0p2, t1p1]</p>
<p>C1: [t0p1, t1p0, t1p2]</p>
<p>用图形表示大概是这样的:</p>
<img src="https://img2018.cnblogs.com/blog/1629331/201911/1629331-20191129230645759-1165797262.png" referrerpolicy="no-referrer">
]]></content>
      <categories>
        <category>中间件</category>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka本地安装</title>
    <url>/posts/a111c625.html</url>
    <content><![CDATA[<h3 id="安装zookeeper">安装zookeeper</h3>
<p>地址：<a href="http://apache.org/dist/zookeeper/zookeeper-3.4.14/">zookeeper-3.4.14</a>，下载后解压</p>
<ol>
<li class="lvl-3">
<p>进入zookeeper的相关设置所在的文件目录，例如本文的：D: \ …\zookeeper-3.4.10\conf</p>
</li>
<li class="lvl-3">
<p>将&quot;zoo_sample.cfg&quot;重命名为&quot;zoo.cfg&quot;</p>
</li>
<li class="lvl-3">
<p>dataDir=/tmp/zookeeper  to  D:/ …/zookeeper-3.4.10/data</p>
</li>
<li class="lvl-3">
<p>添加系统环境变量</p>
<ul class="lvl-2">
<li class="lvl-6">
<p>系统变量中添加ZOOKEEPER_HOME=D:\ …\zookeeper-3.4.10</p>
</li>
<li class="lvl-6">
<p>编辑系统变量中的path变量，增加%ZOOKEEPER_HOME%\bin</p>
</li>
</ul>
</li>
</ol>
<h3 id="安装kafka">安装kafka</h3>
<p>地址: <a href="http://apache.org/dist/kafka/2.1.1/">kafka-2.11_2.1.1</a>，下载后解压</p>
<p>同样加入到环境变量中</p>
<h3 id="启动kafka">启动kafka</h3>
<ol>
<li class="lvl-3">
<p>启动zookeeper</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">zkserver.cmd</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>启动kafka</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.\bin\windows\kafka-server-start.bat .\config\server.properties</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>申请生产者</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.\bin\windows\kafka-console-producer.bat --broker-list localhost:<span class="number">9092</span> --topic test</span><br></pre></td></tr></table></figure>
<ol start="4">
<li class="lvl-3">
<p>申请消费者</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.\bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:<span class="number">9092</span> --topic test --from-beginning</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>中间件</category>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建Kafka高可用集群</title>
    <url>/posts/20c2960d.html</url>
    <content><![CDATA[<h2 id="一、Zookeeper集群搭建">一、Zookeeper集群搭建</h2>
<p>为保证集群高可用，Zookeeper 集群的节点数最好是奇数，最少有三个节点，所以这里搭建一个三个节点的集群。</p>
<h3 id="1-1-下载-解压">1.1 下载 &amp; 解压</h3>
<p>下载对应版本 Zookeeper，这里我下载的版本 <code>3.4.14</code>。官方下载地址：<a href="https://archive.apache.org/dist/zookeeper/">https://archive.apache.org/dist/zookeeper/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">下载</span></span><br><span class="line">wget https://archive.apache.org/dist/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz</span><br><span class="line"><span class="meta"># </span><span class="language-bash">解压</span></span><br><span class="line">tar -zxvf zookeeper-3.4.14.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="1-2-修改配置">1.2 修改配置</h3>
<p>拷贝三份 zookeeper 安装包。分别进入安装目录的 <code>conf</code> 目录，拷贝配置样本 <code>zoo_sample.cfg </code> 为 <code>zoo.cfg</code> 并进行修改，修改后三份配置文件内容分别如下：</p>
<p>zookeeper01 配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line">initLimit=10</span><br><span class="line">syncLimit=5</span><br><span class="line">dataDir=/usr/local/zookeeper-cluster/data/01</span><br><span class="line">dataLogDir=/usr/local/zookeeper-cluster/log/01</span><br><span class="line">clientPort=2181</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">server.1 这个1是服务器的标识，可以是任意有效数字，标识这是第几个服务器节点，这个标识要写到dataDir目录下面myid文件里</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">指名集群间通讯端口和选举端口</span></span><br><span class="line">server.1=127.0.0.1:2287:3387</span><br><span class="line">server.2=127.0.0.1:2288:3388</span><br><span class="line">server.3=127.0.0.1:2289:3389</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果是多台服务器，则集群中每个节点通讯端口和选举端口可相同，IP 地址修改为每个节点所在主机 IP 即可。</p>
</blockquote>
<p>zookeeper02 配置，与 zookeeper01 相比，只有 <code>dataLogDir</code>、<code>dataLogDir</code> 和 <code>clientPort</code> 不同：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line">initLimit=10</span><br><span class="line">syncLimit=5</span><br><span class="line">dataDir=/usr/local/zookeeper-cluster/data/02</span><br><span class="line">dataLogDir=/usr/local/zookeeper-cluster/log/02</span><br><span class="line">clientPort=2182</span><br><span class="line"></span><br><span class="line">server.1=127.0.0.1:2287:3387</span><br><span class="line">server.2=127.0.0.1:2288:3388</span><br><span class="line">server.3=127.0.0.1:2289:3389</span><br></pre></td></tr></table></figure>
<p>zookeeper03 配置，与 zookeeper01，02 相比，也只有 <code>dataLogDir</code>、<code>dataLogDir</code> 和 <code>clientPort</code> 不同：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line">initLimit=10</span><br><span class="line">syncLimit=5</span><br><span class="line">dataDir=/usr/local/zookeeper-cluster/data/03</span><br><span class="line">dataLogDir=/usr/local/zookeeper-cluster/log/03</span><br><span class="line">clientPort=2183</span><br><span class="line"></span><br><span class="line">server.1=127.0.0.1:2287:3387</span><br><span class="line">server.2=127.0.0.1:2288:3388</span><br><span class="line">server.3=127.0.0.1:2289:3389</span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置参数说明：</p>
<ul class="lvl-1">
<li class="lvl-2"><strong>tickTime</strong>：用于计算的基础时间单元。比如 session 超时：N*tickTime；</li>
<li class="lvl-2"><strong>initLimit</strong>：用于集群，允许从节点连接并同步到 master 节点的初始化连接时间，以 tickTime 的倍数来表示；</li>
<li class="lvl-2"><strong>syncLimit</strong>：用于集群， master 主节点与从节点之间发送消息，请求和应答时间长度（心跳机制）；</li>
<li class="lvl-2"><strong>dataDir</strong>：数据存储位置；</li>
<li class="lvl-2"><strong>dataLogDir</strong>：日志目录；</li>
<li class="lvl-2"><strong>clientPort</strong>：用于客户端连接的端口，默认 2181</li>
</ul>
</blockquote>
<h3 id="1-3-标识节点">1.3 标识节点</h3>
<p>分别在三个节点的数据存储目录下新建 <code>myid</code> 文件,并写入对应的节点标识。Zookeeper 集群通过 <code>myid</code> 文件识别集群节点，并通过上文配置的节点通信端口和选举端口来进行节点通信，选举出 leader 节点。</p>
<p>创建存储目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">dataDir</span></span><br><span class="line">mkdir -vp  /usr/local/zookeeper-cluster/data/01</span><br><span class="line"><span class="meta"># </span><span class="language-bash">dataDir</span></span><br><span class="line">mkdir -vp  /usr/local/zookeeper-cluster/data/02</span><br><span class="line"><span class="meta"># </span><span class="language-bash">dataDir</span></span><br><span class="line">mkdir -vp  /usr/local/zookeeper-cluster/data/03</span><br></pre></td></tr></table></figure>
<p>创建并写入节点标识到 <code>myid</code> 文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">server1</span></span><br><span class="line">echo &quot;1&quot; &gt; /usr/local/zookeeper-cluster/data/01/myid</span><br><span class="line"><span class="meta">#</span><span class="language-bash">server2</span></span><br><span class="line">echo &quot;2&quot; &gt; /usr/local/zookeeper-cluster/data/02/myid</span><br><span class="line"><span class="meta">#</span><span class="language-bash">server3</span></span><br><span class="line">echo &quot;3&quot; &gt; /usr/local/zookeeper-cluster/data/03/myid</span><br></pre></td></tr></table></figure>
<h3 id="1-4-启动集群">1.4 启动集群</h3>
<p>分别启动三个节点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">启动节点1</span></span><br><span class="line">/usr/app/zookeeper-cluster/zookeeper01/bin/zkServer.sh start</span><br><span class="line"><span class="meta"># </span><span class="language-bash">启动节点2</span></span><br><span class="line">/usr/app/zookeeper-cluster/zookeeper02/bin/zkServer.sh start</span><br><span class="line"><span class="meta"># </span><span class="language-bash">启动节点3</span></span><br><span class="line">/usr/app/zookeeper-cluster/zookeeper03/bin/zkServer.sh start</span><br></pre></td></tr></table></figure>
<h3 id="1-5-集群验证">1.5 集群验证</h3>
<p>使用 jps 查看进程，并且使用 <code>zkServer.sh status</code> 查看集群各个节点状态。如图三个节点进程均启动成功，并且两个节点为 follower 节点，一个节点为 leader 节点。</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/zookeeper-cluster.png"/> </div>
<h2 id="二、Kafka集群搭建">二、Kafka集群搭建</h2>
<h3 id="2-1-下载解压">2.1 下载解压</h3>
<p>Kafka 安装包官方下载地址：<a href="http://kafka.apache.org/downloads">http://kafka.apache.org/downloads</a> ，本用例下载的版本为 <code>2.2.0</code>，下载命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">下载</span></span><br><span class="line">wget https://www-eu.apache.org/dist/kafka/2.2.0/kafka_2.12-2.2.0.tgz</span><br><span class="line"><span class="meta"># </span><span class="language-bash">解压</span></span><br><span class="line">tar -xzf kafka_2.12-2.2.0.tgz</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里 j 解释一下 kafka 安装包的命名规则：以 <code>kafka_2.12-2.2.0.tgz</code> 为例，前面的 2.12 代表 Scala 的版本号（Kafka 采用 Scala 语言进行开发），后面的 2.2.0 则代表 Kafka 的版本号。</p>
</blockquote>
<h3 id="2-2-拷贝配置文件">2.2 拷贝配置文件</h3>
<p>进入解压目录的 <code> config</code> 目录下 ，拷贝三份配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">cp</span> server.properties server-1.properties</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">cp</span> server.properties server-2.properties</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">cp</span> server.properties server-3.properties</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-修改配置">2.3 修改配置</h3>
<p>分别修改三份配置文件中的部分配置，如下：</p>
<p>server-1.properties：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The id of the broker. 集群中每个节点的唯一标识</span></span><br><span class="line"><span class="attr">broker.id</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"># 监听地址</span></span><br><span class="line"><span class="attr">listeners</span>=<span class="string">PLAINTEXT://hadoop001:9092</span></span><br><span class="line"><span class="comment"># 数据的存储位置</span></span><br><span class="line"><span class="attr">log.dirs</span>=<span class="string">/usr/local/kafka-logs/00</span></span><br><span class="line"><span class="comment"># Zookeeper连接地址</span></span><br><span class="line"><span class="attr">zookeeper.connect</span>=<span class="string">hadoop001:2181,hadoop001:2182,hadoop001:2183</span></span><br></pre></td></tr></table></figure>
<p>server-2.properties：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">broker.id</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">listeners</span>=<span class="string">PLAINTEXT://hadoop001:9093</span></span><br><span class="line"><span class="attr">log.dirs</span>=<span class="string">/usr/local/kafka-logs/01</span></span><br><span class="line"><span class="attr">zookeeper.connect</span>=<span class="string">hadoop001:2181,hadoop001:2182,hadoop001:2183</span></span><br></pre></td></tr></table></figure>
<p>server-3.properties：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">broker.id</span>=<span class="string">2</span></span><br><span class="line"><span class="attr">listeners</span>=<span class="string">PLAINTEXT://hadoop001:9094</span></span><br><span class="line"><span class="attr">log.dirs</span>=<span class="string">/usr/local/kafka-logs/02</span></span><br><span class="line"><span class="attr">zookeeper.connect</span>=<span class="string">hadoop001:2181,hadoop001:2182,hadoop001:2183</span></span><br></pre></td></tr></table></figure>
<p>这里需要说明的是 <code>log.dirs</code> 指的是数据日志的存储位置，确切的说，就是分区数据的存储位置，而不是程序运行日志的位置。程序运行日志的位置是通过同一目录下的 <code>log4j.properties</code> 进行配置的。</p>
<h3 id="2-4-启动集群">2.4 启动集群</h3>
<p>分别指定不同配置文件，启动三个 Kafka 节点。启动后可以使用 jps 查看进程，此时应该有三个 zookeeper 进程和三个 kafka 进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-server-start.sh config/server-1.properties</span><br><span class="line">bin/kafka-server-start.sh config/server-2.properties</span><br><span class="line">bin/kafka-server-start.sh config/server-3.properties</span><br></pre></td></tr></table></figure>
<h3 id="2-5-创建测试主题">2.5 创建测试主题</h3>
<p>创建测试主题：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --bootstrap-server hadoop001:9092 \</span><br><span class="line">					--replication-factor 3 \</span><br><span class="line">					--partitions 1 --topic my-replicated-topic</span><br></pre></td></tr></table></figure>
<p>创建后可以使用以下命令查看创建的主题信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --describe --bootstrap-server hadoop001:9092 --topic my-replicated-topic</span><br></pre></td></tr></table></figure>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka-cluster-shell.png"/> </div>
<p>可以看到分区 0 的有 0,1,2 三个副本，且三个副本都是可用副本，都在 ISR(in-sync Replica 同步副本) 列表中，其中 1 为首领副本，此时代表集群已经搭建成功。</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列易错指南</title>
    <url>/posts/c942750e.html</url>
    <content><![CDATA[<h2 id="1-消息队列的坑之非幂等">1.消息队列的坑之非幂等</h2>
<h3 id="（1）幂等性概念">（1）幂等性概念</h3>
<p>所谓幂等性就是无论多少次操作和第一次的操作结果一样。如果消息被多次消费，很有可能造成数据的不一致。而如果消息不可避免地被消费多次，如果我们开发人员能通过技术手段保证数据的前后一致性，那也是可以接受的 。</p>
<p><code>RabbitMQ</code>、<code>RocketMQ</code>、<code>Kafka</code> 消息队列中间件都有可能出现消息重复消费问题。这种问题并不是 MQ 自己保证的，而是需要开发人员来保证。</p>
<p>这几款消息队列中间都是是全球最牛的分布式消息队列，那肯定考虑到了消息的幂等性。我们以 Kafka 为例，看看 Kafka 是怎么保证消息队列的幂等性。</p>
<p>Kafka 有一个 <code>偏移量</code> 的概念，代表着消息的序号，每条消息写到消息队列都会有一个偏移量，消费者消费了数据之后，每过一段固定的时间，就会把消费过的消息的偏移量提交一下，表示已经消费过了，下次消费就从偏移量后面开始消费。</p>
<h3 id="（2）避坑指南">（2）避坑指南</h3>
<p>微信支付结果通知场景</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>微信官方文档上提到微信支付通知结果可能会推送多次，需要开发者自行保证幂等性。第一次我们可以直接修改订单状态（如支付中 -&gt; 支付成功），第二次就根据订单状态来判断，如果不是支付中，则不进行订单处理逻辑。</p>
</li>
</ul>
<p>插入数据库场景</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>每次插入数据时，先检查下数据库中是否有这条数据的主键 id，如果有，则进行更新操作。</p>
</li>
</ul>
<p>写 Redis 场景</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Redis 的 <code>Set</code> 操作天然幂等性，所以不用考虑 Redis 写数据的问题。</p>
</li>
</ul>
<p>其他场景方案</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>生产者发送每条数据时，增加一个全局唯一 id，类似订单 id。每次消费时，先去 Redis 查下是否有这个 id，如果没有，则进行正常处理消息，且将 id 存到 Redis。如果查到有这个 id，说明之前消费过，则不要进行重复处理这条消息。</p>
</li>
<li class="lvl-2">
<p>不同业务场景，可能会有不同的幂等性方案，大家选择合适的即可，上面的几种方案只是提供常见的解决思路。</p>
</li>
</ul>
<h2 id="2-消息队列的坑之消息丢失">2.消息队列的坑之消息丢失</h2>
<blockquote>
<p>消息丢失会带来什么问题？如果是订单下单、支付结果通知、扣费相关的消息丢失，则可能造成财务损失，如果量很大，就会给甲方带来巨大损失</p>
</blockquote>
<h3 id="（1）生产者存放消息的过程中丢失消息">（1）生产者存放消息的过程中丢失消息</h3>
<h4 id="解决方案">解决方案</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>事务机制（不推荐，异步方式）</p>
</li>
</ul>
<p>对于 RabbitMQ 来说，生产者发送数据之前开启 RabbitMQ 的<strong>事务机制</strong><code>channel.txselect</code> ，如果消息没有进队列，则生产者受到异常报错，并进行回滚 <code>channel.txRollback</code>，然后重试发送消息；如果收到了消息，则可以提交事务 <code>channel.txCommit</code>。但这是一个同步的操作，会影响性能。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>confirm 机制（推荐，异步方式）</p>
</li>
</ul>
<p>我们可以采用另外一种模式： <code>confirm</code> 模式来解决同步机制的性能问题。每次生产者发送的消息都会分配一个唯一的 id，如果写入到了 RabbitMQ 队列中，则 RabbitMQ 会回传一个 <code>ack</code> 消息，说明这个消息接收成功。如果 RabbitMQ 没能处理这个消息，则回调 <code>nack</code> 接口。说明需要重试发送消息。</p>
<p>也可以自定义超时时间 + 消息 id 来实现超时等待后重试机制。但可能出现的问题是调用 ack 接口时失败了，所以会出现消息被发送两次的问题，这个时候就需要保证消费者消费消息的幂等性。</p>
<h4 id="事务模式-和-confirm-模式的区别："><code>事务模式</code> 和 <code>confirm</code> 模式的区别：</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>事务机制是同步的，提交事务后悔被<strong>阻塞</strong>直到提交事务完成后。</p>
</li>
<li class="lvl-2">
<p>confirm 模式异步接收通知，但可能<strong>接收不到通知</strong>。需要考虑接收不到通知的场景。</p>
</li>
</ul>
<h3 id="（2）消息队列丢失消息">（2）消息队列丢失消息</h3>
<p>消息队列的消息可以放到内存中，或将内存中的消息转到硬盘（比如数据库）中，一般都是内存和硬盘中都存有消息。如果只是放在内存中，那么当机器重启了，消息就全部丢失了。如果是硬盘中，则可能存在一种极端情况，就是将内存中的数据转换到硬盘的期间中，消息队列出问题了，未能将消息持久化到硬盘。</p>
<p><strong>解决方案</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>创建 <code>Queue</code> 的时候将其设置为持久化。这个地方没搞懂，欢迎探讨解答。</p>
</li>
<li class="lvl-2">
<p>发送消息的时候将消息的 <code>deliveryMode</code> 设置为 2 。</p>
</li>
<li class="lvl-2">
<p>开启生产者 <code>confirm</code> 模式，可以重试发送消息。</p>
</li>
</ul>
<h3 id="（3）消费者丢失消息">（3）消费者丢失消息</h3>
<p>消费者刚拿到数据，还没开始处理消息，结果进程因为异常退出了，消费者没有机会再次拿到消息。</p>
<p><strong>解决方案</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>关闭 RabbitMQ 的自动 <code>ack</code>，每次生产者将消息写入消息队列后，就自动回传一个 <code>ack</code> 给生产者。</p>
</li>
<li class="lvl-2">
<p>消费者处理完消息再主动 <code>ack</code>，告诉消息队列我处理完了。</p>
</li>
</ul>
<p><strong>问题：</strong> 那这种主动 <code>ack</code> 有什么漏洞了？如果 主动 <code>ack</code> 的时候挂了，怎么办？</p>
<p>则可能会被再次消费，这个时候就需要幂等处理了。</p>
<p><strong>问题：</strong> 如果这条消息一直被重复消费怎么办？</p>
<p>则需要有加上重试次数的监测，如果超过一定次数则将消息丢失，记录到异常表或发送异常通知给值班人员。</p>
<h3 id="（4）Kafka-消息丢失">（4）Kafka 消息丢失</h3>
<p><strong>场景：</strong><code>Kafka</code> 的某个 broker（节点）宕机了，重新选举 leader （写入的节点）。如果 leader 挂了，follower 还有些数据未同步完，则 follower 成为 leader 后，消息队列会丢失一部分数据。</p>
<p><strong>解决方案</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>给 topic 设置 <code>replication.factor</code> 参数，值必须大于 1，要求每个 partition 必须有至少 2 个副本。</p>
</li>
<li class="lvl-2">
<p>给 kafka 服务端设置 <code>min.insyc.replicas</code> 必须大于 1，表示一个 leader 至少一个 follower 还跟自己保持联系。</p>
</li>
</ul>
<h2 id="3-消息队列的坑之消息乱序">3. 消息队列的坑之消息乱序</h2>
<blockquote>
<p>用户先下单成功，然后取消订单，如果顺序颠倒，则最后数据库里面会有一条下单成功的订单。</p>
</blockquote>
<p><strong>RabbitMQ 场景：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>生产者向消息队列按照顺序发送了 2 条消息，消息1：增加数据 A，消息2：删除数据 A。</p>
</li>
<li class="lvl-2">
<p>期望结果：数据 A 被删除。</p>
</li>
<li class="lvl-2">
<p>但是如果有两个消费者，消费顺序是：消息2、消息 1。则最后结果是增加了数据 A。</p>
</li>
</ul>
<p><strong>RabbitMQ 解决方案：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>将 Queue 进行拆分，创建多个内存 Queue，消息 1 和 消息 2 进入同一个 Queue。</p>
</li>
<li class="lvl-2">
<p>创建多个消费者，每一个消费者对应一个 Queue。</p>
</li>
</ul>
<p><strong>Kafka 场景：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>创建了 topic，有 3 个 partition。</p>
</li>
<li class="lvl-2">
<p>创建一条订单记录，订单 id 作为 key，订单相关的消息都丢到同一个 partition 中，同一个生产者创建的消息，顺序是正确的。</p>
</li>
<li class="lvl-2">
<p>为了快速消费消息，会创建多个消费者去处理消息，而为了提高效率，每个消费者可能会创建多个线程来并行的去拿消息及处理消息，处理消息的顺序可能就乱序了。</p>
</li>
</ul>
<p><strong>Kafka 解决方案：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>解决方案和 RabbitMQ 类似，利用多个 内存 Queue，每个线程消费 1个 Queue。</p>
</li>
<li class="lvl-2">
<p>具有相同 key 的消息 进同一个 Queue。</p>
</li>
</ul>
<h2 id="4-消息队列的坑之消息积压">4. 消息队列的坑之消息积压</h2>
<p>消息积压：消息队列里面有很多消息来不及消费。</p>
<p><strong>场景 1：</strong> 消费端出了问题，比如消费者都挂了，没有消费者来消费了，导致消息在队列里面不断积压。</p>
<p><strong>场景 2：</strong> 消费端出了问题，比如消费者消费的速度太慢了，导致消息不断积压。</p>
<blockquote>
<p>比如线上正在做订单活动，下单全部走消息队列，如果消息不断积压，订单都没有下单成功 ，那么会造成很大的损失</p>
</blockquote>
<p>解决方案：<strong>解铃还须系铃人</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>修复代码层面消费者的问题，确保后续消费速度恢复或尽可能加快消费的速度。</p>
</li>
<li class="lvl-2">
<p>停掉现有的消费者。</p>
</li>
<li class="lvl-2">
<p>临时建立好原先 5 倍的 Queue 数量。</p>
</li>
<li class="lvl-2">
<p>临时建立好原先 5 倍数量的 消费者。</p>
</li>
<li class="lvl-2">
<p>将堆积的消息全部转入临时的 Queue，消费者来消费这些 Queue。</p>
</li>
</ul>
<h2 id="5-消息队列的坑之消息过期失效">5. 消息队列的坑之消息过期失效</h2>
<blockquote>
<p>RabbitMQ 可以设置过期时间，如果消息超过一定的时间还没有被消费，则会被 RabbitMQ 给清理掉。消息就丢失了</p>
</blockquote>
<p>解决方案：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>准备好批量重导的程序</p>
</li>
<li class="lvl-2">
<p>手动将消息闲时批量重导</p>
</li>
</ul>
<h2 id="6-消息队列的坑之队列写满">6. 消息队列的坑之队列写满</h2>
<blockquote>
<p>当消息队列因消息积压导致的队列快写满，所以不能接收更多的消息了。生产者生产的消息将被丢弃。</p>
</blockquote>
<p>解决方案：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>判断哪些是无用的消息，RabbitMQ 可以进行 <code>Purge Message</code> 操作。</p>
</li>
<li class="lvl-2">
<p>如果是有用的消息，则需要将消息快速消费，将消息里面的内容转存到数据库。</p>
</li>
<li class="lvl-2">
<p>准备好程序将转存在数据库中的消息再次重导到消息队列。</p>
</li>
<li class="lvl-2">
<p>闲时重导消息到消息队列。</p>
</li>
</ul>
<p>原文链接：<a href="https://www.cnblogs.com/jackson0714/p/fenbushi.html">https://www.cnblogs.com/jackson0714/p/fenbushi.html</a></p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Kafka副本机制</title>
    <url>/posts/c6a82497.html</url>
    <content><![CDATA[<h2 id="一、Kafka集群">一、Kafka集群</h2>
<p>Kafka 使用 Zookeeper 来维护集群成员 (brokers) 的信息。每个 broker 都有一个唯一标识 <code>broker.id</code>，用于标识自己在集群中的身份，可以在配置文件 <code>server.properties</code> 中进行配置，或者由程序自动生成。下面是 Kafka brokers 集群自动创建的过程：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>每一个 broker 启动的时候，它会在 Zookeeper 的 <code>/brokers/ids</code> 路径下创建一个 <code>临时节点</code>，并将自己的 <code>broker.id</code> 写入，从而将自身注册到集群；</p>
</li>
<li class="lvl-2">
<p>当有多个 broker 时，所有 broker 会竞争性地在 Zookeeper 上创建 <code>/controller</code> 节点，由于 Zookeeper 上的节点不会重复，所以必然只会有一个 broker 创建成功，此时该 broker 称为 controller broker。它除了具备其他 broker 的功能外，<strong>还负责管理主题分区及其副本的状态</strong>。</p>
</li>
<li class="lvl-2">
<p>当 broker 出现宕机或者主动退出从而导致其持有的 Zookeeper 会话超时时，会触发注册在 Zookeeper 上的 watcher 事件，此时 Kafka 会进行相应的容错处理；如果宕机的是 controller broker 时，还会触发新的 controller 选举。</p>
</li>
</ul>
<h2 id="二、副本机制">二、副本机制</h2>
<p>为了保证高可用，kafka 的分区是多副本的，如果一个副本丢失了，那么还可以从其他副本中获取分区数据。但是这要求对应副本的数据必须是完整的，这是 Kafka 数据一致性的基础，所以才需要使用 <code>controller broker</code> 来进行专门的管理。下面将详解介绍 Kafka 的副本机制。</p>
<h3 id="2-1-分区和副本">2.1 分区和副本</h3>
<p>Kafka 的主题被分为多个分区 ，分区是 Kafka 最基本的存储单位。每个分区可以有多个副本 (可以在创建主题时使用 <code> replication-factor</code> 参数进行指定)。其中一个副本是首领副本 (Leader replica)，所有的事件都直接发送给首领副本；其他副本是跟随者副本 (Follower replica)，需要通过复制来保持与首领副本数据一致，当首领副本不可用时，其中一个跟随者副本将成为新首领。</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka-cluster.png"/> </div>
<h3 id="2-2-ISR机制">2.2 ISR机制</h3>
<p>每个分区都有一个 ISR(in-sync Replica) 列表，用于维护所有同步的、可用的副本。首领副本必然是同步副本，而对于跟随者副本来说，它需要满足以下条件才能被认为是同步副本：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>与 Zookeeper 之间有一个活跃的会话，即必须定时向 Zookeeper 发送心跳；</p>
</li>
<li class="lvl-3">
<p>在规定的时间内从首领副本那里低延迟地获取过消息。</p>
</li>
</ul>
<p>如果副本不满足上面条件的话，就会被从 ISR 列表中移除，直到满足条件才会被再次加入。</p>
<p>这里给出一个主题创建的示例：使用 <code>--replication-factor</code> 指定副本系数为 3，创建成功后使用 <code>--describe </code> 命令可以看到分区 0 的有 0,1,2 三个副本，且三个副本都在 ISR 列表中，其中 1 为首领副本。</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka-分区副本.png"/> </div>
<h3 id="2-3-不完全的首领选举">2.3 不完全的首领选举</h3>
<p>对于副本机制，在 broker 级别有一个可选的配置参数 <code>unclean.leader.election.enable</code>，默认值为 fasle，代表禁止不完全的首领选举。这是针对当首领副本挂掉且 ISR 中没有其他可用副本时，是否允许某个不完全同步的副本成为首领副本，这可能会导致数据丢失或者数据不一致，在某些对数据一致性要求较高的场景 (如金融领域)，这可能无法容忍的，所以其默认值为 false，如果你能够允许部分数据不一致的话，可以配置为 true。</p>
<h3 id="2-4-最少同步副本">2.4 最少同步副本</h3>
<p>ISR 机制的另外一个相关参数是 <code>min.insync.replicas</code> , 可以在 broker 或者主题级别进行配置，代表 ISR 列表中至少要有几个可用副本。这里假设设置为 2，那么当可用副本数量小于该值时，就认为整个分区处于不可用状态。此时客户端再向分区写入数据时候就会抛出异常 <code>org.apache.kafka.common.errors.NotEnoughReplicasExceptoin: Messages are rejected since there are fewer in-sync replicas than required。</code></p>
<h3 id="2-5-发送确认">2.5 发送确认</h3>
<p>Kafka 在生产者上有一个可选的参数 ack，该参数指定了必须要有多少个分区副本收到消息，生产者才会认为消息写入成功：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>acks=0</strong> ：消息发送出去就认为已经成功了，不会等待任何来自服务器的响应；</p>
</li>
<li class="lvl-2">
<p><strong>acks=1</strong> ： 只要集群的首领节点收到消息，生产者就会收到一个来自服务器成功响应；</p>
</li>
<li class="lvl-2">
<p><strong>acks=all</strong> ：只有当所有参与复制的节点全部收到消息时，生产者才会收到一个来自服务器的成功响应。</p>
</li>
</ul>
<h2 id="三、数据请求">三、数据请求</h2>
<h3 id="3-1-元数据请求机制">3.1 元数据请求机制</h3>
<p>在所有副本中，只有领导副本才能进行消息的读写处理。由于不同分区的领导副本可能在不同的 broker 上，如果某个 broker 收到了一个分区请求，但是该分区的领导副本并不在该 broker 上，那么它就会向客户端返回一个 <code>Not a Leader for Partition</code> 的错误响应。 为了解决这个问题，Kafka 提供了元数据请求机制。</p>
<p>首先集群中的每个 broker 都会缓存所有主题的分区副本信息，客户端会定期发送发送元数据请求，然后将获取的元数据进行缓存。定时刷新元数据的时间间隔可以通过为客户端配置 <code>metadata.max.age.ms</code> 来进行指定。有了元数据信息后，客户端就知道了领导副本所在的 broker，之后直接将读写请求发送给对应的 broker 即可。</p>
<p>如果在定时请求的时间间隔内发生的分区副本的选举，则意味着原来缓存的信息可能已经过时了，此时还有可能会收到 <code>Not a Leader for Partition</code> 的错误响应，这种情况下客户端会再次求发出元数据请求，然后刷新本地缓存，之后再去正确的 broker 上执行对应的操作，过程如下图：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka-元数据请求.png"/> </div>
<h3 id="3-2-数据可见性">3.2 数据可见性</h3>
<p>需要注意的是，并不是所有保存在分区首领上的数据都可以被客户端读取到，为了保证数据一致性，只有被所有同步副本 (ISR 中所有副本) 都保存了的数据才能被客户端读取到。</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka-数据可见性.png"/> </div>
<h3 id="3-3-零拷贝">3.3 零拷贝</h3>
<p>Kafka 所有数据的写入和读取都是通过零拷贝来实现的。传统拷贝与零拷贝的区别如下：</p>
<h4 id="传统模式下的四次拷贝与四次上下文切换">传统模式下的四次拷贝与四次上下文切换</h4>
<p>以将磁盘文件通过网络发送为例。传统模式下，一般使用如下伪代码所示的方法先将文件数据读入内存，然后通过 Socket 将内存中的数据发送出去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer = File.read</span><br><span class="line">Socket.send(buffer)</span><br></pre></td></tr></table></figure>
<p>这一过程实际上发生了四次数据拷贝。首先通过系统调用将文件数据读入到内核态 Buffer（DMA 拷贝），然后应用程序将内存态 Buffer 数据读入到用户态 Buffer（CPU 拷贝），接着用户程序通过 Socket 发送数据时将用户态 Buffer 数据拷贝到内核态 Buffer（CPU 拷贝），最后通过 DMA 拷贝将数据拷贝到 NIC Buffer。同时，还伴随着四次上下文切换，如下图所示：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka-BIO.png"/> </div>
<h4 id="sendfile和transferTo实现零拷贝">sendfile和transferTo实现零拷贝</h4>
<p>Linux 2.4+ 内核通过 <code>sendfile</code> 系统调用，提供了零拷贝。数据通过 DMA 拷贝到内核态 Buffer 后，直接通过 DMA 拷贝到 NIC Buffer，无需 CPU 拷贝。这也是零拷贝这一说法的来源。除了减少数据拷贝外，因为整个读文件到网络发送由一个 <code>sendfile</code> 调用完成，整个过程只有两次上下文切换，因此大大提高了性能。零拷贝过程如下图所示：</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka-零拷贝.png"/> </div>
<p>从具体实现来看，Kafka 的数据传输通过 TransportLayer 来完成，其子类 <code>PlaintextTransportLayer</code> 的 <code>transferFrom</code> 方法通过调用 Java NIO 中 FileChannel 的 <code>transferTo</code> 方法实现零拷贝，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">transferFrom</span><span class="params">(FileChannel fileChannel, <span class="type">long</span> position, <span class="type">long</span> count)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> fileChannel.transferTo(position, count, socketChannel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong> <code>transferTo</code> 和 <code>transferFrom</code> 并不保证一定能使用零拷贝。实际上是否能使用零拷贝与操作系统相关，如果操作系统提供 <code>sendfile</code> 这样的零拷贝系统调用，则这两个方法会通过这样的系统调用充分利用零拷贝的优势，否则并不能通过这两个方法本身实现零拷贝。</p>
<h2 id="四、物理存储">四、物理存储</h2>
<h3 id="4-1-分区分配">4.1 分区分配</h3>
<p>在创建主题时，Kafka 会首先决定如何在 broker 间分配分区副本，它遵循以下原则：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在所有 broker 上均匀地分配分区副本；</p>
</li>
<li class="lvl-2">
<p>确保分区的每个副本分布在不同的 broker 上；</p>
</li>
<li class="lvl-2">
<p>如果使用了 <code>broker.rack</code> 参数为 broker 指定了机架信息，那么会尽可能的把每个分区的副本分配到不同机架的 broker 上，以避免一个机架不可用而导致整个分区不可用。</p>
</li>
</ul>
<p>基于以上原因，如果你在一个单节点上创建一个 3 副本的主题，通常会抛出下面的异常：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">Error</span> <span class="string">while executing topic command : org.apache.kafka.common.errors.InvalidReplicationFactor   </span></span><br><span class="line"><span class="attr">Exception</span>: <span class="string">Replication factor: 3 larger than available brokers: 1.</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-分区数据保留规则">4.2 分区数据保留规则</h3>
<p>保留数据是 Kafka 的一个基本特性， 但是 Kafka 不会一直保留数据，也不会等到所有消费者都读取了消息之后才删除消息。相反， Kafka 为每个主题配置了数据保留期限，规定数据被删除之前可以保留多长时间，或者清理数据之前可以保留的数据量大小。分别对应以下四个参数：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>log.retention.bytes</code> ：删除数据前允许的最大数据量；默认值-1，代表没有限制；</p>
</li>
<li class="lvl-2">
<p><code>log.retention.ms</code>：保存数据文件的毫秒数，如果未设置，则使用 <code>log.retention.minutes</code> 中的值，默认为 null；</p>
</li>
<li class="lvl-2">
<p><code>log.retention.minutes</code>：保留数据文件的分钟数，如果未设置，则使用 <code>log.retention.hours</code> 中的值，默认为 null；</p>
</li>
<li class="lvl-2">
<p><code>log.retention.hours</code>：保留数据文件的小时数，默认值为 168，也就是一周。</p>
</li>
</ul>
<p>因为在一个大文件里查找和删除消息是很费时的，也很容易出错，所以 Kafka 把分区分成若干个片段，当前正在写入数据的片段叫作活跃片段。活动片段永远不会被删除。如果按照默认值保留数据一周，而且每天使用一个新片段，那么你就会看到，在每天使用一个新片段的同时会删除一个最老的片段，所以大部分时间该分区会有 7 个片段存在。</p>
<h3 id="4-3-文件格式">4.3 文件格式</h3>
<p>通常保存在磁盘上的数据格式与生产者发送过来消息格式是一样的。 如果生产者发送的是压缩过的消息，那么同一个批次的消息会被压缩在一起，被当作“包装消息”进行发送 (格式如下所示) ，然后保存到磁盘上。之后消费者读取后再自己解压这个包装消息，获取每条消息的具体信息。</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/kafka-compress-message.png"/> </div>]]></content>
      <categories>
        <category>中间件</category>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper使用场景</title>
    <url>/posts/59a1d908.html</url>
    <content><![CDATA[<h2 id="ZooKeeper-是什么">ZooKeeper 是什么</h2>
<p>  ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 Google 的 Chubby 一个开源的实现，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。<br>
  客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上注册了监听器，这个监听器也是由所连接的 zookeeper 机器来处理。对于写请求，这些请求会同时发给其他 zookeeper 机器并且达成一致后，请求才会返回成功。因此，随着 zookeeper 的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。有序性是 zookeeper 中非常重要的一个特性，所有的更新都是全局有序的，每个更新都有一个唯一的时间戳，这个时间戳称为 zxid（Zookeeper Transaction Id）。而读请求只会相对于更新有序，也就是读请求的返回结果中会带有这个 zookeeper 最新的 zxid。</p>
<h2 id="Zookeeper-工作原理">Zookeeper 工作原理</h2>
<p>  Zookeeper 的核心是原子广播，这个机制保证了各个 Server 之间的同步。实现这个机制的协议叫做 Zab 协议。Zab 协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab 就进入了恢复模式，当领导者被选举出来，且大多数 Server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 Server 具有相同的系统状态。</p>
<h2 id="ZooKeeper-提供了什么">ZooKeeper 提供了什么</h2>
<p>1、文件系统<br>
2、通知机制</p>
<h3 id="Zookeeper-文件系统">Zookeeper 文件系统</h3>
<p>  Zookeeper 提供一个多层级的节点命名空间（节点称为 znode）。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。Zookeeper 为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得 Zookeeper 不能用于存放大量的数据，每个节点的存放数据上限为 1M。</p>
<h4 id="四种类型的-znode">四种类型的 znode</h4>
<p>1、PERSISTENT-持久化目录节点客户端与 zookeeper 断开连接后，该节点依旧存在<br>
2、PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点客户端与 zookeeper 断开连接后，该节点依旧存在，只是 Zookeeper 给该节点名称进行顺序编号<br>
3、EPHEMERAL-临时目录节点客户端与 zookeeper 断开连接后，该节点被删除<br>
4、EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点</p>
<p>  客户端与 zookeeper 断开连接后，该节点被删除，只是 Zookeeper 给该节点名称进行顺序编号</p>
<h3 id="Zookeeper-通知机制">Zookeeper 通知机制</h3>
<p>  client 端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些 client 会收到 zk 的通知，然后 client 可以根据 znode 变化来做出业务上的改变等。</p>
<h4 id="zookeeper-watch-机制">zookeeper watch 机制</h4>
<p>  Watch 机制官方声明：一个 Watch 事件是一个一次性的触发器，当被设置了 Watch 的数据发生了改变的时候，则服务器将这个改变发送给设置了 Watch 的客户端，以便通知它们。<br>
Zookeeper 机制的特点：</p>
<ol>
<li class="lvl-3">
<p>一次性触发数据发生改变时，一个 watcher event 会被发送到 client，但是 client 只会收到一次这样的信息。</p>
</li>
<li class="lvl-3">
<p>watcher event 异步发送 watcher 的通知事件从 server 发送到 client 是异步的，这就存在一个问题，不同的客户端和服务器之间通过 socket 进行通信，由于网络延迟或其他因素导致客户端在不通的时刻监听到事件，由于 Zookeeper 本身提供了 ordering guarantee，即客户端监听事件后，才会感知它所监视 znode 发生了变化。所以我们使用 Zookeeper 不能期望能够监控到节点每次的变化。Zookeeper 只能保证最终的一致性，而无法保证强一致性。</p>
</li>
<li class="lvl-3">
<p>数据监视 Zookeeper 有数据监视和子数据监视 getdata() and exists()设置数据监视，getchildren()设置了子节点监视。</p>
</li>
<li class="lvl-3">
<p>注册 watcher getData、exists、getChildren</p>
</li>
<li class="lvl-3">
<p>触发 watcher create、delete、setData</p>
</li>
<li class="lvl-3">
<p>setData()会触发 znode 上设置的 data watch（如果 set 成功的话）。一个成功的 create() 操作会触发被创建的 znode 上的数据 watch，以及其父节点上的 child watch。而一个成功的 delete()操作将会同时触发一个 znode 的 data watch 和 child watch（因为这样就没有子节点了），同时也会触发其父节点的 childwatch。</p>
</li>
<li class="lvl-3">
<p>当一个客户端连接到一个新的服务器上时，watch 将会被以任意会话事件触发。当与一个服务器失去连接的时候，是无法接收到 watch 的。而当 client 重新连接时，如果需要的话，所有先前注册过的 watch，都会被重新注册。通常这是完全透明的。只有在一个特殊情况下，watch 可能会丢失：对于一个未创建的 znode 的exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上之前又删除了，这种情况下，这个 watch 事件可能会被丢失。</p>
</li>
<li class="lvl-3">
<p>Watch 是轻量级的，其实就是本地 JVM 的 Callback，服务器端只是存了是否有设置了 Watcher 的布尔类型</p>
</li>
</ol>
<h2 id="Zookeeper-做了什么">Zookeeper 做了什么</h2>
<p>1、命名服务<br>
2、配置管理<br>
3、集群管理<br>
4、分布式锁<br>
5、队列管理</p>
<h3 id="zk-的命名服务（文件系统）">zk 的命名服务（文件系统）</h3>
<p>  命名服务是指通过指定的名字来获取资源或者服务的地址，利用 zk 创建一个全局的路径，即是唯一的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等等。</p>
<h3 id="zk-的配置管理（文件系统、通知机制）">zk 的配置管理（文件系统、通知机制）</h3>
<p>  程序分布式的部署在不同的机器上，将程序的配置信息放在 zk 的 znode 下，当有配置发生改变时，也就是znode 发生变化时，可以通过改变 zk 中某个目录节点的内容，利用 watcher 通知给各个客户端，从而更改配置。</p>
<h3 id="Zookeeper-集群管理（文件系统、通知机制）">Zookeeper 集群管理（文件系统、通知机制）</h3>
<p>  所谓集群管理无在乎两点：是否有机器退出和加入、选举 master。<br>
  对于第一点，所有机器约定在父目录下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与zookeeper 的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除，于是，所有人都知道：它上船了。<br>
  新机器加入也是类似，所有机器收到通知：新兄弟目录加入，highcount 又有了，对于第二点，我们稍微改变一下，所有机器创建临时顺序编号目录节点，每次选取编号最小的机器作为 master 就好。</p>
<h3 id="Zookeeper-分布式锁（文件系统、通知机制）">Zookeeper 分布式锁（文件系统、通知机制）</h3>
<p>  有了 zookeeper 的一致性文件系统，锁的问题变得容易。锁服务可以分为两类，一个是保持独占，另一个是控制时序。<br>
  对于第一类，我们将 zookeeper 上的一个 znode 看作是一把锁，通过 createznode 的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的distribute_lock 节点就释放出锁。<br>
  对于第二类， /distribute_lock 已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选master 一样，编号最小的获得锁，用完删除，依次方便。</p>
<h4 id="获取分布式锁的流程">获取分布式锁的流程</h4>
<p>  在获取分布式锁的时候在 locker 节点下创建临时顺序节点，释放锁的时候删除该临时节点。客户端调用createNode 方法在 locker 下创建临时顺序节点，然后调用 getChildren(“locker”)来获取 locker 下面的所有子节点，注意此时不用设置任何 Watcher。客户端获取到所有的子节点 path 之后，如果发现自己创建的节点在所有创建的子节点序号最小，那么就认为该客户端获取到了锁。如果发现自己创建的节点并非 locker 所有子节点中最小的，说明自己还没有获取到锁，此时客户端需要找到比自己小的那个节点，然后对其调用 exist()方法，同时对其注册事件监听器。之后，让这个被关注的节点删除，则客户端的 Watcher 会收到相应通知，此时再次判断自己创建的节点是否是 locker 子节点中序号最小的，如果是则获取到了锁，如果不是则重复以上步骤继续获取到比自己小的一个节点并注册监听。当前这个过程中还需要许多的逻辑判断。<br>
  代码的实现主要是基于互斥锁，获取分布式锁的重点逻辑在于BaseDistributedLock，实现了基于Zookeeper 实现分布式锁的细节。</p>
<h3 id="Zookeeper-队列管理（文件系统、通知机制）">Zookeeper 队列管理（文件系统、通知机制）</h3>
<p>两种类型的队列：<br>
1、同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。<br>
2、队列按照 FIFO 方式进行入队和出队操作。第一类，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。第二类，和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。在特定的目录下创建PERSISTENT_SEQUENTIAL 节点，创建成功时 Watcher 通知等待的队列，队列删除序列号最小的节点用以消费。此场景下 Zookeeper 的 znode 用于消息存储，znode 存储的数据就是消息队列中的消息内容，<br>
SEQUENTIAL 序列号就是消息的编号，按序取出即可。由于创建的节点是持久化的，所以不必担心队列消息的丢失问题。</p>
<h2 id="Zookeeper其他问题">Zookeeper其他问题</h2>
<h3 id="Zookeeper-数据复制">Zookeeper 数据复制</h3>
<p>Zookeeper 作为一个集群提供一致的数据服务，自然，它要在所有机器间做数据复制。数据复制的好处：<br>
1、容错：一个节点出错，不致于让整个系统停止工作，别的节点可以接管它的工作；<br>
2、提高系统的扩展能力 ：把负载分布到多个节点上，或者增加节点来提高系统的负载能力；<br>
3、提高性能：让客户端本地访问就近的节点，提高用户访问速度。从客户端读写访问的透明度来看，数据复制集群系统分下面两种：<br>
1、写主(WriteMaster) ：对数据的修改提交给指定的节点。读无此限制，可以读取任何一个节点。这种情况下客户端需要对读与写进行区别，俗称读写分离；<br>
2、写任意(Write Any)：对数据的修改可提交给任意的节点，跟读一样。这种情况下，客户端对集群节点的角色与变化透明。</p>
<p>对 zookeeper 来说，它采用的方式是写任意。通过增加机器，它的读吞吐能力和响应能力扩展性非常好，而写，随着机器的增多吞吐能力肯定下降（这也是它建立 observer 的原因），而响应能力则取决于具体实现方式，是延迟复制保持最终一致性，还是立即复制快速响应。</p>
<h3 id="zookeeper-保证事务的顺序一致性">zookeeper 保证事务的顺序一致性</h3>
<p>  zookeeper 采用了递增的事务 Id 来标识，所有的 proposal（提议）都在被提出的时候加上了 zxid，zxid 实际上是一个 64 位的数字，高 32 位是 epoch（时期; 纪元; 世; 新时代）用来标识 leader 是否发生改变，如果有新的 leader 产生出来，epoch 会自增，低 32 位用来递增计数。当新产生 proposal 的时候，会依据数据库的两阶段过程，首先会向其他的 server 发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行。</p>
<h3 id="Zookeeper-下-Server-工作状态">Zookeeper 下 Server 工作状态</h3>
<p>每个 Server 在工作过程中有三种状态：<br>
LOOKING：当前 Server 不知道 leader 是谁，正在搜寻<br>
LEADING：当前 Server 即为选举出来的 leader<br>
FOLLOWING：leader 已经选举出来，当前 Server 与之同步</p>
<h3 id="zookeeper-如何选取主-leader">zookeeper 如何选取主 leader</h3>
<p>当 leader 崩溃或者 leader 失去大多数的 follower，这时 zk 进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的 Server 都恢复到一个正确的状态。Zk 的选举算法有两种：一种是基于 basic paxos 实现的，另外一种是基于 fast paxos 算法实现的。系统默认的选举算法为 fast paxos。</p>
<p>1、Zookeeper 选主流程(basic paxos)<br>
（1）选举线程由当前 Server 发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的Server；（2）选举线程首先向所有 Server 发起一次询问(包括自己)；（3）选举线程收到回复后，验证是否是自己发起的询问(验证 zxid 是否一致)，然后获取对方的 id(myid)，并存储到当前询问对象列表中，最后获取对方提议的 leader 相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中；（4）收到所有 Server 回复以后，就计算出 zxid 最大的那个 Server，并将这个 Server 相关信息设置成下一次要投票的 Server；（5）线程将当前 zxid 最大的 Server 设置为当前 Server 要推荐的 Leader，如果此时获胜的 Server 获得 n/2+ 1 的 Server 票数，设置当前推荐的 leader 为获胜的 Server，将根据获胜的 Server 相关信息设置自己的状态，否则，继续这个过程，直到 leader 被选举出来。 通过流程分析我们可以得出：要使 Leader 获得多数Server 的支持，则 Server 总数必须是奇数 2n+1，且存活的 Server 的数目不得少于 n+1. 每个 Server 启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的 server 还会从磁盘快照中恢复数据和会话信息，zk 会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。</p>
<p>2、Zookeeper 选主流程(basic paxos)<br>
fast paxos 流程是在选举过程中，某 Server 首先向所有 Server 提议自己要成为 leader，当其它 Server 收到提议以后，解决 epoch 和 zxid 的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出 Leader。</p>
<h3 id="Zookeeper-同步流程">Zookeeper 同步流程</h3>
<p>选完 Leader 以后，zk 就进入状态同步过程。<br>
1、Leader 等待 server 连接；<br>
2、Follower 连接 leader，将最大的 zxid 发送给 leader；<br>
3、Leader 根据 follower 的 zxid 确定同步点；<br>
4、完成同步后通知 follower 已经成为 uptodate 状态；<br>
5、Follower 收到 uptodate 消息后，又可以重新接受 client 的请求进行服务了。</p>
<h4 id="机器中为什么会有-leader">机器中为什么会有 leader</h4>
<p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，于是就需要进行 leader 选举。</p>
<h3 id="zk-节点宕机如何处理">zk 节点宕机如何处理</h3>
<p>Zookeeper 本身也是集群，推荐配置不少于 3 个服务器。Zookeeper 自身也要保证当一个节点宕机时，其他节点会继续提供服务。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果是一个 Follower 宕机，还有 2 台服务器提供访问，因为 Zookeeper 上的数据是有多个副本的，数据并不会丢失；</p>
</li>
<li class="lvl-2">
<p>如果是一个 Leader 宕机，Zookeeper 会选举出新的 Leader。</p>
</li>
</ul>
<p>ZK 集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在 ZK 节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。所以<br>
3 个节点的 cluster 可以挂掉 1 个节点(leader 可以得到 2 票&gt;1.5)<br>
2 个节点的 cluster 就不能挂掉任何 1 个节点了(leader 可以得到 1 票&lt;=1)</p>
<h4 id="zookeeper-负载均衡和-nginx-负载均衡区别">zookeeper 负载均衡和 nginx 负载均衡区别</h4>
<p>zk 的负载均衡是可以调控，nginx 只是能调权重，其他需要可控的都需要自己写插件；但是 nginx 的吞吐量比zk 大很多，应该说按业务选择用哪种方式。</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>基于ZooKeeper搭建Hadoop</title>
    <url>/posts/89e1e826.html</url>
    <content><![CDATA[<h2 id="一、高可用简介">一、高可用简介</h2>
<p>Hadoop 高可用 (High Availability) 分为 HDFS 高可用和 YARN 高可用，两者的实现基本类似，但 HDFS NameNode 对数据存储及其一致性的要求比 YARN ResourceManger 高得多，所以它的实现也更加复杂，故下面先进行讲解：</p>
<h3 id="1-1-高可用整体架构">1.1 高可用整体架构</h3>
<p>HDFS 高可用架构如下：</p>
<p><img src="https://camo.githubusercontent.com/b0b8e7bfcf3d75fc2048d0fb1671e7c7ffa234f8/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f484446532d48412d4172636869746563747572652d45647572656b612e706e67" alt="img"></p>
<blockquote>
<p><em>图片引用自：<a href="https://www.edureka.co/blog/how-to-set-up-hadoop-cluster-with-hdfs-high-availability/">https://www.edureka.co/blog/how-to-set-up-hadoop-cluster-with-hdfs-high-availability/</a></em></p>
</blockquote>
<p>HDFS 高可用架构主要由以下组件所构成：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Active NameNode 和 Standby NameNode</strong>：两台 NameNode 形成互备，一台处于 Active 状态，为主 NameNode，另外一台处于 Standby 状态，为备 NameNode，只有主 NameNode 才能对外提供读写服务。</p>
</li>
<li class="lvl-2">
<p><strong>主备切换控制器 ZKFailoverController</strong>：ZKFailoverController  作为独立的进程运行，对 NameNode 的主备切换进行总体控制。ZKFailoverController 能及时检测到 NameNode  的健康状况，在主 NameNode 故障时借助 Zookeeper 实现自动的主备选举和切换，当然 NameNode 目前也支持不依赖于  Zookeeper 的手动主备切换。</p>
</li>
<li class="lvl-2">
<p><strong>Zookeeper 集群</strong>：为主备切换控制器提供主备选举支持。</p>
</li>
<li class="lvl-2">
<p><strong>共享存储系统</strong>：共享存储系统是实现 NameNode 的高可用最为关键的部分，共享存储系统保存了  NameNode 在运行过程中所产生的 HDFS 的元数据。主 NameNode 和 NameNode  通过共享存储系统实现元数据同步。在进行主备切换的时候，新的主 NameNode 在确认元数据完全同步之后才能继续对外提供服务。</p>
</li>
<li class="lvl-2">
<p><strong>DataNode 节点</strong>：除了通过共享存储系统共享 HDFS 的元数据信息之外，主 NameNode 和备 NameNode 还需要共享 HDFS 的数据块和 DataNode 之间的映射关系。DataNode 会同时向主 NameNode 和备  NameNode 上报数据块的位置信息。</p>
</li>
</ul>
<h3 id="1-2-基于-QJM-的共享存储系统的数据同步机制分析">1.2 基于 QJM 的共享存储系统的数据同步机制分析</h3>
<p>目前 Hadoop 支持使用 Quorum Journal Manager (QJM) 或 Network File System  (NFS) 作为共享的存储系统，这里以 QJM 集群为例进行说明：Active NameNode 首先把 EditLog 提交到  JournalNode 集群，然后 Standby NameNode 再从 JournalNode 集群定时同步 EditLog，当  Active NameNode  宕机后， Standby  NameNode 在确认元数据完全同步之后就可以对外提供服务。</p>
<p>需要说明的是向 JournalNode 集群写入 EditLog 是遵循 “过半写入则成功” 的策略，所以你至少要有 3 个  JournalNode 节点，当然你也可以继续增加节点数量，但是应该保证节点总数是奇数。同时如果有 2N+1 台  JournalNode，那么根据过半写的原则，最多可以容忍有 N 台 JournalNode 节点挂掉。</p>
<p><img src="https://camo.githubusercontent.com/3f5274ffc21109f2390bdd2e1ec37d3e837b4cc1/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f6861646f6f702d514a4d2de5908ce6ada5e69cbae588b62e706e67" alt="img"></p>
<h3 id="1-3-NameNode-主备切换">1.3 NameNode 主备切换</h3>
<p>NameNode 实现主备切换的流程下图所示：</p>
<p><img src="https://camo.githubusercontent.com/33bb0d7c919a1ef21c959460dc3e5e116070b5bb/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f6861646f6f702d6e616d656e6f6465e4b8bbe5a487e58887e68da22e706e67" alt="img"></p>
<p>\1. HealthMonitor 初始化完成之后会启动内部的线程来定时调用对应 NameNode 的 HAServiceProtocol RPC 接口的方法，对 NameNode 的健康状态进行检测。 2. HealthMonitor 如果检测到 NameNode 的健康状态发生变化，会回调 ZKFailoverController 注册的相应方法进行处理。 3. 如果 ZKFailoverController 判断需要进行主备切换，会首先使用 ActiveStandbyElector 来进行自动的主备选举。 4. ActiveStandbyElector 与 Zookeeper 进行交互完成自动的主备选举。 5. ActiveStandbyElector 在主备选举完成后，会回调 ZKFailoverController 的相应方法来通知当前的 NameNode 成为主 NameNode 或备 NameNode。 6. ZKFailoverController 调用对应 NameNode 的 HAServiceProtocol RPC 接口的方法将 NameNode 转换为 Active 状态或 Standby 状态。</p>
<h3 id="1-4-YARN高可用">1.4 YARN高可用</h3>
<p>YARN ResourceManager 的高可用与 HDFS NameNode 的高可用类似，但是 ResourceManager 不像 NameNode ，没有那么多的元数据信息需要维护，所以它的状态信息可以直接写到 Zookeeper 上，并依赖 Zookeeper  来进行主备选举。</p>
<p><img src="https://camo.githubusercontent.com/9e7d4c0e0db498ab5f8663d58ad38deeaa330218/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f6861646f6f702d726d2d68612d6f766572766965772e706e67" alt="img"></p>
<h2 id="二、集群规划">二、集群规划</h2>
<p>按照高可用的设计目标：需要保证至少有两个 NameNode (一主一备)  和 两个 ResourceManager (一主一备)   ，同时为满足“过半写入则成功”的原则，需要至少要有 3 个 JournalNode 节点。这里使用三台主机进行搭建，集群规划如下：</p>
<p><img src="https://camo.githubusercontent.com/9d815ddad1f979ac693a6d96f2e59c0962a72c14/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f6861646f6f70e9ab98e58fafe794a8e99b86e7bea4e8a784e588922e706e67" alt="img"></p>
<h2 id="三、前置条件">三、前置条件</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>所有服务器都安装有 JDK，安装步骤可以参见：<a href="https://github.com/ihadyou/BigData-Notes/blob/master/notes/installation/Linux%E4%B8%8BJDK%E5%AE%89%E8%A3%85.md">Linux 下 JDK 的安装</a>；</p>
</li>
<li class="lvl-2">
<p>搭建好 ZooKeeper 集群，搭建步骤可以参见：<a href="https://github.com/ihadyou/BigData-Notes/blob/master/notes/installation/Zookeeper%E5%8D%95%E6%9C%BA%E7%8E%AF%E5%A2%83%E5%92%8C%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md">Zookeeper 单机环境和集群环境搭建</a></p>
</li>
<li class="lvl-2">
<p>所有服务器之间都配置好 SSH 免密登录。</p>
</li>
</ul>
<h2 id="四、集群配置">四、集群配置</h2>
<h3 id="4-1-下载并解压">4.1 下载并解压</h3>
<p>下载 Hadoop。这里我下载的是 CDH 版本 Hadoop，下载地址为：<a href="http://archive.cloudera.com/cdh5/cdh/5/">http://archive.cloudera.com/cdh5/cdh/5/</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># tar -zvxf hadoop-2.6.0-cdh5.15.2.tar.gz </span><br></pre></td></tr></table></figure>
<h3 id="4-2-配置环境变量">4.2 配置环境变量</h3>
<p>编辑 <code>profile</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># vim /etc/profile</span><br></pre></td></tr></table></figure>
<p>增加如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export HADOOP_HOME=/usr/app/hadoop-2.6.0-cdh5.15.2</span><br><span class="line">export  PATH=$&#123;HADOOP_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>执行 <code>source</code> 命令，使得配置立即生效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># source /etc/profile</span><br></pre></td></tr></table></figure>
<h3 id="4-3-修改配置">4.3 修改配置</h3>
<p>进入 <code>$&#123;HADOOP_HOME&#125;/etc/hadoop</code> 目录下，修改配置文件。各个配置文件内容如下：</p>
<h4 id="1-hadoop-env-sh">1. <a href="http://hadoop-env.sh">hadoop-env.sh</a></h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 指定JDK的安装位置</span><br><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_201/</span><br></pre></td></tr></table></figure>
<h4 id="2-core-site-xml">2.  core-site.xml</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- 指定 namenode 的 hdfs 协议文件系统的通信地址 --&gt;</span><br><span class="line">        &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hdfs://hadoop001:8020&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- 指定 hadoop 集群存储临时文件的目录 --&gt;</span><br><span class="line">        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;/home/hadoop/tmp&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- ZooKeeper 集群的地址 --&gt;</span><br><span class="line">        &lt;name&gt;ha.zookeeper.quorum&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hadoop001:2181,hadoop002:2181,hadoop002:2181&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- ZKFC 连接到 ZooKeeper 超时时长 --&gt;</span><br><span class="line">        &lt;name&gt;ha.zookeeper.session-timeout.ms&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;10000&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<h4 id="3-hdfs-site-xml">3. hdfs-site.xml</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- 指定 HDFS 副本的数量 --&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;3&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- namenode 节点数据（即元数据）的存放位置，可以指定多个目录实现容错，多个目录用逗号分隔 --&gt;</span><br><span class="line">        &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;/home/hadoop/namenode/data&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- datanode 节点数据（即数据块）的存放位置 --&gt;</span><br><span class="line">        &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;/home/hadoop/datanode/data&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- 集群服务的逻辑名称 --&gt;</span><br><span class="line">        &lt;name&gt;dfs.nameservices&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;mycluster&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- NameNode ID 列表--&gt;</span><br><span class="line">        &lt;name&gt;dfs.ha.namenodes.mycluster&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;nn1,nn2&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- nn1 的 RPC 通信地址 --&gt;</span><br><span class="line">        &lt;name&gt;dfs.namenode.rpc-address.mycluster.nn1&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hadoop001:8020&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- nn2 的 RPC 通信地址 --&gt;</span><br><span class="line">        &lt;name&gt;dfs.namenode.rpc-address.mycluster.nn2&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hadoop002:8020&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- nn1 的 http 通信地址 --&gt;</span><br><span class="line">        &lt;name&gt;dfs.namenode.http-address.mycluster.nn1&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hadoop001:50070&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- nn2 的 http 通信地址 --&gt;</span><br><span class="line">        &lt;name&gt;dfs.namenode.http-address.mycluster.nn2&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hadoop002:50070&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- NameNode 元数据在 JournalNode 上的共享存储目录 --&gt;</span><br><span class="line">        &lt;name&gt;dfs.namenode.shared.edits.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;qjournal://hadoop001:8485;hadoop002:8485;hadoop003:8485/mycluster&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- Journal Edit Files 的存储目录 --&gt;</span><br><span class="line">        &lt;name&gt;dfs.journalnode.edits.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;/home/hadoop/journalnode/data&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- 配置隔离机制，确保在任何给定时间只有一个 NameNode 处于活动状态 --&gt;</span><br><span class="line">        &lt;name&gt;dfs.ha.fencing.methods&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;sshfence&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- 使用 sshfence 机制时需要 ssh 免密登录 --&gt;</span><br><span class="line">        &lt;name&gt;dfs.ha.fencing.ssh.private-key-files&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;/root/.ssh/id_rsa&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- SSH 超时时间 --&gt;</span><br><span class="line">        &lt;name&gt;dfs.ha.fencing.ssh.connect-timeout&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;30000&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- 访问代理类，用于确定当前处于 Active 状态的 NameNode --&gt;</span><br><span class="line">        &lt;name&gt;dfs.client.failover.proxy.provider.mycluster&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- 开启故障自动转移 --&gt;</span><br><span class="line">        &lt;name&gt;dfs.ha.automatic-failover.enabled&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<h4 id="4-yarn-site-xml">4. yarn-site.xml</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!--配置 NodeManager 上运行的附属服务。需要配置成 mapreduce_shuffle 后才可以在 Yarn 上运行 MapReduce 程序。--&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- 是否启用日志聚合 (可选) --&gt;</span><br><span class="line">        &lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- 聚合日志的保存时间 (可选) --&gt;</span><br><span class="line">        &lt;name&gt;yarn.log-aggregation.retain-seconds&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;86400&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- 启用 RM HA --&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.ha.enabled&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- RM 集群标识 --&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.cluster-id&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;my-yarn-cluster&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- RM 的逻辑 ID 列表 --&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.ha.rm-ids&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;rm1,rm2&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- RM1 的服务地址 --&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.hostname.rm1&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hadoop002&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- RM2 的服务地址 --&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.hostname.rm2&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hadoop003&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- RM1 Web 应用程序的地址 --&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.webapp.address.rm1&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hadoop002:8088&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- RM2 Web 应用程序的地址 --&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.webapp.address.rm2&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hadoop003:8088&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- ZooKeeper 集群的地址 --&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.zk-address&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hadoop001:2181,hadoop002:2181,hadoop003:2181&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- 启用自动恢复 --&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.recovery.enabled&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!-- 用于进行持久化存储的类 --&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.store.class&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;org.apache.hadoop.yarn.server.resourcemanager.recovery.ZKRMStateStore&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<h4 id="5-mapred-site-xml">5.  mapred-site.xml</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;!--指定 mapreduce 作业运行在 yarn 上--&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<h4 id="5-slaves">5. slaves</h4>
<p>配置所有从属节点的主机名或 IP 地址，每行一个。所有从属节点上的 <code>DataNode</code> 服务和 <code>NodeManager</code> 服务都会被启动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hadoop001</span><br><span class="line">hadoop002</span><br><span class="line">hadoop003</span><br></pre></td></tr></table></figure>
<h3 id="4-4-分发程序">4.4 分发程序</h3>
<p>将 Hadoop 安装包分发到其他两台服务器，分发后建议在这两台服务器上也配置一下 Hadoop 的环境变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将安装包分发到hadoop002</span><br><span class="line">scp -r /usr/app/hadoop-2.6.0-cdh5.15.2/  hadoop002:/usr/app/</span><br><span class="line"># 将安装包分发到hadoop003</span><br><span class="line">scp -r /usr/app/hadoop-2.6.0-cdh5.15.2/  hadoop003:/usr/app/</span><br></pre></td></tr></table></figure>
<h2 id="五、启动集群">五、启动集群</h2>
<h3 id="5-1-启动ZooKeeper">5.1 启动ZooKeeper</h3>
<p>分别到三台服务器上启动 ZooKeeper 服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zkServer.sh start</span><br></pre></td></tr></table></figure>
<h3 id="5-2-启动Journalnode">5.2 启动Journalnode</h3>
<p>分别到三台服务器的的 <code>$&#123;HADOOP_HOME&#125;/sbin</code> 目录下，启动 <code>journalnode</code> 进程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hadoop-daemon.sh start journalnode</span><br></pre></td></tr></table></figure>
<h3 id="5-3-初始化NameNode">5.3 初始化NameNode</h3>
<p>在 <code>hadop001</code> 上执行 <code>NameNode</code> 初始化命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hdfs namenode -format</span><br></pre></td></tr></table></figure>
<p>执行初始化命令后，需要将 <code>NameNode</code> 元数据目录的内容，复制到其他未格式化的 <code>NameNode</code> 上。元数据存储目录就是我们在 <code>hdfs-site.xml</code> 中使用 <code>dfs.namenode.name.dir</code> 属性指定的目录。这里我们需要将其复制到 <code>hadoop002</code> 上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp -r /home/hadoop/namenode/data hadoop002:/home/hadoop/namenode/</span><br></pre></td></tr></table></figure>
<h3 id="5-4-初始化HA状态">5.4 初始化HA状态</h3>
<p>在任意一台 <code>NameNode</code> 上使用以下命令来初始化 ZooKeeper 中的 HA 状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hdfs zkfc -formatZK</span><br></pre></td></tr></table></figure>
<h3 id="5-5-启动HDFS">5.5 启动HDFS</h3>
<p>进入到 <code>hadoop001</code> 的 <code>$&#123;HADOOP_HOME&#125;/sbin</code> 目录下，启动 HDFS。此时 <code>hadoop001</code> 和 <code>hadoop002</code> 上的 <code>NameNode</code> 服务，和三台服务器上的 <code>DataNode</code> 服务都会被启动：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start-dfs.sh</span><br></pre></td></tr></table></figure>
<h3 id="5-6-启动YARN">5.6 启动YARN</h3>
<p>进入到 <code>hadoop002</code> 的 <code>$&#123;HADOOP_HOME&#125;/sbin</code> 目录下，启动 YARN。此时 <code>hadoop002</code> 上的 <code>ResourceManager</code> 服务，和三台服务器上的 <code>NodeManager</code> 服务都会被启动：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start-yarn.sh</span><br></pre></td></tr></table></figure>
<p>需要注意的是，这个时候 <code>hadoop003</code> 上的 <code>ResourceManager</code> 服务通常是没有启动的，需要手动启动：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn-daemon.sh start resourcemanager</span><br></pre></td></tr></table></figure>
<h2 id="六、查看集群">六、查看集群</h2>
<h3 id="6-1-查看进程">6.1 查看进程</h3>
<p>成功启动后，每台服务器上的进程应该如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@hadoop001 sbin]# jps</span><br><span class="line">4512 DFSZKFailoverController</span><br><span class="line">3714 JournalNode</span><br><span class="line">4114 NameNode</span><br><span class="line">3668 QuorumPeerMain</span><br><span class="line">5012 DataNode</span><br><span class="line">4639 NodeManager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@hadoop002 sbin]# jps</span><br><span class="line">4499 ResourceManager</span><br><span class="line">4595 NodeManager</span><br><span class="line">3465 QuorumPeerMain</span><br><span class="line">3705 NameNode</span><br><span class="line">3915 DFSZKFailoverController</span><br><span class="line">5211 DataNode</span><br><span class="line">3533 JournalNode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@hadoop003 sbin]# jps</span><br><span class="line">3491 JournalNode</span><br><span class="line">3942 NodeManager</span><br><span class="line">4102 ResourceManager</span><br><span class="line">4201 DataNode</span><br><span class="line">3435 QuorumPeerMain</span><br></pre></td></tr></table></figure>
<h3 id="6-2-查看Web-UI">6.2 查看Web UI</h3>
<p>HDFS 和 YARN 的端口号分别为 <code>50070</code> 和 <code>8080</code>，界面应该如下：</p>
<p>此时 hadoop001 上的 <code>NameNode</code> 处于可用状态：</p>
<p><img src="https://camo.githubusercontent.com/0dfee81cee0e0ea059224ad0a0df2b04b91339ef/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f6861646f6f70e9ab98e58fafe794a8e99b86e7bea4312e706e67" alt="img"></p>
<p>而 hadoop002 上的 <code>NameNode</code> 则处于备用状态：</p>
<p><img src="https://camo.githubusercontent.com/f0adb502fb1dc9f1b4d524b7ee954bb3e9ca04a2/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f6861646f6f70e9ab98e58fafe794a8e99b86e7bea4332e706e67" alt="img"></p>
<p>hadoop002 上的 <code>ResourceManager</code> 处于可用状态：</p>
<p><img src="https://camo.githubusercontent.com/afbb05472c97edf7c1f06b33c65f97a80171a1de/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f6861646f6f70e9ab98e58fafe794a8e99b86e7bea4342e706e67" alt="img"></p>
<p>hadoop003 上的 <code>ResourceManager</code> 则处于备用状态：</p>
<p><img src="https://camo.githubusercontent.com/dbed5c91d8834f4203f1ea9206767d3efc3b1491/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f6861646f6f70e9ab98e58fafe794a8e99b86e7bea4352e706e67" alt="img"></p>
<p>同时界面上也有 <code>Journal Manager</code> 的相关信息：</p>
<p><img src="https://camo.githubusercontent.com/00e35f7ac2eb2e8638bc6013be956ce728df2283/68747470733a2f2f67697465652e636f6d2f68656962616979696e672f426967446174612d4e6f7465732f7261772f6d61737465722f70696374757265732f6861646f6f70e9ab98e58fafe794a8e99b86e7bea4322e706e67" alt="img"></p>
<p>## 七、集群的二次启动</p>
<p>上面的集群初次启动涉及到一些必要初始化操作，所以过程略显繁琐。但是集群一旦搭建好后，想要再次启用它是比较方便的，步骤如下（首选需要确保 ZooKeeper 集群已经启动）：</p>
<p>在 <code> hadoop001</code> 启动 HDFS，此时会启动所有与 HDFS 高可用相关的服务，包括 NameNode，DataNode 和 JournalNode：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start-dfs.sh</span><br></pre></td></tr></table></figure>
<p>在 <code>hadoop002</code> 启动 YARN：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start-yarn.sh</span><br></pre></td></tr></table></figure>
<p>这个时候 <code>hadoop003</code> 上的 <code>ResourceManager</code> 服务通常还是没有启动的，需要手动启动：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn-daemon.sh start resourcemanager</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>中间件</category>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Sqoop一致性探讨</title>
    <url>/posts/f51cf5f9.html</url>
    <content><![CDATA[<h2 id="Sqoop导入导出Null存储一致性问题">Sqoop导入导出Null存储一致性问题</h2>
<p>Hive中的Null在底层是以“\N”来存储，而MySQL中的Null在底层就是Null，为了保证数据两端的一致性。在导出数据时采用–input-null-string和–input-null-non-string两个参数。导入数据时采用–null-string和–null-non-string。</p>
<h2 id="Sqoop数据导出一致性问题">Sqoop数据导出一致性问题</h2>
<h3 id="场景1：">场景1：</h3>
<p>如Sqoop在导出到Mysql时，使用4个Map任务，过程中有2个任务失败，那此时MySQL中存储了另外两个Map任务导入的数据，此时老板正好看到了这个报表数据。而开发工程师发现任务失败后，会调试问题并最终将全部数据正确的导入MySQL，那后面老板再次看报表数据，发现本次看到的数据与之前的不一致，这在生产环境是不允许的。</p>
<h4 id="解决方案：">解决方案：</h4>
<p>由于Sqoop将导出过程分解为多个事务，因此失败的导出作业可能会导致部分数据提交到数据库。在某些情况下，这可能进一步导致后续作业因插入冲突而失败，在其他情况下，这又可能导致数据重复。您可以通过–staging-table选项指定暂存表来解决此问题，该选项用作用于暂存导出数据的辅助表。最后，分阶段处理的数据将在单个事务中移至目标表</p>
<h5 id="命令：">命令：</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sqoop export \</span><br><span class="line">--connect jdbc:mysql://192.168.137.10:3306/user_behavior \</span><br><span class="line">--username root \</span><br><span class="line">--password 123456 \</span><br><span class="line">--table app_cource_study_report \</span><br><span class="line">--columns watch_video_cnt,complete_video_cnt,dt \</span><br><span class="line">--fields-terminated-by &quot;\t&quot; \</span><br><span class="line">--export-dir &quot;/user/hive/warehouse/tmp.db/app_cource_study_analysis_$&#123;day&#125;&quot; \</span><br><span class="line">--staging-table app_cource_study_report_tmp \</span><br><span class="line">--clear-staging-table \</span><br><span class="line">--input-null-string &#x27;\N&#x27;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Sqoop</category>
      </categories>
      <tags>
        <tag>sqoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Sqoop使用案例</title>
    <url>/posts/fdbfd415.html</url>
    <content><![CDATA[<h2 id="Sqoop-原理">Sqoop 原理</h2>
<p>将导入或导出命令翻译成 mapreduce 程序来实现。在翻译出的 mapreduce 中主要是对 inputformat 和 outputformat 进行定制。</p>
<h3 id="测试-Sqoop-是否能够成功连接数据库">测试 Sqoop 是否能够成功连接数据库</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop list-databases --connect jdbc:mysql://hadoop102:3306/</span></span><br><span class="line">--username root --password 000000</span><br></pre></td></tr></table></figure>
<h2 id="Sqoop-的简单使用案例">Sqoop 的简单使用案例</h2>
<h3 id="导入数据">导入数据</h3>
<p>在 Sqoop 中，“导入”概念指：从非大数据集群（RDBMS）向大数据集群（HDFS，HIVE，<br>
HBASE）中传输数据，叫做：导入，即使用 import 关键字。</p>
<h4 id="（1）全部导入">（1）全部导入</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop import \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--table staff \</span></span><br><span class="line"><span class="language-bash">--target-dir /user/company \</span></span><br><span class="line"><span class="language-bash">--delete-target-dir \</span></span><br><span class="line"><span class="language-bash">--num-mappers 1 \</span></span><br><span class="line"><span class="language-bash">--fields-terminated-by <span class="string">&quot;\t&quot;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="（2）查询导入">（2）查询导入</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop import \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--target-dir /user/company \</span></span><br><span class="line"><span class="language-bash">--delete-target-dir \</span></span><br><span class="line"><span class="language-bash">--num-mappers 1 \</span></span><br><span class="line"><span class="language-bash">--fields-terminated-by <span class="string">&quot;\t&quot;</span> \</span></span><br><span class="line"><span class="language-bash">--query <span class="string">&#x27;select name,sex from staff where id &lt;=1 and $CONDITIONS;&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>提示：<code>must contain '$CONDITIONS' in WHERE clause</code>.<br>
如果 query 后使用的是双引号，则$CONDITIONS 前必须加转移符，防止 shell 识别为自己的变量。</p>
<h4 id="（3）导入指定列">（3）导入指定列</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop import \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--target-dir /user/company \</span></span><br><span class="line"><span class="language-bash">--delete-target-dir \</span></span><br><span class="line"><span class="language-bash">--num-mappers 1 \</span></span><br><span class="line"><span class="language-bash">--fields-terminated-by <span class="string">&quot;\t&quot;</span> \</span></span><br><span class="line"><span class="language-bash">--columns <span class="built_in">id</span>,sex \</span></span><br><span class="line"><span class="language-bash">--table staff</span></span><br></pre></td></tr></table></figure>
<p>提示：columns 中如果涉及到多列，用逗号分隔，分隔时不要添加空格</p>
<h4 id="（4）使用-sqoop-关键字筛选查询导入数据">（4）使用 sqoop 关键字筛选查询导入数据</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop import \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--target-dir /user/company \</span></span><br><span class="line"><span class="language-bash">--delete-target-dir \</span></span><br><span class="line"><span class="language-bash">--num-mappers 1 \</span></span><br><span class="line"><span class="language-bash">--fields-terminated-by <span class="string">&quot;\t&quot;</span> \</span></span><br><span class="line"><span class="language-bash">--table staff \</span></span><br><span class="line"><span class="language-bash">--<span class="built_in">where</span> <span class="string">&quot;id=1&quot;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="RDBMS-到-Hive">RDBMS 到 Hive</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop import \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--table staff \</span></span><br><span class="line"><span class="language-bash">--num-mappers 1 \</span></span><br><span class="line"><span class="language-bash">--hive-import \</span></span><br><span class="line"><span class="language-bash">--fields-terminated-by <span class="string">&quot;\t&quot;</span> \</span></span><br><span class="line"><span class="language-bash">--hive-overwrite \</span></span><br><span class="line"><span class="language-bash">--hive-table staff_hive</span></span><br></pre></td></tr></table></figure>
<p>提示：该过程分为两步，第一步将数据导入到 HDFS，第二步将导入到 HDFS 的数据迁移到<br>
Hive 仓库，第一步默认的临时目录是/user/atguigu/表名</p>
<h4 id="RDBMS-到-Hbase">RDBMS 到 Hbase</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop import \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--table company \</span></span><br><span class="line"><span class="language-bash">--columns <span class="string">&quot;id,name,sex&quot;</span> \</span></span><br><span class="line"><span class="language-bash">--column-family <span class="string">&quot;info&quot;</span> \</span></span><br><span class="line"><span class="language-bash">--hbase-create-table \</span></span><br><span class="line"><span class="language-bash">--hbase-row-key <span class="string">&quot;id&quot;</span> \</span></span><br><span class="line"><span class="language-bash">--hbase-table <span class="string">&quot;hbase_company&quot;</span> \</span></span><br><span class="line"><span class="language-bash">--num-mappers 1 \</span></span><br><span class="line"><span class="language-bash">--split-by <span class="built_in">id</span></span></span><br></pre></td></tr></table></figure>
<p>提示：sqoop1.4.6 只支持 HBase1.0.1 之前的版本的自动创建 HBase 表的功能解决方案：手动创建 HBase 表</p>
<h3 id="导出数据">导出数据</h3>
<p>在 Sqoop 中，“导出”概念指：从大数据集群（HDFS，HIVE，HBASE）向非大数据集群（RDBMS）中传输数据，叫做：导出，即使用 export 关键字。</p>
<h4 id="HIVE-HDFS-到-RDBMS">HIVE/HDFS 到 RDBMS</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop <span class="built_in">export</span> \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--table staff \</span></span><br><span class="line"><span class="language-bash">--num-mappers 1 \</span></span><br><span class="line"><span class="language-bash">--export-dir /user/hive/warehouse/staff_hive \</span></span><br><span class="line"><span class="language-bash">--input-fields-terminated-by <span class="string">&quot;\t&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>提示：Mysql 中如果表不存在，不会自动创建</p>
<h3 id="脚本打包">脚本打包</h3>
<p>使用 opt 格式的文件打包 sqoop 命令，然后执行</p>
<h4 id="1-创建一个-opt-文件">1) 创建一个.opt 文件</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">mkdir</span> opt</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">touch</span> opt/job_HDFS2RDBMS.opt</span></span><br></pre></td></tr></table></figure>
<h4 id="2-编写-sqoop-脚本">2) 编写 sqoop 脚本</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">vi opt/job_HDFS2RDBMS.opt</span></span><br><span class="line">export</span><br><span class="line">--connect</span><br><span class="line">jdbc:mysql://hadoop102:3306/company</span><br><span class="line">--username</span><br><span class="line">root</span><br><span class="line">--password</span><br><span class="line">000000</span><br><span class="line">--table</span><br><span class="line">staff</span><br><span class="line">--num-mappers</span><br><span class="line">1</span><br><span class="line">--export-dir</span><br><span class="line">/user/hive/warehouse/staff_hive</span><br><span class="line">--input-fields-terminated-by</span><br><span class="line">&quot;\t&quot;</span><br></pre></td></tr></table></figure>
<h4 id="3-执行该脚本">3) 执行该脚本</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop --options-file opt/job_HDFS2RDBMS.opt</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Sqoop</category>
      </categories>
      <tags>
        <tag>sqoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Sqoop常用命令及参数</title>
    <url>/posts/e22156b1.html</url>
    <content><![CDATA[<h2 id="Sqoop-常用命令及参数">Sqoop 常用命令及参数</h2>
<h3 id="常用命令列举">常用命令列举</h3>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">命令</th>
<th style="text-align:left">类</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">import</td>
<td style="text-align:left">ImportTool</td>
<td style="text-align:left">将数据导入到集群</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">export</td>
<td style="text-align:left">ExportTool</td>
<td style="text-align:left">将集群数据导出</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">codegen</td>
<td style="text-align:left">CodeGenTool</td>
<td style="text-align:left">获取数据库中某张表数据生成Java 并打包Jar</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">create-hive-table</td>
<td style="text-align:left">CreateHiveTableTool</td>
<td style="text-align:left">创建 Hive 表</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">eval</td>
<td style="text-align:left">EvalSqlTool</td>
<td style="text-align:left">查看 SQL 执行结果</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">import-all-tables</td>
<td style="text-align:left">ImportAllTablesTool</td>
<td style="text-align:left">导入某个数据库下所有表到 HDFS 中</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">job</td>
<td style="text-align:left">JobTool</td>
<td style="text-align:left">用来生成一个 sqoop的任务，生成后，该任务并不执行，除非使用命令执行该任务</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">list-databases</td>
<td style="text-align:left">ListDatabasesTool</td>
<td style="text-align:left">列出所有数据库名</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">list-tables</td>
<td style="text-align:left">ListTablesTool</td>
<td style="text-align:left">列出某个数据库下所有表</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">merge</td>
<td style="text-align:left">MergeTool</td>
<td style="text-align:left">将 HDFS 中不同目录下面的数据合在一起，并存放在指定的目录中</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left">metastore</td>
<td style="text-align:left">MetastoreTool</td>
<td style="text-align:left">记录 sqoop job 的元数据信息，如果不启动 metastore 实例，则默认的元数据存储目录为：~/.sqoop，如果要更改存储目录，可以 在 配 置 文 件sqoop-site.xml 中进行更改</td>
</tr>
</tbody>
</table>
<h3 id="命令-参数详解">命令&amp;参数详解</h3>
<p>对于不同的命令，有不同的参数.</p>
<h4 id="公用参数：数据库连接">公用参数：数据库连接</h4>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">–connect</td>
<td style="text-align:left">连接关系型数据库的 URL</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">–connection-manager</td>
<td style="text-align:left">指定要使用的连接管理类</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">–driver</td>
<td style="text-align:left">Hadoop 根目录</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">–help</td>
<td style="text-align:left">打印帮助信息</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">–password</td>
<td style="text-align:left">连接数据库的密码</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">–username</td>
<td style="text-align:left">连接数据库的用户名</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">–verbose</td>
<td style="text-align:left">在控制台打印出详细信息</td>
</tr>
</tbody>
</table>
<h4 id="公用参数：import">公用参数：import</h4>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">–enclosed-by <char></td>
<td style="text-align:left">给字段值前加上指定的字符</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">–escaped-by <char></td>
<td style="text-align:left">对字段中的双引号加转义符</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">–fields-terminated-by <char></td>
<td style="text-align:left">设定每个字段是以什么符号作为结束，默认为逗号</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">–lines-terminated-by <char></td>
<td style="text-align:left">设定每行记录之间的分隔符，默认是\n</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">–mysql-delimiters</td>
<td style="text-align:left">Mysql 默认的分隔符设置，字段之间以逗号分隔，行之间以\n 分隔，默认转义符是\，字段值以单引号包裹。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">–optionally-enclosed-by <char></td>
<td style="text-align:left">给带有双引号或单引号的字段值前后加上指定字符。</td>
</tr>
</tbody>
</table>
<h4 id="公用参数：export">公用参数：export</h4>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">–input-enclosed-by <char></td>
<td style="text-align:left">对字段值前后加上指定字符</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">–input-escaped-by <char></td>
<td style="text-align:left">对含有转移符的字段做转义处理</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">–input-fields-terminated-by <char></td>
<td style="text-align:left">字段之间的分隔符</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">–input-lines-terminated-by <char></td>
<td style="text-align:left">行之间的分隔符</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">–input-optionally-enclosed-by <char></td>
<td style="text-align:left">给带有双引号或单引号的字段前后加上指定字符</td>
</tr>
</tbody>
</table>
<h4 id="公用参数：hive">公用参数：hive</h4>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">–hive-delims-replacement <arg></td>
<td style="text-align:left">用自定义的字符串替换掉数据中的\r\n和\013 \010等字符</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">–hive-drop-import-delims</td>
<td style="text-align:left">在导入数据到 hive 时，去掉数据中的\r\n\013\010 这样的字符</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">–map-column-hive <arg></td>
<td style="text-align:left">生成 hive 表时，可以更改生成字段的数据类型</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">–hive-partition-key</td>
<td style="text-align:left">创建分区，后面直接跟分区名，分区字段的默认类型为string</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">–hive-partition-value <v></td>
<td style="text-align:left">导入数据时，指定某个分区的值</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">–hive-home <dir></td>
<td style="text-align:left">hive 的安装目录，可以通过该参数覆盖之前默认配置的目录</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">–hive-import</td>
<td style="text-align:left">将数据从关系数据库中导入到 hive 表中</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">–hive-overwrite</td>
<td style="text-align:left">覆盖掉在 hive 表中已经存在的数据</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">–create-hive-table</td>
<td style="text-align:left">默认是 false，即，如果目标表已经存在了，那么创建任务失败。</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">–hive-table</td>
<td style="text-align:left">后面接要创建的 hive 表,默认使用 MySQL 的表名</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left">–table</td>
<td style="text-align:left">指定关系数据库的表名</td>
</tr>
</tbody>
</table>
<h4 id="命令-参数：import">命令&amp;参数：import</h4>
<p>将关系型数据库中的数据导入到 HDFS（包括 Hive，HBase）中，如果导入的是 Hive，那么当 Hive 中没有对应表时，则自动创建。</p>
<h5 id="1-命令：">1) 命令：</h5>
<h6 id="如：导入数据到-hive-中">如：导入数据到 hive 中</h6>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop import \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--table staff \</span></span><br><span class="line"><span class="language-bash">--hive-import</span></span><br></pre></td></tr></table></figure>
<h6 id="如：增量导入数据到-hive-中，mode-append">如：增量导入数据到 hive 中，mode=append</h6>
<p>append 导入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop import \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--table staff \</span></span><br><span class="line"><span class="language-bash">--num-mappers 1 \</span></span><br><span class="line"><span class="language-bash">--fields-terminated-by <span class="string">&quot;\t&quot;</span> \</span></span><br><span class="line"><span class="language-bash">--target-dir /user/hive/warehouse/staff_hive \</span></span><br><span class="line"><span class="language-bash">--check-column <span class="built_in">id</span> \</span></span><br><span class="line"><span class="language-bash">--incremental append \</span></span><br><span class="line"><span class="language-bash">--last-value 3</span></span><br></pre></td></tr></table></figure>
<p>尖叫提示：append 不能与–hive-等参数同时使用（Append mode for hive imports is not yet supported. Please remove the parameter --append-mode）</p>
<h6 id="如：增量导入数据到-hdfs-中，mode-lastmodified">如：增量导入数据到 hdfs 中，mode=lastmodified</h6>
<p>先在 mysql 中建表并插入几条数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> company.staff_timestamp(id <span class="type">int</span>(<span class="number">4</span>), name <span class="type">varchar</span>(<span class="number">255</span>), sex <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">last_modified <span class="type">timestamp</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span></span><br><span class="line"><span class="built_in">CURRENT_TIMESTAMP</span>);</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> company.staff_timestamp (id, name, sex) <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;AAA&#x27;</span>, <span class="string">&#x27;female&#x27;</span>);</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> company.staff_timestamp (id, name, sex) <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">&#x27;BBB&#x27;</span>, <span class="string">&#x27;female&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>先导入一部分数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop import \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--table staff_timestamp \</span></span><br><span class="line"><span class="language-bash">--delete-target-dir \</span></span><br><span class="line"><span class="language-bash">--m 1</span></span><br></pre></td></tr></table></figure>
<p>再增量导入一部分数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">insert into company.staff_timestamp (<span class="built_in">id</span>, name, sex) values(3, <span class="string">&#x27;CCC&#x27;</span>, <span class="string">&#x27;female&#x27;</span>);</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop import \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--table staff_timestamp \</span></span><br><span class="line"><span class="language-bash">--check-column last_modified \</span></span><br><span class="line"><span class="language-bash">--incremental lastmodified \</span></span><br><span class="line"><span class="language-bash">--last-value <span class="string">&quot;2017-09-28 22:20:38&quot;</span> \</span></span><br><span class="line"><span class="language-bash">--m 1 \</span></span><br><span class="line"><span class="language-bash">--append</span></span><br></pre></td></tr></table></figure>
<p>尖叫提示：使用 lastmodified 方式导入数据要指定增量数据是要–append（追加）还是要–merge-key（合并）尖叫提示：last-value 指定的值是会包含于增量导入的数据中</p>
<h5 id="2-参数：">2) 参数：</h5>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">- -append</td>
<td style="text-align:left">将数据追加到 HDFS 中已经存在的 DataSet 中，如果使用该参数，sqoop 会把数据先导入到临时文件目录，再合并。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">- -as-avrodatafile</td>
<td style="text-align:left">将数据导入到一个 Avro 数据文件中</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">- -as-sequencefile</td>
<td style="text-align:left">将数据导入到一个 sequence文件中</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">- -as-textfile</td>
<td style="text-align:left">将数据导入到一个普通文本文件中</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">- -boundary-query <statement></td>
<td style="text-align:left">边界查询，导入的数据为该参数的值（一条 sql 语句）所执行的结果区间内的数据。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">- -columns &lt;col1, col2, col3&gt;</td>
<td style="text-align:left">指定要导入的字段</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">- -direct</td>
<td style="text-align:left">直接导入模式，使用的是关系数据库自带的导入导出工具，以便加快导入导出过程。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">- -direct-split-size</td>
<td style="text-align:left">在使用上面 direct 直接导入的基础上，对导入的流按字节分块，即达到该阈值就产生一个新的文件</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">- -inline-lob-limit</td>
<td style="text-align:left">设定大对象数据类型的最大值</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">–m 或–num-mappers</td>
<td style="text-align:left">启动 N 个 map 来并行导入数据，默认 4 个。</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left">–query 或–e <statement></td>
<td style="text-align:left">将查询结果的数据导入，使用时必须伴随参–target-dir，–hive-table，如果查询中有where 条件，则条件后必须加上$CONDITIONS 关键字</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left">–split-by <column-name></td>
<td style="text-align:left">按照某一列来切分表的工作单元，不能与–autoreset-to-one-mapper 连用</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left">–table <table-name></td>
<td style="text-align:left">关系数据库的表名</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left">–target-dir <dir></td>
<td style="text-align:left">指定 HDFS 路径</td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left">–warehouse-dir <dir></td>
<td style="text-align:left">与 14 参数不能同时使用，导入数据到 HDFS 时指定的目录</td>
</tr>
<tr>
<td style="text-align:left">16</td>
<td style="text-align:left">–where</td>
<td style="text-align:left">从关系数据库导入数据时的查询条件</td>
</tr>
<tr>
<td style="text-align:left">17</td>
<td style="text-align:left">–z 或–compress</td>
<td style="text-align:left">允许压缩</td>
</tr>
<tr>
<td style="text-align:left">18</td>
<td style="text-align:left">–compression-codec</td>
<td style="text-align:left">指定 hadoop 压缩编码类，默认为 gzip(Use Hadoop codecdefault gzip)</td>
</tr>
<tr>
<td style="text-align:left">19</td>
<td style="text-align:left">–null-string <null-string></td>
<td style="text-align:left">string 类型的列如果 null，替换为指定字符串</td>
</tr>
<tr>
<td style="text-align:left">20</td>
<td style="text-align:left">–null-non-string <null-string></td>
<td style="text-align:left">非 string 类型的列如果 null，替换为指定字符串</td>
</tr>
<tr>
<td style="text-align:left">21</td>
<td style="text-align:left">–check-column <col></td>
<td style="text-align:left">作为增量导入判断的列名</td>
</tr>
<tr>
<td style="text-align:left">22</td>
<td style="text-align:left">–incremental <mode></td>
<td style="text-align:left">mode：append 或 lastmodified</td>
</tr>
<tr>
<td style="text-align:left">23</td>
<td style="text-align:left">–last-value <value></td>
<td style="text-align:left">指定某一个值，用于标记增量导入的位置</td>
</tr>
</tbody>
</table>
<h4 id="命令-参数：export">命令&amp;参数：export</h4>
<p>从 HDFS（包括 Hive 和 HBase）中奖数据导出到关系型数据库中。</p>
<h5 id="1-命令：-2">1) 命令：</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop <span class="built_in">export</span> \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--table staff \</span></span><br><span class="line"><span class="language-bash">--export-dir /user/company \</span></span><br><span class="line"><span class="language-bash">--input-fields-terminated-by <span class="string">&quot;\t&quot;</span> \</span></span><br><span class="line"><span class="language-bash">--num-mappers 1</span></span><br></pre></td></tr></table></figure>
<h5 id="2-参数：-2">2) 参数：</h5>
<table>
<thead>
<tr>
<th>序号</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>–direct</td>
<td>利用数据库自带的导入导出工具，以便于提高效率</td>
</tr>
<tr>
<td>2</td>
<td>–export-dir <dir></td>
<td>存放数据的 HDFS 的源目录</td>
</tr>
<tr>
<td>3</td>
<td>m 或–num-mappers <n></td>
<td>启动 N 个 map 来并行导入数据，默认 4 个</td>
</tr>
<tr>
<td>4</td>
<td>–table <table-name></td>
<td>指定导出到哪个 RDBMS 中的表</td>
</tr>
<tr>
<td>5</td>
<td>–update-key <col-name></td>
<td>对某一列的字段进行更新操作</td>
</tr>
<tr>
<td>6</td>
<td>–update-mode <mode></td>
<td>updateonlyallowinsert(默认)</td>
</tr>
<tr>
<td>7</td>
<td>–input-null-string <null-string></td>
<td>请参考 import</td>
</tr>
<tr>
<td>8</td>
<td>–input-null-non-string <null-string></td>
<td>请参考 import</td>
</tr>
<tr>
<td>9</td>
<td>–staging-table <staging-table-name></td>
<td>创建一张临时表，用于存放所有事务的结果，然后将所有事务结果一次性导入到目标表中，防止错误。</td>
</tr>
<tr>
<td>10</td>
<td>–clear-staging-table</td>
<td>如果第 9 个参数非空，则可以在导出操作执行前，清空临时事务结果表</td>
</tr>
</tbody>
</table>
<h4 id="命令-参数：codegen">命令&amp;参数：codegen</h4>
<p>将关系型数据库中的表映射为一个 Java 类，在该类中有各列对应的各个字段。</p>
<h5 id="1-命令：-3">1) 命令：</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop codegen \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--table staff \</span></span><br><span class="line"><span class="language-bash">--bindir /home/admin/Desktop/staff \</span></span><br><span class="line"><span class="language-bash">--class-name Staff \</span></span><br><span class="line"><span class="language-bash">--fields-terminated-by <span class="string">&quot;\t&quot;</span></span></span><br></pre></td></tr></table></figure>
<h5 id="2-参数：-3">2) 参数：</h5>
<table>
<thead>
<tr>
<th>序号</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>–bindir <dir></td>
<td>指定生成的 Java 文件、编译成的 class 文件及将生成文件打包为 jar 的文件输出路径</td>
</tr>
<tr>
<td>2</td>
<td>–class-name <name></td>
<td>设定生成的 Java 文件指定的名称</td>
</tr>
<tr>
<td>3</td>
<td>–outdir <dir></td>
<td>生成 Java 文件存放的路径</td>
</tr>
<tr>
<td>4</td>
<td>–package-name <name></td>
<td>包名，如 com.z，就会生成 com和 z 两级目录</td>
</tr>
<tr>
<td>5</td>
<td>–input-null-non-string <null-str></td>
<td>在生成的 Java 文件中，可以将 null 字符串或者不存在的字符串设置为想要设定的值（例如空字符串）</td>
</tr>
<tr>
<td>6</td>
<td>–input-null-string <null-str></td>
<td>将 null 字符串替换成想要替换的值（一般与 5 同时使用）</td>
</tr>
<tr>
<td>7</td>
<td>–map-column-java <arg></td>
<td>数据库字段在生成的 Java 文件中会映射成各种属性，且默认的数据类型与数据库类型保持对应关系。该参数可以改变默认类型，例如：–map-column-java id=long,name=String</td>
</tr>
<tr>
<td>8</td>
<td>–null-non-string <null-str></td>
<td>在生成 Java 文件时，可以将不存在或者 null 的字符串设置为其他值</td>
</tr>
<tr>
<td>9</td>
<td>–null-string <null-str></td>
<td>在生成 Java 文件时，将 null字符串设置为其他值（一般与8 同时用）</td>
</tr>
<tr>
<td>10</td>
<td>–table <table-name></td>
<td>对应关系数据库中的表名，生成的 Java 文件中的各个属性与该表的各个字段一一对应</td>
</tr>
</tbody>
</table>
<h4 id="命令-参数：create-hive-table">命令&amp;参数：create-hive-table</h4>
<p>生成与关系数据库表结构对应的 hive 表结构。</p>
<h5 id="1-命令：-4">1) 命令：</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop create-hive-table \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--table staff \</span></span><br><span class="line"><span class="language-bash">--hive-table hive_staff</span></span><br></pre></td></tr></table></figure>
<h5 id="2-参数：-4">2) 参数：</h5>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">–hive-home <dir></td>
<td style="text-align:left">Hive 的安装目录，可以通过该参数覆盖掉默认的 Hive 目录</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">–hive-overwrite</td>
<td style="text-align:left">覆盖掉在 Hive 表中已经存在的数据</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">–create-hive-table</td>
<td style="text-align:left">默认是 false，如果目标表已经存在了，那么创建任务会失败</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">–hive-table</td>
<td style="text-align:left">后面接要创建的 hive 表</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">–table</td>
<td style="text-align:left">指定关系数据库的表名</td>
</tr>
</tbody>
</table>
<h4 id="命令-参数：eval">命令&amp;参数：eval</h4>
<p>可以快速的使用 SQL 语句对关系型数据库进行操作，经常用于在 import 数据之前，了解一下 SQL 语句是否正确，数据是否正常，并可以将结果显示在控制台。</p>
<h5 id="1-命令：-5">1) 命令：</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop <span class="built_in">eval</span> \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--query <span class="string">&quot;SELECT * FROM staff&quot;</span></span></span><br></pre></td></tr></table></figure>
<h5 id="2-参数：-5">2) 参数：</h5>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">–query 或–e</td>
<td style="text-align:left">后跟查询的 SQL 语句</td>
</tr>
</tbody>
</table>
<h4 id="命令-参数：import-all-tables">命令&amp;参数：import-all-tables</h4>
<p>可以将 RDBMS 中的所有表导入到 HDFS 中，每一个表都对应一个 HDFS 目录</p>
<h5 id="1-命令：-6">1) 命令：</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop import-all-tables \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--warehouse-dir /all_tables</span></span><br></pre></td></tr></table></figure>
<h5 id="2-参数">2) 参数</h5>
<p>这些参数的含义均和 import 对应的含义一致</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">参数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">–as-avrodatafile</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">–as-sequencefile</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">–as-textfile</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">–direct</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">–direct-split-size <n></td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">–inline-lob-limit <n></td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">–m 或—num-mappers <n></td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">–warehouse-dir <dir></td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">-z 或–compress</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">–compression-codec</td>
</tr>
</tbody>
</table>
<h4 id="命令-参数：job">命令&amp;参数：job</h4>
<p>用来生成一个 sqoop 任务，生成后不会立即执行，需要手动执行。</p>
<h5 id="1-命令：-7">1) 命令：</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop job \</span></span><br><span class="line"><span class="language-bash">--create myjob -- import-all-tables \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop job \</span></span><br><span class="line"><span class="language-bash">--list</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop job \</span></span><br><span class="line"><span class="language-bash">--<span class="built_in">exec</span> myjob</span></span><br></pre></td></tr></table></figure>
<p>尖叫提示：注意 import-all-tables 和它左边的–之间有一个空格尖叫提示：如果需要连接 metastore，则–meta-connect jdbc:hsqldb:hsql://linux01:16000/sqoop</p>
<h5 id="2-参数-2">2) 参数</h5>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">–create <job-id></td>
<td style="text-align:left">创建 job 参数</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">–delete <job-id></td>
<td style="text-align:left">删除一个 job</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">–exec <job-id></td>
<td style="text-align:left">执行一个 job</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">–help</td>
<td style="text-align:left">显示 job 帮助</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">–list</td>
<td style="text-align:left">显示 job 列表</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">–meta-connect <jdbc-uri></td>
<td style="text-align:left">用来连接 metastore 服务</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">–show <job-id></td>
<td style="text-align:left">显示一个 job 的信息</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">–verbose</td>
<td style="text-align:left">打印命令运行时的详细信息</td>
</tr>
<tr>
<td style="text-align:left">尖叫提示：在执行一个 job 时，如果需要手动输入数据库密码，可以做如下优化</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>sqoop.metastore.client.record.password<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>If true, allow saved passwords in the metastore.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="命令-参数：list-databases">命令&amp;参数：list-databases</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop list-databases \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/ \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000</span></span><br></pre></td></tr></table></figure>
<h4 id="命令-参数：list-tables">命令&amp;参数：list-tables</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop list-tables \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000</span></span><br></pre></td></tr></table></figure>
<h4 id="命令-参数：merge">命令&amp;参数：merge</h4>
<p>将 HDFS 中不同目录下面的数据合并在一起并放入指定目录中</p>
<h5 id="数据环境：">数据环境：</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">new_staff</span><br><span class="line">1 AAA male</span><br><span class="line">2 BBB male</span><br><span class="line">3 CCC male</span><br><span class="line">4 DDD male</span><br><span class="line">old_staff</span><br><span class="line">1 AAA female</span><br><span class="line">2 CCC female</span><br><span class="line">3 BBB female</span><br><span class="line">6 DDD female</span><br></pre></td></tr></table></figure>
<p>尖叫提示：上边数据的列之间的分隔符应该为\t，行与行之间的分割符为\n，如果直接复制，请检查之。</p>
<h5 id="命令：-2">命令：</h5>
<p>创建 JavaBean：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop codegen \</span></span><br><span class="line"><span class="language-bash">--connect jdbc:mysql://hadoop102:3306/company \</span></span><br><span class="line"><span class="language-bash">--username root \</span></span><br><span class="line"><span class="language-bash">--password 000000 \</span></span><br><span class="line"><span class="language-bash">--table staff \</span></span><br><span class="line"><span class="language-bash">--bindir /home/admin/Desktop/staff \</span></span><br><span class="line"><span class="language-bash">--class-name Staff \</span></span><br><span class="line"><span class="language-bash">--fields-terminated-by <span class="string">&quot;\t&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>开始合并：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop merge \</span></span><br><span class="line"><span class="language-bash">--new-data /test/new/ \</span></span><br><span class="line"><span class="language-bash">--onto /test/old/ \</span></span><br><span class="line"><span class="language-bash">--target-dir /test/merged \</span></span><br><span class="line"><span class="language-bash">--jar-file /home/admin/Desktop/staff/Staff.jar \</span></span><br><span class="line"><span class="language-bash">--class-name Staff \</span></span><br><span class="line"><span class="language-bash">--merge-key <span class="built_in">id</span></span></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 AAA MALE</span><br><span class="line">2 BBB MALE</span><br><span class="line">3 CCC MALE</span><br><span class="line">4 DDD MALE</span><br><span class="line">6 DDD FEMALE</span><br></pre></td></tr></table></figure>
<h5 id="参数：">参数：</h5>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">–new-data <path></td>
<td style="text-align:left">HDFS 待合并的数据目录，合并后在新的数据集中保留</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">–onto <path></td>
<td style="text-align:left">HDFS 合并后，重复的部分在新的数据集中被覆盖</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">–merge-key <col></td>
<td style="text-align:left">合并键，一般是主键 ID</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">–jar-file <file></td>
<td style="text-align:left">合并时引入的 jar 包，该 jar包是通过 Codegen 工具生成的 jar 包</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">–class-name <class></td>
<td style="text-align:left">对应的表名或对象名，该class 类是包含在 jar 包中的</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">–target-dir <path></td>
<td style="text-align:left">合并后的数据在 HDFS 里存放的目录</td>
</tr>
</tbody>
</table>
<h4 id="命令-参数：metastore">命令&amp;参数：metastore</h4>
<p>记录了 Sqoop job 的元数据信息，如果不启动该服务，那么默认 job 元数据的存储目录为<br>
~/.sqoop，可在 sqoop-site.xml 中修改。启动 sqoop 的 metastore 服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop metastore</span></span><br></pre></td></tr></table></figure>
<p>关闭 sqoop 的 metastore 服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">bin/sqoop metastore --shutdown</span>  </span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Sqoop</category>
      </categories>
      <tags>
        <tag>sqoop</tag>
      </tags>
  </entry>
  <entry>
    <title>HDFS JAVA API</title>
    <url>/posts/b40432dd.html</url>
    <content><![CDATA[<h2 id="一、-简介">一、 简介</h2>
<p>想要使用 HDFS API，需要导入依赖 <code>hadoop-client</code>。如果是 CDH 版本的 Hadoop，还需要额外指明其仓库地址：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 </span></span><br><span class="line"><span class="string">         http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.ihadu&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hdfs-java-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.0</span>&lt;/version&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-<span class="number">8</span>&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;hadoop.version&gt;<span class="number">2.6</span><span class="number">.0</span>-cdh5<span class="number">.15</span><span class="number">.2</span>&lt;/hadoop.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!---配置 CDH 仓库地址--&gt;</span><br><span class="line">    &lt;repositories&gt;</span><br><span class="line">        &lt;repository&gt;</span><br><span class="line">            &lt;id&gt;cloudera&lt;/id&gt;</span><br><span class="line">            &lt;url&gt;https:<span class="comment">//repository.cloudera.com/artifactory/cloudera-repos/&lt;/url&gt;</span></span><br><span class="line">        &lt;/repository&gt;</span><br><span class="line">    &lt;/repositories&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--Hadoop-client--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;hadoop.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">4.12</span>&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<h2 id="二、API的使用">二、API的使用</h2>
<h3 id="2-1-FileSystem">2.1 FileSystem</h3>
<p>FileSystem 是所有 HDFS 操作的主入口。由于之后的每个单元测试都需要用到它，这里使用 <code>@Before</code> 注解进行标注。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HDFS_PATH</span> <span class="operator">=</span> <span class="string">&quot;hdfs://192.168.0.106:8020&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HDFS_USER</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> FileSystem fileSystem;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">        <span class="comment">// 这里我启动的是单节点的 Hadoop,所以副本系数设置为 1,默认值为 3</span></span><br><span class="line">        configuration.set(<span class="string">&quot;dfs.replication&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        fileSystem = FileSystem.get(<span class="keyword">new</span> <span class="title class_">URI</span>(HDFS_PATH), configuration, HDFS_USER);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@After</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    fileSystem = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-创建目录">2.2 创建目录</h3>
<p>支持递归创建目录：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mkDir</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    fileSystem.mkdirs(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/hdfs-api/test0/&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-创建指定权限的目录">2.3 创建指定权限的目录</h3>
<p><code>FsPermission(FsAction u, FsAction g, FsAction o)</code> 的三个参数分别对应：创建者权限，同组其他用户权限，其他用户权限，权限值定义在 <code>FsAction</code> 枚举类中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mkDirWithPermission</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    fileSystem.mkdirs(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/hdfs-api/test1/&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FsPermission</span>(FsAction.READ_WRITE, FsAction.READ, FsAction.READ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-创建文件，并写入内容">2.4 创建文件，并写入内容</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 如果文件存在，默认会覆盖, 可以通过第二个参数进行控制。第三个参数可以控制使用缓冲区的大小</span></span><br><span class="line">    <span class="type">FSDataOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> fileSystem.create(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/hdfs-api/test/a.txt&quot;</span>),</span><br><span class="line">                                               <span class="literal">true</span>, <span class="number">4096</span>);</span><br><span class="line">    out.write(<span class="string">&quot;hello hadoop!&quot;</span>.getBytes());</span><br><span class="line">    out.write(<span class="string">&quot;hello spark!&quot;</span>.getBytes());</span><br><span class="line">    out.write(<span class="string">&quot;hello flink!&quot;</span>.getBytes());</span><br><span class="line">    <span class="comment">// 强制将缓冲区中内容刷出</span></span><br><span class="line">    out.flush();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-判断文件是否存在">2.5 判断文件是否存在</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exist</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> fileSystem.exists(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/hdfs-api/test/a.txt&quot;</span>));</span><br><span class="line">    System.out.println(exists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-查看文件内容">2.6 查看文件内容</h3>
<p>查看小文本文件的内容，直接转换成字符串后输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readToString</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">FSDataInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> fileSystem.open(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/hdfs-api/test/a.txt&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">context</span> <span class="operator">=</span> inputStreamToString(inputStream, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    System.out.println(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>inputStreamToString</code> 是一个自定义方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把输入流转换为指定编码的字符</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputStream 输入流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> encode      指定编码类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">inputStreamToString</span><span class="params">(InputStream inputStream, String encode)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (encode == <span class="literal">null</span> || (<span class="string">&quot;&quot;</span>.equals(encode))) &#123;</span><br><span class="line">            encode = <span class="string">&quot;utf-8&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream, encode));</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> ((str = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            builder.append(str).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-7-文件重命名">2.7 文件重命名</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rename</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">oldPath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/hdfs-api/test/a.txt&quot;</span>);</span><br><span class="line">    <span class="type">Path</span> <span class="variable">newPath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/hdfs-api/test/b.txt&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> fileSystem.rename(oldPath, newPath);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-8-删除目录或文件">2.8 删除目录或文件</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  第二个参数代表是否递归删除</span></span><br><span class="line"><span class="comment">     *    +  如果 path 是一个目录且递归删除为 true, 则删除该目录及其中所有文件;</span></span><br><span class="line"><span class="comment">     *    +  如果 path 是一个目录但递归删除为 false,则会则抛出异常。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> fileSystem.delete(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/hdfs-api/test/b.txt&quot;</span>), <span class="literal">true</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-9-上传文件到HDFS">2.9 上传文件到HDFS</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFromLocalFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 如果指定的是目录，则会把目录及其中的文件都复制到指定目录下</span></span><br><span class="line">    <span class="type">Path</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;D:\\BigData-Notes\\notes\\installation&quot;</span>);</span><br><span class="line">    <span class="type">Path</span> <span class="variable">dst</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/hdfs-api/test/&quot;</span>);</span><br><span class="line">    fileSystem.copyFromLocalFile(src, dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-10-上传大文件并显示上传进度">2.10 上传大文件并显示上传进度</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFromLocalBigFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\kafka.tgz&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">float</span> <span class="variable">fileSize</span> <span class="operator">=</span> file.length();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line"></span><br><span class="line">        <span class="type">FSDataOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> fileSystem.create(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/hdfs-api/test/kafka5.tgz&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Progressable</span>() &#123;</span><br><span class="line">                  <span class="type">long</span> <span class="variable">fileCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">progress</span><span class="params">()</span> &#123;</span><br><span class="line">                     fileCount++;</span><br><span class="line">                     <span class="comment">// progress 方法每上传大约 64KB 的数据后就会被调用一次</span></span><br><span class="line">                     System.out.println(<span class="string">&quot;上传进度：&quot;</span> + (fileCount * <span class="number">64</span> * <span class="number">1024</span> / fileSize) * <span class="number">100</span> + <span class="string">&quot; %&quot;</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        IOUtils.copyBytes(in, out, <span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-11-从HDFS上下载文件">2.11 从HDFS上下载文件</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyToLocalFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/hdfs-api/test/kafka.tgz&quot;</span>);</span><br><span class="line">    <span class="type">Path</span> <span class="variable">dst</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;D:\\app\\&quot;</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 第一个参数控制下载完成后是否删除源文件,默认是 true,即删除;</span></span><br><span class="line"><span class="comment">     * 最后一个参数表示是否将 RawLocalFileSystem 用作本地文件系统;</span></span><br><span class="line"><span class="comment">     * RawLocalFileSystem 默认为 false,通常情况下可以不设置,</span></span><br><span class="line"><span class="comment">     * 但如果你在执行时候抛出 NullPointerException 异常,则代表你的文件系统与程序可能存在不兼容的情况 (window 下常见),</span></span><br><span class="line"><span class="comment">     * 此时可以将 RawLocalFileSystem 设置为 true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    fileSystem.copyToLocalFile(<span class="literal">false</span>, src, dst, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-12-查看指定目录下所有文件的信息">2.12 查看指定目录下所有文件的信息</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listFiles</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    FileStatus[] statuses = fileSystem.listStatus(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/hdfs-api&quot;</span>));</span><br><span class="line">    <span class="keyword">for</span> (FileStatus fileStatus : statuses) &#123;</span><br><span class="line">        <span class="comment">//fileStatus 的 toString 方法被重写过，直接打印可以看到所有信息</span></span><br><span class="line">        System.out.println(fileStatus.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>FileStatus</code> 中包含了文件的基本信息，比如文件路径，是否是文件夹，修改时间，访问时间，所有者，所属组，文件权限，是否是符号链接等，输出内容示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FileStatus&#123;</span><br><span class="line">path=hdfs://192.168.0.106:8020/hdfs-api/test; </span><br><span class="line">isDirectory=true; </span><br><span class="line">modification_time=1556680796191; </span><br><span class="line">access_time=0; </span><br><span class="line">owner=root; </span><br><span class="line">group=supergroup; </span><br><span class="line">permission=rwxr-xr-x; </span><br><span class="line">isSymlink=false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-13-递归查看指定目录下所有文件的信息">2.13 递归查看指定目录下所有文件的信息</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listFilesRecursive</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    RemoteIterator&lt;LocatedFileStatus&gt; files = fileSystem.listFiles(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/hbase&quot;</span>), <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">while</span> (files.hasNext()) &#123;</span><br><span class="line">        System.out.println(files.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和上面输出类似，只是多了文本大小，副本系数，块大小信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LocatedFileStatus&#123;</span><br><span class="line">path=hdfs://192.168.0.106:8020/hbase/hbase.version; </span><br><span class="line">isDirectory=false; </span><br><span class="line">length=7; </span><br><span class="line">replication=1; </span><br><span class="line">blocksize=134217728; </span><br><span class="line">modification_time=1554129052916; </span><br><span class="line">access_time=1554902661455; </span><br><span class="line">owner=root; </span><br><span class="line">group=supergroup;</span><br><span class="line">permission=rw-r--r--; </span><br><span class="line">isSymlink=false&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-14-查看文件的块信息">2.14 查看文件的块信息</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getFileBlockLocations</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">FileStatus</span> <span class="variable">fileStatus</span> <span class="operator">=</span> fileSystem.getFileStatus(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/hdfs-api/test/kafka.tgz&quot;</span>));</span><br><span class="line">    BlockLocation[] blocks = fileSystem.getFileBlockLocations(fileStatus, <span class="number">0</span>, fileStatus.getLen());</span><br><span class="line">    <span class="keyword">for</span> (BlockLocation block : blocks) &#123;</span><br><span class="line">        System.out.println(block);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>块输出信息有三个值，分别是文件的起始偏移量 (offset)，文件大小 (length)，块所在的主机名 (hosts)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0,57028557,hadoop001</span><br></pre></td></tr></table></figure>
<p>这里我上传的文件只有 57M(小于 128M)，且程序中设置了副本系数为 1，所有只有一个块信息。</p>
<blockquote>
<p>原文：<a href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>HDFS常用shell命令</title>
    <url>/posts/6e6bbadb.html</url>
    <content><![CDATA[<p><strong>1. 显示当前目录结构</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">显示当前目录结构</span></span><br><span class="line">hadoop fs -ls  &lt;path&gt;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">递归显示当前目录结构</span></span><br><span class="line">hadoop fs -ls  -R  &lt;path&gt;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">显示根目录下内容</span></span><br><span class="line">hadoop fs -ls  /</span><br></pre></td></tr></table></figure>
<p><strong>2. 创建目录</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">创建目录</span></span><br><span class="line">hadoop fs -mkdir  &lt;path&gt; </span><br><span class="line"><span class="meta"># </span><span class="language-bash">递归创建目录</span></span><br><span class="line">hadoop fs -mkdir -p  &lt;path&gt;  </span><br></pre></td></tr></table></figure>
<p><strong>3. 删除操作</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">删除文件</span></span><br><span class="line">hadoop fs -rm  &lt;path&gt;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">递归删除目录和文件</span></span><br><span class="line">hadoop fs -rm -R  &lt;path&gt; </span><br></pre></td></tr></table></figure>
<p><strong>4. 从本地加载文件到 HDFS</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">二选一执行即可</span></span><br><span class="line">hadoop fs -put  [localsrc] [dst] </span><br><span class="line">hadoop fs - copyFromLocal [localsrc] [dst] </span><br></pre></td></tr></table></figure>
<p><strong>5. 从 HDFS 导出文件到本地</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">二选一执行即可</span></span><br><span class="line">hadoop fs -get  [dst] [localsrc] </span><br><span class="line">hadoop fs -copyToLocal [dst] [localsrc] </span><br></pre></td></tr></table></figure>
<p><strong>6. 查看文件内容</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">二选一执行即可</span></span><br><span class="line">hadoop fs -text  &lt;path&gt; </span><br><span class="line">hadoop fs -cat  &lt;path&gt;  </span><br></pre></td></tr></table></figure>
<p><strong>7. 显示文件的最后一千字节</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -tail  &lt;path&gt; </span><br><span class="line"><span class="meta"># </span><span class="language-bash">和Linux下一样，会持续监听文件内容变化 并显示文件的最后一千字节</span></span><br><span class="line">hadoop fs -tail -f  &lt;path&gt; </span><br></pre></td></tr></table></figure>
<p><strong>8. 拷贝文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -cp [src] [dst]</span><br></pre></td></tr></table></figure>
<p><strong>9. 移动文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -mv [src] [dst] </span><br></pre></td></tr></table></figure>
<p><strong>10. 统计当前目录下各文件大小</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>默认单位字节</p>
</li>
<li class="lvl-2">
<p>-s : 显示所有文件大小总和，</p>
</li>
<li class="lvl-2">
<p>-h : 将以更友好的方式显示文件大小（例如 64.0m 而不是 67108864）</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -du  &lt;path&gt;  </span><br></pre></td></tr></table></figure>
<p><strong>11. 合并下载多个文件</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>-nl  在每个文件的末尾添加换行符（LF）</p>
</li>
<li class="lvl-2">
<p>-skip-empty-file 跳过空文件</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -getmerge</span><br><span class="line"><span class="meta"># </span><span class="language-bash">示例 将HDFS上的hbase-policy.xml和hbase-site.xml文件合并后下载到本地的/usr/test.xml</span></span><br><span class="line">hadoop fs -getmerge -nl  /test/hbase-policy.xml /test/hbase-site.xml /usr/test.xml</span><br></pre></td></tr></table></figure>
<p><strong>12. 统计文件系统的可用空间信息</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -df -h /</span><br></pre></td></tr></table></figure>
<p><strong>13. 更改文件复制因子</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -setrep [-R] [-w] &lt;numReplicas&gt; &lt;path&gt;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>更改文件的复制因子。如果 path 是目录，则更改其下所有文件的复制因子</p>
</li>
<li class="lvl-2">
<p>-w : 请求命令是否等待复制完成</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">示例</span></span><br><span class="line">hadoop fs -setrep -w 3 /user/hadoop/dir1</span><br></pre></td></tr></table></figure>
<p><strong>14. 权限控制</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">权限控制和Linux上使用方式一致</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">变更文件或目录的所属群组。 用户必须是文件的所有者或超级用户。</span></span><br><span class="line">hadoop fs -chgrp [-R] GROUP URI [URI ...]</span><br><span class="line"><span class="meta"># </span><span class="language-bash">修改文件或目录的访问权限  用户必须是文件的所有者或超级用户。</span></span><br><span class="line">hadoop fs -chmod [-R] &lt;MODE[,MODE]... | OCTALMODE&gt; URI [URI ...]</span><br><span class="line"><span class="meta"># </span><span class="language-bash">修改文件的拥有者  用户必须是超级用户。</span></span><br><span class="line">hadoop fs -chown [-R] [OWNER][:[GROUP]] URI [URI ]</span><br></pre></td></tr></table></figure>
<p><strong>15. 文件检测</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop fs -test - [defsz]  URI</span><br></pre></td></tr></table></figure>
<p>可选选项：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>-d：如果路径是目录，返回 0。</p>
</li>
<li class="lvl-2">
<p>-e：如果路径存在，则返回 0。</p>
</li>
<li class="lvl-2">
<p>-f：如果路径是文件，则返回 0。</p>
</li>
<li class="lvl-2">
<p>-s：如果路径不为空，则返回 0。</p>
</li>
<li class="lvl-2">
<p>-r：如果路径存在且授予读权限，则返回 0。</p>
</li>
<li class="lvl-2">
<p>-w：如果路径存在且授予写入权限，则返回 0。</p>
</li>
<li class="lvl-2">
<p>-z：如果文件长度为零，则返回 0。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">示例</span></span><br><span class="line">hadoop fs -test -e filename</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop分布式文件系统—HDFS</title>
    <url>/posts/eb6e206b.html</url>
    <content><![CDATA[<h2 id="一、介绍">一、介绍</h2>
<p><strong>HDFS</strong> （<strong>Hadoop Distributed File System</strong>）是 Hadoop 下的分布式文件系统，具有高容错、高吞吐量等特性，可以部署在低成本的硬件上。</p>
<h2 id="二、HDFS-设计原理">二、HDFS 设计原理</h2>
<div align="center"> <img width="600px" src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hdfsarchitecture.png"/> </div>
<h3 id="2-1-HDFS-架构">2.1 HDFS 架构</h3>
<p>HDFS 遵循主/从架构，由单个 NameNode(NN) 和多个 DataNode(DN) 组成：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>NameNode</strong> : 负责执行有关 <code>文件系统命名空间</code> 的操作，例如打开，关闭、重命名文件和目录等。它同时还负责集群元数据的存储，记录着文件中各个数据块的位置信息。</p>
</li>
<li class="lvl-2">
<p><strong>DataNode</strong>：负责提供来自文件系统客户端的读写请求，执行块的创建，删除等操作。</p>
</li>
</ul>
<h3 id="2-2-文件系统命名空间">2.2 文件系统命名空间</h3>
<p>HDFS 的 <code>文件系统命名空间</code> 的层次结构与大多数文件系统类似 (如 Linux)， 支持目录和文件的创建、移动、删除和重命名等操作，支持配置用户和访问权限，但不支持硬链接和软连接。<code>NameNode</code> 负责维护文件系统名称空间，记录对名称空间或其属性的任何更改。</p>
<h3 id="2-3-数据复制">2.3 数据复制</h3>
<p>由于 Hadoop 被设计运行在廉价的机器上，这意味着硬件是不可靠的，为了保证容错性，HDFS 提供了数据复制机制。HDFS 将每一个文件存储为一系列<strong>块</strong>，每个块由多个副本来保证容错，块的大小和复制因子可以自行配置（默认情况下，块大小是 128M，默认复制因子是 3）。</p>
<div align="center"> <img width="600px" src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hdfsdatanodes.png"/> </div>
<h3 id="2-4-数据复制的实现原理">2.4 数据复制的实现原理</h3>
<p>大型的 HDFS 实例在通常分布在多个机架的多台服务器上，不同机架上的两台服务器之间通过交换机进行通讯。在大多数情况下，同一机架中的服务器间的网络带宽大于不同机架中的服务器之间的带宽。因此 HDFS 采用机架感知副本放置策略，对于常见情况，当复制因子为 3 时，HDFS 的放置策略是：</p>
<p>在写入程序位于 <code>datanode</code> 上时，就优先将写入文件的一个副本放置在该 <code>datanode</code> 上，否则放在随机 <code>datanode</code> 上。之后在另一个远程机架上的任意一个节点上放置另一个副本，并在该机架上的另一个节点上放置最后一个副本。此策略可以减少机架间的写入流量，从而提高写入性能。</p>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hdfs-机架.png"/> </div>
<p>如果复制因子大于 3，则随机确定第 4 个和之后副本的放置位置，同时保持每个机架的副本数量低于上限，上限值通常为 <code>（复制系数 - 1）/机架数量 + 2</code>，需要注意的是不允许同一个 <code>dataNode</code> 上具有同一个块的多个副本。</p>
<h3 id="2-5-副本的选择">2.5  副本的选择</h3>
<p>为了最大限度地减少带宽消耗和读取延迟，HDFS 在执行读取请求时，优先读取距离读取器最近的副本。如果在与读取器节点相同的机架上存在副本，则优先选择该副本。如果 HDFS 群集跨越多个数据中心，则优先选择本地数据中心上的副本。</p>
<h3 id="2-6-架构的稳定性">2.6 架构的稳定性</h3>
<h4 id="1-心跳机制和重新复制">1. 心跳机制和重新复制</h4>
<p>每个 DataNode 定期向 NameNode 发送心跳消息，如果超过指定时间没有收到心跳消息，则将 DataNode 标记为死亡。NameNode 不会将任何新的 IO 请求转发给标记为死亡的 DataNode，也不会再使用这些 DataNode 上的数据。 由于数据不再可用，可能会导致某些块的复制因子小于其指定值，NameNode 会跟踪这些块，并在必要的时候进行重新复制。</p>
<h4 id="2-数据的完整性">2. 数据的完整性</h4>
<p>由于存储设备故障等原因，存储在 DataNode 上的数据块也会发生损坏。为了避免读取到已经损坏的数据而导致错误，HDFS 提供了数据完整性校验机制来保证数据的完整性，具体操作如下：</p>
<p>当客户端创建 HDFS 文件时，它会计算文件的每个块的 <code>校验和</code>，并将 <code>校验和</code> 存储在同一 HDFS 命名空间下的单独的隐藏文件中。当客户端检索文件内容时，它会验证从每个 DataNode 接收的数据是否与存储在关联校验和文件中的 <code>校验和</code> 匹配。如果匹配失败，则证明数据已经损坏，此时客户端会选择从其他 DataNode 获取该块的其他可用副本。</p>
<h4 id="3-元数据的磁盘故障">3.元数据的磁盘故障</h4>
<p><code>FsImage</code> 和 <code>EditLog</code> 是 HDFS 的核心数据，这些数据的意外丢失可能会导致整个 HDFS 服务不可用。为了避免这个问题，可以配置 NameNode 使其支持 <code>FsImage</code> 和 <code>EditLog</code> 多副本同步，这样 <code>FsImage</code> 或 <code>EditLog</code> 的任何改变都会引起每个副本 <code>FsImage</code> 和 <code>EditLog</code> 的同步更新。</p>
<h4 id="4-支持快照">4.支持快照</h4>
<p>快照支持在特定时刻存储数据副本，在数据意外损坏时，可以通过回滚操作恢复到健康的数据状态。</p>
<h2 id="三、HDFS-的特点">三、HDFS 的特点</h2>
<h3 id="3-1-高容错">3.1 高容错</h3>
<p>由于 HDFS 采用数据的多副本方案，所以部分硬件的损坏不会导致全部数据的丢失。</p>
<h3 id="3-2-高吞吐量">3.2 高吞吐量</h3>
<p>HDFS 设计的重点是支持高吞吐量的数据访问，而不是低延迟的数据访问。</p>
<h3 id="3-3-大文件支持">3.3  大文件支持</h3>
<p>HDFS 适合于大文件的存储，文档的大小应该是是 GB 到 TB 级别的。</p>
<h3 id="3-3-简单一致性模型">3.3 简单一致性模型</h3>
<p>HDFS 更适合于一次写入多次读取 (write-once-read-many) 的访问模型。支持将内容追加到文件末尾，但不支持数据的随机访问，不能从文件任意位置新增数据。</p>
<h3 id="3-4-跨平台移植性">3.4 跨平台移植性</h3>
<p>HDFS 具有良好的跨平台移植性，这使得其他大数据计算框架都将其作为数据持久化存储的首选方案。</p>
<h2 id="附：图解HDFS存储原理">附：图解HDFS存储原理</h2>
<blockquote>
<p>说明：以下图片引用自博客：<a href="https://blog.csdn.net/hudiefenmu/article/details/37655491">翻译经典 HDFS 原理讲解漫画</a></p>
</blockquote>
<h3 id="1-HDFS写数据原理">1. HDFS写数据原理</h3>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hdfs-write-1.jpg"/> </div>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hdfs-write-2.jpg"/> </div>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hdfs-write-3.jpg"/> </div>
<h3 id="2-HDFS读数据原理">2. HDFS读数据原理</h3>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hdfs-read-1.jpg"/> </div>
<h3 id="3-HDFS故障类型和其检测方法">3. HDFS故障类型和其检测方法</h3>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hdfs-tolerance-1.jpg"/> </div>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hdfs-tolerance-2.jpg"/> </div>
<p><strong>第二部分：读写故障的处理</strong></p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hdfs-tolerance-3.jpg"/> </div>
<p><strong>第三部分：DataNode 故障处理</strong></p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hdfs-tolerance-4.jpg"/> </div>
<p><strong>副本布局策略</strong>：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hdfs-tolerance-5.jpg"/> </div>
<blockquote>
<p>原文：<a href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>hdfs</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop单机版环境搭建</title>
    <url>/posts/1ad2170e.html</url>
    <content><![CDATA[<h2 id="一、前置条件">一、前置条件</h2>
<p>Hadoop 的运行依赖 JDK，需要预先安装，安装步骤见：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://gitee.com/oicio/BigData-Notes/blob/master/notes/installation/Linux%E4%B8%8BJDK%E5%AE%89%E8%A3%85.md">Linux 下 JDK 的安装</a></p>
</li>
</ul>
<h2 id="二、配置免密登录">二、配置免密登录</h2>
<p>Hadoop 组件之间需要基于 SSH 进行通讯。</p>
<h4 id="2-1-配置映射">2.1 配置映射</h4>
<p>配置 ip 地址和主机名映射：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/hosts</span><br><span class="line"><span class="meta"># </span><span class="language-bash">文件末尾增加</span></span><br><span class="line">192.168.43.202  hadoop001</span><br></pre></td></tr></table></figure>
<h3 id="2-2-生成公私钥">2.2  生成公私钥</h3>
<p>执行下面命令行生成公匙和私匙：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>
<h3 id="3-3-授权">3.3 授权</h3>
<p>进入 <code>~/.ssh</code> 目录下，查看生成的公匙和私匙，并将公匙写入到授权文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@@hadoop001 sbin]#  cd ~/.ssh</span><br><span class="line">[root@@hadoop001 .ssh]# ll</span><br><span class="line">-rw-------. 1 root root 1675 3 月  15 09:48 id_rsa</span><br><span class="line">-rw-r--r--. 1 root root  388 3 月  15 09:48 id_rsa.pub</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">写入公匙到授权文件</span></span><br><span class="line">[root@hadoop001 .ssh]# cat id_rsa.pub &gt;&gt; authorized_keys</span><br><span class="line">[root@hadoop001 .ssh]# chmod 600 authorized_keys</span><br></pre></td></tr></table></figure>
<h2 id="三、Hadoop-HDFS-环境搭建">三、Hadoop(HDFS)环境搭建</h2>
<h3 id="3-1-下载并解压">3.1 下载并解压</h3>
<p>下载 Hadoop 安装包，这里我下载的是 CDH 版本的，下载地址为：<a href="http://archive.cloudera.com/cdh5/cdh/5/">http://archive.cloudera.com/cdh5/cdh/5/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">解压</span></span><br><span class="line">tar -zvxf hadoop-2.6.0-cdh5.15.2.tar.gz </span><br></pre></td></tr></table></figure>
<h3 id="3-2-配置环境变量">3.2 配置环境变量</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">vi /etc/profile</span></span><br></pre></td></tr></table></figure>
<p>配置环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export HADOOP_HOME=/usr/app/hadoop-2.6.0-cdh5.15.2</span><br><span class="line">export  PATH=$&#123;HADOOP_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>执行 <code>source</code> 命令，使得配置的环境变量立即生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">source</span> /etc/profile</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-修改Hadoop配置">3.3 修改Hadoop配置</h3>
<p>进入 <code>$&#123;HADOOP_HOME&#125;/etc/hadoop/ </code> 目录下，修改以下配置：</p>
<h4 id="1-hadoop-env-sh-2">1. <a href="http://hadoop-env.sh">hadoop-env.sh</a></h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">JDK安装路径</span></span><br><span class="line">export  JAVA_HOME=/usr/java/jdk1.8.0_201/</span><br></pre></td></tr></table></figure>
<h4 id="2-core-site-xml-2">2. core-site.xml</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定 namenode 的 hdfs 协议文件系统的通信地址--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop001:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定 hadoop 存储临时文件的目录--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/hadoop/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-hdfs-site-xml-2">3. hdfs-site.xml</h4>
<p>指定副本系数和临时文件存储位置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--由于我们这里搭建是单机版本，所以指定 dfs 的副本系数为 1--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="4-slaves">4. slaves</h4>
<p>配置所有从属节点的主机名或 IP 地址，由于是单机版本，所以指定本机即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop001</span><br></pre></td></tr></table></figure>
<h3 id="3-4-关闭防火墙">3.4 关闭防火墙</h3>
<p>不关闭防火墙可能导致无法访问 Hadoop 的 Web UI 界面：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">查看防火墙状态</span></span><br><span class="line">sudo firewall-cmd --state</span><br><span class="line"><span class="meta"># </span><span class="language-bash">关闭防火墙:</span></span><br><span class="line">sudo systemctl stop firewalld.service</span><br></pre></td></tr></table></figure>
<h3 id="3-5-初始化">3.5 初始化</h3>
<p>第一次启动 Hadoop 时需要进行初始化，进入 <code>$&#123;HADOOP_HOME&#125;/bin/</code> 目录下，执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop001 bin]# ./hdfs namenode -format</span><br></pre></td></tr></table></figure>
<h3 id="3-6-启动HDFS">3.6 启动HDFS</h3>
<p>进入 <code>$&#123;HADOOP_HOME&#125;/sbin/</code> 目录下，启动 HDFS：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop001 sbin]# ./start-dfs.sh</span><br></pre></td></tr></table></figure>
<h3 id="3-7-验证是否启动成功">3.7 验证是否启动成功</h3>
<p>方式一：执行 <code>jps</code> 查看 <code>NameNode</code> 和 <code>DataNode</code> 服务是否已经启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop001 hadoop-2.6.0-cdh5.15.2]# jps</span><br><span class="line">9137 DataNode</span><br><span class="line">9026 NameNode</span><br><span class="line">9390 SecondaryNameNode</span><br></pre></td></tr></table></figure>
<p>方式二：查看 Web UI 界面，端口为 <code>50070</code>：</p>
<div align="center"> <img width="700px" src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hadoop安装验证.png"/> </div>
<h2 id="四、Hadoop-YARN-环境搭建">四、Hadoop(YARN)环境搭建</h2>
<h3 id="4-1-修改配置">4.1 修改配置</h3>
<p>进入 <code>$&#123;HADOOP_HOME&#125;/etc/hadoop/ </code> 目录下，修改以下配置：</p>
<h4 id="1-mapred-site-xml">1. mapred-site.xml</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">如果没有mapred-site.xml，则拷贝一份样例文件后再修改</span></span><br><span class="line">cp mapred-site.xml.template mapred-site.xml</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-yarn-site-xml">2. yarn-site.xml</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置 NodeManager 上运行的附属服务。需要配置成 mapreduce_shuffle 后才可以在 Yarn 上运行 MapReduce 程序。--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-启动服务">4.2 启动服务</h3>
<p>进入 <code>$&#123;HADOOP_HOME&#125;/sbin/</code> 目录下，启动 YARN：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./start-yarn.sh</span><br></pre></td></tr></table></figure>
<h4 id="4-3-验证是否启动成功">4.3 验证是否启动成功</h4>
<p>方式一：执行 <code>jps</code> 命令查看 <code>NodeManager</code> 和 <code>ResourceManager</code> 服务是否已经启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop001 hadoop-2.6.0-cdh5.15.2]# jps</span><br><span class="line">9137 DataNode</span><br><span class="line">9026 NameNode</span><br><span class="line">12294 NodeManager</span><br><span class="line">12185 ResourceManager</span><br><span class="line">9390 SecondaryNameNode</span><br></pre></td></tr></table></figure>
<p>方式二：查看 Web UI 界面，端口号为 <code>8088</code>：</p>
<div align="center"> <img width="700px" src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hadoop-yarn安装验证.png"/> </div>
<blockquote>
<p>原文：<a href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop集群环境搭建</title>
    <url>/posts/9daef378.html</url>
    <content><![CDATA[<h2 id="一、集群规划">一、集群规划</h2>
<p>这里搭建一个 3 节点的 Hadoop 集群，其中三台主机均部署 <code>DataNode</code> 和 <code>NodeManager</code> 服务，但只有 hadoop001 上部署 <code>NameNode</code> 和 <code>ResourceManager</code> 服务。</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hadoop集群规划.png"/> </div>
<h2 id="二、前置条件">二、前置条件</h2>
<p>Hadoop 的运行依赖 JDK，需要预先安装。其安装步骤单独整理至：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://gitee.com/oicio/BigData-Notes/blob/master/notes/installation/Linux%E4%B8%8BJDK%E5%AE%89%E8%A3%85.md">Linux 下 JDK 的安装</a></p>
</li>
</ul>
<h2 id="三、配置免密登录">三、配置免密登录</h2>
<h3 id="3-1-生成密匙">3.1 生成密匙</h3>
<p>在每台主机上使用 <code>ssh-keygen</code> 命令生成公钥私钥对：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>
<h3 id="3-2-免密登录">3.2 免密登录</h3>
<p>将 <code>hadoop001</code> 的公钥写到本机和远程机器的 <code> ~/ .ssh/authorized_key</code> 文件中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub hadoop001</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub hadoop002</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub hadoop003</span><br></pre></td></tr></table></figure>
<h3 id="3-3-验证免密登录">3.3 验证免密登录</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh hadoop002</span><br><span class="line">ssh hadoop003</span><br></pre></td></tr></table></figure>
<h2 id="四、集群搭建">四、集群搭建</h2>
<h3 id="3-1-下载并解压-2">3.1 下载并解压</h3>
<p>下载 Hadoop。这里我下载的是 CDH 版本 Hadoop，下载地址为：<a href="http://archive.cloudera.com/cdh5/cdh/5/">http://archive.cloudera.com/cdh5/cdh/5/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">tar -zvxf hadoop-2.6.0-cdh5.15.2.tar.gz</span> </span><br></pre></td></tr></table></figure>
<h3 id="3-2-配置环境变量-2">3.2 配置环境变量</h3>
<p>编辑 <code>profile</code> 文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">vim /etc/profile</span></span><br></pre></td></tr></table></figure>
<p>增加如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export HADOOP_HOME=/usr/app/hadoop-2.6.0-cdh5.15.2</span><br><span class="line">export  PATH=$&#123;HADOOP_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>执行 <code>source</code> 命令，使得配置立即生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">source</span> /etc/profile</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-修改配置">3.3 修改配置</h3>
<p>进入 <code>$&#123;HADOOP_HOME&#125;/etc/hadoop</code> 目录下，修改配置文件。各个配置文件内容如下：</p>
<h4 id="1-hadoop-env-sh-3">1. <a href="http://hadoop-env.sh">hadoop-env.sh</a></h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">指定JDK的安装位置</span></span><br><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_201/</span><br></pre></td></tr></table></figure>
<h4 id="2-core-site-xml-3">2.  core-site.xml</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定 namenode 的 hdfs 协议文件系统的通信地址--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop001:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定 hadoop 集群存储临时文件的目录--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/hadoop/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-hdfs-site-xml-3">3. hdfs-site.xml</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--namenode 节点数据（即元数据）的存放位置，可以指定多个目录实现容错，多个目录用逗号分隔--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/hadoop/namenode/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--datanode 节点数据（即数据块）的存放位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/hadoop/datanode/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="4-yarn-site-xml-2">4. yarn-site.xml</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置 NodeManager 上运行的附属服务。需要配置成 mapreduce_shuffle 后才可以在 Yarn 上运行 MapReduce 程序。--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--resourcemanager 的主机名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop001<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="5-mapred-site-xml-2">5.  mapred-site.xml</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定 mapreduce 作业运行在 yarn 上--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="5-slaves-2">5. slaves</h4>
<p>配置所有从属节点的主机名或 IP 地址，每行一个。所有从属节点上的 <code>DataNode</code> 服务和 <code>NodeManager</code> 服务都会被启动。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">hadoop001</span></span><br><span class="line"><span class="attr">hadoop002</span></span><br><span class="line"><span class="attr">hadoop003</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4-分发程序">3.4 分发程序</h3>
<p>将 Hadoop 安装包分发到其他两台服务器，分发后建议在这两台服务器上也配置一下 Hadoop 的环境变量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">将安装包分发到hadoop002</span></span><br><span class="line">scp -r /usr/app/hadoop-2.6.0-cdh5.15.2/  hadoop002:/usr/app/</span><br><span class="line"><span class="meta"># </span><span class="language-bash">将安装包分发到hadoop003</span></span><br><span class="line">scp -r /usr/app/hadoop-2.6.0-cdh5.15.2/  hadoop003:/usr/app/</span><br></pre></td></tr></table></figure>
<h3 id="3-5-初始化-2">3.5  初始化</h3>
<p>在 <code>Hadoop001</code> 上执行 namenode 初始化命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hdfs namenode -format</span><br></pre></td></tr></table></figure>
<h3 id="3-6-启动集群">3.6 启动集群</h3>
<p>进入到 <code>Hadoop001</code> 的 <code>$&#123;HADOOP_HOME&#125;/sbin</code> 目录下，启动 Hadoop。此时 <code>hadoop002</code> 和 <code>hadoop003</code> 上的相关服务也会被启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">启动dfs服务</span></span><br><span class="line">start-dfs.sh</span><br><span class="line"><span class="meta"># </span><span class="language-bash">启动yarn服务</span></span><br><span class="line">start-yarn.sh</span><br></pre></td></tr></table></figure>
<h3 id="3-7-查看集群">3.7 查看集群</h3>
<p>在每台服务器上使用 <code>jps</code> 命令查看服务进程，或直接进入 Web-UI 界面进行查看，端口为 <code>50070</code>。可以看到此时有三个可用的 <code>Datanode</code>：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hadoop-集群环境搭建.png"/> </div>
<BR/>
<p>点击 <code>Live Nodes</code> 进入，可以看到每个 <code>DataNode</code> 的详细情况：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hadoop-集群搭建2.png"/> </div>
<BR/>
<p>接着可以查看 Yarn 的情况，端口号为 <code>8088</code> ：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hadoop-集群搭建3.png"/> </div>
<h2 id="五、提交服务到集群">五、提交服务到集群</h2>
<p>提交作业到集群的方式和单机环境完全一致，这里以提交 Hadoop 内置的计算 Pi 的示例程序为例，在任何一个节点上执行都可以，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop jar /usr/app/hadoop-2.6.0-cdh5.15.2/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.6.0-cdh5.15.2.jar  pi  3  3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式计算框架—MapReduce</title>
    <url>/posts/9c03dda8.html</url>
    <content><![CDATA[<h2 id="一、MapReduce概述">一、MapReduce概述</h2>
<p>Hadoop MapReduce 是一个分布式计算框架，用于编写批处理应用程序。编写好的程序可以提交到 Hadoop 集群上用于并行处理大规模的数据集。</p>
<p>MapReduce 作业通过将输入的数据集拆分为独立的块，这些块由 <code>map</code> 以并行的方式处理，框架对 <code>map</code> 的输出进行排序，然后输入到 <code>reduce</code> 中。MapReduce 框架专门用于 <code>&lt;key，value&gt;</code> 键值对处理，它将作业的输入视为一组 <code>&lt;key，value&gt;</code> 对，并生成一组 <code>&lt;key，value&gt;</code> 对作为输出。输出和输出的 <code>key</code> 和 <code>value</code> 都必须实现<a href="http://hadoop.apache.org/docs/stable/api/org/apache/hadoop/io/Writable.html">Writable</a> 接口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(input) &lt;k1, v1&gt; -&gt; map -&gt; &lt;k2, v2&gt; -&gt; combine -&gt; &lt;k2, v2&gt; -&gt; reduce -&gt; &lt;k3, v3&gt; (output)</span><br></pre></td></tr></table></figure>
<h2 id="二、MapReduce编程模型简述">二、MapReduce编程模型简述</h2>
<p>这里以词频统计为例进行说明，MapReduce 处理的流程如下：</p>
<div align="center"> <img width="600px" src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/mapreduceProcess.png"/> </div>
<ol>
<li class="lvl-3">
<p><strong>input</strong> : 读取文本文件；</p>
</li>
<li class="lvl-3">
<p><strong>splitting</strong> : 将文件按照行进行拆分，此时得到的 <code>K1</code> 行数，<code>V1</code> 表示对应行的文本内容；</p>
</li>
<li class="lvl-3">
<p><strong>mapping</strong> : 并行将每一行按照空格进行拆分，拆分得到的 <code>List(K2,V2)</code>，其中 <code>K2</code> 代表每一个单词，由于是做词频统计，所以 <code>V2</code> 的值为 1，代表出现 1 次；</p>
</li>
<li class="lvl-3">
<p><strong>shuffling</strong>：由于 <code>Mapping</code> 操作可能是在不同的机器上并行处理的，所以需要通过 <code>shuffling</code> 将相同 <code>key</code> 值的数据分发到同一个节点上去合并，这样才能统计出最终的结果，此时得到 <code>K2</code> 为每一个单词，<code>List(V2)</code> 为可迭代集合，<code>V2</code> 就是 Mapping 中的 V2；</p>
</li>
<li class="lvl-3">
<p><strong>Reducing</strong> : 这里的案例是统计单词出现的总次数，所以 <code>Reducing</code> 对 <code>List(V2)</code> 进行归约求和操作，最终输出。</p>
</li>
</ol>
<p>MapReduce 编程模型中 <code>splitting</code> 和 <code>shuffing</code> 操作都是由框架实现的，需要我们自己编程实现的只有 <code>mapping</code> 和 <code>reducing</code>，这也就是 MapReduce 这个称呼的来源。</p>
<h2 id="三、combiner-partitioner">三、combiner &amp; partitioner</h2>
<div align="center"> <img width="600px" src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/Detailed-Hadoop-MapReduce-Data-Flow-14.png"/> </div>
<h3 id="3-1-InputFormat-RecordReaders">3.1 InputFormat &amp; RecordReaders</h3>
<p><code>InputFormat</code> 将输出文件拆分为多个 <code>InputSplit</code>，并由 <code>RecordReaders</code> 将 <code>InputSplit</code> 转换为标准的&lt;key，value&gt;键值对，作为 map 的输出。这一步的意义在于只有先进行逻辑拆分并转为标准的键值对格式后，才能为多个 <code>map</code> 提供输入，以便进行并行处理。</p>
<h3 id="3-2-Combiner">3.2 Combiner</h3>
<p><code>combiner</code> 是 <code>map</code> 运算后的可选操作，它实际上是一个本地化的 <code>reduce</code> 操作，它主要是在 <code>map</code> 计算出中间文件后做一个简单的合并重复 <code>key</code> 值的操作。这里以词频统计为例：</p>
<p><code>map</code> 在遇到一个 hadoop 的单词时就会记录为 1，但是这篇文章里 hadoop 可能会出现 n 多次，那么 <code>map</code> 输出文件冗余就会很多，因此在 <code>reduce</code> 计算前对相同的 key 做一个合并操作，那么需要传输的数据量就会减少，传输效率就可以得到提升。</p>
<p>但并非所有场景都适合使用 <code>combiner</code>，使用它的原则是 <code>combiner</code> 的输出不会影响到 <code>reduce</code> 计算的最终输入，例如：求总数，最大值，最小值时都可以使用 <code>combiner</code>，但是做平均值计算则不能使用 <code>combiner</code>。</p>
<p>不使用 combiner 的情况：</p>
<div align="center"> <img  width="600px"  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/mapreduce-without-combiners.png"/> </div>
<p>使用 combiner 的情况：</p>
<div align="center"> <img width="600px"  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/mapreduce-with-combiners.png"/> </div>
<p>可以看到使用 combiner 的时候，需要传输到 reducer 中的数据由 12keys，降低到 10keys。降低的幅度取决于你 keys 的重复率，下文词频统计案例会演示用 combiner 降低数百倍的传输量。</p>
<h3 id="3-3-Partitioner">3.3 Partitioner</h3>
<p><code>partitioner</code> 可以理解成分类器，将 <code>map</code> 的输出按照 key 值的不同分别分给对应的 <code>reducer</code>，支持自定义实现，下文案例会给出演示。</p>
<h2 id="四、MapReduce词频统计案例">四、MapReduce词频统计案例</h2>
<h3 id="4-1-项目简介">4.1 项目简介</h3>
<p>这里给出一个经典的词频统计的案例：统计如下样本数据中每个单词出现的次数。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">Spark</span>	<span class="string">HBase</span></span><br><span class="line"><span class="attr">Hive</span>	<span class="string">Flink	Storm	Hadoop	HBase	Spark</span></span><br><span class="line"><span class="attr">Flink</span></span><br><span class="line"><span class="attr">HBase</span>	<span class="string">Storm</span></span><br><span class="line"><span class="attr">HBase</span>	<span class="string">Hadoop	Hive	Flink</span></span><br><span class="line"><span class="attr">HBase</span>	<span class="string">Flink	Hive	Storm</span></span><br><span class="line"><span class="attr">Hive</span>	<span class="string">Flink	Hadoop</span></span><br><span class="line"><span class="attr">HBase</span>	<span class="string">Hive</span></span><br><span class="line"><span class="attr">Hadoop</span>	<span class="string">Spark	HBase	Storm</span></span><br><span class="line"><span class="attr">HBase</span>	<span class="string">Hadoop	Hive	Flink</span></span><br><span class="line"><span class="attr">HBase</span>	<span class="string">Flink	Hive	Storm</span></span><br><span class="line"><span class="attr">Hive</span>	<span class="string">Flink	Hadoop</span></span><br><span class="line"><span class="attr">HBase</span>	<span class="string">Hive</span></span><br></pre></td></tr></table></figure>
<p>为方便大家开发，我在项目源码中放置了一个工具类 <code>WordCountDataUtils</code>，用于模拟产生词频统计的样本，生成的文件支持输出到本地或者直接写到 HDFS 上。</p>
<blockquote>
<p>项目完整源码下载地址：<a href="https://gitee.com/oicio/BigData-Notes/tree/master/code/Hadoop/hadoop-word-count">hadoop-word-count</a></p>
</blockquote>
<h3 id="4-2-项目依赖">4.2 项目依赖</h3>
<p>想要进行 MapReduce 编程，需要导入 <code>hadoop-client</code> 依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hadoop.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-3-WordCountMapper">4.3 WordCountMapper</h3>
<p>将每行数据按照指定分隔符进行拆分。这里需要注意在 MapReduce 中必须使用 Hadoop 定义的类型，因为 Hadoop 预定义的类型都是可序列化，可比较的，所有类型均实现了 <code>WritableComparable</code> 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCountMapper</span> <span class="keyword">extends</span> <span class="title class_">Mapper</span>&lt;LongWritable, Text, Text, IntWritable&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, </span><br><span class="line">                                                                      InterruptedException &#123;</span><br><span class="line">        String[] words = value.toString().split(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            context.write(<span class="keyword">new</span> <span class="title class_">Text</span>(word), <span class="keyword">new</span> <span class="title class_">IntWritable</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>WordCountMapper</code> 对应下图的 Mapping 操作：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hadoop-code-mapping.png"/> </div>
<p><code>WordCountMapper</code> 继承自 <code>Mappe</code> 类，这是一个泛型类，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WordCountMapper <span class="keyword">extends</span> <span class="title class_">Mapper</span>&lt;LongWritable, Text, Text, IntWritable&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mapper</span>&lt;KEYIN, VALUEIN, KEYOUT, VALUEOUT&gt; &#123;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>KEYIN</strong> : <code>mapping</code> 输入 key 的类型，即每行的偏移量 (每行第一个字符在整个文本中的位置)，<code>Long</code> 类型，对应 Hadoop 中的 <code>LongWritable</code> 类型；</p>
</li>
<li class="lvl-2">
<p><strong>VALUEIN</strong> : <code>mapping</code> 输入 value 的类型，即每行数据；<code>String</code> 类型，对应 Hadoop 中 <code>Text</code> 类型；</p>
</li>
<li class="lvl-2">
<p><strong>KEYOUT</strong> ：<code>mapping</code> 输出的 key 的类型，即每个单词；<code>String</code> 类型，对应 Hadoop 中 <code>Text</code> 类型；</p>
</li>
<li class="lvl-2">
<p><strong>VALUEOUT</strong>：<code>mapping</code> 输出 value 的类型，即每个单词出现的次数；这里用 <code>int</code> 类型，对应 <code>IntWritable</code> 类型。</p>
</li>
</ul>
<h3 id="4-4-WordCountReducer">4.4 WordCountReducer</h3>
<p>在 Reduce 中进行单词出现次数的统计：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCountReducer</span> <span class="keyword">extends</span> <span class="title class_">Reducer</span>&lt;Text, IntWritable, Text, IntWritable&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, </span><br><span class="line">                                                                                  InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (IntWritable value : values) &#123;</span><br><span class="line">            count += value.get();</span><br><span class="line">        &#125;</span><br><span class="line">        context.write(key, <span class="keyword">new</span> <span class="title class_">IntWritable</span>(count));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下图，<code>shuffling</code> 的输出是 reduce 的输入。这里的 key 是每个单词，values 是一个可迭代的数据类型，类似 <code>(1,1,1,...)</code>。</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hadoop-code-reducer.png"/> </div>
<h3 id="4-4-WordCountApp">4.4 WordCountApp</h3>
<p>组装 MapReduce 作业，并提交到服务器运行，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组装作业 并提交到集群运行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCountApp</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里为了直观显示参数 使用了硬编码，实际开发中可以通过外部传参</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HDFS_URL</span> <span class="operator">=</span> <span class="string">&quot;hdfs://192.168.0.107:8020&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HADOOP_USER_NAME</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  文件输入路径和输出路径由外部传参指定</span></span><br><span class="line">        <span class="keyword">if</span> (args.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Input and output paths are necessary!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要指明 hadoop 用户名，否则在 HDFS 上创建目录时可能会抛出权限不足的异常</span></span><br><span class="line">        System.setProperty(<span class="string">&quot;HADOOP_USER_NAME&quot;</span>, HADOOP_USER_NAME);</span><br><span class="line"></span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">        <span class="comment">// 指明 HDFS 的地址</span></span><br><span class="line">        configuration.set(<span class="string">&quot;fs.defaultFS&quot;</span>, HDFS_URL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个 Job</span></span><br><span class="line">        <span class="type">Job</span> <span class="variable">job</span> <span class="operator">=</span> Job.getInstance(configuration);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置运行的主类</span></span><br><span class="line">        job.setJarByClass(WordCountApp.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 Mapper 和 Reducer</span></span><br><span class="line">        job.setMapperClass(WordCountMapper.class);</span><br><span class="line">        job.setReducerClass(WordCountReducer.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 Mapper 输出 key 和 value 的类型</span></span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(IntWritable.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 Reducer 输出 key 和 value 的类型</span></span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(IntWritable.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果输出目录已经存在，则必须先删除，否则重复运行程序时会抛出异常</span></span><br><span class="line">        <span class="type">FileSystem</span> <span class="variable">fileSystem</span> <span class="operator">=</span> FileSystem.get(<span class="keyword">new</span> <span class="title class_">URI</span>(HDFS_URL), configuration, HADOOP_USER_NAME);</span><br><span class="line">        <span class="type">Path</span> <span class="variable">outputPath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Path</span>(args[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (fileSystem.exists(outputPath)) &#123;</span><br><span class="line">            fileSystem.delete(outputPath, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置作业输入文件和输出文件的路径</span></span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> <span class="title class_">Path</span>(args[<span class="number">0</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, outputPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将作业提交到群集并等待它完成，参数设置为 true 代表打印显示对应的进度</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> job.waitForCompletion(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭之前创建的 fileSystem</span></span><br><span class="line">        fileSystem.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据作业结果,终止当前运行的 Java 虚拟机,退出程序</span></span><br><span class="line">        System.exit(result ? <span class="number">0</span> : -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是：如果不设置 <code>Mapper</code> 操作的输出类型，则程序默认它和 <code>Reducer</code> 操作输出的类型相同。</p>
<h3 id="4-5-提交到服务器运行">4.5 提交到服务器运行</h3>
<p>在实际开发中，可以在本机配置 hadoop 开发环境，直接在 IDE 中启动进行测试。这里主要介绍一下打包提交到服务器运行。由于本项目没有使用除 Hadoop 外的第三方依赖，直接打包即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">mvn clean package</span></span><br></pre></td></tr></table></figure>
<p>使用以下命令提交作业：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop jar /usr/appjar/hadoop-word-count-1.0.jar \</span><br><span class="line">com.oicio.WordCountApp \</span><br><span class="line">/wordcount/input.txt /wordcount/output/WordCountApp</span><br></pre></td></tr></table></figure>
<p>作业完成后查看 HDFS 上生成目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">查看目录</span></span><br><span class="line">hadoop fs -ls /wordcount/output/WordCountApp</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看统计结果</span></span><br><span class="line">hadoop fs -cat /wordcount/output/WordCountApp/part-r-00000</span><br></pre></td></tr></table></figure>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hadoop-wordcountapp.png"/> </div>
<h2 id="五、词频统计案例进阶之Combiner">五、词频统计案例进阶之Combiner</h2>
<h3 id="5-1-代码实现">5.1 代码实现</h3>
<p>想要使用 <code>combiner</code> 功能只要在组装作业时，添加下面一行代码即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置 Combiner</span></span><br><span class="line">job.setCombinerClass(WordCountReducer.class);</span><br></pre></td></tr></table></figure>
<h3 id="5-2-执行结果">5.2 执行结果</h3>
<p>加入 <code>combiner</code> 后统计结果是不会有变化的，但是可以从打印的日志看出 <code>combiner</code> 的效果：</p>
<p>没有加入 <code>combiner</code> 的打印日志：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hadoop-no-combiner.png"/> </div>
<p>加入 <code>combiner</code> 后的打印日志如下：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hadoop-combiner.png"/> </div>
<p>这里我们只有一个输入文件并且小于 128M，所以只有一个 Map 进行处理。可以看到经过 combiner 后，records 由 <code>3519</code> 降低为 <code>6</code>(样本中单词种类就只有 6 种)，在这个用例中 combiner 就能极大地降低需要传输的数据量。</p>
<h2 id="六、词频统计案例进阶之Partitioner">六、词频统计案例进阶之Partitioner</h2>
<h3 id="6-1-默认的Partitioner">6.1  默认的Partitioner</h3>
<p>这里假设有个需求：将不同单词的统计结果输出到不同文件。这种需求实际上比较常见，比如统计产品的销量时，需要将结果按照产品种类进行拆分。要实现这个功能，就需要用到自定义 <code>Partitioner</code>。</p>
<p>这里先介绍下 MapReduce 默认的分类规则：在构建 job 时候，如果不指定，默认的使用的是 <code>HashPartitioner</code>：对 key 值进行哈希散列并对 <code>numReduceTasks</code> 取余。其实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashPartitioner</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">Partitioner</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPartition</span><span class="params">(K key, V value,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> numReduceTasks)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (key.hashCode() &amp; Integer.MAX_VALUE) % numReduceTasks;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-自定义Partitioner">6.2 自定义Partitioner</h3>
<p>这里我们继承 <code>Partitioner</code> 自定义分类规则，这里按照单词进行分类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomPartitioner</span> <span class="keyword">extends</span> <span class="title class_">Partitioner</span>&lt;Text, IntWritable&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPartition</span><span class="params">(Text text, IntWritable intWritable, <span class="type">int</span> numPartitions)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> WordCountDataUtils.WORD_LIST.indexOf(text.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构建 <code>job</code> 时候指定使用我们自己的分类规则，并设置 <code>reduce</code> 的个数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置自定义分区规则</span></span><br><span class="line">job.setPartitionerClass(CustomPartitioner.class);</span><br><span class="line"><span class="comment">// 设置 reduce 个数</span></span><br><span class="line">job.setNumReduceTasks(WordCountDataUtils.WORD_LIST.size());</span><br></pre></td></tr></table></figure>
<h3 id="6-3-执行结果">6.3  执行结果</h3>
<p>执行结果如下，分别生成 6 个文件，每个文件中为对应单词的统计结果：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hadoop-wordcountcombinerpartition.png"/> </div>
<blockquote>
<p>原文：<a href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>集群资源管理器—YARN</title>
    <url>/posts/1cd6a8e1.html</url>
    <content><![CDATA[<h2 id="一、hadoop-yarn-简介">一、hadoop yarn 简介</h2>
<p><strong>Apache YARN</strong> (Yet Another Resource Negotiator)  是 hadoop 2.0 引入的集群资源管理系统。用户可以将各种服务框架部署在 YARN 上，由 YARN 进行统一地管理和资源分配。</p>
<div align="center"> <img width="600px"  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/yarn-base.png"/> </div>
<h2 id="二、YARN架构">二、YARN架构</h2>
<div align="center"> <img width="600px" src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/Figure3Architecture-of-YARN.png"/> </div>
<h3 id="1-ResourceManager">1. ResourceManager</h3>
<p><code>ResourceManager</code> 通常在独立的机器上以后台进程的形式运行，它是整个集群资源的主要协调者和管理者。<code>ResourceManager</code> 负责给用户提交的所有应用程序分配资源，它根据应用程序优先级、队列容量、ACLs、数据位置等信息，做出决策，然后以共享的、安全的、多租户的方式制定分配策略，调度集群资源。</p>
<h3 id="2-NodeManager">2. NodeManager</h3>
<p><code>NodeManager</code> 是 YARN 集群中的每个具体节点的管理者。主要负责该节点内所有容器的生命周期的管理，监视资源和跟踪节点健康。具体如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>启动时向 <code>ResourceManager</code> 注册并定时发送心跳消息，等待 <code>ResourceManager</code> 的指令；</p>
</li>
<li class="lvl-2">
<p>维护 <code>Container</code> 的生命周期，监控 <code>Container</code> 的资源使用情况；</p>
</li>
<li class="lvl-2">
<p>管理任务运行时的相关依赖，根据 <code>ApplicationMaster</code> 的需要，在启动 <code>Container</code> 之前将需要的程序及其依赖拷贝到本地。</p>
</li>
</ul>
<h3 id="3-ApplicationMaster">3. ApplicationMaster</h3>
<p>在用户提交一个应用程序时，YARN 会启动一个轻量级的进程 <code>ApplicationMaster</code>。<code>ApplicationMaster</code> 负责协调来自 <code>ResourceManager</code> 的资源，并通过 <code>NodeManager</code> 监视容器内资源的使用情况，同时还负责任务的监控与容错。具体如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>根据应用的运行状态来决定动态计算资源需求；</p>
</li>
<li class="lvl-2">
<p>向 <code>ResourceManager</code> 申请资源，监控申请的资源的使用情况；</p>
</li>
<li class="lvl-2">
<p>跟踪任务状态和进度，报告资源的使用情况和应用的进度信息；</p>
</li>
<li class="lvl-2">
<p>负责任务的容错。</p>
</li>
</ul>
<h3 id="4-Contain">4. Contain</h3>
<p><code>Container</code> 是 YARN 中的资源抽象，它封装了某个节点上的多维度资源，如内存、CPU、磁盘、网络等。当 AM 向 RM 申请资源时，RM 为 AM 返回的资源是用 <code>Container</code> 表示的。YARN 会为每个任务分配一个 <code>Container</code>，该任务只能使用该 <code>Container</code> 中描述的资源。<code>ApplicationMaster</code> 可在 <code>Container</code> 内运行任何类型的任务。例如，<code>MapReduce ApplicationMaster</code> 请求一个容器来启动 map 或 reduce 任务，而 <code>Giraph ApplicationMaster</code> 请求一个容器来运行 Giraph 任务。</p>
<h2 id="三、YARN工作原理简述">三、YARN工作原理简述</h2>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/yarn工作原理简图.png"/> </div>
<ol>
<li class="lvl-3">
<p><code>Client</code> 提交作业到 YARN 上；</p>
</li>
<li class="lvl-3">
<p><code>Resource Manager</code> 选择一个 <code>Node Manager</code>，启动一个 <code>Container</code> 并运行 <code>Application Master</code> 实例；</p>
</li>
<li class="lvl-3">
<p><code>Application Master</code> 根据实际需要向 <code>Resource Manager</code> 请求更多的 <code>Container</code> 资源（如果作业很小, 应用管理器会选择在其自己的 JVM 中运行任务）；</p>
</li>
<li class="lvl-3">
<p><code>Application Master</code> 通过获取到的 <code>Container</code> 资源执行分布式计算。</p>
</li>
</ol>
<h2 id="四、YARN工作原理详述">四、YARN工作原理详述</h2>
<div align="center"> <img width="600px" src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/yarn工作原理.png"/> </div>
<h4 id="1-作业提交">1. 作业提交</h4>
<p>client 调用 job.waitForCompletion 方法，向整个集群提交 MapReduce 作业 (第 1 步) 。新的作业 ID(应用 ID) 由资源管理器分配 (第 2 步)。作业的 client 核实作业的输出, 计算输入的 split, 将作业的资源 (包括 Jar 包，配置文件, split 信息) 拷贝给 HDFS(第 3 步)。 最后, 通过调用资源管理器的 submitApplication() 来提交作业 (第 4 步)。</p>
<h4 id="2-作业初始化">2. 作业初始化</h4>
<p>当资源管理器收到 submitApplciation() 的请求时, 就将该请求发给调度器 (scheduler), 调度器分配 container, 然后资源管理器在该 container 内启动应用管理器进程, 由节点管理器监控 (第 5 步)。</p>
<p>MapReduce 作业的应用管理器是一个主类为 MRAppMaster 的 Java 应用，其通过创造一些 bookkeeping 对象来监控作业的进度,  得到任务的进度和完成报告 (第 6 步)。然后其通过分布式文件系统得到由客户端计算好的输入 split(第 7 步)，然后为每个输入 split 创建一个 map 任务, 根据 mapreduce.job.reduces 创建 reduce 任务对象。</p>
<h4 id="3-任务分配">3. 任务分配</h4>
<p>如果作业很小, 应用管理器会选择在其自己的 JVM 中运行任务。</p>
<p>如果不是小作业,  那么应用管理器向资源管理器请求 container 来运行所有的 map 和 reduce 任务 (第 8 步)。这些请求是通过心跳来传输的,  包括每个 map 任务的数据位置，比如存放输入 split 的主机名和机架 (rack)，调度器利用这些信息来调度任务，尽量将任务分配给存储数据的节点, 或者分配给和存放输入 split 的节点相同机架的节点。</p>
<h4 id="4-任务运行">4. 任务运行</h4>
<p>当一个任务由资源管理器的调度器分配给一个 container 后，应用管理器通过联系节点管理器来启动 container(第 9 步)。任务由一个主类为 YarnChild 的 Java 应用执行， 在运行任务之前首先本地化任务需要的资源，比如作业配置，JAR 文件,  以及分布式缓存的所有文件 (第 10 步。 最后, 运行 map 或 reduce 任务 (第 11 步)。</p>
<p>YarnChild 运行在一个专用的 JVM 中, 但是 YARN 不支持 JVM 重用。</p>
<h4 id="5-进度和状态更新">5. 进度和状态更新</h4>
<p>YARN 中的任务将其进度和状态 (包括 counter) 返回给应用管理器, 客户端每秒 (通 mapreduce.client.progressmonitor.pollinterval 设置) 向应用管理器请求进度更新, 展示给用户。</p>
<h4 id="6-作业完成">6. 作业完成</h4>
<p>除了向应用管理器请求作业进度外,  客户端每 5 分钟都会通过调用 waitForCompletion() 来检查作业是否完成，时间间隔可以通过 mapreduce.client.completion.pollinterval 来设置。作业完成之后,  应用管理器和 container 会清理工作状态， OutputCommiter 的作业清理方法也会被调用。作业的信息会被作业历史服务器存储以备之后用户核查。</p>
<h2 id="五、提交作业到YARN上运行">五、提交作业到YARN上运行</h2>
<p>这里以提交 Hadoop Examples 中计算 Pi 的 MApReduce 程序为例，相关 Jar 包在 Hadoop 安装目录的 <code>share/hadoop/mapreduce</code> 目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">提交格式: hadoop jar jar包路径 主类名称 主类参数</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">hadoop jar hadoop-mapreduce-examples-2.6.0-cdh5.15.2.jar pi 3 3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hbase JAVA API使用</title>
    <url>/posts/38ae16ce.html</url>
    <content><![CDATA[<h2 id="一、简述">一、简述</h2>
<p>截至到目前 (2019.04)，HBase 有两个主要的版本，分别是 1.x 和 2.x ，两个版本的 Java API 有所不同，1.x 中某些方法在 2.x 中被标识为 <code>@deprecated</code> 过时。所以下面关于 API 的样例，我会分别给出 1.x 和 2.x 两个版本。完整的代码见本仓库：</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><a href="https://github.com/ihadyou/BigData-Notes/tree/master/code/Hbase/hbase-java-api-1.x">Java API 1.x Examples</a></p>
</li>
<li class="lvl-2">
<p><a href="https://github.com/ihadyou/BigData-Notes/tree/master/code/Hbase/hbase-java-api-2.x">Java API 2.x Examples</a></p>
</li>
</ul>
</blockquote>
<p>同时你使用的客户端的版本必须与服务端版本保持一致，如果用 2.x 版本的客户端代码去连接 1.x 版本的服务端，会抛出 <code>NoSuchColumnFamilyException</code> 等异常。</p>
<h2 id="二、Java-API-1-x-基本使用">二、Java API 1.x 基本使用</h2>
<h4 id="2-1-新建Maven工程，导入项目依赖">2.1 新建Maven工程，导入项目依赖</h4>
<p>要使用 Java API 操作 HBase，需要引入 <code>hbase-client</code>。这里选取的 <code>HBase Client</code> 的版本为 <code>1.2.0</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-API-基本使用">2.2 API 基本使用</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HBaseUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection connection;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> HBaseConfiguration.create();</span><br><span class="line">        configuration.set(<span class="string">&quot;hbase.zookeeper.property.clientPort&quot;</span>, <span class="string">&quot;2181&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果是集群 则主机名用逗号分隔</span></span><br><span class="line">        configuration.set(<span class="string">&quot;hbase.zookeeper.quorum&quot;</span>, <span class="string">&quot;hadoop001&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = ConnectionFactory.createConnection(configuration);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 HBase 表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName      表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnFamilies 列族的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">createTable</span><span class="params">(String tableName, List&lt;String&gt; columnFamilies)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">HBaseAdmin</span> <span class="variable">admin</span> <span class="operator">=</span> (HBaseAdmin) connection.getAdmin();</span><br><span class="line">            <span class="keyword">if</span> (admin.tableExists(tableName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">HTableDescriptor</span> <span class="variable">tableDescriptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HTableDescriptor</span>(TableName.valueOf(tableName));</span><br><span class="line">            columnFamilies.forEach(columnFamily -&gt; &#123;</span><br><span class="line">                <span class="type">HColumnDescriptor</span> <span class="variable">columnDescriptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HColumnDescriptor</span>(columnFamily);</span><br><span class="line">                columnDescriptor.setMaxVersions(<span class="number">1</span>);</span><br><span class="line">                tableDescriptor.addFamily(columnDescriptor);</span><br><span class="line">            &#125;);</span><br><span class="line">            admin.createTable(tableDescriptor);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除 hBase 表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName 表名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">deleteTable</span><span class="params">(String tableName)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">HBaseAdmin</span> <span class="variable">admin</span> <span class="operator">=</span> (HBaseAdmin) connection.getAdmin();</span><br><span class="line">            <span class="comment">// 删除表前需要先禁用表</span></span><br><span class="line">            admin.disableTable(tableName);</span><br><span class="line">            admin.deleteTable(tableName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName        表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey           唯一标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnFamilyName 列族名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> qualifier        列标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value            数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">putRow</span><span class="params">(String tableName, String rowKey, String columnFamilyName, String qualifier,</span></span><br><span class="line"><span class="params">                                 String value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Put</span> <span class="variable">put</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Put</span>(Bytes.toBytes(rowKey));</span><br><span class="line">            put.addColumn(Bytes.toBytes(columnFamilyName), Bytes.toBytes(qualifier), Bytes.toBytes(value));</span><br><span class="line">            table.put(put);</span><br><span class="line">            table.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName        表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey           唯一标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnFamilyName 列族名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pairList         列标识和值的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">putRow</span><span class="params">(String tableName, String rowKey, String columnFamilyName, List&lt;Pair&lt;String, String&gt;&gt; pairList)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Put</span> <span class="variable">put</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Put</span>(Bytes.toBytes(rowKey));</span><br><span class="line">            pairList.forEach(pair -&gt; put.addColumn(Bytes.toBytes(columnFamilyName), Bytes.toBytes(pair.getKey()), Bytes.toBytes(pair.getValue())));</span><br><span class="line">            table.put(put);</span><br><span class="line">            table.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 rowKey 获取指定行的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName 表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey    唯一标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">getRow</span><span class="params">(String tableName, String rowKey)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Get</span> <span class="variable">get</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Get</span>(Bytes.toBytes(rowKey));</span><br><span class="line">            <span class="keyword">return</span> table.get(get);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定行指定列 (cell) 的最新版本的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName    表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey       唯一标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnFamily 列族</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> qualifier    列标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCell</span><span class="params">(String tableName, String rowKey, String columnFamily, String qualifier)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Get</span> <span class="variable">get</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Get</span>(Bytes.toBytes(rowKey));</span><br><span class="line">            <span class="keyword">if</span> (!get.isCheckExistenceOnly()) &#123;</span><br><span class="line">                get.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(qualifier));</span><br><span class="line">                <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> table.get(get);</span><br><span class="line">                <span class="type">byte</span>[] resultValue = result.getValue(Bytes.toBytes(columnFamily), Bytes.toBytes(qualifier));</span><br><span class="line">                <span class="keyword">return</span> Bytes.toString(resultValue);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检索全表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName 表名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ResultScanner <span class="title function_">getScanner</span><span class="params">(String tableName)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Scan</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scan</span>();</span><br><span class="line">            <span class="keyword">return</span> table.getScanner(scan);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检索表中指定数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName  表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filterList 过滤器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ResultScanner <span class="title function_">getScanner</span><span class="params">(String tableName, FilterList filterList)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Scan</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scan</span>();</span><br><span class="line">            scan.setFilter(filterList);</span><br><span class="line">            <span class="keyword">return</span> table.getScanner(scan);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检索表中指定数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName   表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startRowKey 起始 RowKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endRowKey   终止 RowKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filterList  过滤器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ResultScanner <span class="title function_">getScanner</span><span class="params">(String tableName, String startRowKey, String endRowKey,</span></span><br><span class="line"><span class="params">                                           FilterList filterList)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Scan</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scan</span>();</span><br><span class="line">            scan.setStartRow(Bytes.toBytes(startRowKey));</span><br><span class="line">            scan.setStopRow(Bytes.toBytes(endRowKey));</span><br><span class="line">            scan.setFilter(filterList);</span><br><span class="line">            <span class="keyword">return</span> table.getScanner(scan);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定行记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName 表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey    唯一标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">deleteRow</span><span class="params">(String tableName, String rowKey)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Delete</span> <span class="variable">delete</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Delete</span>(Bytes.toBytes(rowKey));</span><br><span class="line">            table.delete(delete);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定行的指定列</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName  表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey     唯一标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> familyName 列族</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> qualifier  列标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">deleteColumn</span><span class="params">(String tableName, String rowKey, String familyName,</span></span><br><span class="line"><span class="params">                                          String qualifier)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Delete</span> <span class="variable">delete</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Delete</span>(Bytes.toBytes(rowKey));</span><br><span class="line">            delete.addColumn(Bytes.toBytes(familyName), Bytes.toBytes(qualifier));</span><br><span class="line">            table.delete(delete);</span><br><span class="line">            table.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-单元测试">2.3 单元测试</h3>
<p>以单元测试的方式对上面封装的 API 进行测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HBaseUtilsTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TABLE_NAME</span> <span class="operator">=</span> <span class="string">&quot;class&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TEACHER</span> <span class="operator">=</span> <span class="string">&quot;teacher&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">STUDENT</span> <span class="operator">=</span> <span class="string">&quot;student&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createTable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 新建表</span></span><br><span class="line">        List&lt;String&gt; columnFamilies = Arrays.asList(TEACHER, STUDENT);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">table</span> <span class="operator">=</span> HBaseUtils.createTable(TABLE_NAME, columnFamilies);</span><br><span class="line">        System.out.println(<span class="string">&quot;表创建结果:&quot;</span> + table);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertData</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Pair&lt;String, String&gt;&gt; pairs1 = Arrays.asList(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Tom&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;22&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;gender&quot;</span>, <span class="string">&quot;1&quot;</span>));</span><br><span class="line">        HBaseUtils.putRow(TABLE_NAME, <span class="string">&quot;rowKey1&quot;</span>, STUDENT, pairs1);</span><br><span class="line"></span><br><span class="line">        List&lt;Pair&lt;String, String&gt;&gt; pairs2 = Arrays.asList(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;33&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;gender&quot;</span>, <span class="string">&quot;2&quot;</span>));</span><br><span class="line">        HBaseUtils.putRow(TABLE_NAME, <span class="string">&quot;rowKey2&quot;</span>, STUDENT, pairs2);</span><br><span class="line"></span><br><span class="line">        List&lt;Pair&lt;String, String&gt;&gt; pairs3 = Arrays.asList(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Mike&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;44&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;gender&quot;</span>, <span class="string">&quot;1&quot;</span>));</span><br><span class="line">        HBaseUtils.putRow(TABLE_NAME, <span class="string">&quot;rowKey3&quot;</span>, STUDENT, pairs3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getRow</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> HBaseUtils.getRow(TABLE_NAME, <span class="string">&quot;rowKey1&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(Bytes</span><br><span class="line">                    .toString(result.getValue(Bytes.toBytes(STUDENT), Bytes.toBytes(<span class="string">&quot;name&quot;</span>))));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getCell</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">cell</span> <span class="operator">=</span> HBaseUtils.getCell(TABLE_NAME, <span class="string">&quot;rowKey2&quot;</span>, STUDENT, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;cell age :&quot;</span> + cell);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getScanner</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ResultScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> HBaseUtils.getScanner(TABLE_NAME);</span><br><span class="line">        <span class="keyword">if</span> (scanner != <span class="literal">null</span>) &#123;</span><br><span class="line">            scanner.forEach(result -&gt; System.out.println(Bytes.toString(result.getRow()) + <span class="string">&quot;-&gt;&quot;</span> + Bytes</span><br><span class="line">                    .toString(result.getValue(Bytes.toBytes(STUDENT), Bytes.toBytes(<span class="string">&quot;name&quot;</span>)))));</span><br><span class="line">            scanner.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getScannerWithFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">FilterList</span> <span class="variable">filterList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterList</span>(FilterList.Operator.MUST_PASS_ALL);</span><br><span class="line">        <span class="type">SingleColumnValueFilter</span> <span class="variable">nameFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleColumnValueFilter</span>(Bytes.toBytes(STUDENT),</span><br><span class="line">                Bytes.toBytes(<span class="string">&quot;name&quot;</span>), CompareOperator.EQUAL, Bytes.toBytes(<span class="string">&quot;Jack&quot;</span>));</span><br><span class="line">        filterList.addFilter(nameFilter);</span><br><span class="line">        <span class="type">ResultScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> HBaseUtils.getScanner(TABLE_NAME, filterList);</span><br><span class="line">        <span class="keyword">if</span> (scanner != <span class="literal">null</span>) &#123;</span><br><span class="line">            scanner.forEach(result -&gt; System.out.println(Bytes.toString(result.getRow()) + <span class="string">&quot;-&gt;&quot;</span> + Bytes</span><br><span class="line">                    .toString(result.getValue(Bytes.toBytes(STUDENT), Bytes.toBytes(<span class="string">&quot;name&quot;</span>)))));</span><br><span class="line">            scanner.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteColumn</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> HBaseUtils.deleteColumn(TABLE_NAME, <span class="string">&quot;rowKey2&quot;</span>, STUDENT, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除结果: &quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteRow</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> HBaseUtils.deleteRow(TABLE_NAME, <span class="string">&quot;rowKey2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除结果: &quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteTable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> HBaseUtils.deleteTable(TABLE_NAME);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除结果: &quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、Java-API-2-x-基本使用">三、Java API 2.x 基本使用</h2>
<h4 id="3-1-新建Maven工程，导入项目依赖">3.1 新建Maven工程，导入项目依赖</h4>
<p>这里选取的 <code>HBase Client</code> 的版本为最新的 <code>2.1.4</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-2-API-的基本使用">3.2 API 的基本使用</h4>
<p>2.x 版本相比于 1.x 废弃了一部分方法，关于废弃的方法在源码中都会指明新的替代方法，比如，在 2.x 中创建表时：<code>HTableDescriptor</code> 和 <code>HColumnDescriptor</code> 等类都标识为废弃，取而代之的是使用 <code>TableDescriptorBuilder</code> 和 <code>ColumnFamilyDescriptorBuilder</code> 来定义表和列族。</p>
<div align="center"> <img width="700px"  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/deprecated.png"/> </div>
<p>以下为 HBase  2.x 版本 Java API 的使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HBaseUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection connection;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> HBaseConfiguration.create();</span><br><span class="line">        configuration.set(<span class="string">&quot;hbase.zookeeper.property.clientPort&quot;</span>, <span class="string">&quot;2181&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果是集群 则主机名用逗号分隔</span></span><br><span class="line">        configuration.set(<span class="string">&quot;hbase.zookeeper.quorum&quot;</span>, <span class="string">&quot;hadoop001&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = ConnectionFactory.createConnection(configuration);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 HBase 表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName      表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnFamilies 列族的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">createTable</span><span class="params">(String tableName, List&lt;String&gt; columnFamilies)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">HBaseAdmin</span> <span class="variable">admin</span> <span class="operator">=</span> (HBaseAdmin) connection.getAdmin();</span><br><span class="line">            <span class="keyword">if</span> (admin.tableExists(TableName.valueOf(tableName))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">TableDescriptorBuilder</span> <span class="variable">tableDescriptor</span> <span class="operator">=</span> TableDescriptorBuilder.newBuilder(TableName.valueOf(tableName));</span><br><span class="line">            columnFamilies.forEach(columnFamily -&gt; &#123;</span><br><span class="line">                <span class="type">ColumnFamilyDescriptorBuilder</span> <span class="variable">cfDescriptorBuilder</span> <span class="operator">=</span> ColumnFamilyDescriptorBuilder.newBuilder(Bytes.toBytes(columnFamily));</span><br><span class="line">                cfDescriptorBuilder.setMaxVersions(<span class="number">1</span>);</span><br><span class="line">                <span class="type">ColumnFamilyDescriptor</span> <span class="variable">familyDescriptor</span> <span class="operator">=</span> cfDescriptorBuilder.build();</span><br><span class="line">                tableDescriptor.setColumnFamily(familyDescriptor);</span><br><span class="line">            &#125;);</span><br><span class="line">            admin.createTable(tableDescriptor.build());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除 hBase 表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName 表名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">deleteTable</span><span class="params">(String tableName)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">HBaseAdmin</span> <span class="variable">admin</span> <span class="operator">=</span> (HBaseAdmin) connection.getAdmin();</span><br><span class="line">            <span class="comment">// 删除表前需要先禁用表</span></span><br><span class="line">            admin.disableTable(TableName.valueOf(tableName));</span><br><span class="line">            admin.deleteTable(TableName.valueOf(tableName));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName        表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey           唯一标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnFamilyName 列族名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> qualifier        列标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value            数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">putRow</span><span class="params">(String tableName, String rowKey, String columnFamilyName, String qualifier,</span></span><br><span class="line"><span class="params">                                 String value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Put</span> <span class="variable">put</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Put</span>(Bytes.toBytes(rowKey));</span><br><span class="line">            put.addColumn(Bytes.toBytes(columnFamilyName), Bytes.toBytes(qualifier), Bytes.toBytes(value));</span><br><span class="line">            table.put(put);</span><br><span class="line">            table.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName        表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey           唯一标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnFamilyName 列族名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pairList         列标识和值的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">putRow</span><span class="params">(String tableName, String rowKey, String columnFamilyName, List&lt;Pair&lt;String, String&gt;&gt; pairList)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Put</span> <span class="variable">put</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Put</span>(Bytes.toBytes(rowKey));</span><br><span class="line">            pairList.forEach(pair -&gt; put.addColumn(Bytes.toBytes(columnFamilyName), Bytes.toBytes(pair.getKey()), Bytes.toBytes(pair.getValue())));</span><br><span class="line">            table.put(put);</span><br><span class="line">            table.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 rowKey 获取指定行的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName 表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey    唯一标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">getRow</span><span class="params">(String tableName, String rowKey)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Get</span> <span class="variable">get</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Get</span>(Bytes.toBytes(rowKey));</span><br><span class="line">            <span class="keyword">return</span> table.get(get);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定行指定列 (cell) 的最新版本的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName    表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey       唯一标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnFamily 列族</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> qualifier    列标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCell</span><span class="params">(String tableName, String rowKey, String columnFamily, String qualifier)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Get</span> <span class="variable">get</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Get</span>(Bytes.toBytes(rowKey));</span><br><span class="line">            <span class="keyword">if</span> (!get.isCheckExistenceOnly()) &#123;</span><br><span class="line">                get.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(qualifier));</span><br><span class="line">                <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> table.get(get);</span><br><span class="line">                <span class="type">byte</span>[] resultValue = result.getValue(Bytes.toBytes(columnFamily), Bytes.toBytes(qualifier));</span><br><span class="line">                <span class="keyword">return</span> Bytes.toString(resultValue);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检索全表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName 表名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ResultScanner <span class="title function_">getScanner</span><span class="params">(String tableName)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Scan</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scan</span>();</span><br><span class="line">            <span class="keyword">return</span> table.getScanner(scan);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检索表中指定数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName  表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filterList 过滤器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ResultScanner <span class="title function_">getScanner</span><span class="params">(String tableName, FilterList filterList)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Scan</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scan</span>();</span><br><span class="line">            scan.setFilter(filterList);</span><br><span class="line">            <span class="keyword">return</span> table.getScanner(scan);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检索表中指定数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName   表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startRowKey 起始 RowKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endRowKey   终止 RowKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filterList  过滤器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ResultScanner <span class="title function_">getScanner</span><span class="params">(String tableName, String startRowKey, String endRowKey,</span></span><br><span class="line"><span class="params">                                           FilterList filterList)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Scan</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scan</span>();</span><br><span class="line">            scan.withStartRow(Bytes.toBytes(startRowKey));</span><br><span class="line">            scan.withStopRow(Bytes.toBytes(endRowKey));</span><br><span class="line">            scan.setFilter(filterList);</span><br><span class="line">            <span class="keyword">return</span> table.getScanner(scan);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定行记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName 表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey    唯一标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">deleteRow</span><span class="params">(String tableName, String rowKey)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Delete</span> <span class="variable">delete</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Delete</span>(Bytes.toBytes(rowKey));</span><br><span class="line">            table.delete(delete);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定行指定列</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName  表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey     唯一标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> familyName 列族</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> qualifier  列标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">deleteColumn</span><span class="params">(String tableName, String rowKey, String familyName,</span></span><br><span class="line"><span class="params">                                          String qualifier)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Delete</span> <span class="variable">delete</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Delete</span>(Bytes.toBytes(rowKey));</span><br><span class="line">            delete.addColumn(Bytes.toBytes(familyName), Bytes.toBytes(qualifier));</span><br><span class="line">            table.delete(delete);</span><br><span class="line">            table.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、正确连接Hbase">四、正确连接Hbase</h2>
<p>在上面的代码中，在类加载时就初始化了 Connection 连接，并且之后的方法都是复用这个 Connection，这时我们可能会考虑是否可以使用自定义连接池来获取更好的性能表现？实际上这是没有必要的。</p>
<p>首先官方对于 <code>Connection</code> 的使用说明如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">Connection</span> <span class="string">Pooling For applications which require high-end multithreaded   </span></span><br><span class="line"><span class="attr">access</span> <span class="string">(e.g., web-servers or  application servers  that may serve many   </span></span><br><span class="line"><span class="attr">application</span> <span class="string">threads in a single JVM), you can pre-create a Connection,   </span></span><br><span class="line"><span class="attr">as</span> <span class="string">shown in the following example:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">对于高并发多线程访问的应用程序（例如，在单个</span> <span class="string">JVM 中存在的为多个线程服务的 Web 服务器或应用程序服务器），  </span></span><br><span class="line"><span class="attr">您只需要预先创建一个</span> <span class="string">Connection。例子如下：</span></span><br><span class="line"></span><br><span class="line"> <span class="attr">//Create</span> <span class="string">a connection to the cluster.</span></span><br><span class="line"><span class="attr">Configuration</span> <span class="string">conf = HBaseConfiguration.create();</span></span><br><span class="line"><span class="attr">try</span> <span class="string">(Connection connection = ConnectionFactory.createConnection(conf);</span></span><br><span class="line">     <span class="attr">Table</span> <span class="string">table = connection.getTable(TableName.valueOf(tablename))) &#123;</span></span><br><span class="line">   <span class="attr">//use</span> <span class="string">table as needed, the table returned is lightweight</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>
<p>之所以能这样使用，这是因为 Connection 并不是一个简单的 socket 连接，<a href="https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Connection.html">接口文档</a> 中对 Connection 的表述是：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">A</span> <span class="string">cluster connection encapsulating lower level individual connections to actual servers and a  </span></span><br><span class="line"><span class="attr">connection</span> <span class="string">to zookeeper.  Connections are instantiated through the ConnectionFactory class.  </span></span><br><span class="line"><span class="attr">The</span> <span class="string">lifecycle of the connection is managed by the caller,  who has to close() the connection   </span></span><br><span class="line"><span class="attr">to</span> <span class="string">release the resources. </span></span><br><span class="line"></span><br><span class="line"><span class="attr">Connection</span> <span class="string">是一个集群连接，封装了与多台服务器（Matser/Region Server）的底层连接以及与 zookeeper 的连接。  </span></span><br><span class="line"><span class="attr">连接通过</span> <span class="string">ConnectionFactory  类实例化。连接的生命周期由调用者管理，调用者必须使用 close() 关闭连接以释放资源。</span></span><br></pre></td></tr></table></figure>
<p>之所以封装这些连接，是因为 HBase 客户端需要连接三个不同的服务角色：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Zookeeper</strong> ：主要用于获取 <code>meta</code> 表的位置信息，Master 的信息；</p>
</li>
<li class="lvl-2">
<p><strong>HBase Master</strong> ：主要用于执行 HBaseAdmin 接口的一些操作，例如建表等；</p>
</li>
<li class="lvl-2">
<p><strong>HBase RegionServer</strong> ：用于读、写数据。</p>
</li>
</ul>
<div align="center"> <img width="700px"  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-arc.png"/> </div>
<p>Connection 对象和实际的 Socket 连接之间的对应关系如下图：</p>
<div align="center"> <img width="700px"   src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-connection.png"/> </div>
<blockquote>
<p>上面两张图片引用自博客：<a href="https://yq.aliyun.com/articles/581702?spm=a2c4e.11157919.spm-cont-list.1.146c27aeFxoMsN%20%E8%BF%9E%E6%8E%A5HBase%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF">连接 HBase 的正确姿势</a></p>
</blockquote>
<p>在 HBase 客户端代码中，真正对应 Socket 连接的是 <code>RpcConnection</code> 对象。HBase 使用 <code>PoolMap</code> 这种数据结构来存储客户端到 HBase 服务器之间的连接。<code>PoolMap</code> 的内部有一个 <code>ConcurrentHashMap</code> 实例，其 key 是 <code>ConnectionId</code>(封装了服务器地址和用户 ticket)，value 是一个 <code>RpcConnection</code> 对象的资源池。当 HBase 需要连接一个服务器时，首先会根据 <code>ConnectionId</code> 找到对应的连接池，然后从连接池中取出一个连接对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@InterfaceAudience</span>.Private</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PoolMap</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> PoolType poolType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> poolMaxSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;K, Pool&lt;V&gt;&gt; pools = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PoolMap</span><span class="params">(PoolType poolType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.poolType = poolType;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HBase 中提供了三种资源池的实现，分别是 <code>Reusable</code>，<code>RoundRobin</code> 和 <code>ThreadLocal</code>。具体实现可以通 <code>hbase.client.ipc.pool.type</code> 配置项指定，默认为 <code>Reusable</code>。连接池的大小也可以通过 <code>hbase.client.ipc.pool.size</code> 配置项指定，默认为 1，即每个 Server 1 个连接。也可以通过修改配置实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">config.set(<span class="string">&quot;hbase.client.ipc.pool.type&quot;</span>,...);</span><br><span class="line">config.set(<span class="string">&quot;hbase.client.ipc.pool.size&quot;</span>,...);</span><br><span class="line">connection = ConnectionFactory.createConnection(config);</span><br></pre></td></tr></table></figure>
<p>由此可以看出 HBase 中 Connection 类已经实现了对连接的管理功能，所以我们不必在 Connection 上在做额外的管理。</p>
<p>另外，Connection 是线程安全的，但 Table 和 Admin 却不是线程安全的，因此正确的做法是一个进程共用一个 Connection 对象，而在不同的线程中使用单独的 Table 和 Admin 对象。Table 和 Admin 的获取操作 <code>getTable()</code> 和 <code>getAdmin()</code> 都是轻量级，所以不必担心性能的消耗，同时建议在使用完成后显示的调用 <code>close()</code> 方法来关闭它们。</p>
<blockquote>
<p>原文：<a href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>hbase</category>
      </categories>
      <tags>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>Hbase协处理器</title>
    <url>/posts/2e2f423b.html</url>
    <content><![CDATA[<h2 id="一、简述-2">一、简述</h2>
<p>在使用 HBase 时，如果你的数据量达到了数十亿行或数百万列，此时能否在查询中返回大量数据将受制于网络的带宽，即便网络状况允许，但是客户端的计算处理也未必能够满足要求。在这种情况下，协处理器（Coprocessors）应运而生。它允许你将业务计算代码放入在 RegionServer 的协处理器中，将处理好的数据再返回给客户端，这可以极大地降低需要传输的数据量，从而获得性能上的提升。同时协处理器也允许用户扩展实现 HBase 目前所不具备的功能，如权限校验、二级索引、完整性约束等。</p>
<h2 id="二、协处理器类型">二、协处理器类型</h2>
<h3 id="2-1-Observer协处理器">2.1 Observer协处理器</h3>
<h4 id="1-功能">1. 功能</h4>
<p>Observer 协处理器类似于关系型数据库中的触发器，当发生某些事件的时候这类协处理器会被 Server 端调用。通常可以用来实现下面功能：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>权限校验</strong>：在执行 <code>Get</code> 或 <code>Put</code> 操作之前，您可以使用 <code>preGet</code> 或 <code>prePut</code> 方法检查权限；</p>
</li>
<li class="lvl-2">
<p><strong>完整性约束</strong>： HBase 不支持关系型数据库中的外键功能，可以通过触发器在插入或者删除数据的时候，对关联的数据进行检查；</p>
</li>
<li class="lvl-2">
<p><strong>二级索引</strong>： 可以使用协处理器来维护二级索引。</p>
</li>
</ul>
<h4 id="2-类型">2. 类型</h4>
<p>当前 Observer 协处理器有以下四种类型：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>RegionObserver</strong> :<br>
允许您观察 Region 上的事件，例如 Get 和 Put 操作。</p>
</li>
<li class="lvl-2">
<p><strong>RegionServerObserver</strong> :<br>
允许您观察与 RegionServer 操作相关的事件，例如启动，停止或执行合并，提交或回滚。</p>
</li>
<li class="lvl-2">
<p><strong>MasterObserver</strong> :<br>
允许您观察与 HBase Master 相关的事件，例如表创建，删除或 schema 修改。</p>
</li>
<li class="lvl-2">
<p><strong>WalObserver</strong> :<br>
允许您观察与预写日志（WAL）相关的事件。</p>
</li>
</ul>
<h4 id="3-接口">3. 接口</h4>
<p>以上四种类型的 Observer 协处理器均继承自 <code>Coprocessor</code> 接口，这四个接口中分别定义了所有可用的钩子方法，以便在对应方法前后执行特定的操作。通常情况下，我们并不会直接实现上面接口，而是继承其 Base 实现类，Base 实现类只是简单空实现了接口中的方法，这样我们在实现自定义的协处理器时，就不必实现所有方法，只需要重写必要方法即可。</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-coprocessor.png"/> </div>
<p>这里以 <code>RegionObservers </code> 为例，其接口类中定义了所有可用的钩子方法，下面截取了部分方法的定义，多数方法都是成对出现的，有 <code>pre</code> 就有 <code>post</code>：</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/RegionObserver.png"/> </div>
<h4 id="4-执行流程">4. 执行流程</h4>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/RegionObservers-works.png"/> </div>
<ul class="lvl-0">
<li class="lvl-2">
<p>客户端发出 put 请求</p>
</li>
<li class="lvl-2">
<p>该请求被分派给合适的 RegionServer 和 region</p>
</li>
<li class="lvl-2">
<p>coprocessorHost 拦截该请求，然后在该表的每个 RegionObserver 上调用 prePut()</p>
</li>
<li class="lvl-2">
<p>如果没有被 <code>prePut()</code> 拦截，该请求继续送到 region，然后进行处理</p>
</li>
<li class="lvl-2">
<p>region 产生的结果再次被 CoprocessorHost 拦截，调用 <code>postPut()</code></p>
</li>
<li class="lvl-2">
<p>假如没有 <code>postPut()</code> 拦截该响应，最终结果被返回给客户端</p>
</li>
</ul>
<p>如果大家了解 Spring，可以将这种执行方式类比于其 AOP 的执行原理即可，官方文档当中也是这样类比的：</p>
<blockquote>
<p>If you are familiar with Aspect Oriented Programming (AOP), you can think of a coprocessor as applying advice by intercepting a request and then running some custom code,before passing the request on to its final destination (or even changing the destination).</p>
<p>如果您熟悉面向切面编程（AOP），您可以将协处理器视为通过拦截请求然后运行一些自定义代码来使用 Advice，然后将请求传递到其最终目标（或者更改目标）。</p>
</blockquote>
<h3 id="2-2-Endpoint协处理器">2.2  Endpoint协处理器</h3>
<p>Endpoint 协处理器类似于关系型数据库中的存储过程。客户端可以调用 Endpoint 协处理器在服务端对数据进行处理，然后再返回。</p>
<p>以聚集操作为例，如果没有协处理器，当用户需要找出一张表中的最大数据，即 max 聚合操作，就必须进行全表扫描，然后在客户端上遍历扫描结果，这必然会加重了客户端处理数据的压力。利用 Coprocessor，用户可以将求最大值的代码部署到 HBase Server 端，HBase 将利用底层 cluster 的多个节点并发执行求最大值的操作。即在每个 Region 范围内执行求最大值的代码，将每个 Region 的最大值在 Region Server 端计算出来，仅仅将该 max 值返回给客户端。之后客户端只需要将每个 Region 的最大值进行比较而找到其中最大的值即可。</p>
<h2 id="三、协处理的加载方式">三、协处理的加载方式</h2>
<p>要使用我们自己开发的协处理器，必须通过静态（使用 HBase 配置）或动态（使用 HBase Shell 或 Java API）加载它。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>静态加载的协处理器称之为 <strong>System Coprocessor</strong>（系统级协处理器）,作用范围是整个 HBase 上的所有表，需要重启 HBase 服务；</p>
</li>
<li class="lvl-2">
<p>动态加载的协处理器称之为 <strong>Table Coprocessor</strong>（表处理器），作用于指定的表，不需要重启 HBase 服务。</p>
</li>
</ul>
<p>其加载和卸载方式分别介绍如下。</p>
<h2 id="四、静态加载与卸载">四、静态加载与卸载</h2>
<h3 id="4-1-静态加载">4.1 静态加载</h3>
<p>静态加载分以下三步：</p>
<ol>
<li class="lvl-3">
<p>在 <code>hbase-site.xml</code> 定义需要加载的协处理器。</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.coprocessor.region.classes<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.myname.hbase.coprocessor.endpoint.SumEndPoint<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code> &lt;name&gt;</code> 标签的值必须是下面其中之一：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>RegionObservers 和 Endpoints 协处理器：<code>hbase.coprocessor.region.classes</code></p>
</li>
<li class="lvl-2">
<p>WALObservers 协处理器： <code>hbase.coprocessor.wal.classes</code></p>
</li>
<li class="lvl-2">
<p>MasterObservers 协处理器：<code>hbase.coprocessor.master.classes</code></p>
</li>
</ul>
<p><code>&lt;value&gt;</code> 必须是协处理器实现类的全限定类名。如果为加载指定了多个类，则类名必须以逗号分隔。</p>
<ol start="2">
<li class="lvl-3">
<p>将 jar(包含代码和所有依赖项) 放入 HBase 安装目录中的 <code>lib</code> 目录下；</p>
</li>
<li class="lvl-3">
<p>重启 HBase。</p>
</li>
</ol>
<h3 id="4-2-静态卸载">4.2 静态卸载</h3>
<ol>
<li class="lvl-3">
<p>从 hbase-site.xml 中删除配置的协处理器的&lt;property&gt;元素及其子元素；</p>
</li>
<li class="lvl-3">
<p>从类路径或 HBase 的 lib 目录中删除协处理器的 JAR 文件（可选）；</p>
</li>
<li class="lvl-3">
<p>重启 HBase。</p>
</li>
</ol>
<h2 id="五、动态加载与卸载">五、动态加载与卸载</h2>
<p>使用动态加载协处理器，不需要重新启动 HBase。但动态加载的协处理器是基于每个表加载的，只能用于所指定的表。此外，在使用动态加载必须使表脱机（disable）以加载协处理器。动态加载通常有两种方式：Shell 和 Java API 。</p>
<blockquote>
<p>以下示例基于两个前提：</p>
<ol>
<li class="lvl-3">coprocessor.jar 包含协处理器实现及其所有依赖项。</li>
<li class="lvl-3">JAR 包存放在 HDFS 上的路径为：hdfs：// &lt;namenode&gt;：&lt;port&gt; / user / &lt;hadoop-user&gt; /coprocessor.jar</li>
</ol>
</blockquote>
<h3 id="5-1-HBase-Shell动态加载">5.1 HBase Shell动态加载</h3>
<ol>
<li class="lvl-3">
<p>使用 HBase Shell 禁用表</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase &gt; disable &#x27;tableName&#x27;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>使用如下命令加载协处理器</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase &gt; alter &#x27;tableName&#x27;, METHOD =&gt; &#x27;table_att&#x27;, &#x27;Coprocessor&#x27;=&gt;&#x27;hdfs://&lt;namenode&gt;:&lt;port&gt;/</span><br><span class="line">user/&lt;hadoop-user&gt;/coprocessor.jar| org.myname.hbase.Coprocessor.RegionObserverExample|1073741823|</span><br><span class="line">arg1=1,arg2=2&#x27;</span><br></pre></td></tr></table></figure>
<p><code>Coprocessor</code> 包含由管道（|）字符分隔的四个参数，按顺序解释如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>JAR 包路径</strong>：通常为 JAR 包在 HDFS 上的路径。关于路径以下两点需要注意：</p>
</li>
<li class="lvl-2">
<p>允许使用通配符，例如：<code>hdfs://&lt;namenode&gt;:&lt;port&gt;/user/&lt;hadoop-user&gt;/*.jar</code> 来添加指定的 JAR 包；</p>
</li>
<li class="lvl-2">
<p>可以使指定目录，例如：<code>hdfs://&lt;namenode&gt;:&lt;port&gt;/user/&lt;hadoop-user&gt;/</code> ，这会添加目录中的所有 JAR 包，但不会搜索子目录中的 JAR 包。</p>
</li>
<li class="lvl-2">
<p><strong>类名</strong>：协处理器的完整类名。</p>
</li>
<li class="lvl-2">
<p><strong>优先级</strong>：协处理器的优先级，遵循数字的自然序，即值越小优先级越高。可以为空，在这种情况下，将分配默认优先级值。</p>
</li>
<li class="lvl-2">
<p><strong>可选参数</strong> ：传递的协处理器的可选参数。</p>
</li>
</ul>
<ol start="3">
<li class="lvl-3">
<p>启用表</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase &gt; enable &#x27;tableName&#x27;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li class="lvl-3">
<p>验证协处理器是否已加载</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase &gt; describe &#x27;tableName&#x27;</span><br></pre></td></tr></table></figure>
<p>协处理器出现在 <code>TABLE_ATTRIBUTES</code> 属性中则代表加载成功。</p>
<h3 id="5-2-HBase-Shell动态卸载">5.2 HBase Shell动态卸载</h3>
<ol>
<li class="lvl-3">
<p>禁用表</p>
</li>
</ol>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">hbase&gt; </span><span class="language-bash"><span class="built_in">disable</span> <span class="string">&#x27;tableName&#x27;</span></span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>移除表协处理器</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">hbase&gt; </span><span class="language-bash">alter <span class="string">&#x27;tableName&#x27;</span>, METHOD =&gt; <span class="string">&#x27;table_att_unset&#x27;</span>, NAME =&gt; <span class="string">&#x27;coprocessor$1&#x27;</span></span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>启用表</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">hbase&gt; </span><span class="language-bash"><span class="built_in">enable</span> <span class="string">&#x27;tableName&#x27;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="5-3-Java-API-动态加载">5.3 Java API 动态加载</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TableName</span> <span class="variable">tableName</span> <span class="operator">=</span> TableName.valueOf(<span class="string">&quot;users&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;hdfs://&lt;namenode&gt;:&lt;port&gt;/user/&lt;hadoop-user&gt;/coprocessor.jar&quot;</span>;</span><br><span class="line"><span class="type">Configuration</span> <span class="variable">conf</span> <span class="operator">=</span> HBaseConfiguration.create();</span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionFactory.createConnection(conf);</span><br><span class="line"><span class="type">Admin</span> <span class="variable">admin</span> <span class="operator">=</span> connection.getAdmin();</span><br><span class="line">admin.disableTable(tableName);</span><br><span class="line"><span class="type">HTableDescriptor</span> <span class="variable">hTableDescriptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HTableDescriptor</span>(tableName);</span><br><span class="line"><span class="type">HColumnDescriptor</span> <span class="variable">columnFamily1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HColumnDescriptor</span>(<span class="string">&quot;personalDet&quot;</span>);</span><br><span class="line">columnFamily1.setMaxVersions(<span class="number">3</span>);</span><br><span class="line">hTableDescriptor.addFamily(columnFamily1);</span><br><span class="line"><span class="type">HColumnDescriptor</span> <span class="variable">columnFamily2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HColumnDescriptor</span>(<span class="string">&quot;salaryDet&quot;</span>);</span><br><span class="line">columnFamily2.setMaxVersions(<span class="number">3</span>);</span><br><span class="line">hTableDescriptor.addFamily(columnFamily2);</span><br><span class="line">hTableDescriptor.setValue(<span class="string">&quot;COPROCESSOR$1&quot;</span>, path + <span class="string">&quot;|&quot;</span></span><br><span class="line">+ RegionObserverExample.class.getCanonicalName() + <span class="string">&quot;|&quot;</span></span><br><span class="line">+ Coprocessor.PRIORITY_USER);</span><br><span class="line">admin.modifyTable(tableName, hTableDescriptor);</span><br><span class="line">admin.enableTable(tableName);</span><br></pre></td></tr></table></figure>
<p>在 HBase 0.96 及其以后版本中，HTableDescriptor 的 addCoprocessor() 方法提供了一种更为简便的加载方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TableName</span> <span class="variable">tableName</span> <span class="operator">=</span> TableName.valueOf(<span class="string">&quot;users&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;hdfs://&lt;namenode&gt;:&lt;port&gt;/user/&lt;hadoop-user&gt;/coprocessor.jar&quot;</span>);</span><br><span class="line"><span class="type">Configuration</span> <span class="variable">conf</span> <span class="operator">=</span> HBaseConfiguration.create();</span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionFactory.createConnection(conf);</span><br><span class="line"><span class="type">Admin</span> <span class="variable">admin</span> <span class="operator">=</span> connection.getAdmin();</span><br><span class="line">admin.disableTable(tableName);</span><br><span class="line"><span class="type">HTableDescriptor</span> <span class="variable">hTableDescriptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HTableDescriptor</span>(tableName);</span><br><span class="line"><span class="type">HColumnDescriptor</span> <span class="variable">columnFamily1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HColumnDescriptor</span>(<span class="string">&quot;personalDet&quot;</span>);</span><br><span class="line">columnFamily1.setMaxVersions(<span class="number">3</span>);</span><br><span class="line">hTableDescriptor.addFamily(columnFamily1);</span><br><span class="line"><span class="type">HColumnDescriptor</span> <span class="variable">columnFamily2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HColumnDescriptor</span>(<span class="string">&quot;salaryDet&quot;</span>);</span><br><span class="line">columnFamily2.setMaxVersions(<span class="number">3</span>);</span><br><span class="line">hTableDescriptor.addFamily(columnFamily2);</span><br><span class="line">hTableDescriptor.addCoprocessor(RegionObserverExample.class.getCanonicalName(), path,</span><br><span class="line">Coprocessor.PRIORITY_USER, <span class="literal">null</span>);</span><br><span class="line">admin.modifyTable(tableName, hTableDescriptor);</span><br><span class="line">admin.enableTable(tableName);</span><br></pre></td></tr></table></figure>
<h3 id="5-4-Java-API-动态卸载">5.4 Java API 动态卸载</h3>
<p>卸载其实就是重新定义表但不设置协处理器。这会删除所有表上的协处理器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TableName</span> <span class="variable">tableName</span> <span class="operator">=</span> TableName.valueOf(<span class="string">&quot;users&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;hdfs://&lt;namenode&gt;:&lt;port&gt;/user/&lt;hadoop-user&gt;/coprocessor.jar&quot;</span>;</span><br><span class="line"><span class="type">Configuration</span> <span class="variable">conf</span> <span class="operator">=</span> HBaseConfiguration.create();</span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectionFactory.createConnection(conf);</span><br><span class="line"><span class="type">Admin</span> <span class="variable">admin</span> <span class="operator">=</span> connection.getAdmin();</span><br><span class="line">admin.disableTable(tableName);</span><br><span class="line"><span class="type">HTableDescriptor</span> <span class="variable">hTableDescriptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HTableDescriptor</span>(tableName);</span><br><span class="line"><span class="type">HColumnDescriptor</span> <span class="variable">columnFamily1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HColumnDescriptor</span>(<span class="string">&quot;personalDet&quot;</span>);</span><br><span class="line">columnFamily1.setMaxVersions(<span class="number">3</span>);</span><br><span class="line">hTableDescriptor.addFamily(columnFamily1);</span><br><span class="line"><span class="type">HColumnDescriptor</span> <span class="variable">columnFamily2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HColumnDescriptor</span>(<span class="string">&quot;salaryDet&quot;</span>);</span><br><span class="line">columnFamily2.setMaxVersions(<span class="number">3</span>);</span><br><span class="line">hTableDescriptor.addFamily(columnFamily2);</span><br><span class="line">admin.modifyTable(tableName, hTableDescriptor);</span><br><span class="line">admin.enableTable(tableName);</span><br></pre></td></tr></table></figure>
<h2 id="六、协处理器案例">六、协处理器案例</h2>
<p>这里给出一个简单的案例，实现一个类似于 Redis 中 <code>append</code> 命令的协处理器，当我们对已有列执行 put 操作时候，HBase 默认执行的是 update 操作，这里我们修改为执行 append 操作。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">redis append 命令示例</span></span><br><span class="line"><span class="meta">redis&gt; </span><span class="language-bash"> EXISTS mykey</span></span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">redis&gt; </span><span class="language-bash"> APPEND mykey <span class="string">&quot;Hello&quot;</span></span></span><br><span class="line">(integer) 5</span><br><span class="line"><span class="meta">redis&gt; </span><span class="language-bash"> APPEND mykey <span class="string">&quot; World&quot;</span></span></span><br><span class="line">(integer) 11</span><br><span class="line"><span class="meta">redis&gt; </span><span class="language-bash"> GET mykey</span> </span><br><span class="line">&quot;Hello World&quot;</span><br></pre></td></tr></table></figure>
<h3 id="6-1-创建测试表">6.1 创建测试表</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">创建一张杂志表 有文章和图片两个列族</span></span><br><span class="line">hbase &gt;  create &#x27;magazine&#x27;,&#x27;article&#x27;,&#x27;picture&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-协处理器编程">6.2 协处理器编程</h3>
<blockquote>
<p>完整代码可见本仓库：<a href="https://github.com/ihadyou/BigData-Notes/tree/master/code/Hbase%5Chbase-observer-coprocessor">hbase-observer-coprocessor</a></p>
</blockquote>
<p>新建 Maven 工程，导入下面依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>继承 <code>BaseRegionObserver</code> 实现我们自定义的 <code>RegionObserver</code>,对相同的 <code>article:content</code> 执行 put 命令时，将新插入的内容添加到原有内容的末尾，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppendRegionObserver</span> <span class="keyword">extends</span> <span class="title class_">BaseRegionObserver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] columnFamily = Bytes.toBytes(<span class="string">&quot;article&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] qualifier = Bytes.toBytes(<span class="string">&quot;content&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prePut</span><span class="params">(ObserverContext&lt;RegionCoprocessorEnvironment&gt; e, Put put, WALEdit edit,</span></span><br><span class="line"><span class="params">                       Durability durability)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (put.has(columnFamily, qualifier)) &#123;</span><br><span class="line">            <span class="comment">// 遍历查询结果，获取指定列的原值</span></span><br><span class="line">            <span class="type">Result</span> <span class="variable">rs</span> <span class="operator">=</span> e.getEnvironment().getRegion().get(<span class="keyword">new</span> <span class="title class_">Get</span>(put.getRow()));</span><br><span class="line">            <span class="type">String</span> <span class="variable">oldValue</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (Cell cell : rs.rawCells())</span><br><span class="line">                <span class="keyword">if</span> (CellUtil.matchingColumn(cell, columnFamily, qualifier)) &#123;</span><br><span class="line">                    oldValue = Bytes.toString(CellUtil.cloneValue(cell));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取指定列新插入的值</span></span><br><span class="line">            List&lt;Cell&gt; cells = put.get(columnFamily, qualifier);</span><br><span class="line">            <span class="type">String</span> <span class="variable">newValue</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (Cell cell : cells) &#123;</span><br><span class="line">                <span class="keyword">if</span> (CellUtil.matchingColumn(cell, columnFamily, qualifier)) &#123;</span><br><span class="line">                    newValue = Bytes.toString(CellUtil.cloneValue(cell));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Append 操作</span></span><br><span class="line">            put.addColumn(columnFamily, qualifier, Bytes.toBytes(oldValue + newValue));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-3-打包项目">6.3 打包项目</h3>
<p>使用 maven 命令进行打包，打包后的文件名为 <code>hbase-observer-coprocessor-1.0-SNAPSHOT.jar</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">mvn clean package</span></span><br></pre></td></tr></table></figure>
<h3 id="6-4-上传JAR包到HDFS">6.4 上传JAR包到HDFS</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">上传项目到HDFS上的hbase目录</span></span><br><span class="line">hadoop fs -put /usr/app/hbase-observer-coprocessor-1.0-SNAPSHOT.jar /hbase</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看上传是否成功</span></span><br><span class="line">hadoop fs -ls /hbase</span><br></pre></td></tr></table></figure>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-cp-hdfs.png"/> </div>
<h3 id="6-5-加载协处理器">6.5 加载协处理器</h3>
<ol>
<li class="lvl-3">
<p>加载协处理器前需要先禁用表</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase &gt;  disable &#x27;magazine&#x27;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>加载协处理器</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase &gt;   alter &#x27;magazine&#x27;, METHOD =&gt; &#x27;table_att&#x27;, &#x27;Coprocessor&#x27;=&gt;&#x27;hdfs://hadoop001:8020/hbase/hbase-observer-coprocessor-1.0-SNAPSHOT.jar|com.ihadyou.AppendRegionObserver|1001|&#x27;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>启用表</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase &gt;  enable &#x27;magazine&#x27;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li class="lvl-3">
<p>查看协处理器是否加载成功</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase &gt;  desc &#x27;magazine&#x27;</span><br></pre></td></tr></table></figure>
<p>协处理器出现在 <code>TABLE_ATTRIBUTES</code> 属性中则代表加载成功，如下图：</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-cp-load.png"/> </div>
<h3 id="6-6-测试加载结果">6.6 测试加载结果</h3>
<p>插入一组测试数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase &gt; put &#x27;magazine&#x27;, &#x27;rowkey1&#x27;,&#x27;article:content&#x27;,&#x27;Hello&#x27;</span><br><span class="line">hbase &gt; get &#x27;magazine&#x27;,&#x27;rowkey1&#x27;,&#x27;article:content&#x27;</span><br><span class="line">hbase &gt; put &#x27;magazine&#x27;, &#x27;rowkey1&#x27;,&#x27;article:content&#x27;,&#x27;World&#x27;</span><br><span class="line">hbase &gt; get &#x27;magazine&#x27;,&#x27;rowkey1&#x27;,&#x27;article:content&#x27;</span><br></pre></td></tr></table></figure>
<p>可以看到对于指定列的值已经执行了 append 操作：</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-cp-helloworld.png"/> </div>
<p>插入一组对照数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase &gt; put &#x27;magazine&#x27;, &#x27;rowkey1&#x27;,&#x27;article:author&#x27;,&#x27;zhangsan&#x27;</span><br><span class="line">hbase &gt; get &#x27;magazine&#x27;,&#x27;rowkey1&#x27;,&#x27;article:author&#x27;</span><br><span class="line">hbase &gt; put &#x27;magazine&#x27;, &#x27;rowkey1&#x27;,&#x27;article:author&#x27;,&#x27;lisi&#x27;</span><br><span class="line">hbase &gt; get &#x27;magazine&#x27;,&#x27;rowkey1&#x27;,&#x27;article:author&#x27;</span><br></pre></td></tr></table></figure>
<p>可以看到对于正常的列还是执行 update 操作:</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-cp-lisi.png"/> </div>
<h3 id="6-7-卸载协处理器">6.7 卸载协处理器</h3>
<ol>
<li class="lvl-3">
<p>卸载协处理器前需要先禁用表</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase &gt;  disable &#x27;magazine&#x27;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>卸载协处理器</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase &gt; alter &#x27;magazine&#x27;, METHOD =&gt; &#x27;table_att_unset&#x27;, NAME =&gt; &#x27;coprocessor$1&#x27;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>启用表</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase &gt;  enable &#x27;magazine&#x27;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li class="lvl-3">
<p>查看协处理器是否卸载成功</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase &gt;  desc &#x27;magazine&#x27;</span><br></pre></td></tr></table></figure>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-co-unload.png"/> </div>
<h3 id="6-8-测试卸载结果">6.8 测试卸载结果</h3>
<p>依次执行下面命令可以测试卸载是否成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase &gt; get &#x27;magazine&#x27;,&#x27;rowkey1&#x27;,&#x27;article:content&#x27;</span><br><span class="line">hbase &gt; put &#x27;magazine&#x27;, &#x27;rowkey1&#x27;,&#x27;article:content&#x27;,&#x27;Hello&#x27;</span><br><span class="line">hbase &gt; get &#x27;magazine&#x27;,&#x27;rowkey1&#x27;,&#x27;article:content&#x27;</span><br></pre></td></tr></table></figure>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-unload-test.png"/> </div>
<blockquote>
<p>原文：<a href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>hbase</category>
      </categories>
      <tags>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>Hbase容灾与备份</title>
    <url>/posts/51420bb9.html</url>
    <content><![CDATA[<h2 id="一、前言">一、前言</h2>
<p>本文主要介绍 Hbase 常用的三种简单的容灾备份方案，即<strong>CopyTable</strong>、<strong>Export</strong>/<strong>Import</strong>、<strong>Snapshot</strong>。分别介绍如下：</p>
<h2 id="二、CopyTable">二、CopyTable</h2>
<h3 id="2-1-简介">2.1 简介</h3>
<p><strong>CopyTable</strong>可以将现有表的数据复制到新表中，具有以下特点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>支持时间区间 、row 区间 、改变表名称 、改变列族名称 、以及是否 Copy 已被删除的数据等功能；</p>
</li>
<li class="lvl-2">
<p>执行命令前，需先创建与原表结构相同的新表；</p>
</li>
<li class="lvl-2">
<p><code>CopyTable</code> 的操作是基于 HBase Client API 进行的，即采用 <code>scan</code> 进行查询, 采用 <code>put</code> 进行写入。</p>
</li>
</ul>
<h3 id="2-2-命令格式">2.2 命令格式</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Usage: CopyTable [general options] [--starttime=X] [--endtime=Y] [--new.name=NEW] [--peer.adr=ADR] &lt;tablename&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-常用命令">2.3 常用命令</h3>
<ol>
<li class="lvl-3">
<p>同集群下 CopyTable</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase org.apache.hadoop.hbase.mapreduce.CopyTable --new.name=tableCopy  tableOrig</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>不同集群下 CopyTable</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">两表名称相同的情况</span></span><br><span class="line">hbase org.apache.hadoop.hbase.mapreduce.CopyTable \</span><br><span class="line">--peer.adr=dstClusterZK:2181:/hbase tableOrig</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">也可以指新的表名</span></span><br><span class="line">hbase org.apache.hadoop.hbase.mapreduce.CopyTable \</span><br><span class="line">--peer.adr=dstClusterZK:2181:/hbase \</span><br><span class="line">--new.name=tableCopy tableOrig</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>下面是一个官方给的比较完整的例子，指定开始和结束时间，集群地址，以及只复制指定的列族：</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase org.apache.hadoop.hbase.mapreduce.CopyTable \</span><br><span class="line">--starttime=1265875194289 \</span><br><span class="line">--endtime=1265878794289 \</span><br><span class="line">--peer.adr=server1,server2,server3:2181:/hbase \</span><br><span class="line">--families=myOldCf:myNewCf,cf2,cf3 TestTable</span><br></pre></td></tr></table></figure>
<h3 id="2-4-更多参数">2.4 更多参数</h3>
<p>可以通过 <code>--help</code> 查看更多支持的参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">hbase org.apache.hadoop.hbase.mapreduce.CopyTable --<span class="built_in">help</span></span></span><br></pre></td></tr></table></figure>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-copy-table.png"/> </div>
<h2 id="三、Export-Import">三、Export/Import</h2>
<h3 id="3-1-简介">3.1 简介</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>Export</code> 支持导出数据到 HDFS, <code>Import</code> 支持从 HDFS 导入数据。<code>Export</code> 还支持指定导出数据的开始时间和结束时间，因此可以用于增量备份。</p>
</li>
<li class="lvl-2">
<p><code>Export</code> 导出与 <code>CopyTable</code> 一样，依赖 HBase 的 <code>scan</code> 操作</p>
</li>
</ul>
<h3 id="3-2-命令格式">3.2 命令格式</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">Export</span></span><br><span class="line">hbase org.apache.hadoop.hbase.mapreduce.Export &lt;tablename&gt; &lt;outputdir&gt; [&lt;versions&gt; [&lt;starttime&gt; [&lt;endtime&gt;]]]</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Inport</span></span><br><span class="line">hbase org.apache.hadoop.hbase.mapreduce.Import &lt;tablename&gt; &lt;inputdir&gt;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>导出的 <code>outputdir</code> 目录可以不用预先创建，程序会自动创建。导出完成后，导出文件的所有权将由执行导出命令的用户所拥有。</p>
</li>
<li class="lvl-2">
<p>默认情况下，仅导出给定 <code>Cell</code> 的最新版本，而不管历史版本。要导出多个版本，需要将 <code>&lt;versions&gt;</code> 参数替换为所需的版本数。</p>
</li>
</ul>
<h3 id="3-3-常用命令">3.3 常用命令</h3>
<ol>
<li class="lvl-3">
<p>导出命令</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase org.apache.hadoop.hbase.mapreduce.Export tableName  hdfs 路径/tableName.db</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>导入命令</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hbase org.apache.hadoop.hbase.mapreduce.Import tableName  hdfs 路径/tableName.db</span><br></pre></td></tr></table></figure>
<h2 id="四、Snapshot">四、Snapshot</h2>
<h3 id="4-1-简介">4.1 简介</h3>
<p>HBase 的快照 (Snapshot) 功能允许您获取表的副本 (包括内容和元数据)，并且性能开销很小。因为快照存储的仅仅是表的元数据和 HFiles 的信息。快照的 <code>clone</code> 操作会从该快照创建新表，快照的 <code>restore</code> 操作会将表的内容还原到快照节点。<code>clone</code> 和 <code>restore</code> 操作不需要复制任何数据，因为底层 HFiles(包含 HBase 表数据的文件) 不会被修改，修改的只是表的元数据信息。</p>
<h3 id="4-2-配置">4.2 配置</h3>
<p>HBase 快照功能默认没有开启，如果要开启快照，需要在 <code>hbase-site.xml</code> 文件中添加如下配置项：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.snapshot.enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-3-常用命令">4.3 常用命令</h3>
<p>快照的所有命令都需要在 Hbase Shell 交互式命令行中执行。</p>
<h4 id="1-Take-a-Snapshot">1. Take a Snapshot</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">拍摄快照</span></span><br><span class="line"><span class="meta">hbase&gt; </span><span class="language-bash">snapshot <span class="string">&#x27;表名&#x27;</span>, <span class="string">&#x27;快照名&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>默认情况下拍摄快照之前会在内存中执行数据刷新。以保证内存中的数据包含在快照中。但是如果你不希望包含内存中的数据，则可以使用 <code>SKIP_FLUSH</code> 选项禁止刷新。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">禁止内存刷新</span></span><br><span class="line"><span class="meta">hbase&gt; </span><span class="language-bash">snapshot  <span class="string">&#x27;表名&#x27;</span>, <span class="string">&#x27;快照名&#x27;</span>, &#123;SKIP_FLUSH =&gt; <span class="literal">true</span>&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-Listing-Snapshots">2. Listing Snapshots</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">获取快照列表</span></span><br><span class="line"><span class="meta">hbase&gt; </span><span class="language-bash">list_snapshots</span></span><br></pre></td></tr></table></figure>
<h4 id="3-Deleting-Snapshots">3. Deleting Snapshots</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">删除快照</span></span><br><span class="line"><span class="meta">hbase&gt; </span><span class="language-bash">delete_snapshot <span class="string">&#x27;快照名&#x27;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="4-Clone-a-table-from-snapshot">4. Clone a table from snapshot</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">从现有的快照创建一张新表</span></span><br><span class="line"><span class="meta">hbase&gt; </span><span class="language-bash"> clone_snapshot <span class="string">&#x27;快照名&#x27;</span>, <span class="string">&#x27;新表名&#x27;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="5-Restore-a-snapshot">5. Restore a snapshot</h4>
<p>将表恢复到快照节点，恢复操作需要先禁用表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">hbase&gt; </span><span class="language-bash"><span class="built_in">disable</span> <span class="string">&#x27;表名&#x27;</span></span></span><br><span class="line"><span class="meta">hbase&gt; </span><span class="language-bash">restore_snapshot <span class="string">&#x27;快照名&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>这里需要注意的是：是如果 HBase 配置了基于 Replication 的主从复制，由于 Replication 在日志级别工作，而快照在文件系统级别工作，因此在还原之后，会出现副本与主服务器处于不同的状态的情况。这时候可以先停止同步，所有服务器还原到一致的数据点后再重新建立同步。</p>
<blockquote>
<p>原文：<a href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>hbase</category>
      </categories>
      <tags>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>Hbase常用shell命令</title>
    <url>/posts/e516feb9.html</url>
    <content><![CDATA[<h2 id="一、基本命令">一、基本命令</h2>
<p>打开 Hbase Shell：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">hbase shell</span></span><br></pre></td></tr></table></figure>
<h4 id="1-1-获取帮助">1.1 获取帮助</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">获取帮助</span></span><br><span class="line">help</span><br><span class="line"><span class="meta"># </span><span class="language-bash">获取命令的详细信息</span></span><br><span class="line">help &#x27;status&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-查看服务器状态">1.2 查看服务器状态</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">status</span><br></pre></td></tr></table></figure>
<h4 id="1-3-查看版本信息">1.3 查看版本信息</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">version</span><br></pre></td></tr></table></figure>
<h2 id="二、关于表的操作">二、关于表的操作</h2>
<h4 id="2-1-查看所有表">2.1 查看所有表</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">list</span><br></pre></td></tr></table></figure>
<h4 id="2-2-创建表">2.2 创建表</h4>
<p><strong>命令格式</strong>： create ‘表名称’, ‘列族名称 1’,‘列族名称 2’,‘列名称 N’</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">创建一张名为Student的表,包含基本信息（baseInfo）、学校信息（schoolInfo）两个列族</span></span><br><span class="line">create &#x27;Student&#x27;,&#x27;baseInfo&#x27;,&#x27;schoolInfo&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-查看表的基本信息">2.3 查看表的基本信息</h4>
<p><strong>命令格式</strong>：desc ‘表名’</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">describe &#x27;Student&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-表的启用-禁用">2.4 表的启用/禁用</h4>
<p>enable 和 disable 可以启用/禁用这个表,is_enabled 和 is_disabled 来检查表是否被禁用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">禁用表</span></span><br><span class="line">disable &#x27;Student&#x27;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">检查表是否被禁用</span></span><br><span class="line">is_disabled &#x27;Student&#x27;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">启用表</span></span><br><span class="line">enable &#x27;Student&#x27;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">检查表是否被启用</span></span><br><span class="line">is_enabled &#x27;Student&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="2-5-检查表是否存在">2.5 检查表是否存在</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exists &#x27;Student&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="2-6-删除表">2.6 删除表</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">删除表前需要先禁用表</span></span><br><span class="line">disable &#x27;Student&#x27;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">删除表</span></span><br><span class="line">drop &#x27;Student&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="三、增删改">三、增删改</h2>
<h4 id="3-1-添加列族">3.1 添加列族</h4>
<p><strong>命令格式</strong>： alter ‘表名’, ‘列族名’</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alter &#x27;Student&#x27;, &#x27;teacherInfo&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-删除列族">3.2 删除列族</h4>
<p><strong>命令格式</strong>：alter ‘表名’, {NAME =&gt; ‘列族名’, METHOD =&gt; ‘delete’}</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alter &#x27;Student&#x27;, &#123;NAME =&gt; &#x27;teacherInfo&#x27;, METHOD =&gt; &#x27;delete&#x27;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-更改列族存储版本的限制">3.3 更改列族存储版本的限制</h4>
<p>默认情况下，列族只存储一个版本的数据，如果需要存储多个版本的数据，则需要修改列族的属性。修改后可通过 <code>desc</code> 命令查看。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alter &#x27;Student&#x27;,&#123;NAME=&gt;&#x27;baseInfo&#x27;,VERSIONS=&gt;3&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-4-插入数据">3.4 插入数据</h4>
<p><strong>命令格式</strong>：put ‘表名’, ‘行键’,‘列族:列’,‘值’</p>
<p><strong>注意：如果新增数据的行键值、列族名、列名与原有数据完全相同，则相当于更新操作</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">put &#x27;Student&#x27;, &#x27;rowkey1&#x27;,&#x27;baseInfo:name&#x27;,&#x27;tom&#x27;</span><br><span class="line">put &#x27;Student&#x27;, &#x27;rowkey1&#x27;,&#x27;baseInfo:birthday&#x27;,&#x27;1990-01-09&#x27;</span><br><span class="line">put &#x27;Student&#x27;, &#x27;rowkey1&#x27;,&#x27;baseInfo:age&#x27;,&#x27;29&#x27;</span><br><span class="line">put &#x27;Student&#x27;, &#x27;rowkey1&#x27;,&#x27;schoolInfo:name&#x27;,&#x27;Havard&#x27;</span><br><span class="line">put &#x27;Student&#x27;, &#x27;rowkey1&#x27;,&#x27;schoolInfo:localtion&#x27;,&#x27;Boston&#x27;</span><br><span class="line"></span><br><span class="line">put &#x27;Student&#x27;, &#x27;rowkey2&#x27;,&#x27;baseInfo:name&#x27;,&#x27;jack&#x27;</span><br><span class="line">put &#x27;Student&#x27;, &#x27;rowkey2&#x27;,&#x27;baseInfo:birthday&#x27;,&#x27;1998-08-22&#x27;</span><br><span class="line">put &#x27;Student&#x27;, &#x27;rowkey2&#x27;,&#x27;baseInfo:age&#x27;,&#x27;21&#x27;</span><br><span class="line">put &#x27;Student&#x27;, &#x27;rowkey2&#x27;,&#x27;schoolInfo:name&#x27;,&#x27;yale&#x27;</span><br><span class="line">put &#x27;Student&#x27;, &#x27;rowkey2&#x27;,&#x27;schoolInfo:localtion&#x27;,&#x27;New Haven&#x27;</span><br><span class="line"></span><br><span class="line">put &#x27;Student&#x27;, &#x27;rowkey3&#x27;,&#x27;baseInfo:name&#x27;,&#x27;maike&#x27;</span><br><span class="line">put &#x27;Student&#x27;, &#x27;rowkey3&#x27;,&#x27;baseInfo:birthday&#x27;,&#x27;1995-01-22&#x27;</span><br><span class="line">put &#x27;Student&#x27;, &#x27;rowkey3&#x27;,&#x27;baseInfo:age&#x27;,&#x27;24&#x27;</span><br><span class="line">put &#x27;Student&#x27;, &#x27;rowkey3&#x27;,&#x27;schoolInfo:name&#x27;,&#x27;yale&#x27;</span><br><span class="line">put &#x27;Student&#x27;, &#x27;rowkey3&#x27;,&#x27;schoolInfo:localtion&#x27;,&#x27;New Haven&#x27;</span><br><span class="line"></span><br><span class="line">put &#x27;Student&#x27;, &#x27;wrowkey4&#x27;,&#x27;baseInfo:name&#x27;,&#x27;maike-jack&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="3-5-获取指定行、指定行中的列族、列的信息">3.5 获取指定行、指定行中的列族、列的信息</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">获取指定行中所有列的数据信息</span></span><br><span class="line">get &#x27;Student&#x27;,&#x27;rowkey3&#x27;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">获取指定行中指定列族下所有列的数据信息</span></span><br><span class="line">get &#x27;Student&#x27;,&#x27;rowkey3&#x27;,&#x27;baseInfo&#x27;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">获取指定行中指定列的数据信息</span></span><br><span class="line">get &#x27;Student&#x27;,&#x27;rowkey3&#x27;,&#x27;baseInfo:name&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="3-6-删除指定行、指定行中的列">3.6 删除指定行、指定行中的列</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">删除指定行</span></span><br><span class="line">delete &#x27;Student&#x27;,&#x27;rowkey3&#x27;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">删除指定行中指定列的数据</span></span><br><span class="line">delete &#x27;Student&#x27;,&#x27;rowkey3&#x27;,&#x27;baseInfo:name&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="四、查询">四、查询</h2>
<p>hbase 中访问数据有两种基本的方式：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>按指定 rowkey 获取数据：get 方法；</p>
</li>
<li class="lvl-2">
<p>按指定条件获取数据：scan 方法。</p>
</li>
</ul>
<p><code>scan</code> 可以设置 begin 和 end 参数来访问一个范围内所有的数据。get 本质上就是 begin 和 end 相等的一种特殊的 scan。</p>
<h4 id="4-1Get查询">4.1Get查询</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">获取指定行中所有列的数据信息</span></span><br><span class="line">get &#x27;Student&#x27;,&#x27;rowkey3&#x27;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">获取指定行中指定列族下所有列的数据信息</span></span><br><span class="line">get &#x27;Student&#x27;,&#x27;rowkey3&#x27;,&#x27;baseInfo&#x27;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">获取指定行中指定列的数据信息</span></span><br><span class="line">get &#x27;Student&#x27;,&#x27;rowkey3&#x27;,&#x27;baseInfo:name&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-查询整表数据">4.2 查询整表数据</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scan &#x27;Student&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-查询指定列簇的数据">4.3 查询指定列簇的数据</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scan &#x27;Student&#x27;, &#123;COLUMN=&gt;&#x27;baseInfo&#x27;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-条件查询">4.4  条件查询</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">查询指定列的数据</span></span><br><span class="line">scan &#x27;Student&#x27;, &#123;COLUMNS=&gt; &#x27;baseInfo:birthday&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>除了列 <code>（COLUMNS）</code> 修饰词外，HBase 还支持 <code>Limit</code>（限制查询结果行数），<code>STARTROW</code>（<code>ROWKEY</code> 起始行，会先根据这个 <code>key</code> 定位到 <code>region</code>，再向后扫描）、<code>STOPROW</code>(结束行)、<code>TIMERANGE</code>（限定时间戳范围）、<code>VERSIONS</code>（版本数）、和 <code>FILTER</code>（按条件过滤行）等。</p>
<p>如下代表从 <code>rowkey2</code> 这个 <code>rowkey</code> 开始，查找下两个行的最新 3 个版本的 name 列的数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scan &#x27;Student&#x27;, &#123;COLUMNS=&gt; &#x27;baseInfo:name&#x27;,STARTROW =&gt; &#x27;rowkey2&#x27;,STOPROW =&gt; &#x27;wrowkey4&#x27;,LIMIT=&gt;2, VERSIONS=&gt;3&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-5-条件过滤">4.5  条件过滤</h4>
<p>Filter 可以设定一系列条件来进行过滤。如我们要查询值等于 24 的所有数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scan &#x27;Student&#x27;, FILTER=&gt;&quot;ValueFilter(=,&#x27;binary:24&#x27;)&quot;</span><br></pre></td></tr></table></figure>
<p>值包含 yale 的所有数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scan &#x27;Student&#x27;, FILTER=&gt;&quot;ValueFilter(=,&#x27;substring:yale&#x27;)&quot;</span><br></pre></td></tr></table></figure>
<p>列名中的前缀为 birth 的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scan &#x27;Student&#x27;, FILTER=&gt;&quot;ColumnPrefixFilter(&#x27;birth&#x27;)&quot;</span><br></pre></td></tr></table></figure>
<p>FILTER 中支持多个过滤条件通过括号、AND 和 OR 进行组合：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">列名中的前缀为birth且列值中包含1998的数据</span></span><br><span class="line">scan &#x27;Student&#x27;, FILTER=&gt;&quot;ColumnPrefixFilter(&#x27;birth&#x27;) AND ValueFilter ValueFilter(=,&#x27;substring:1998&#x27;)&quot;</span><br></pre></td></tr></table></figure>
<p><code>PrefixFilter</code> 用于对 Rowkey 的前缀进行判断：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scan &#x27;Student&#x27;, FILTER=&gt;&quot;PrefixFilter(&#x27;wr&#x27;)&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>hbase</category>
      </categories>
      <tags>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>Hbase架构及数据结构</title>
    <url>/posts/ad906e39.html</url>
    <content><![CDATA[<h2 id="一、基本概念">一、基本概念</h2>
<p>一个典型的 Hbase Table 表如下：</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-webtable.png"/> </div>
<h3 id="1-1-Row-Key-行键">1.1 Row Key (行键)</h3>
<p><code>Row Key</code> 是用来检索记录的主键。想要访问 HBase Table 中的数据，只有以下三种方式：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>通过指定的 <code>Row Key</code> 进行访问；</p>
</li>
<li class="lvl-2">
<p>通过 Row Key 的 range 进行访问，即访问指定范围内的行；</p>
</li>
<li class="lvl-2">
<p>进行全表扫描。</p>
</li>
</ul>
<p><code>Row Key</code> 可以是任意字符串，存储时数据按照 <code>Row Key</code> 的字典序进行排序。这里需要注意以下两点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>因为字典序对 Int 排序的结果是 1,10,100,11,12,13,14,15,16,17,18,19,2,20,21,…,9,91,92,93,94,95,96,97,98,99。如果你使用整型的字符串作为行键，那么为了保持整型的自然序，行键必须用 0 作左填充。</p>
</li>
<li class="lvl-2">
<p>行的一次读写操作时原子性的 (不论一次读写多少列)。</p>
</li>
</ul>
<h3 id="1-2-Column-Family（列族）">1.2 Column Family（列族）</h3>
<p>HBase 表中的每个列，都归属于某个列族。列族是表的 Schema 的一部分，所以列族需要在创建表时进行定义。列族的所有列都以列族名作为前缀，例如 <code>courses:history</code>，<code>courses:math</code> 都属于 <code>courses</code> 这个列族。</p>
<h3 id="1-3-Column-Qualifier-列限定符">1.3 Column Qualifier (列限定符)</h3>
<p>列限定符，你可以理解为是具体的列名，例如 <code>courses:history</code>，<code>courses:math</code> 都属于 <code>courses</code> 这个列族，它们的列限定符分别是 <code>history</code> 和 <code>math</code>。需要注意的是列限定符不是表 Schema 的一部分，你可以在插入数据的过程中动态创建列。</p>
<h3 id="1-4-Column-列">1.4 Column(列)</h3>
<p>HBase 中的列由列族和列限定符组成，它们由 <code>:</code>(冒号) 进行分隔，即一个完整的列名应该表述为 <code>列族名 ：列限定符</code>。</p>
<h3 id="1-5-Cell">1.5 Cell</h3>
<p><code>Cell</code> 是行，列族和列限定符的组合，并包含值和时间戳。你可以等价理解为关系型数据库中由指定行和指定列确定的一个单元格，但不同的是 HBase 中的一个单元格是由多个版本的数据组成的，每个版本的数据用时间戳进行区分。</p>
<h3 id="1-6-Timestamp-时间戳">1.6 Timestamp(时间戳)</h3>
<p>HBase 中通过 <code>row key</code> 和 <code>column</code> 确定的为一个存储单元称为 <code>Cell</code>。每个 <code>Cell</code> 都保存着同一份数据的多个版本。版本通过时间戳来索引，时间戳的类型是 64 位整型，时间戳可以由 HBase 在数据写入时自动赋值，也可以由客户显式指定。每个 <code>Cell</code> 中，不同版本的数据按照时间戳倒序排列，即最新的数据排在最前面。</p>
<h2 id="二、存储结构">二、存储结构</h2>
<h3 id="2-1-Regions">2.1 Regions</h3>
<p>HBase Table 中的所有行按照 <code>Row Key</code> 的字典序排列。HBase Tables 通过行键的范围 (row key range) 被水平切分成多个 <code>Region</code>, 一个 <code>Region</code> 包含了在 start key 和 end key 之间的所有行。</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/HBaseArchitecture-Blog-Fig2.png"/> </div>
<p>每个表一开始只有一个 <code>Region</code>，随着数据不断增加，<code>Region</code> 会不断增大，当增大到一个阀值的时候，<code>Region</code> 就会等分为两个新的 <code>Region</code>。当 Table 中的行不断增多，就会有越来越多的 <code>Region</code>。</p>
<div align="center"> <img width="600px" src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-region-splite.png"/> </div>
<p><code>Region</code> 是 HBase 中<strong>分布式存储和负载均衡的最小单元</strong>。这意味着不同的 <code>Region</code> 可以分布在不同的 <code>Region Server</code> 上。但一个 <code>Region</code> 是不会拆分到多个 Server 上的。</p>
<div align="center"> <img width="600px" src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-region-dis.png"/> </div>
<h3 id="2-2-Region-Server">2.2 Region Server</h3>
<p><code>Region Server</code> 运行在 HDFS 的 DataNode 上。它具有以下组件：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>WAL(Write Ahead Log，预写日志)</strong>：用于存储尚未进持久化存储的数据记录，以便在发生故障时进行恢复。</p>
</li>
<li class="lvl-2">
<p><strong>BlockCache</strong>：读缓存。它将频繁读取的数据存储在内存中，如果存储不足，它将按照 <code>最近最少使用原则</code> 清除多余的数据。</p>
</li>
<li class="lvl-2">
<p><strong>MemStore</strong>：写缓存。它存储尚未写入磁盘的新数据，并会在数据写入磁盘之前对其进行排序。每个 Region 上的每个列族都有一个 MemStore。</p>
</li>
<li class="lvl-2">
<p><strong>HFile</strong> ：将行数据按照 Key\Values 的形式存储在文件系统上。</p>
</li>
</ul>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-Region-Server.png"/> </div>
<p>Region Server 存取一个子表时，会创建一个 Region 对象，然后对表的每个列族创建一个 <code>Store</code> 实例，每个 <code>Store</code> 会有 0 个或多个 <code>StoreFile</code> 与之对应，每个 <code>StoreFile</code> 则对应一个 <code>HFile</code>，HFile 就是实际存储在 HDFS 上的文件。</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-hadoop.png"/> </div>
<h2 id="三、Hbase系统架构">三、Hbase系统架构</h2>
<h3 id="3-1-系统架构">3.1 系统架构</h3>
<p>HBase 系统遵循 Master/Salve 架构，由三种不同类型的组件组成：</p>
<p><strong>Zookeeper</strong></p>
<ol>
<li class="lvl-3">
<p>保证任何时候，集群中只有一个 Master；</p>
</li>
<li class="lvl-3">
<p>存贮所有 Region 的寻址入口；</p>
</li>
<li class="lvl-3">
<p>实时监控 Region Server 的状态，将 Region Server 的上线和下线信息实时通知给 Master；</p>
</li>
<li class="lvl-3">
<p>存储 HBase 的 Schema，包括有哪些 Table，每个 Table 有哪些 Column Family 等信息。</p>
</li>
</ol>
<p><strong>Master</strong></p>
<ol>
<li class="lvl-3">
<p>为 Region Server 分配 Region ；</p>
</li>
<li class="lvl-3">
<p>负责 Region Server 的负载均衡 ；</p>
</li>
<li class="lvl-3">
<p>发现失效的 Region Server 并重新分配其上的 Region；</p>
</li>
<li class="lvl-3">
<p>GFS 上的垃圾文件回收；</p>
</li>
<li class="lvl-3">
<p>处理 Schema 的更新请求。</p>
</li>
</ol>
<p><strong>Region Server</strong></p>
<ol>
<li class="lvl-3">
<p>Region Server 负责维护 Master 分配给它的 Region ，并处理发送到 Region 上的 IO 请求；</p>
</li>
<li class="lvl-3">
<p>Region Server 负责切分在运行过程中变得过大的 Region。</p>
</li>
</ol>
<div align="center"> <img width="600px" src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/HBaseArchitecture-Blog-Fig1.png"/> </div>
<h3 id="3-2-组件间的协作">3.2 组件间的协作</h3>
<p>HBase 使用 ZooKeeper 作为分布式协调服务来维护集群中的服务器状态。 Zookeeper 负责维护可用服务列表，并提供服务故障通知等服务：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>每个 Region Server 都会在 ZooKeeper 上创建一个临时节点，Master 通过 Zookeeper 的 Watcher 机制对节点进行监控，从而可以发现新加入的 Region Server 或故障退出的 Region Server；</p>
</li>
<li class="lvl-2">
<p>所有 Masters 会竞争性地在 Zookeeper 上创建同一个临时节点，由于 Zookeeper 只能有一个同名节点，所以必然只有一个 Master 能够创建成功，此时该 Master 就是主 Master，主 Master 会定期向 Zookeeper 发送心跳。备用 Masters 则通过 Watcher 机制对主 HMaster 所在节点进行监听；</p>
</li>
<li class="lvl-2">
<p>如果主 Master 未能定时发送心跳，则其持有的 Zookeeper 会话会过期，相应的临时节点也会被删除，这会触发定义在该节点上的 Watcher 事件，使得备用的 Master Servers 得到通知。所有备用的 Master Servers 在接到通知后，会再次去竞争性地创建临时节点，完成主 Master 的选举。</p>
</li>
</ul>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/HBaseArchitecture-Blog-Fig5.png"/> </div>
<h2 id="四、数据的读写流程简述">四、数据的读写流程简述</h2>
<h3 id="4-1-写入数据的流程">4.1 写入数据的流程</h3>
<ol>
<li class="lvl-3">
<p>Client 向 Region Server 提交写请求；</p>
</li>
<li class="lvl-3">
<p>Region Server 找到目标 Region；</p>
</li>
<li class="lvl-3">
<p>Region 检查数据是否与 Schema 一致；</p>
</li>
<li class="lvl-3">
<p>如果客户端没有指定版本，则获取当前系统时间作为数据版本；</p>
</li>
<li class="lvl-3">
<p>将更新写入 WAL Log；</p>
</li>
<li class="lvl-3">
<p>将更新写入 Memstore；</p>
</li>
<li class="lvl-3">
<p>判断 Memstore 存储是否已满，如果存储已满则需要 flush 为 Store Hfile 文件。</p>
</li>
</ol>
<blockquote>
<p>更为详细写入流程可以参考：<a href="http://hbasefly.com/2016/03/23/hbase_writer/">HBase － 数据写入流程解析</a></p>
</blockquote>
<h3 id="4-2-读取数据的流程">4.2 读取数据的流程</h3>
<p>以下是客户端首次读写 HBase 上数据的流程：</p>
<ol>
<li class="lvl-3">
<p>客户端从 Zookeeper 获取 <code>META</code> 表所在的 Region Server；</p>
</li>
<li class="lvl-3">
<p>客户端访问 <code>META</code> 表所在的 Region Server，从 <code>META</code> 表中查询到访问行键所在的 Region Server，之后客户端将缓存这些信息以及 <code>META</code> 表的位置；</p>
</li>
<li class="lvl-3">
<p>客户端从行键所在的 Region Server 上获取数据。</p>
</li>
</ol>
<p>如果再次读取，客户端将从缓存中获取行键所在的 Region Server。这样客户端就不需要再次查询 <code>META</code> 表，除非 Region 移动导致缓存失效，这样的话，则将会重新查询并更新缓存。</p>
<p>注：<code>META</code> 表是 HBase 中一张特殊的表，它保存了所有 Region 的位置信息，META 表自己的位置信息则存储在 ZooKeeper 上。</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/HBaseArchitecture-Blog-Fig7.png"/> </div>
<blockquote>
<p>更为详细读取数据流程参考：</p>
<p><a href="http://hbasefly.com/2016/12/21/hbase-getorscan/">HBase 原理－数据读取流程解析</a></p>
<p><a href="http://hbasefly.com/2017/06/11/hbase-scan-2/">HBase 原理－迟到的‘数据读取流程部分细节</a></p>
</blockquote>
<blockquote>
<p>原文：<a href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>hbase</category>
      </categories>
      <tags>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>Hbase环境搭建</title>
    <url>/posts/ff07428e.html</url>
    <content><![CDATA[<h2 id="一、安装前置条件说明">一、安装前置条件说明</h2>
<h3 id="1-1-JDK版本说明">1.1 JDK版本说明</h3>
<p>HBase 需要依赖 JDK 环境，同时 HBase 2.0+ 以上版本不再支持 JDK 1.7 ，需要安装 JDK 1.8+ 。JDK 安装方式见本仓库：</p>
<blockquote>
<p><a href="https://github.com/ihadyou/BigData-Notes/blob/master/notes/installation/Linux%E4%B8%8BJDK%E5%AE%89%E8%A3%85.md">Linux 环境下 JDK 安装</a></p>
</blockquote>
<h3 id="1-2-Standalone模式和伪集群模式的区别">1.2 Standalone模式和伪集群模式的区别</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>在 <code>Standalone</code> 模式下，所有守护进程都运行在一个 <code>jvm</code> 进程/实例中；</p>
</li>
<li class="lvl-2">
<p>在伪分布模式下，HBase 仍然在单个主机上运行，但是每个守护进程 (HMaster，HRegionServer 和 ZooKeeper) 则分别作为一个单独的进程运行。</p>
</li>
</ul>
<p><strong>说明：两种模式任选其一进行部署即可，对于开发测试来说区别不大。</strong></p>
<h2 id="二、Standalone-模式">二、Standalone 模式</h2>
<h3 id="2-1-下载并解压">2.1 下载并解压</h3>
<p>从<a href="https://hbase.apache.org/downloads.html">官方网站</a> 下载所需要版本的二进制安装包，并进行解压：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">tar -zxvf hbase-2.1.4-bin.tar.gz</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-配置环境变量">2.2 配置环境变量</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">vim /etc/profile</span></span><br></pre></td></tr></table></figure>
<p>添加环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HBASE_HOME=/usr/app/hbase-2.1.4</span><br><span class="line">export PATH=$HBASE_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>使得配置的环境变量生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">source</span> /etc/profile</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-进行HBase相关配置">2.3 进行HBase相关配置</h3>
<p>修改安装目录下的 <code>conf/hbase-env.sh</code>,指定 JDK 的安装路径：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">The java implementation to use.  Java 1.8+ required.</span></span><br><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_201</span><br></pre></td></tr></table></figure>
<p>修改安装目录下的 <code>conf/hbase-site.xml</code>，增加如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:///home/hbase/rootdir<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.dataDir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/zookeeper/dataDir<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.unsafe.stream.capability.enforce<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>hbase.rootdir</code>: 配置 hbase 数据的存储路径；</p>
<p><code>hbase.zookeeper.property.dataDir</code>: 配置 zookeeper 数据的存储路径；</p>
<p><code>hbase.unsafe.stream.capability.enforce</code>: 使用本地文件系统存储，不使用 HDFS 的情况下需要禁用此配置，设置为 false。</p>
<h3 id="2-4-启动HBase">2.4 启动HBase</h3>
<p>由于已经将 HBase 的 bin 目录配置到环境变量，直接使用以下命令启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">start-hbase.sh</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-验证启动是否成功">2.5 验证启动是否成功</h3>
<p>验证方式一 ：使用 <code>jps</code> 命令查看 HMaster 进程是否启动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@hadoop001 hbase-2.1.4]# jps</span><br><span class="line">16336 Jps</span><br><span class="line">15500 HMaster</span><br></pre></td></tr></table></figure>
<p>验证方式二 ：访问 HBaseWeb UI 页面，默认端口为 <code>16010</code> 。</p>
<div align="center"> <img src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-web-ui.png"/> </div>
<h2 id="三、伪集群模式安装（Pseudo-Distributed）">三、伪集群模式安装（Pseudo-Distributed）</h2>
<h3 id="3-1-Hadoop单机伪集群安装">3.1 Hadoop单机伪集群安装</h3>
<p>这里我们采用 HDFS 作为 HBase 的存储方案，需要预先安装 Hadoop。Hadoop 的安装方式单独整理至：</p>
<blockquote>
<p><a href="https://github.com/ihadyou/BigData-Notes/blob/master/notes/installation/Hadoop%E5%8D%95%E6%9C%BA%E7%89%88%E6%9C%AC%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md">Hadoop 单机伪集群搭建</a></p>
</blockquote>
<h3 id="3-2-Hbase版本选择">3.2 Hbase版本选择</h3>
<p>HBase 的版本必须要与 Hadoop 的版本兼容，不然会出现各种 Jar 包冲突。这里我 Hadoop 安装的版本为 <code>hadoop-2.6.0-cdh5.15.2</code>，为保持版本一致，选择的 HBase 版本为 <code>hbase-1.2.0-cdh5.15.2</code> 。所有软件版本如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Hadoop 版本： hadoop-2.6.0-cdh5.15.2</p>
</li>
<li class="lvl-2">
<p>HBase 版本： hbase-1.2.0-cdh5.15.2</p>
</li>
<li class="lvl-2">
<p>JDK 版本：JDK 1.8</p>
</li>
</ul>
<h3 id="3-3-软件下载解压">3.3 软件下载解压</h3>
<p>下载后进行解压，下载地址：<a href="http://archive.cloudera.com/cdh5/cdh/5/">http://archive.cloudera.com/cdh5/cdh/5/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">tar -zxvf hbase-1.2.0-cdh5.15.2.tar.gz</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4-配置环境变量">3.4 配置环境变量</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">vim /etc/profile</span></span><br></pre></td></tr></table></figure>
<p>添加环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HBASE_HOME=/usr/app/hbase-1.2.0-cdh5.15.2</span><br><span class="line">export PATH=$HBASE_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>使得配置的环境变量生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">source</span> /etc/profile</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-进行HBase相关配置">3.5 进行HBase相关配置</h3>
<p>1.修改安装目录下的 <code>conf/hbase-env.sh</code>,指定 JDK 的安装路径：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">The java implementation to use.  Java 1.7+ required.</span></span><br><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_201</span><br></pre></td></tr></table></figure>
<p>2.修改安装目录下的 <code>conf/hbase-site.xml</code>，增加如下配置 (hadoop001 为主机名)：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--指定 HBase 以分布式模式运行--&gt;</span>   </span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--指定 HBase 数据存储路径为 HDFS 上的 hbase 目录,hbase 目录不需要预先创建，程序会自动创建--&gt;</span>   </span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop001:8020/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定 zookeeper 数据的存储位置--&gt;</span>   </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.dataDir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/zookeeper/dataDir<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>3.修改安装目录下的 <code>conf/regionservers</code>，指定 region  servers 的地址，修改后其内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop001</span><br></pre></td></tr></table></figure>
<h3 id="3-6-启动">3.6 启动</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">bin/start-hbase.sh</span></span><br></pre></td></tr></table></figure>
<h3 id="3-7-验证启动是否成功">3.7 验证启动是否成功</h3>
<p>验证方式一 ：使用 <code>jps</code> 命令查看进程。其中 <code>HMaster</code>，<code>HRegionServer</code> 是 HBase 的进程，<code>HQuorumPeer</code> 是 HBase 内置的 Zookeeper 的进程，其余的为 HDFS 和 YARN 的进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop001 conf]# jps</span><br><span class="line">28688 NodeManager</span><br><span class="line">25824 GradleDaemon</span><br><span class="line">10177 Jps</span><br><span class="line">22083 HRegionServer</span><br><span class="line">20534 DataNode</span><br><span class="line">20807 SecondaryNameNode</span><br><span class="line">18744 Main</span><br><span class="line">20411 NameNode</span><br><span class="line">21851 HQuorumPeer</span><br><span class="line">28573 ResourceManager</span><br><span class="line">21933 HMaster</span><br></pre></td></tr></table></figure>
<p>验证方式二 ：访问 HBase Web UI 界面，需要注意的是 1.2 版本的 HBase 的访问端口为 <code>60010</code></p>
<div align="center"> <img src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-60010.png"/> </div>
<blockquote>
<p>原文：<a href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>hbase</category>
      </categories>
      <tags>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>Hbase的SQL中间层—Phoenix</title>
    <url>/posts/1618daf0.html</url>
    <content><![CDATA[<h2 id="一、Phoenix简介">一、Phoenix简介</h2>
<p><code>Phoenix</code> 是 HBase 的开源 SQL 中间层，它允许你使用标准 JDBC 的方式来操作 HBase 上的数据。在 <code>Phoenix</code> 之前，如果你要访问 HBase，只能调用它的 Java API，但相比于使用一行 SQL 就能实现数据查询，HBase 的 API 还是过于复杂。<code>Phoenix</code> 的理念是 <code>we put sql SQL back in NOSQL</code>，即你可以使用标准的 SQL 就能完成对 HBase 上数据的操作。同时这也意味着你可以通过集成 <code>Spring Data  JPA</code> 或 <code>Mybatis</code> 等常用的持久层框架来操作 HBase。</p>
<p>其次 <code>Phoenix</code> 的性能表现也非常优异，<code>Phoenix</code> 查询引擎会将 SQL 查询转换为一个或多个 HBase Scan，通过并行执行来生成标准的 JDBC 结果集。它通过直接使用 HBase API 以及协处理器和自定义过滤器，可以为小型数据查询提供毫秒级的性能，为千万行数据的查询提供秒级的性能。同时 Phoenix 还拥有二级索引等 HBase 不具备的特性，因为以上的优点，所以 <code>Phoenix</code> 成为了 HBase 最优秀的 SQL 中间层。</p>
<div align="center"> <img width="600px"  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/Phoenix-hadoop.png"/> </div>
<h2 id="二、Phoenix安装">二、Phoenix安装</h2>
<blockquote>
<p>我们可以按照官方安装说明进行安装，官方说明如下：</p>
<ul class="lvl-1">
<li class="lvl-2">download and expand our installation tar</li>
<li class="lvl-2">copy the phoenix server jar that is compatible with your HBase installation into the lib directory of every region server</li>
<li class="lvl-2">restart the region servers</li>
<li class="lvl-2">add the phoenix client jar to the classpath of your HBase client</li>
<li class="lvl-2">download and setup SQuirrel as your SQL client so you can issue adhoc SQL against your HBase cluster</li>
</ul>
</blockquote>
<h3 id="2-1-下载并解压-2">2.1 下载并解压</h3>
<p>官方针对 Apache 版本和 CDH 版本的 HBase 均提供了安装包，按需下载即可。官方下载地址: <a href="http://phoenix.apache.org/download.html">http://phoenix.apache.org/download.html</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">下载</span></span><br><span class="line">wget http://mirror.bit.edu.cn/apache/phoenix/apache-phoenix-4.14.0-cdh5.14.2/bin/apache-phoenix-4.14.0-cdh5.14.2-bin.tar.gz</span><br><span class="line"><span class="meta"># </span><span class="language-bash">解压</span></span><br><span class="line">tar tar apache-phoenix-4.14.0-cdh5.14.2-bin.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="2-2-拷贝Jar包">2.2 拷贝Jar包</h3>
<p>按照官方文档的说明，需要将 <code>phoenix server jar</code> 添加到所有 <code>Region Servers</code> 的安装目录的 <code>lib</code> 目录下。</p>
<p>这里由于我搭建的是 HBase 伪集群，所以只需要拷贝到当前机器的 HBase 的 lib 目录下。如果是真实集群，则使用 scp 命令分发到所有 <code>Region Servers</code> 机器上。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /usr/app/apache-phoenix-4.14.0-cdh5.14.2-bin/phoenix-4.14.0-cdh5.14.2-server.jar /usr/app/hbase-1.2.0-cdh5.15.2/lib</span><br></pre></td></tr></table></figure>
<h3 id="2-3-重启-Region-Servers">2.3 重启 Region Servers</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">停止Hbase</span></span><br><span class="line">stop-hbase.sh</span><br><span class="line"><span class="meta"># </span><span class="language-bash">启动Hbase</span></span><br><span class="line">start-hbase.sh</span><br></pre></td></tr></table></figure>
<h3 id="2-4-启动Phoenix">2.4 启动Phoenix</h3>
<p>在 Phoenix 解压目录下的 <code>bin</code> 目录下执行如下命令，需要指定 Zookeeper 的地址：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果 HBase 采用 Standalone 模式或者伪集群模式搭建，则默认采用内置的 Zookeeper 服务，端口为 2181；</p>
</li>
<li class="lvl-2">
<p>如果是 HBase 是集群模式并采用外置的 Zookeeper 集群，则按照自己的实际情况进行指定。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">./sqlline.py hadoop001:2181</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-启动结果">2.5 启动结果</h3>
<p>启动后则进入了 Phoenix 交互式 SQL 命令行，可以使用 <code>!table</code> 或 <code>!tables</code> 查看当前所有表的信息</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/phoenix-shell.png"/> </div>
<h2 id="三、Phoenix-简单使用">三、Phoenix 简单使用</h2>
<h3 id="3-1-创建表">3.1 创建表</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> us_population (</span><br><span class="line">      state <span class="type">CHAR</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">      city <span class="type">VARCHAR</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">      population <span class="type">BIGINT</span></span><br><span class="line">      <span class="keyword">CONSTRAINT</span> my_pk <span class="keyword">PRIMARY</span> KEY (state, city));</span><br></pre></td></tr></table></figure>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/Phoenix-create-table.png"/> </div>
新建的表会按照特定的规则转换为 HBase 上的表，关于表的信息，可以通过 Hbase Web UI 进行查看：
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-web-ui-phoenix.png"/> </div>
### 3.2 插入数据
<p>Phoenix 中插入数据采用的是 <code>UPSERT</code> 而不是 <code>INSERT</code>,因为 Phoenix 并没有更新操作，插入相同主键的数据就视为更新，所以 <code>UPSERT</code> 就相当于 <code>UPDATE</code>+<code>INSERT</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">UPSERT INTO us_population VALUES(&#x27;NY&#x27;,&#x27;New York&#x27;,8143197);</span><br><span class="line">UPSERT INTO us_population VALUES(&#x27;CA&#x27;,&#x27;Los Angeles&#x27;,3844829);</span><br><span class="line">UPSERT INTO us_population VALUES(&#x27;IL&#x27;,&#x27;Chicago&#x27;,2842518);</span><br><span class="line">UPSERT INTO us_population VALUES(&#x27;TX&#x27;,&#x27;Houston&#x27;,2016582);</span><br><span class="line">UPSERT INTO us_population VALUES(&#x27;PA&#x27;,&#x27;Philadelphia&#x27;,1463281);</span><br><span class="line">UPSERT INTO us_population VALUES(&#x27;AZ&#x27;,&#x27;Phoenix&#x27;,1461575);</span><br><span class="line">UPSERT INTO us_population VALUES(&#x27;TX&#x27;,&#x27;San Antonio&#x27;,1256509);</span><br><span class="line">UPSERT INTO us_population VALUES(&#x27;CA&#x27;,&#x27;San Diego&#x27;,1255540);</span><br><span class="line">UPSERT INTO us_population VALUES(&#x27;TX&#x27;,&#x27;Dallas&#x27;,1213825);</span><br><span class="line">UPSERT INTO us_population VALUES(&#x27;CA&#x27;,&#x27;San Jose&#x27;,912332);</span><br></pre></td></tr></table></figure>
<h3 id="3-3-修改数据">3.3 修改数据</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 插入主键相同的数据就视为更新</span></span><br><span class="line">UPSERT <span class="keyword">INTO</span> us_population <span class="keyword">VALUES</span>(<span class="string">&#x27;NY&#x27;</span>,<span class="string">&#x27;New York&#x27;</span>,<span class="number">999999</span>);</span><br></pre></td></tr></table></figure>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/Phoenix-update.png"/> </div>
### 3.4 删除数据
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> us_population <span class="keyword">WHERE</span> city<span class="operator">=</span><span class="string">&#x27;Dallas&#x27;</span>;</span><br></pre></td></tr></table></figure>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/Phoenix-delete.png"/> </div>
### 3.5 查询数据
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> state <span class="keyword">as</span> &quot;州&quot;,<span class="built_in">count</span>(city) <span class="keyword">as</span> &quot;市&quot;,<span class="built_in">sum</span>(population) <span class="keyword">as</span> &quot;热度&quot;</span><br><span class="line"><span class="keyword">FROM</span> us_population</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> state</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">sum</span>(population) <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/Phoenix-select.png"/> </div>
<h3 id="3-6-退出命令">3.6 退出命令</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">!</span>quit</span><br></pre></td></tr></table></figure>
<h3 id="3-7-扩展">3.7 扩展</h3>
<p>从上面的操作中可以看出，Phoenix 支持大多数标准的 SQL 语法。关于 Phoenix 支持的语法、数据类型、函数、序列等详细信息，因为涉及内容很多，可以参考其官方文档，官方文档上有详细的说明：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>语法 (Grammar)</strong> ：<a href="https://phoenix.apache.org/language/index.html">https://phoenix.apache.org/language/index.html</a></p>
</li>
<li class="lvl-2">
<p><strong>函数 (Functions)</strong> ：<a href="http://phoenix.apache.org/language/functions.html">http://phoenix.apache.org/language/functions.html</a></p>
</li>
<li class="lvl-2">
<p><strong>数据类型 (Datatypes)</strong> ：<a href="http://phoenix.apache.org/language/datatypes.html">http://phoenix.apache.org/language/datatypes.html</a></p>
</li>
<li class="lvl-2">
<p><strong>序列 (Sequences)</strong> :<a href="http://phoenix.apache.org/sequences.html">http://phoenix.apache.org/sequences.html</a></p>
</li>
<li class="lvl-2">
<p><strong>联结查询 (Joins)</strong> ：<a href="http://phoenix.apache.org/joins.html">http://phoenix.apache.org/joins.html</a></p>
</li>
</ul>
<h2 id="四、Phoenix-Java-API">四、Phoenix Java API</h2>
<p>因为 Phoenix 遵循 JDBC 规范，并提供了对应的数据库驱动 <code>PhoenixDriver</code>，这使得采用 Java 语言对其进行操作的时候，就如同对其他关系型数据库一样，下面给出基本的使用示例。</p>
<h3 id="4-1-引入Phoenix-core-JAR包">4.1 引入Phoenix core JAR包</h3>
<p>如果是 maven 项目，直接在 maven 中央仓库找到对应的版本，导入依赖即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.phoenix/phoenix-core --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.phoenix<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>phoenix-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.14.0-cdh5.14.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果是普通项目，则可以从 Phoenix 解压目录下找到对应的 JAR 包，然后手动引入：</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/phoenix-core-jar.png"/> </div>
### 4.2 简单的Java API实例
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoenixJavaApi</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载数据库驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;org.apache.phoenix.jdbc.PhoenixDriver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 指定数据库地址,格式为 jdbc:phoenix:Zookeeper 地址</span></span><br><span class="line"><span class="comment">         * 如果 HBase 采用 Standalone 模式或者伪集群模式搭建，则 HBase 默认使用内置的 Zookeeper，默认端口为 2181</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:phoenix:192.168.200.226:2181&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.prepareStatement(<span class="string">&quot;SELECT * FROM us_population&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">            System.out.println(resultSet.getString(<span class="string">&quot;city&quot;</span>) + <span class="string">&quot; &quot;</span></span><br><span class="line">                    + resultSet.getInt(<span class="string">&quot;population&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/Phoenix-java-api-result.png"/> </div>
<p>实际的开发中我们通常都是采用第三方框架来操作数据库，如 <code>mybatis</code>，<code>Hibernate</code>，<code>Spring Data</code> 等。关于 Phoenix 与这些框架的整合步骤参见下一篇文章：<a href="https://github.com/ihadyou/BigData-Notes/blob/master/notes/Spring+Mybtais+Phoenix%E6%95%B4%E5%90%88.md">Spring/Spring Boot + Mybatis + Phoenix</a></p>
<blockquote>
<p>原文：<a href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>hbase</category>
      </categories>
      <tags>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>Hbase简介</title>
    <url>/posts/98e8148c.html</url>
    <content><![CDATA[<h2 id="一、Hadoop的局限">一、Hadoop的局限</h2>
<p>HBase 是一个构建在 Hadoop 文件系统之上的面向列的数据库管理系统。</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase.jpg"/> </div>
<p>要想明白为什么产生 HBase，就需要先了解一下 Hadoop 存在的限制？Hadoop 可以通过 HDFS 来存储结构化、半结构甚至非结构化的数据，它是传统数据库的补充，是海量数据存储的最佳方法，它针对大文件的存储，批量访问和流式访问都做了优化，同时也通过多副本解决了容灾问题。</p>
<p>但是 Hadoop 的缺陷在于它只能执行批处理，并且只能以顺序方式访问数据，这意味着即使是最简单的工作，也必须搜索整个数据集，无法实现对数据的随机访问。实现数据的随机访问是传统的关系型数据库所擅长的，但它们却不能用于海量数据的存储。在这种情况下，必须有一种新的方案来解决海量数据存储和随机访问的问题，HBase 就是其中之一 (HBase，Cassandra，couchDB，Dynamo 和 MongoDB 都能存储海量数据并支持随机访问)。</p>
<blockquote>
<p>注：数据结构分类：</p>
<ul class="lvl-1">
<li class="lvl-2">结构化数据：即以关系型数据库表形式管理的数据；</li>
<li class="lvl-2">半结构化数据：非关系模型的，有基本固定结构模式的数据，例如日志文件、XML 文档、JSON 文档、Email 等；</li>
<li class="lvl-2">非结构化数据：没有固定模式的数据，如 WORD、PDF、PPT、EXL，各种格式的图片、视频等。</li>
</ul>
</blockquote>
<h2 id="二、HBase简介">二、HBase简介</h2>
<p>HBase 是一个构建在 Hadoop 文件系统之上的面向列的数据库管理系统。</p>
<p>HBase 是一种类似于 <code>Google’s Big Table</code> 的数据模型，它是 Hadoop 生态系统的一部分，它将数据存储在 HDFS 上，客户端可以通过 HBase 实现对 HDFS 上数据的随机访问。它具有以下特性：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>不支持复杂的事务，只支持行级事务，即单行数据的读写都是原子性的；</p>
</li>
<li class="lvl-2">
<p>由于是采用 HDFS 作为底层存储，所以和 HDFS 一样，支持结构化、半结构化和非结构化的存储；</p>
</li>
<li class="lvl-2">
<p>支持通过增加机器进行横向扩展；</p>
</li>
<li class="lvl-2">
<p>支持数据分片；</p>
</li>
<li class="lvl-2">
<p>支持 RegionServers 之间的自动故障转移；</p>
</li>
<li class="lvl-2">
<p>易于使用的 Java 客户端 API；</p>
</li>
<li class="lvl-2">
<p>支持 BlockCache 和布隆过滤器；</p>
</li>
<li class="lvl-2">
<p>过滤器支持谓词下推。</p>
</li>
</ul>
<h2 id="三、HBase-Table">三、HBase Table</h2>
<p>HBase 是一个面向 <code>列</code> 的数据库管理系统，这里更为确切的而说，HBase 是一个面向 <code>列族</code> 的数据库管理系统。表 schema 仅定义列族，表具有多个列族，每个列族可以包含任意数量的列，列由多个单元格（cell ）组成，单元格可以存储多个版本的数据，多个版本数据以时间戳进行区分。</p>
<p>下图为 HBase 中一张表的：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>RowKey 为行的唯一标识，所有行按照 RowKey 的字典序进行排序；</p>
</li>
<li class="lvl-2">
<p>该表具有两个列族，分别是 personal 和 office;</p>
</li>
<li class="lvl-2">
<p>其中列族 personal 拥有 name、city、phone 三个列，列族 office 拥有 tel、addres 两个列。</p>
</li>
</ul>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/HBase_table-iteblog.png"/> </div>
<blockquote>
<p><em>图片引用自 : HBase 是列式存储数据库吗</em> <em><a href="https://www.iteblog.com/archives/2498.html">https://www.iteblog.com/archives/2498.html</a></em></p>
</blockquote>
<p>Hbase 的表具有以下特点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>容量大：一个表可以有数十亿行，上百万列；</p>
</li>
<li class="lvl-2">
<p>面向列：数据是按照列存储，每一列都单独存放，数据即索引，在查询时可以只访问指定列的数据，有效地降低了系统的 I/O 负担；</p>
</li>
<li class="lvl-2">
<p>稀疏性：空 (null) 列并不占用存储空间，表可以设计的非常稀疏  ；</p>
</li>
<li class="lvl-2">
<p>数据多版本：每个单元中的数据可以有多个版本，按照时间戳排序，新的数据在最上面；</p>
</li>
<li class="lvl-2">
<p>存储类型：所有数据的底层存储格式都是字节数组 (byte[])。</p>
</li>
</ul>
<h2 id="四、Phoenix">四、Phoenix</h2>
<p><code>Phoenix</code> 是 HBase 的开源 SQL 中间层，它允许你使用标准 JDBC 的方式来操作 HBase 上的数据。在 <code>Phoenix</code> 之前，如果你要访问 HBase，只能调用它的 Java API，但相比于使用一行 SQL 就能实现数据查询，HBase 的 API 还是过于复杂。<code>Phoenix</code> 的理念是 <code>we put sql SQL back in NOSQL</code>，即你可以使用标准的 SQL 就能完成对 HBase 上数据的操作。同时这也意味着你可以通过集成 <code>Spring Data  JPA</code> 或 <code>Mybatis</code> 等常用的持久层框架来操作 HBase。</p>
<p>其次 <code>Phoenix</code> 的性能表现也非常优异，<code>Phoenix</code> 查询引擎会将 SQL 查询转换为一个或多个 HBase Scan，通过并行执行来生成标准的 JDBC 结果集。它通过直接使用 HBase API 以及协处理器和自定义过滤器，可以为小型数据查询提供毫秒级的性能，为千万行数据的查询提供秒级的性能。同时 Phoenix 还拥有二级索引等 HBase 不具备的特性，因为以上的优点，所以 <code>Phoenix</code> 成为了 HBase 最优秀的 SQL 中间层。</p>
<blockquote>
<p>原文：<a href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>hbase</category>
      </categories>
      <tags>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>Hbase过滤器</title>
    <url>/posts/5f20503a.html</url>
    <content><![CDATA[<h2 id="一、HBase过滤器简介">一、HBase过滤器简介</h2>
<p>Hbase 提供了种类丰富的过滤器（filter）来提高数据处理的效率，用户可以通过内置或自定义的过滤器来对数据进行过滤，所有的过滤器都在服务端生效，即谓词下推（predicate push down）。这样可以保证过滤掉的数据不会被传送到客户端，从而减轻网络传输和客户端处理的压力。</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-fliter.png"/> </div>
<h2 id="二、过滤器基础">二、过滤器基础</h2>
<h3 id="2-1-Filter接口和FilterBase抽象类">2.1  Filter接口和FilterBase抽象类</h3>
<p>Filter 接口中定义了过滤器的基本方法，FilterBase 抽象类实现了 Filter 接口。所有内置的过滤器则直接或者间接继承自 FilterBase 抽象类。用户只需要将定义好的过滤器通过 <code>setFilter</code> 方法传递给 <code>Scan</code> 或 <code>put</code> 的实例即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setFilter(Filter filter)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Scan 中定义的 setFilter</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Scan <span class="title function_">setFilter</span><span class="params">(Filter filter)</span> &#123;</span><br><span class="line">   <span class="built_in">super</span>.setFilter(filter);</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// Get 中定义的 setFilter</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Get <span class="title function_">setFilter</span><span class="params">(Filter filter)</span> &#123;</span><br><span class="line">   <span class="built_in">super</span>.setFilter(filter);</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>FilterBase 的所有子类过滤器如下：<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-filterbase-subclass.png"/> </div></p>
<blockquote>
<p>说明：上图基于当前时间点（2019.4）最新的 Hbase-2.1.4 ，下文所有说明均基于此版本。</p>
</blockquote>
<h3 id="2-2-过滤器分类">2.2 过滤器分类</h3>
<p>HBase 内置过滤器可以分为三类：分别是比较过滤器，专用过滤器和包装过滤器。分别在下面的三个小节中做详细的介绍。</p>
<h2 id="三、比较过滤器">三、比较过滤器</h2>
<p>所有比较过滤器均继承自 <code>CompareFilter</code>。创建一个比较过滤器需要两个参数，分别是<strong>比较运算符</strong>和<strong>比较器实例</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CompareFilter</span><span class="params">(<span class="keyword">final</span> CompareOp compareOp,<span class="keyword">final</span> ByteArrayComparable comparator)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.compareOp = compareOp;</span><br><span class="line">   <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-比较运算符">3.1 比较运算符</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>LESS (&lt;)</p>
</li>
<li class="lvl-2">
<p>LESS_OR_EQUAL (&lt;=)</p>
</li>
<li class="lvl-2">
<p>EQUAL (=)</p>
</li>
<li class="lvl-2">
<p>NOT_EQUAL (!=)</p>
</li>
<li class="lvl-2">
<p>GREATER_OR_EQUAL (&gt;=)</p>
</li>
<li class="lvl-2">
<p>GREATER (&gt;)</p>
</li>
<li class="lvl-2">
<p>NO_OP (排除所有符合条件的值)</p>
</li>
</ul>
<p>比较运算符均定义在枚举类 <code>CompareOperator</code> 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@InterfaceAudience</span>.Public</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">CompareOperator</span> &#123;</span><br><span class="line">  LESS,</span><br><span class="line">  LESS_OR_EQUAL,</span><br><span class="line">  EQUAL,</span><br><span class="line">  NOT_EQUAL,</span><br><span class="line">  GREATER_OR_EQUAL,</span><br><span class="line">  GREATER,</span><br><span class="line">  NO_OP,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在 1.x 版本的 HBase 中，比较运算符定义在 <code>CompareFilter.CompareOp</code> 枚举类中，但在 2.0 之后这个类就被标识为 @deprecated ，并会在 3.0 移除。所以 2.0 之后版本的 HBase 需要使用 <code>CompareOperator</code> 这个枚举类。</p>
</blockquote>
<h3 id="3-2-比较器">3.2 比较器</h3>
<p>所有比较器均继承自 <code>ByteArrayComparable</code> 抽象类，常用的有以下几种：</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-bytearraycomparable.png"/> </div>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>BinaryComparator</strong>  : 使用 <code>Bytes.compareTo(byte []，byte [])</code> 按字典序比较指定的字节数组。</p>
</li>
<li class="lvl-2">
<p><strong>BinaryPrefixComparator</strong> : 按字典序与指定的字节数组进行比较，但只比较到这个字节数组的长度。</p>
</li>
<li class="lvl-2">
<p><strong>RegexStringComparator</strong> :  使用给定的正则表达式与指定的字节数组进行比较。仅支持 <code>EQUAL</code> 和 <code>NOT_EQUAL</code> 操作。</p>
</li>
<li class="lvl-2">
<p><strong>SubStringComparator</strong> : 测试给定的子字符串是否出现在指定的字节数组中，比较不区分大小写。仅支持 <code>EQUAL</code> 和 <code>NOT_EQUAL</code> 操作。</p>
</li>
<li class="lvl-2">
<p><strong>NullComparator</strong> ：判断给定的值是否为空。</p>
</li>
<li class="lvl-2">
<p><strong>BitComparator</strong> ：按位进行比较。</p>
</li>
</ul>
<p><code>BinaryPrefixComparator</code> 和 <code>BinaryComparator</code> 的区别不是很好理解，这里举例说明一下：</p>
<p>在进行 <code>EQUAL</code> 的比较时，如果比较器传入的是 <code>abcd</code> 的字节数组，但是待比较数据是 <code>abcdefgh</code>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果使用的是 <code>BinaryPrefixComparator</code> 比较器，则比较以 <code>abcd</code> 字节数组的长度为准，即 <code>efgh</code> 不会参与比较，这时候认为 <code>abcd</code> 与 <code>abcdefgh</code> 是满足 <code>EQUAL</code> 条件的；</p>
</li>
<li class="lvl-2">
<p>如果使用的是 <code>BinaryComparator</code> 比较器，则认为其是不相等的。</p>
</li>
</ul>
<h3 id="3-3-比较过滤器种类">3.3 比较过滤器种类</h3>
<p>比较过滤器共有五个（Hbase 1.x 版本和 2.x 版本相同），见下图：</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-compareFilter.png"/> </div>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>RowFilter</strong> ：基于行键来过滤数据；</p>
</li>
<li class="lvl-2">
<p><strong>FamilyFilterr</strong> ：基于列族来过滤数据；</p>
</li>
<li class="lvl-2">
<p><strong>QualifierFilterr</strong> ：基于列限定符（列名）来过滤数据；</p>
</li>
<li class="lvl-2">
<p><strong>ValueFilterr</strong> ：基于单元格 (cell) 的值来过滤数据；</p>
</li>
<li class="lvl-2">
<p><strong>DependentColumnFilter</strong> ：指定一个参考列来过滤其他列的过滤器，过滤的原则是基于参考列的时间戳来进行筛选 。</p>
</li>
</ul>
<p>前四种过滤器的使用方法相同，均只要传递比较运算符和运算器实例即可构建，然后通过 <code>setFilter</code> 方法传递给 <code>scan</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Filter</span> <span class="variable">filter</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RowFilter</span>(CompareOperator.LESS_OR_EQUAL,</span><br><span class="line">                               <span class="keyword">new</span> <span class="title class_">BinaryComparator</span>(Bytes.toBytes(<span class="string">&quot;xxx&quot;</span>)));</span><br><span class="line"> scan.setFilter(filter);    </span><br></pre></td></tr></table></figure>
<p><code>DependentColumnFilter</code> 的使用稍微复杂一点，这里单独做下说明。</p>
<h3 id="3-4-DependentColumnFilter">3.4 DependentColumnFilter</h3>
<p>可以把 <code>DependentColumnFilter</code> 理解为<strong>一个 valueFilter 和一个时间戳过滤器的组合</strong>。<code>DependentColumnFilter</code> 有三个带参构造器，这里选择一个参数最全的进行说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DependentColumnFilter(<span class="keyword">final</span> <span class="type">byte</span> [] family, <span class="keyword">final</span> <span class="type">byte</span>[] qualifier,</span><br><span class="line">                               <span class="keyword">final</span> <span class="type">boolean</span> dropDependentColumn, <span class="keyword">final</span> CompareOperator op,</span><br><span class="line">                               <span class="keyword">final</span> ByteArrayComparable valueComparator)</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>family</strong>  ：列族</p>
</li>
<li class="lvl-2">
<p><strong>qualifier</strong> ：列限定符（列名）</p>
</li>
<li class="lvl-2">
<p><strong>dropDependentColumn</strong> ：决定参考列是否被包含在返回结果内，为 true 时表示参考列被返回，为 false 时表示被丢弃</p>
</li>
<li class="lvl-2">
<p><strong>op</strong> ：比较运算符</p>
</li>
<li class="lvl-2">
<p><strong>valueComparator</strong> ：比较器</p>
</li>
</ul>
<p>这里举例进行说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DependentColumnFilter</span> <span class="variable">dependentColumnFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependentColumnFilter</span>( </span><br><span class="line">    Bytes.toBytes(<span class="string">&quot;student&quot;</span>),</span><br><span class="line">    Bytes.toBytes(<span class="string">&quot;name&quot;</span>),</span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    CompareOperator.EQUAL, </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">BinaryPrefixComparator</span>(Bytes.toBytes(<span class="string">&quot;xiaolan&quot;</span>)));</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>首先会去查找 <code>student:name</code> 中值以 <code>xiaolan</code> 开头的所有数据获得 <code>参考数据集</code>，这一步等同于 valueFilter 过滤器；</p>
</li>
<li class="lvl-2">
<p>其次再用参考数据集中所有数据的时间戳去检索其他列，获得时间戳相同的其他列的数据作为 <code>结果数据集</code>，这一步等同于时间戳过滤器；</p>
</li>
<li class="lvl-2">
<p>最后如果 <code>dropDependentColumn</code> 为 true，则返回 <code>参考数据集</code>+<code>结果数据集</code>，若为 false，则抛弃参考数据集，只返回 <code>结果数据集</code>。</p>
</li>
</ul>
<h2 id="四、专用过滤器">四、专用过滤器</h2>
<p>专用过滤器通常直接继承自 <code>FilterBase</code>，适用于范围更小的筛选规则。</p>
<h3 id="4-1-单列列值过滤器-SingleColumnValueFilter">4.1 单列列值过滤器 (SingleColumnValueFilter)</h3>
<p>基于某列（参考列）的值决定某行数据是否被过滤。其实例有以下方法：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>setFilterIfMissing(boolean filterIfMissing)</strong> ：默认值为 false，即如果该行数据不包含参考列，其依然被包含在最后的结果中；设置为 true 时，则不包含；</p>
</li>
<li class="lvl-2">
<p><strong>setLatestVersionOnly(boolean latestVersionOnly)</strong> ：默认为 true，即只检索参考列的最新版本数据；设置为 false，则检索所有版本数据。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SingleColumnValueFilter singleColumnValueFilter = new SingleColumnValueFilter(</span><br><span class="line">                &quot;student&quot;.getBytes(), </span><br><span class="line">                &quot;name&quot;.getBytes(), </span><br><span class="line">                CompareOperator.EQUAL, </span><br><span class="line">                new SubstringComparator(&quot;xiaolan&quot;));</span><br><span class="line">singleColumnValueFilter.setFilterIfMissing(true);</span><br><span class="line">scan.setFilter(singleColumnValueFilter);</span><br></pre></td></tr></table></figure>
<h3 id="4-2-单列列值排除器-SingleColumnValueExcludeFilter">4.2 单列列值排除器 (SingleColumnValueExcludeFilter)</h3>
<p><code>SingleColumnValueExcludeFilter</code> 继承自上面的 <code>SingleColumnValueFilter</code>，过滤行为与其相反。</p>
<h3 id="4-3-行键前缀过滤器-PrefixFilter">4.3 行键前缀过滤器 (PrefixFilter)</h3>
<p>基于 RowKey 值决定某行数据是否被过滤。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PrefixFilter</span> <span class="variable">prefixFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrefixFilter</span>(Bytes.toBytes(<span class="string">&quot;xxx&quot;</span>));</span><br><span class="line">scan.setFilter(prefixFilter);</span><br></pre></td></tr></table></figure>
<h3 id="4-4-列名前缀过滤器-ColumnPrefixFilter">4.4 列名前缀过滤器 (ColumnPrefixFilter)</h3>
<p>基于列限定符（列名）决定某行数据是否被过滤。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ColumnPrefixFilter</span> <span class="variable">columnPrefixFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColumnPrefixFilter</span>(Bytes.toBytes(<span class="string">&quot;xxx&quot;</span>));</span><br><span class="line"> scan.setFilter(columnPrefixFilter);</span><br></pre></td></tr></table></figure>
<h3 id="4-5-分页过滤器-PageFilter">4.5 分页过滤器 (PageFilter)</h3>
<p>可以使用这个过滤器实现对结果按行进行分页，创建 PageFilter 实例的时候需要传入每页的行数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PageFilter</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> pageSize)</span> &#123;</span><br><span class="line">    Preconditions.checkArgument(pageSize &gt;= <span class="number">0</span>, <span class="string">&quot;must be positive %s&quot;</span>, pageSize);</span><br><span class="line">    <span class="built_in">this</span>.pageSize = pageSize;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>下面的代码体现了客户端实现分页查询的主要逻辑，这里对其进行一下解释说明：</p>
<p>客户端进行分页查询，需要传递 <code>startRow</code>(起始 RowKey)，知道起始 <code>startRow</code> 后，就可以返回对应的 pageSize 行数据。这里唯一的问题就是，对于第一次查询，显然 <code>startRow</code> 就是表格的第一行数据，但是之后第二次、第三次查询我们并不知道 <code>startRow</code>，只能知道上一次查询的最后一条数据的 RowKey（简单称之为 <code>lastRow</code>）。</p>
<p>我们不能将 <code>lastRow</code> 作为新一次查询的 <code>startRow</code> 传入，因为 scan 的查询区间是[startRow，endRow) ，即前开后闭区间，这样 <code>startRow</code> 在新的查询也会被返回，这条数据就重复了。</p>
<p>同时在不使用第三方数据库存储 RowKey 的情况下，我们是无法通过知道 <code>lastRow</code> 的下一个 RowKey 的，因为 RowKey 的设计可能是连续的也有可能是不连续的。</p>
<p>由于 Hbase 的 RowKey 是按照字典序进行排序的。这种情况下，就可以在 <code>lastRow</code> 后面加上 <code>0</code> ，作为 <code>startRow</code> 传入，因为按照字典序的规则，某个值加上 <code>0</code> 后的新值，在字典序上一定是这个值的下一个值，对于 HBase 来说下一个 RowKey 在字典序上一定也是等于或者大于这个新值的。</p>
<p>所以最后传入 <code>lastRow</code>+<code>0</code>，如果等于这个值的 RowKey 存在就从这个值开始 scan,否则从字典序的下一个 RowKey 开始 scan。</p>
<blockquote>
<p>25 个字母以及数字字符，字典排序如下:</p>
<p><code>'0' &lt; '1' &lt; '2' &lt; ... &lt; '9' &lt; 'a' &lt; 'b' &lt; ... &lt; 'z'</code></p>
</blockquote>
<p>分页查询主要实现逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] POSTFIX = <span class="keyword">new</span> <span class="title class_">byte</span>[] &#123; <span class="number">0x00</span> &#125;;</span><br><span class="line"><span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageFilter</span>(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">totalRows</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">byte</span>[] lastRow = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">Scan</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scan</span>();</span><br><span class="line">    scan.setFilter(filter);</span><br><span class="line">    <span class="keyword">if</span> (lastRow != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果不是首行 则 lastRow + 0</span></span><br><span class="line">        <span class="type">byte</span>[] startRow = Bytes.add(lastRow, POSTFIX);</span><br><span class="line">        System.out.println(<span class="string">&quot;start row: &quot;</span> +</span><br><span class="line">                           Bytes.toStringBinary(startRow));</span><br><span class="line">        scan.withStartRow(startRow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ResultScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> table.getScanner(scan);</span><br><span class="line">    <span class="type">int</span> <span class="variable">localRows</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Result result;</span><br><span class="line">    <span class="keyword">while</span> ((result = scanner.next()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(localRows++ + <span class="string">&quot;: &quot;</span> + result);</span><br><span class="line">        totalRows++;</span><br><span class="line">        lastRow = result.getRow();</span><br><span class="line">    &#125;</span><br><span class="line">    scanner.close();</span><br><span class="line">    <span class="comment">//最后一页，查询结束  </span></span><br><span class="line">    <span class="keyword">if</span> (localRows == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;total rows: &quot;</span> + totalRows);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是在多台 Regin Services 上执行分页过滤的时候，由于并行执行的过滤器不能共享它们的状态和边界，所以有可能每个过滤器都会在完成扫描前获取了 PageCount 行的结果，这种情况下会返回比分页条数更多的数据，分页过滤器就有失效的可能。</p>
</blockquote>
<h3 id="4-6-时间戳过滤器-TimestampsFilter">4.6 时间戳过滤器 (TimestampsFilter)</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Long&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1554975573000L</span>);</span><br><span class="line"><span class="type">TimestampsFilter</span> <span class="variable">timestampsFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimestampsFilter</span>(list);</span><br><span class="line">scan.setFilter(timestampsFilter);</span><br></pre></td></tr></table></figure>
<h3 id="4-7-首次行键过滤器-FirstKeyOnlyFilter">4.7 首次行键过滤器 (FirstKeyOnlyFilter)</h3>
<p><code>FirstKeyOnlyFilter</code> 只扫描每行的第一列，扫描完第一列后就结束对当前行的扫描，并跳转到下一行。相比于全表扫描，其性能更好，通常用于行数统计的场景，因为如果某一行存在，则行中必然至少有一列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FirstKeyOnlyFilter</span> <span class="variable">firstKeyOnlyFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FirstKeyOnlyFilter</span>();</span><br><span class="line">scan.set(firstKeyOnlyFilter);</span><br></pre></td></tr></table></figure>
<h2 id="五、包装过滤器">五、包装过滤器</h2>
<p>包装过滤器就是通过包装其他过滤器以实现某些拓展的功能。</p>
<h3 id="5-1-SkipFilter过滤器">5.1 SkipFilter过滤器</h3>
<p><code>SkipFilter</code> 包装一个过滤器，当被包装的过滤器遇到一个需要过滤的 KeyValue 实例时，则拓展过滤整行数据。下面是一个使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 ValueFilter 过滤器</span></span><br><span class="line"><span class="type">Filter</span> <span class="variable">filter1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ValueFilter</span>(CompareOperator.NOT_EQUAL,</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">BinaryComparator</span>(Bytes.toBytes(<span class="string">&quot;xxx&quot;</span>)));</span><br><span class="line"><span class="comment">// 使用 SkipFilter 进行包装</span></span><br><span class="line"><span class="type">Filter</span> <span class="variable">filter2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SkipFilter</span>(filter1);</span><br></pre></td></tr></table></figure>
<h3 id="5-2-WhileMatchFilter过滤器">5.2 WhileMatchFilter过滤器</h3>
<p><code>WhileMatchFilter</code> 包装一个过滤器，当被包装的过滤器遇到一个需要过滤的 KeyValue 实例时，<code>WhileMatchFilter</code> 则结束本次扫描，返回已经扫描到的结果。下面是其使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Filter</span> <span class="variable">filter1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RowFilter</span>(CompareOperator.NOT_EQUAL,</span><br><span class="line">                               <span class="keyword">new</span> <span class="title class_">BinaryComparator</span>(Bytes.toBytes(<span class="string">&quot;rowKey4&quot;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="type">Scan</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scan</span>();</span><br><span class="line">scan.setFilter(filter1);</span><br><span class="line"><span class="type">ResultScanner</span> <span class="variable">scanner1</span> <span class="operator">=</span> table.getScanner(scan);</span><br><span class="line"><span class="keyword">for</span> (Result result : scanner1) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Cell cell : result.listCells()) &#123;</span><br><span class="line">        System.out.println(cell);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">scanner1.close();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 WhileMatchFilter 进行包装</span></span><br><span class="line"><span class="type">Filter</span> <span class="variable">filter2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WhileMatchFilter</span>(filter1);</span><br><span class="line"></span><br><span class="line">scan.setFilter(filter2);</span><br><span class="line"><span class="type">ResultScanner</span> <span class="variable">scanner2</span> <span class="operator">=</span> table.getScanner(scan);</span><br><span class="line"><span class="keyword">for</span> (Result result : scanner1) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Cell cell : result.listCells()) &#123;</span><br><span class="line">        System.out.println(cell);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">scanner2.close();</span><br></pre></td></tr></table></figure>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">rowKey0/student</span>:<span class="string">name/1555035006994/Put/vlen=8/seqid=0</span></span><br><span class="line"><span class="attr">rowKey1/student</span>:<span class="string">name/1555035007019/Put/vlen=8/seqid=0</span></span><br><span class="line"><span class="attr">rowKey2/student</span>:<span class="string">name/1555035007025/Put/vlen=8/seqid=0</span></span><br><span class="line"><span class="attr">rowKey3/student</span>:<span class="string">name/1555035007037/Put/vlen=8/seqid=0</span></span><br><span class="line"><span class="attr">rowKey5/student</span>:<span class="string">name/1555035007051/Put/vlen=8/seqid=0</span></span><br><span class="line"><span class="attr">rowKey6/student</span>:<span class="string">name/1555035007057/Put/vlen=8/seqid=0</span></span><br><span class="line"><span class="attr">rowKey7/student</span>:<span class="string">name/1555035007062/Put/vlen=8/seqid=0</span></span><br><span class="line"><span class="attr">rowKey8/student</span>:<span class="string">name/1555035007068/Put/vlen=8/seqid=0</span></span><br><span class="line"><span class="attr">rowKey9/student</span>:<span class="string">name/1555035007073/Put/vlen=8/seqid=0</span></span><br><span class="line"><span class="attr">--------------------</span></span><br><span class="line"><span class="attr">rowKey0/student</span>:<span class="string">name/1555035006994/Put/vlen=8/seqid=0</span></span><br><span class="line"><span class="attr">rowKey1/student</span>:<span class="string">name/1555035007019/Put/vlen=8/seqid=0</span></span><br><span class="line"><span class="attr">rowKey2/student</span>:<span class="string">name/1555035007025/Put/vlen=8/seqid=0</span></span><br><span class="line"><span class="attr">rowKey3/student</span>:<span class="string">name/1555035007037/Put/vlen=8/seqid=0</span></span><br></pre></td></tr></table></figure>
<p>可以看到被包装后，只返回了 <code>rowKey4</code> 之前的数据。</p>
<h2 id="六、FilterList">六、FilterList</h2>
<p>以上都是讲解单个过滤器的作用，当需要多个过滤器共同作用于一次查询的时候，就需要使用 <code>FilterList</code>。<code>FilterList</code> 支持通过构造器或者 <code>addFilter</code> 方法传入多个过滤器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造器传入</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FilterList</span><span class="params">(<span class="keyword">final</span> Operator operator, <span class="keyword">final</span> List&lt;Filter&gt; filters)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FilterList</span><span class="params">(<span class="keyword">final</span> List&lt;Filter&gt; filters)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FilterList</span><span class="params">(<span class="keyword">final</span> Filter... filters)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法传入</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFilter</span><span class="params">(List&lt;Filter&gt; filters)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFilter</span><span class="params">(Filter filter)</span></span><br></pre></td></tr></table></figure>
<p>多个过滤器组合的结果由 <code>operator</code> 参数定义 ，其可选参数定义在 <code>Operator</code> 枚举类中。只有 <code>MUST_PASS_ALL</code> 和 <code>MUST_PASS_ONE</code> 两个可选的值：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>MUST_PASS_ALL</strong> ：相当于 AND，必须所有的过滤器都通过才认为通过；</p>
</li>
<li class="lvl-2">
<p><strong>MUST_PASS_ONE</strong> ：相当于 OR，只有要一个过滤器通过则认为通过。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@InterfaceAudience</span>.Public</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Operator</span> &#123;</span><br><span class="line">    <span class="comment">/** !AND */</span></span><br><span class="line">    MUST_PASS_ALL,</span><br><span class="line">    <span class="comment">/** !OR */</span></span><br><span class="line">    MUST_PASS_ONE</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>使用示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Filter&gt; filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Filter&gt;();</span><br><span class="line"></span><br><span class="line"><span class="type">Filter</span> <span class="variable">filter1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RowFilter</span>(CompareOperator.GREATER_OR_EQUAL,</span><br><span class="line">                               <span class="keyword">new</span> <span class="title class_">BinaryComparator</span>(Bytes.toBytes(<span class="string">&quot;XXX&quot;</span>)));</span><br><span class="line">filters.add(filter1);</span><br><span class="line"></span><br><span class="line"><span class="type">Filter</span> <span class="variable">filter2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RowFilter</span>(CompareOperator.LESS_OR_EQUAL,</span><br><span class="line">                               <span class="keyword">new</span> <span class="title class_">BinaryComparator</span>(Bytes.toBytes(<span class="string">&quot;YYY&quot;</span>)));</span><br><span class="line">filters.add(filter2);</span><br><span class="line"></span><br><span class="line"><span class="type">Filter</span> <span class="variable">filter3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QualifierFilter</span>(CompareOperator.EQUAL,</span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">RegexStringComparator</span>(<span class="string">&quot;ZZZ&quot;</span>));</span><br><span class="line">filters.add(filter3);</span><br><span class="line"></span><br><span class="line"><span class="type">FilterList</span> <span class="variable">filterList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterList</span>(filters);</span><br><span class="line"></span><br><span class="line"><span class="type">Scan</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scan</span>();</span><br><span class="line">scan.setFilter(filterList);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>hbase</category>
      </categories>
      <tags>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>Hbase集群搭建</title>
    <url>/posts/7527daf3.html</url>
    <content><![CDATA[<h2 id="一、集群规划-2">一、集群规划</h2>
<p>这里搭建一个 3 节点的 HBase 集群，其中三台主机上均为 <code>Regin Server</code>。同时为了保证高可用，除了在 hadoop001 上部署主 <code>Master</code> 服务外，还在 hadoop002 上部署备用的 <code>Master</code> 服务。Master 服务由 Zookeeper 集群进行协调管理，如果主 <code>Master</code> 不可用，则备用 <code>Master</code> 会成为新的主 <code>Master</code>。</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase集群规划.png"/> </div>
<h2 id="二、前置条件-2">二、前置条件</h2>
<p>HBase 的运行需要依赖 Hadoop 和 JDK(<code>HBase 2.0+</code> 对应 <code>JDK 1.8+</code>) 。同时为了保证高可用，这里我们不采用 HBase 内置的 Zookeeper 服务，而采用外置的 Zookeeper 集群。相关搭建步骤可以参阅：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://github.com/ihadyou/BigData-Notes/blob/master/notes/installation/Linux%E4%B8%8BJDK%E5%AE%89%E8%A3%85.md">Linux 环境下 JDK 安装</a></p>
</li>
<li class="lvl-2">
<p><a href="https://github.com/ihadyou/BigData-Notes/blob/master/notes/installation/Zookeeper%E5%8D%95%E6%9C%BA%E7%8E%AF%E5%A2%83%E5%92%8C%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md">Zookeeper 单机环境和集群环境搭建</a></p>
</li>
<li class="lvl-2">
<p><a href="https://github.com/ihadyou/BigData-Notes/blob/master/notes/installation/Hadoop%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md">Hadoop 集群环境搭建</a></p>
</li>
</ul>
<h2 id="三、集群搭建">三、集群搭建</h2>
<h3 id="3-1-下载并解压-3">3.1 下载并解压</h3>
<p>下载并解压，这里我下载的是 CDH 版本 HBase，下载地址为：<a href="http://archive.cloudera.com/cdh5/cdh/5/">http://archive.cloudera.com/cdh5/cdh/5/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">tar -zxvf hbase-1.2.0-cdh5.15.2.tar.gz</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-配置环境变量-3">3.2 配置环境变量</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">vim /etc/profile</span></span><br></pre></td></tr></table></figure>
<p>添加环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HBASE_HOME=usr/app/hbase-1.2.0-cdh5.15.2</span><br><span class="line">export PATH=$HBASE_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>使得配置的环境变量立即生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">source</span> /etc/profile</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-集群配置">3.3 集群配置</h3>
<p>进入 <code>$&#123;HBASE_HOME&#125;/conf</code> 目录下，修改配置：</p>
<h4 id="1-hbase-env-sh">1. <a href="http://hbase-env.sh">hbase-env.sh</a></h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">配置JDK安装位置</span></span><br><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_201</span><br><span class="line"><span class="meta"># </span><span class="language-bash">不使用内置的zookeeper服务</span></span><br><span class="line">export HBASE_MANAGES_ZK=false</span><br></pre></td></tr></table></figure>
<h4 id="2-hbase-site-xml">2. hbase-site.xml</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定 hbase 以分布式集群的方式运行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定 hbase 在 HDFS 上的存储位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop001:8020/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定 zookeeper 的地址--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop001:2181,hadoop002:2181,hadoop003:2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-regionservers">3. regionservers</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hadoop001</span><br><span class="line">hadoop002</span><br><span class="line">hadoop003</span><br></pre></td></tr></table></figure>
<h4 id="4-backup-masters">4. backup-masters</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hadoop002</span><br></pre></td></tr></table></figure>
<p><code> backup-masters</code> 这个文件是不存在的，需要新建，主要用来指明备用的 master 节点，可以是多个，这里我们以 1 个为例。</p>
<h3 id="3-4-HDFS客户端配置">3.4 HDFS客户端配置</h3>
<p>这里有一个可选的配置：如果您在 Hadoop 集群上进行了 HDFS 客户端配置的更改，比如将副本系数 <code>dfs.replication</code> 设置成 5，则必须使用以下方法之一来使 HBase 知道，否则 HBase 将依旧使用默认的副本系数 3 来创建文件：</p>
<blockquote>
<ol>
<li class="lvl-3">
<p>Add a pointer to your <code>HADOOP_CONF_DIR</code> to the <code>HBASE_CLASSPATH</code> environment variable in <em><a href="http://hbase-env.sh">hbase-env.sh</a></em>.</p>
</li>
<li class="lvl-3">
<p>Add a copy of <em>hdfs-site.xml</em> (or <em>hadoop-site.xml</em>) or, better, symlinks, under <em>${HBASE_HOME}/conf</em>, or</p>
</li>
<li class="lvl-3">
<p>if only a small set of HDFS client configurations, add them to <em>hbase-site.xml</em>.</p>
</li>
</ol>
</blockquote>
<p>以上是官方文档的说明，这里解释一下：</p>
<p><strong>第一种</strong> ：将 Hadoop 配置文件的位置信息添加到 <code>hbase-env.sh</code> 的 <code>HBASE_CLASSPATH</code> 属性，示例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HBASE_CLASSPATH=usr/app/hadoop-2.6.0-cdh5.15.2/etc/hadoop</span><br></pre></td></tr></table></figure>
<p><strong>第二种</strong> ：将 Hadoop 的 <code> hdfs-site.xml</code> 或 <code>hadoop-site.xml</code> 拷贝到  <code>$&#123;HBASE_HOME&#125;/conf </code> 目录下，或者通过符号链接的方式。如果采用这种方式的话，建议将两者都拷贝或建立符号链接，示例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">拷贝</span></span><br><span class="line">cp core-site.xml hdfs-site.xml /usr/app/hbase-1.2.0-cdh5.15.2/conf/</span><br><span class="line"><span class="meta"># </span><span class="language-bash">使用符号链接</span></span><br><span class="line">ln -s   /usr/app/hadoop-2.6.0-cdh5.15.2/etc/hadoop/core-site.xml</span><br><span class="line">ln -s   /usr/app/hadoop-2.6.0-cdh5.15.2/etc/hadoop/hdfs-site.xml</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：<code>hadoop-site.xml</code> 这个配置文件现在叫做 <code>core-site.xml</code></p>
</blockquote>
<p><strong>第三种</strong> ：如果你只有少量更改，那么直接配置到 <code>hbase-site.xml</code> 中即可。</p>
<h3 id="3-5-安装包分发">3.5 安装包分发</h3>
<p>将 HBase 的安装包分发到其他服务器，分发后建议在这两台服务器上也配置一下 HBase 的环境变量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -r /usr/app/hbase-1.2.0-cdh5.15.2/  hadoop002:usr/app/</span><br><span class="line">scp -r /usr/app/hbase-1.2.0-cdh5.15.2/  hadoop003:usr/app/</span><br></pre></td></tr></table></figure>
<h2 id="四、启动集群">四、启动集群</h2>
<h3 id="4-1-启动ZooKeeper集群">4.1 启动ZooKeeper集群</h3>
<p>分别到三台服务器上启动 ZooKeeper 服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zkServer.sh start</span><br></pre></td></tr></table></figure>
<h3 id="4-2-启动Hadoop集群">4.2 启动Hadoop集群</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">启动dfs服务</span></span><br><span class="line">start-dfs.sh</span><br><span class="line"><span class="meta"># </span><span class="language-bash">启动yarn服务</span></span><br><span class="line">start-yarn.sh</span><br></pre></td></tr></table></figure>
<h3 id="4-3-启动HBase集群">4.3 启动HBase集群</h3>
<p>进入 hadoop001 的 <code>$&#123;HBASE_HOME&#125;/bin</code>，使用以下命令启动 HBase 集群。执行此命令后，会在 hadoop001 上启动 <code>Master</code> 服务，在 hadoop002 上启动备用 <code>Master</code> 服务，在 <code>regionservers</code> 文件中配置的所有节点启动 <code>region server</code> 服务。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-hbase.sh</span><br></pre></td></tr></table></figure>
<h3 id="4-5-查看服务">4.5 查看服务</h3>
<p>访问 HBase 的 Web-UI 界面，这里我安装的 HBase 版本为 1.2，访问端口为 <code>60010</code>，如果你安装的是 2.0 以上的版本，则访问端口号为 <code>16010</code>。可以看到 <code>Master</code> 在 hadoop001 上，三个 <code>Regin Servers</code> 分别在 hadoop001，hadoop002，和 hadoop003 上，并且还有一个 <code>Backup Matser</code> 服务在 hadoop002 上。</p>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-集群搭建1.png"/> </div>
<br/>
<p>hadoop002 上的 HBase 出于备用状态：</p>
<br/>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/hbase-集群搭建2.png"/> </div>
<blockquote>
<p>原文：<a href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>hbase</category>
      </categories>
      <tags>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring整合Mybatis+Phoenix</title>
    <url>/posts/864324fe.html</url>
    <content><![CDATA[<h2 id="一、前言-2">一、前言</h2>
<p>使用 Spring+Mybatis 操作 Phoenix 和操作其他的关系型数据库（如 Mysql，Oracle）在配置上是基本相同的，下面会分别给出 Spring/Spring Boot 整合步骤，完整代码见本仓库：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://github.com/ihadyou/BigData-Notes/tree/master/code/Phoenix/spring-mybatis-phoenix">Spring + Mybatis + Phoenix</a></p>
</li>
<li class="lvl-2">
<p><a href="https://github.com/ihadyou/BigData-Notes/tree/master/code/Phoenix/spring-boot-mybatis-phoenix">SpringBoot + Mybatis + Phoenix</a></p>
</li>
</ul>
<h2 id="二、Spring-Mybatis-Phoenix">二、Spring + Mybatis + Phoenix</h2>
<h3 id="2-1-项目结构">2.1 项目结构</h3>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/spring-mybatis-phoenix.png"/> </div>
<h3 id="2-2-主要依赖">2.2 主要依赖</h3>
<p>除了 Spring 相关依赖外，还需要导入 <code>phoenix-core</code> 和对应的 Mybatis 依赖包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis 依赖包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--phoenix core--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.phoenix<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>phoenix-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.14.0-cdh5.14.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-数据库配置文件">2.3  数据库配置文件</h3>
<p>在数据库配置文件 <code>jdbc.properties</code>  中配置数据库驱动和 zookeeper 地址</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据库驱动</span></span><br><span class="line"><span class="attr">phoenix.driverClassName</span>=<span class="string">org.apache.phoenix.jdbc.PhoenixDriver</span></span><br><span class="line"><span class="comment"># zookeeper地址</span></span><br><span class="line"><span class="attr">phoenix.url</span>=<span class="string">jdbc:phoenix:192.168.0.105:2181</span></span><br></pre></td></tr></table></figure>
<h3 id="2-4-配置数据源和会话工厂">2.4  配置数据源和会话工厂</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启注解包扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ihadyou.*&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--指定配置文件的位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Phoenix 配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;phoenix.driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;phoenix.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置 mybatis 会话工厂 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定 mapper 文件所在的位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath*:/mappers/**/*.xml&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatisConfig.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--扫描注册接口 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--作用:从接口的基础包开始递归搜索，并将它们注册为 MapperFactoryBean(只有至少一种方法的接口才会被注册;, 具体类将被忽略)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定会话工厂 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定 mybatis 接口所在的包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.ihadyou.dao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-Mybtais参数配置">2.5 Mybtais参数配置</h3>
<p>新建 mybtais 配置文件，按照需求配置额外参数， 更多 settings 配置项可以参考<a href="http://www.mybatis.org/mybatis-3/zh/configuration.html">官方文档</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- mybatis 配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 开启驼峰命名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 打印查询 sql --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-6-查询接口">2.6 查询接口</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PopulationDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;USPopulation&gt; <span class="title function_">queryAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(USPopulation USPopulation)</span>;</span><br><span class="line"></span><br><span class="line">    USPopulation <span class="title function_">queryByStateAndCity</span><span class="params">(<span class="meta">@Param(&quot;state&quot;)</span> String state, <span class="meta">@Param(&quot;city&quot;)</span> String city)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteByStateAndCity</span><span class="params">(<span class="meta">@Param(&quot;state&quot;)</span> String state, <span class="meta">@Param(&quot;city&quot;)</span> String city)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.ihadyou.dao.PopulationDao&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.ihadyou.bean.USPopulation&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM us_population</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;save&quot;</span>&gt;</span></span><br><span class="line">        UPSERT INTO us_population VALUES( #&#123;state&#125;, #&#123;city&#125;, #&#123;population&#125; )</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryByStateAndCity&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.ihadyou.bean.USPopulation&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM us_population WHERE state=#&#123;state&#125; AND city = #&#123;city&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByStateAndCity&quot;</span>&gt;</span></span><br><span class="line">        DELETE FROM us_population WHERE state=#&#123;state&#125; AND city = #&#123;city&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-7-单元测试">2.7 单元测试</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&#123;&quot;classpath:springApplication.xml&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PopulationDaoTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PopulationDao populationDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryAll</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;USPopulation&gt; USPopulationList = populationDao.queryAll();</span><br><span class="line">        <span class="keyword">if</span> (USPopulationList != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (USPopulation USPopulation : USPopulationList) &#123;</span><br><span class="line">                System.out.println(USPopulation.getCity() + <span class="string">&quot; &quot;</span> + USPopulation.getPopulation());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        populationDao.save(<span class="keyword">new</span> <span class="title class_">USPopulation</span>(<span class="string">&quot;TX&quot;</span>, <span class="string">&quot;Dallas&quot;</span>, <span class="number">66666</span>));</span><br><span class="line">        <span class="type">USPopulation</span> <span class="variable">usPopulation</span> <span class="operator">=</span> populationDao.queryByStateAndCity(<span class="string">&quot;TX&quot;</span>, <span class="string">&quot;Dallas&quot;</span>);</span><br><span class="line">        System.out.println(usPopulation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        populationDao.save(<span class="keyword">new</span> <span class="title class_">USPopulation</span>(<span class="string">&quot;TX&quot;</span>, <span class="string">&quot;Dallas&quot;</span>, <span class="number">99999</span>));</span><br><span class="line">        <span class="type">USPopulation</span> <span class="variable">usPopulation</span> <span class="operator">=</span> populationDao.queryByStateAndCity(<span class="string">&quot;TX&quot;</span>, <span class="string">&quot;Dallas&quot;</span>);</span><br><span class="line">        System.out.println(usPopulation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        populationDao.deleteByStateAndCity(<span class="string">&quot;TX&quot;</span>, <span class="string">&quot;Dallas&quot;</span>);</span><br><span class="line">        <span class="type">USPopulation</span> <span class="variable">usPopulation</span> <span class="operator">=</span> populationDao.queryByStateAndCity(<span class="string">&quot;TX&quot;</span>, <span class="string">&quot;Dallas&quot;</span>);</span><br><span class="line">        System.out.println(usPopulation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、SpringBoot-Mybatis-Phoenix">三、SpringBoot + Mybatis + Phoenix</h2>
<h3 id="3-1-项目结构">3.1 项目结构</h3>
<div align="center"> <img  src="https://gitee.com/ihadyou/BigData-Notes/raw/master/pictures/spring-boot-mybatis-phoenix.png"/> </div>
<h3 id="3-2-主要依赖">3.2 主要依赖</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring 1.5 x 以上版本对应 mybatis 1.3.x (1.3.1)</span></span><br><span class="line"><span class="comment">        关于更多 spring-boot 与 mybatis 的版本对应可以参见 &lt;a href=&quot;http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/&quot;&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--phoenix core--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.phoenix<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>phoenix-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.14.0-cdh5.14.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>spring boot 与 mybatis 版本的对应关系：</p>
<table>
<thead>
<tr>
<th>MyBatis-Spring-Boot-Starter 版本</th>
<th>MyBatis-Spring 版本</th>
<th>Spring Boot 版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1.3.x (1.3.1)</strong></td>
<td>1.3 or higher</td>
<td>1.5 or higher</td>
</tr>
<tr>
<td><strong>1.2.x (1.2.1)</strong></td>
<td>1.3 or higher</td>
<td>1.4 or higher</td>
</tr>
<tr>
<td><strong>1.1.x (1.1.1)</strong></td>
<td>1.3 or higher</td>
<td>1.3 or higher</td>
</tr>
<tr>
<td><strong>1.0.x (1.0.2)</strong></td>
<td>1.2 or higher</td>
<td>1.3 or higher</td>
</tr>
</tbody>
</table>
<h3 id="3-3-配置数据源">3.3 配置数据源</h3>
<p>在 application.yml 中配置数据源，spring boot 2.x 版本默认采用 Hikari 作为数据库连接池，Hikari 是目前 java 平台性能最好的连接池，性能好于 druid。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment">#zookeeper 地址</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:phoenix:192.168.0.105:2181</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">org.apache.phoenix.jdbc.PhoenixDriver</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果不想配置对数据库连接池做特殊配置的话,以下关于连接池的配置就不是必须的</span></span><br><span class="line">    <span class="comment"># spring-boot 2.X 默认采用高性能的 Hikari 作为连接池 更多配置可以参考 https://github.com/brettwooldridge/HikariCP#configuration-knobs-baby</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="comment"># 池中维护的最小空闲连接数</span></span><br><span class="line">      <span class="attr">minimum-idle:</span> <span class="number">10</span></span><br><span class="line">      <span class="comment"># 池中最大连接数，包括闲置和使用中的连接</span></span><br><span class="line">      <span class="attr">maximum-pool-size:</span> <span class="number">20</span></span><br><span class="line">      <span class="comment"># 此属性控制从池返回的连接的默认自动提交行为。默认为 true</span></span><br><span class="line">      <span class="attr">auto-commit:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># 允许最长空闲时间</span></span><br><span class="line">      <span class="attr">idle-timeout:</span> <span class="number">30000</span></span><br><span class="line">      <span class="comment"># 此属性表示连接池的用户定义名称，主要显示在日志记录和 JMX 管理控制台中，以标识池和池配置。 默认值：自动生成</span></span><br><span class="line">      <span class="attr">pool-name:</span> <span class="string">custom-hikari</span></span><br><span class="line">      <span class="comment">#此属性控制池中连接的最长生命周期，值 0 表示无限生命周期，默认 1800000 即 30 分钟</span></span><br><span class="line">      <span class="attr">max-lifetime:</span> <span class="number">1800000</span></span><br><span class="line">      <span class="comment"># 数据库连接超时时间,默认 30 秒，即 30000</span></span><br><span class="line">      <span class="attr">connection-timeout:</span> <span class="number">30000</span></span><br><span class="line">      <span class="comment"># 连接测试 sql 这个地方需要根据数据库方言差异而配置 例如 oracle 就应该写成  select 1 from dual</span></span><br><span class="line">      <span class="attr">connection-test-query:</span> <span class="string">SELECT</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mybatis 相关配置</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment"># 是否打印 sql 语句 调试的时候可以开启</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4-新建查询接口">3.4 新建查询接口</h3>
<p>上面 Spring+Mybatis 我们使用了 XML 的方式来写 SQL，为了体现 Mybatis 支持多种方式，这里使用注解的方式来写 SQL。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PopulationDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * from us_population&quot;)</span></span><br><span class="line">    List&lt;USPopulation&gt; <span class="title function_">queryAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;UPSERT INTO us_population VALUES( #&#123;state&#125;, #&#123;city&#125;, #&#123;population&#125; )&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(USPopulation USPopulation)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM us_population WHERE state=#&#123;state&#125; AND city = #&#123;city&#125;&quot;)</span></span><br><span class="line">    USPopulation <span class="title function_">queryByStateAndCity</span><span class="params">(String state, String city)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete(&quot;DELETE FROM us_population WHERE state=#&#123;state&#125; AND city = #&#123;city&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteByStateAndCity</span><span class="params">(String state, String city)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-单元测试">3.5 单元测试</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PopulationTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PopulationDao populationDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryAll</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;USPopulation&gt; USPopulationList = populationDao.queryAll();</span><br><span class="line">        <span class="keyword">if</span> (USPopulationList != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (USPopulation USPopulation : USPopulationList) &#123;</span><br><span class="line">                System.out.println(USPopulation.getCity() + <span class="string">&quot; &quot;</span> + USPopulation.getPopulation());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        populationDao.save(<span class="keyword">new</span> <span class="title class_">USPopulation</span>(<span class="string">&quot;TX&quot;</span>, <span class="string">&quot;Dallas&quot;</span>, <span class="number">66666</span>));</span><br><span class="line">        <span class="type">USPopulation</span> <span class="variable">usPopulation</span> <span class="operator">=</span> populationDao.queryByStateAndCity(<span class="string">&quot;TX&quot;</span>, <span class="string">&quot;Dallas&quot;</span>);</span><br><span class="line">        System.out.println(usPopulation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        populationDao.save(<span class="keyword">new</span> <span class="title class_">USPopulation</span>(<span class="string">&quot;TX&quot;</span>, <span class="string">&quot;Dallas&quot;</span>, <span class="number">99999</span>));</span><br><span class="line">        <span class="type">USPopulation</span> <span class="variable">usPopulation</span> <span class="operator">=</span> populationDao.queryByStateAndCity(<span class="string">&quot;TX&quot;</span>, <span class="string">&quot;Dallas&quot;</span>);</span><br><span class="line">        System.out.println(usPopulation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        populationDao.deleteByStateAndCity(<span class="string">&quot;TX&quot;</span>, <span class="string">&quot;Dallas&quot;</span>);</span><br><span class="line">        <span class="type">USPopulation</span> <span class="variable">usPopulation</span> <span class="operator">=</span> populationDao.queryByStateAndCity(<span class="string">&quot;TX&quot;</span>, <span class="string">&quot;Dallas&quot;</span>);</span><br><span class="line">        System.out.println(usPopulation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="附：建表语句">附：建表语句</h2>
<p>上面单元测试涉及到的测试表的建表语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> us_population (</span><br><span class="line">      state <span class="type">CHAR</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">      city <span class="type">VARCHAR</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">      population <span class="type">BIGINT</span></span><br><span class="line">      <span class="keyword">CONSTRAINT</span> my_pk <span class="keyword">PRIMARY</span> KEY (state, city));</span><br><span class="line">      </span><br><span class="line"><span class="comment">-- 测试数据</span></span><br><span class="line">UPSERT <span class="keyword">INTO</span> us_population <span class="keyword">VALUES</span>(<span class="string">&#x27;NY&#x27;</span>,<span class="string">&#x27;New York&#x27;</span>,<span class="number">8143197</span>);</span><br><span class="line">UPSERT <span class="keyword">INTO</span> us_population <span class="keyword">VALUES</span>(<span class="string">&#x27;CA&#x27;</span>,<span class="string">&#x27;Los Angeles&#x27;</span>,<span class="number">3844829</span>);</span><br><span class="line">UPSERT <span class="keyword">INTO</span> us_population <span class="keyword">VALUES</span>(<span class="string">&#x27;IL&#x27;</span>,<span class="string">&#x27;Chicago&#x27;</span>,<span class="number">2842518</span>);</span><br><span class="line">UPSERT <span class="keyword">INTO</span> us_population <span class="keyword">VALUES</span>(<span class="string">&#x27;TX&#x27;</span>,<span class="string">&#x27;Houston&#x27;</span>,<span class="number">2016582</span>);</span><br><span class="line">UPSERT <span class="keyword">INTO</span> us_population <span class="keyword">VALUES</span>(<span class="string">&#x27;PA&#x27;</span>,<span class="string">&#x27;Philadelphia&#x27;</span>,<span class="number">1463281</span>);</span><br><span class="line">UPSERT <span class="keyword">INTO</span> us_population <span class="keyword">VALUES</span>(<span class="string">&#x27;AZ&#x27;</span>,<span class="string">&#x27;Phoenix&#x27;</span>,<span class="number">1461575</span>);</span><br><span class="line">UPSERT <span class="keyword">INTO</span> us_population <span class="keyword">VALUES</span>(<span class="string">&#x27;TX&#x27;</span>,<span class="string">&#x27;San Antonio&#x27;</span>,<span class="number">1256509</span>);</span><br><span class="line">UPSERT <span class="keyword">INTO</span> us_population <span class="keyword">VALUES</span>(<span class="string">&#x27;CA&#x27;</span>,<span class="string">&#x27;San Diego&#x27;</span>,<span class="number">1255540</span>);</span><br><span class="line">UPSERT <span class="keyword">INTO</span> us_population <span class="keyword">VALUES</span>(<span class="string">&#x27;CA&#x27;</span>,<span class="string">&#x27;San Jose&#x27;</span>,<span class="number">912332</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>hbase</category>
      </categories>
      <tags>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>hive CLI和Beeline命令行的基本使用</title>
    <url>/posts/d9ec48a1.html</url>
    <content><![CDATA[<h2 id="一、Hive-CLI">一、Hive CLI</h2>
<h3 id="1-1-Help">1.1 Help</h3>
<p>使用 <code>hive -H</code> 或者 <code>hive --help</code> 命令可以查看所有命令的帮助，显示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">usage: hive</span><br><span class="line"> -d,--define &lt;key=value&gt;          Variable subsitution to apply to hive </span><br><span class="line">                                  commands. e.g. -d A=B or --define A=B  --定义用户自定义变量</span><br><span class="line">    --database &lt;databasename&gt;     Specify the database to use  -- 指定使用的数据库</span><br><span class="line"> -e &lt;quoted-query-string&gt;         SQL from command line   -- 执行指定的 SQL</span><br><span class="line"> -f &lt;filename&gt;                    SQL from files   --执行 SQL 脚本</span><br><span class="line"> -H,--help                        Print help information  -- 打印帮助信息</span><br><span class="line">    --hiveconf &lt;property=value&gt;   Use value for given property    --自定义配置</span><br><span class="line">    --hivevar &lt;key=value&gt;         Variable subsitution to apply to hive  --自定义变量</span><br><span class="line">                                  commands. e.g. --hivevar A=B</span><br><span class="line"> -i &lt;filename&gt;                    Initialization SQL file  --在进入交互模式之前运行初始化脚本</span><br><span class="line"> -S,--silent                      Silent mode in interactive shell    --静默模式</span><br><span class="line"> -v,--verbose                     Verbose mode (echo executed SQL to the  console)  --详细模式</span><br></pre></td></tr></table></figure>
<h3 id="1-2-交互式命令行">1.2 交互式命令行</h3>
<p>直接使用 <code>Hive</code> 命令，不加任何参数，即可进入交互式命令行。</p>
<h3 id="1-3-执行SQL命令">1.3 执行SQL命令</h3>
<p>在不进入交互式命令行的情况下，可以使用 <code>hive -e </code> 执行 SQL 命令。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">hive <span class="operator">-</span>e <span class="string">&#x27;select * from emp&#x27;</span>;</span><br></pre></td></tr></table></figure>
<div align="center"> <img width='700px' src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-e.png"/> </div>
<h3 id="1-4-执行SQL脚本">1.4 执行SQL脚本</h3>
<p>用于执行的 sql 脚本可以在本地文件系统，也可以在 HDFS 上。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">本地文件系统</span></span><br><span class="line">hive -f /usr/file/simple.sql;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">HDFS文件系统</span></span><br><span class="line">hive -f hdfs://hadoop001:8020/tmp/simple.sql;</span><br></pre></td></tr></table></figure>
<p>其中 <code>simple.sql</code> 内容如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>
<h3 id="1-5-配置Hive变量">1.5 配置Hive变量</h3>
<p>可以使用 <code>--hiveconf</code> 设置 Hive 运行时的变量。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">hive <span class="operator">-</span>e <span class="string">&#x27;select * from emp&#x27;</span> \</span><br><span class="line"><span class="comment">--hiveconf hive.exec.scratchdir=/tmp/hive_scratch  \</span></span><br><span class="line"><span class="comment">--hiveconf mapred.reduce.tasks=4;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>hive.exec.scratchdir：指定 HDFS 上目录位置，用于存储不同 map/reduce 阶段的执行计划和这些阶段的中间输出结果。</p>
</blockquote>
<h3 id="1-6-配置文件启动">1.6 配置文件启动</h3>
<p>使用 <code>-i</code> 可以在进入交互模式之前运行初始化脚本，相当于指定配置文件启动。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hive -i /usr/file/hive-init.conf;</span><br></pre></td></tr></table></figure>
<p>其中 <code>hive-init.conf</code> 的内容如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.exec.mode.local.auto <span class="operator">=</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>hive.exec.mode.local.auto 默认值为 false，这里设置为 true ，代表开启本地模式。</p>
</blockquote>
<h3 id="1-7-用户自定义变量">1.7 用户自定义变量</h3>
<p><code>--define &lt;key=value&gt; </code> 和 <code>--hivevar &lt;key=value&gt;  </code> 在功能上是等价的，都是用来实现自定义变量，这里给出一个示例:</p>
<p>定义变量：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">hive  <span class="comment">--define  n=ename --hiveconf  --hivevar j=job;</span></span><br></pre></td></tr></table></figure>
<p>在查询中引用自定义变量：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 以下两条语句等价</span><br><span class="line">hive <span class="operator">&gt;</span> <span class="keyword">select</span> $&#123;n&#125; <span class="keyword">from</span> emp;</span><br><span class="line">hive <span class="operator">&gt;</span>  <span class="keyword">select</span> $&#123;hivevar:n&#125; <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"># 以下两条语句等价</span><br><span class="line">hive <span class="operator">&gt;</span> <span class="keyword">select</span> $&#123;j&#125; <span class="keyword">from</span> emp;</span><br><span class="line">hive <span class="operator">&gt;</span>  <span class="keyword">select</span> $&#123;hivevar:j&#125; <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<div align="center"> <img width='700px' src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-n-j.png"/> </div>
<h2 id="二、Beeline">二、Beeline</h2>
<h3 id="2-1-HiveServer2">2.1 HiveServer2</h3>
<p>Hive 内置了 HiveServer 和 HiveServer2 服务，两者都允许客户端使用多种编程语言进行连接，但是 HiveServer 不能处理多个客户端的并发请求，所以产生了 HiveServer2。</p>
<p>HiveServer2（HS2）允许远程客户端可以使用各种编程语言向 Hive 提交请求并检索结果，支持多客户端并发访问和身份验证。HS2 是由多个服务组成的单个进程，其包括基于 Thrift 的 Hive 服务（TCP 或 HTTP）和用于 Web UI 的 Jetty Web 服务器。</p>
<p>HiveServer2 拥有自己的 CLI(Beeline)，Beeline 是一个基于 SQLLine 的 JDBC 客户端。由于 HiveServer2 是 Hive 开发维护的重点 (Hive0.15 后就不再支持 hiveserver)，所以 Hive CLI 已经不推荐使用了，官方更加推荐使用 Beeline。</p>
<h3 id="2-1-Beeline">2.1 Beeline</h3>
<p>Beeline 拥有更多可使用参数，可以使用 <code>beeline --help</code> 查看，完整参数如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">Usage</span>: <span class="string">java org.apache.hive.cli.beeline.BeeLine</span></span><br><span class="line">   <span class="attr">-u</span> <span class="string">&lt;database url&gt;               the JDBC URL to connect to</span></span><br><span class="line">   <span class="attr">-r</span>                              <span class="string">reconnect to last saved connect url (in conjunction with !save)</span></span><br><span class="line">   <span class="attr">-n</span> <span class="string">&lt;username&gt;                   the username to connect as</span></span><br><span class="line">   <span class="attr">-p</span> <span class="string">&lt;password&gt;                   the password to connect as</span></span><br><span class="line">   <span class="attr">-d</span> <span class="string">&lt;driver class&gt;               the driver class to use</span></span><br><span class="line">   <span class="attr">-i</span> <span class="string">&lt;init file&gt;                  script file for initialization</span></span><br><span class="line">   <span class="attr">-e</span> <span class="string">&lt;query&gt;                      query that should be executed</span></span><br><span class="line">   <span class="attr">-f</span> <span class="string">&lt;exec file&gt;                  script file that should be executed</span></span><br><span class="line">   <span class="attr">-w</span> <span class="string">(or) --password-file &lt;password file&gt;  the password file to read password from</span></span><br><span class="line">   <span class="attr">--hiveconf</span> <span class="string">property=value       Use value for given property</span></span><br><span class="line">   <span class="attr">--hivevar</span> <span class="string">name=value            hive variable name and value</span></span><br><span class="line">                                   <span class="attr">This</span> <span class="string">is Hive specific settings in which variables</span></span><br><span class="line">                                   <span class="attr">can</span> <span class="string">be set at session level and referenced in Hive</span></span><br><span class="line">                                   <span class="attr">commands</span> <span class="string">or queries.</span></span><br><span class="line">   <span class="attr">--property-file</span>=<span class="string">&lt;property-file&gt; the file to read connection properties (url, driver, user, password) from</span></span><br><span class="line">   <span class="attr">--color</span>=<span class="string">[true/false]            control whether color is used for display</span></span><br><span class="line">   <span class="attr">--showHeader</span>=<span class="string">[true/false]       show column names in query results</span></span><br><span class="line">   <span class="attr">--headerInterval</span>=<span class="string">ROWS;          the interval between which heades are displayed</span></span><br><span class="line">   <span class="attr">--fastConnect</span>=<span class="string">[true/false]      skip building table/column list for tab-completion</span></span><br><span class="line">   <span class="attr">--autoCommit</span>=<span class="string">[true/false]       enable/disable automatic transaction commit</span></span><br><span class="line">   <span class="attr">--verbose</span>=<span class="string">[true/false]          show verbose error messages and debug info</span></span><br><span class="line">   <span class="attr">--showWarnings</span>=<span class="string">[true/false]     display connection warnings</span></span><br><span class="line">   <span class="attr">--showNestedErrs</span>=<span class="string">[true/false]   display nested errors</span></span><br><span class="line">   <span class="attr">--numberFormat</span>=<span class="string">[pattern]        format numbers using DecimalFormat pattern</span></span><br><span class="line">   <span class="attr">--force</span>=<span class="string">[true/false]            continue running script even after errors</span></span><br><span class="line">   <span class="attr">--maxWidth</span>=<span class="string">MAXWIDTH             the maximum width of the terminal</span></span><br><span class="line">   <span class="attr">--maxColumnWidth</span>=<span class="string">MAXCOLWIDTH    the maximum width to use when displaying columns</span></span><br><span class="line">   <span class="attr">--silent</span>=<span class="string">[true/false]           be more silent</span></span><br><span class="line">   <span class="attr">--autosave</span>=<span class="string">[true/false]         automatically save preferences</span></span><br><span class="line">   <span class="attr">--outputformat</span>=<span class="string">[table/vertical/csv2/tsv2/dsv/csv/tsv]  format mode for result display</span></span><br><span class="line">   <span class="attr">--incrementalBufferRows</span>=<span class="string">NUMROWS the number of rows to buffer when printing rows on stdout,</span></span><br><span class="line">                                   <span class="attr">defaults</span> <span class="string">to 1000; only applicable if --incremental=true</span></span><br><span class="line">                                   <span class="attr">and</span> <span class="string">--outputformat=table</span></span><br><span class="line">   <span class="attr">--truncateTable</span>=<span class="string">[true/false]    truncate table column when it exceeds length</span></span><br><span class="line">   <span class="attr">--delimiterForDSV</span>=<span class="string">DELIMITER     specify the delimiter for delimiter-separated values output format (default: |)</span></span><br><span class="line">   <span class="attr">--isolation</span>=<span class="string">LEVEL               set the transaction isolation level</span></span><br><span class="line">   <span class="attr">--nullemptystring</span>=<span class="string">[true/false]  set to true to get historic behavior of printing null as empty string</span></span><br><span class="line">   <span class="attr">--maxHistoryRows</span>=<span class="string">MAXHISTORYROWS The maximum number of rows to store beeline history.</span></span><br><span class="line">   <span class="attr">--convertBinaryArrayToString</span>=<span class="string">[true/false]    display binary column data as string or as byte array</span></span><br><span class="line">   <span class="attr">--help</span>                          <span class="string">display this message</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-3-常用参数">2.3 常用参数</h3>
<p>在 Hive CLI 中支持的参数，Beeline 都支持，常用的参数如下。更多参数说明可以参见官方文档 <a href="https://cwiki.apache.org/confluence/display/Hive/HiveServer2+Clients#HiveServer2Clients-Beeline%E2%80%93NewCommandLineShell">Beeline Command Options</a></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>-u &lt;database URL&gt;</strong></td>
<td>数据库地址</td>
</tr>
<tr>
<td><strong>-n &lt;username&gt;</strong></td>
<td>用户名</td>
</tr>
<tr>
<td><strong>-p &lt;password&gt;</strong></td>
<td>密码</td>
</tr>
<tr>
<td><strong>-d &lt;driver class&gt;</strong></td>
<td>驱动 (可选)</td>
</tr>
<tr>
<td><strong>-e &lt;query&gt;</strong></td>
<td>执行 SQL 命令</td>
</tr>
<tr>
<td><strong>-f &lt;file&gt;</strong></td>
<td>执行 SQL 脚本</td>
</tr>
<tr>
<td><strong>-i  (or)–init  &lt;file or files&gt;</strong></td>
<td>在进入交互模式之前运行初始化脚本</td>
</tr>
<tr>
<td><strong>–property-file &lt;file&gt;</strong></td>
<td>指定配置文件</td>
</tr>
<tr>
<td><strong>–hiveconf</strong> <em>property</em>*=*<em>value</em></td>
<td>指定配置属性</td>
</tr>
<tr>
<td><strong>–hivevar</strong> <em>name</em>*=*<em>value</em></td>
<td>用户自定义属性，在会话级别有效</td>
</tr>
</tbody>
</table>
<p>示例： 使用用户名和密码连接 Hive</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">beeline -u jdbc:hive2://localhost:10000  -n username -p password</span> </span><br></pre></td></tr></table></figure>
<p>​</p>
<h2 id="三、Hive配置">三、Hive配置</h2>
<p>可以通过三种方式对 Hive 的相关属性进行配置，分别介绍如下：</p>
<h3 id="3-1-配置文件">3.1 配置文件</h3>
<p>方式一为使用配置文件，使用配置文件指定的配置是永久有效的。Hive 有以下三个可选的配置文件：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>hive-site.xml ：Hive 的主要配置文件；</p>
</li>
<li class="lvl-2">
<p>hivemetastore-site.xml： 关于元数据的配置；</p>
</li>
<li class="lvl-2">
<p>hiveserver2-site.xml：关于 HiveServer2 的配置。</p>
</li>
</ul>
<p>示例如下,在 hive-site.xml 配置 <code>hive.exec.scratchdir</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.exec.scratchdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">value</span>&gt;</span>/tmp/mydir<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">description</span>&gt;</span>Scratch space for Hive jobs<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-hiveconf">3.2 hiveconf</h3>
<p>方式二为在启动命令行 (Hive CLI / Beeline) 的时候使用 <code>--hiveconf</code> 指定配置，这种方式指定的配置作用于整个 Session。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive --hiveconf hive.exec.scratchdir=/tmp/mydir</span><br></pre></td></tr></table></figure>
<h3 id="3-3-set">3.3 set</h3>
<p>方式三为在交互式环境下 (Hive CLI / Beeline)，使用 set 命令指定。这种设置的作用范围也是 Session 级别的，配置对于执行该命令后的所有命令生效。set 兼具设置参数和查看参数的功能。如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0: jdbc:hive2://hadoop001:10000&gt; set hive.exec.scratchdir=/tmp/mydir;</span><br><span class="line">No rows affected (0.025 seconds)</span><br><span class="line">0: jdbc:hive2://hadoop001:10000&gt; set hive.exec.scratchdir;</span><br><span class="line">+----------------------------------+--+</span><br><span class="line">|               set                |</span><br><span class="line">+----------------------------------+--+</span><br><span class="line">| hive.exec.scratchdir=/tmp/mydir  |</span><br><span class="line">+----------------------------------+--+</span><br></pre></td></tr></table></figure>
<h3 id="3-4-配置优先级">3.4 配置优先级</h3>
<p>配置的优先顺序如下 (由低到高)：<br>
<code>hive-site.xml</code> - &gt;<code>hivemetastore-site.xml</code>- &gt; <code>hiveserver2-site.xml</code> - &gt;<code> -- hiveconf</code>- &gt; <code>set</code></p>
<h3 id="3-5-配置参数">3.5 配置参数</h3>
<p>Hive 可选的配置参数非常多，在用到时查阅官方文档即可<a href="https://cwiki.apache.org/confluence/display/Hive/AdminManual+Configuration">AdminManual Configuration</a></p>
<blockquote>
<p>原文：<a href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>hive</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive分区表和分桶表</title>
    <url>/posts/7393af63.html</url>
    <content><![CDATA[<h2 id="一、分区表">一、分区表</h2>
<h3 id="1-1-概念">1.1 概念</h3>
<p>Hive 中的表对应为 HDFS 上的指定目录，在查询数据时候，默认会对全表进行扫描，这样时间和性能的消耗都非常大。</p>
<p><strong>分区为 HDFS 上表目录的子目录</strong>，数据按照分区存储在子目录中。如果查询的 <code>where</code> 字句的中包含分区条件，则直接从该分区去查找，而不是扫描整个表目录，合理的分区设计可以极大提高查询速度和性能。</p>
<blockquote>
<p>这里说明一下分区表并 Hive 独有的概念，实际上这个概念非常常见。比如在我们常用的 Oracle 数据库中，当表中的数据量不断增大，查询数据的速度就会下降，这时也可以对表进行分区。表进行分区后，逻辑上表仍然是一张完整的表，只是将表中的数据存放到多个表空间（物理文件上），这样查询数据时，就不必要每次都扫描整张表，从而提升查询性能。</p>
</blockquote>
<h3 id="1-2-使用场景">1.2  使用场景</h3>
<p>通常，在管理大规模数据集的时候都需要进行分区，比如将日志文件按天进行分区，从而保证数据细粒度的划分，使得查询性能得到提升。</p>
<h3 id="1-3-创建分区表">1.3 创建分区表</h3>
<p>在 Hive 中可以使用 <code>PARTITIONED BY</code> 子句创建分区表。表可以包含一个或多个分区列，程序会为分区列中的每个不同值组合创建单独的数据目录。下面的我们创建一张雇员表作为测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CREATE EXTERNAL TABLE emp_partition(</span><br><span class="line">   empno INT,</span><br><span class="line">   ename STRING,</span><br><span class="line">   job STRING,</span><br><span class="line">   mgr INT,</span><br><span class="line">   hiredate TIMESTAMP,</span><br><span class="line">   sal DECIMAL(7,2),</span><br><span class="line">   comm DECIMAL(7,2)</span><br><span class="line">   )</span><br><span class="line">   PARTITIONED BY (deptno INT)   -- 按照部门编号进行分区</span><br><span class="line">   ROW FORMAT DELIMITED FIELDS TERMINATED BY &quot;\t&quot;</span><br><span class="line">   LOCATION &#x27;/hive/emp_partition&#x27;;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-加载数据到分区表">1.4 加载数据到分区表</h3>
<p>加载数据到分区表时候必须要指定数据所处的分区：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">加载部门编号为20的数据到表中</span></span><br><span class="line">LOAD DATA LOCAL INPATH &quot;/usr/file/emp20.txt&quot; OVERWRITE INTO TABLE emp_partition PARTITION (deptno=20)</span><br><span class="line"><span class="meta"># </span><span class="language-bash">加载部门编号为30的数据到表中</span></span><br><span class="line">LOAD DATA LOCAL INPATH &quot;/usr/file/emp30.txt&quot; OVERWRITE INTO TABLE emp_partition PARTITION (deptno=30)</span><br></pre></td></tr></table></figure>
<h3 id="1-5-查看分区目录">1.5 查看分区目录</h3>
<p>这时候我们直接查看表目录，可以看到表目录下存在两个子目录，分别是 <code>deptno=20</code> 和 <code>deptno=30</code>,这就是分区目录，分区目录下才是我们加载的数据文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">hadoop fs -<span class="built_in">ls</span>  hdfs://hadoop001:8020/hive/emp_partition/</span></span><br></pre></td></tr></table></figure>
<p>这时候当你的查询语句的 <code>where</code> 包含 <code>deptno=20</code>，则就去对应的分区目录下进行查找，而不用扫描全表。</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-hadoop-partitation.png"/> </div>
<h2 id="二、分桶表">二、分桶表</h2>
<h3 id="1-1-简介">1.1 简介</h3>
<p>分区提供了一个隔离数据和优化查询的可行方案，但是并非所有的数据集都可以形成合理的分区，分区的数量也不是越多越好，过多的分区条件可能会导致很多分区上没有数据。同时 Hive 会限制动态分区可以创建的最大分区数，用来避免过多分区文件对文件系统产生负担。鉴于以上原因，Hive 还提供了一种更加细粒度的数据拆分方案：分桶表 (bucket Table)。</p>
<p>分桶表会将指定列的值进行哈希散列，并对 bucket（桶数量）取余，然后存储到对应的 bucket（桶）中。</p>
<h3 id="1-2-理解分桶表">1.2 理解分桶表</h3>
<p>单从概念上理解分桶表可能会比较晦涩，其实和分区一样，分桶这个概念同样不是 Hive 独有的，对于 Java 开发人员而言，这可能是一个每天都会用到的概念，因为 Hive 中的分桶概念和 Java 数据结构中的 HashMap 的分桶概念是一致的。</p>
<p>当调用 HashMap 的 put() 方法存储数据时，程序会先对 key 值调用 hashCode() 方法计算出 hashcode，然后对数组长度取模计算出 index，最后将数据存储在数组 index 位置的链表上，链表达到一定阈值后会转换为红黑树 (JDK1.8+)。下图为 HashMap 的数据结构图：</p>
<div align="center"> <img width="600px"  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/HashMap-HashTable.png"/> </div>
<blockquote>
<p>图片引用自：<a href="http://www.itcuties.com/java/hashmap-hashtable/">HashMap vs. Hashtable</a></p>
</blockquote>
<h3 id="1-3-创建分桶表">1.3 创建分桶表</h3>
<p>在 Hive 中，我们可以通过 <code>CLUSTERED BY</code> 指定分桶列，并通过 <code>SORTED BY</code> 指定桶中数据的排序参考列。下面为分桶表建表语句示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> emp_bucket(</span><br><span class="line">  empno <span class="type">INT</span>,</span><br><span class="line">  ename STRING,</span><br><span class="line">  job STRING,</span><br><span class="line">  mgr <span class="type">INT</span>,</span><br><span class="line">  hiredate <span class="type">TIMESTAMP</span>,</span><br><span class="line">  sal <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">  comm <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">  deptno <span class="type">INT</span>)</span><br><span class="line">  CLUSTERED <span class="keyword">BY</span>(empno) SORTED <span class="keyword">BY</span>(empno <span class="keyword">ASC</span>) <span class="keyword">INTO</span> <span class="number">4</span> BUCKETS  <span class="comment">--按照员工编号散列到四个 bucket 中</span></span><br><span class="line">  <span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> &quot;\t&quot;</span><br><span class="line">  LOCATION <span class="string">&#x27;/hive/emp_bucket&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-加载数据到分桶表">1.4 加载数据到分桶表</h3>
<p>这里直接使用 <code>Load</code> 语句向分桶表加载数据，数据时可以加载成功的，但是数据并不会分桶。</p>
<p>这是由于分桶的实质是对指定字段做了 hash 散列然后存放到对应文件中，这意味着向分桶表中插入数据是必然要通过 MapReduce，且 Reducer 的数量必须等于分桶的数量。由于以上原因，分桶表的数据通常只能使用 CTAS(CREATE TABLE AS SELECT) 方式插入，因为 CTAS 操作会触发 MapReduce。加载数据步骤如下：</p>
<h4 id="1-设置强制分桶">1. 设置强制分桶</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.enforce.bucketing <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">--Hive 2.x 不需要这一步</span></span><br></pre></td></tr></table></figure>
<p>在 Hive 0.x and 1.x 版本，必须使用设置 <code>hive.enforce.bucketing = true</code>，表示强制分桶，允许程序根据表结构自动选择正确数量的 Reducer 和 cluster by  column 来进行分桶。</p>
<h4 id="2-CTAS导入数据">2. CTAS导入数据</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> emp_bucket <span class="keyword">SELECT</span> <span class="operator">*</span>  <span class="keyword">FROM</span> emp;  <span class="comment">--这里的 emp 表就是一张普通的雇员表</span></span><br></pre></td></tr></table></figure>
<p>可以从执行日志看到 CTAS 触发 MapReduce 操作，且 Reducer 数量和建表时候指定 bucket 数量一致：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-hadoop-mapreducer.png"/> </div>
<h3 id="1-5-查看分桶文件">1.5 查看分桶文件</h3>
<p>bucket(桶) 本质上就是表目录下的具体文件：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-hadoop-bucket.png"/> </div>
<h2 id="三、分区表和分桶表结合使用">三、分区表和分桶表结合使用</h2>
<p>分区表和分桶表的本质都是将数据按照不同粒度进行拆分，从而使得在查询时候不必扫描全表，只需要扫描对应的分区或分桶，从而提升查询效率。两者可以结合起来使用，从而保证表数据在不同粒度上都能得到合理的拆分。下面是 Hive 官方给出的示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> page_view_bucketed(</span><br><span class="line">	viewTime <span class="type">INT</span>, </span><br><span class="line">    userid <span class="type">BIGINT</span>,</span><br><span class="line">    page_url STRING, </span><br><span class="line">    referrer_url STRING,</span><br><span class="line">    ip STRING )</span><br><span class="line"> PARTITIONED <span class="keyword">BY</span>(dt STRING)</span><br><span class="line"> CLUSTERED <span class="keyword">BY</span>(userid) SORTED <span class="keyword">BY</span>(viewTime) <span class="keyword">INTO</span> <span class="number">32</span> BUCKETS</span><br><span class="line"> <span class="type">ROW</span> FORMAT DELIMITED</span><br><span class="line">   FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\001&#x27;</span></span><br><span class="line">   COLLECTION ITEMS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\002&#x27;</span></span><br><span class="line">   MAP KEYS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\003&#x27;</span></span><br><span class="line"> STORED <span class="keyword">AS</span> SEQUENCEFILE;</span><br></pre></td></tr></table></figure>
<p>此时导入数据时需要指定分区：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">INSERT OVERWRITE page_view_bucketed</span><br><span class="line">PARTITION (dt=&#x27;2009-02-25&#x27;)</span><br><span class="line">SELECT * FROM page_view WHERE dt=&#x27;2009-02-25&#x27;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>hive</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive常用DDL操作</title>
    <url>/posts/d5dc7ba9.html</url>
    <content><![CDATA[<h2 id="一、Database">一、Database</h2>
<h3 id="1-1-查看数据列表">1.1 查看数据列表</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br></pre></td></tr></table></figure>
<div align="center"> <img width='700px' src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-show-database.png"/> </div>
<h3 id="1-2-使用数据库">1.2 使用数据库</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE database_name;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-新建数据库">1.3 新建数据库</h3>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> (DATABASE<span class="operator">|</span>SCHEMA) [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] database_name   <span class="comment">--DATABASE|SCHEMA 是等价的</span></span><br><span class="line">  [COMMENT database_comment] <span class="comment">--数据库注释</span></span><br><span class="line">  [LOCATION hdfs_path] <span class="comment">--存储在 HDFS 上的位置</span></span><br><span class="line">  [<span class="keyword">WITH</span> DBPROPERTIES (property_name<span class="operator">=</span>property_value, ...)]; <span class="comment">--指定额外属性</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> hive_test</span><br><span class="line">  COMMENT <span class="string">&#x27;hive database for test&#x27;</span></span><br><span class="line">  <span class="keyword">WITH</span> DBPROPERTIES (<span class="string">&#x27;create&#x27;</span><span class="operator">=</span><span class="string">&#x27;oicio&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="1-4-查看数据库信息">1.4 查看数据库信息</h3>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESC</span> DATABASE [EXTENDED] db_name; <span class="comment">--EXTENDED 表示是否显示额外属性</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESC</span> DATABASE  EXTENDED hive_test;</span><br></pre></td></tr></table></figure>
<h3 id="1-5-删除数据库">1.5 删除数据库</h3>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> (DATABASE<span class="operator">|</span>SCHEMA) [IF <span class="keyword">EXISTS</span>] database_name [RESTRICT<span class="operator">|</span>CASCADE];</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>默认行为是 RESTRICT，如果数据库中存在表则删除失败。要想删除库及其中的表，可以使用 CASCADE 级联删除。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> hive_test CASCADE;</span><br></pre></td></tr></table></figure>
<h2 id="二、创建表">二、创建表</h2>
<h3 id="2-1-建表语法">2.1 建表语法</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [TEMPORARY] [<span class="keyword">EXTERNAL</span>] <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [db_name.]table_name     <span class="comment">--表名</span></span><br><span class="line">  [(col_name data_type [COMMENT col_comment],</span><br><span class="line">    ... [constraint_specification])]  <span class="comment">--列名 列数据类型</span></span><br><span class="line">  [COMMENT table_comment]   <span class="comment">--表描述</span></span><br><span class="line">  [PARTITIONED <span class="keyword">BY</span> (col_name data_type [COMMENT col_comment], ...)]  <span class="comment">--分区表分区规则</span></span><br><span class="line">  [</span><br><span class="line">    CLUSTERED <span class="keyword">BY</span> (col_name, col_name, ...) </span><br><span class="line">   [SORTED <span class="keyword">BY</span> (col_name [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], ...)] <span class="keyword">INTO</span> num_buckets BUCKETS</span><br><span class="line">  ]  <span class="comment">--分桶表分桶规则</span></span><br><span class="line">  [SKEWED <span class="keyword">BY</span> (col_name, col_name, ...) <span class="keyword">ON</span> ((col_value, col_value, ...), (col_value, col_value, ...), ...)  </span><br><span class="line">   [STORED <span class="keyword">AS</span> DIRECTORIES] </span><br><span class="line">  ]  <span class="comment">--指定倾斜列和值</span></span><br><span class="line">  [</span><br><span class="line">   [<span class="type">ROW</span> FORMAT row_format]    </span><br><span class="line">   [STORED <span class="keyword">AS</span> file_format]</span><br><span class="line">     <span class="operator">|</span> STORED <span class="keyword">BY</span> <span class="string">&#x27;storage.handler.class.name&#x27;</span> [<span class="keyword">WITH</span> SERDEPROPERTIES (...)]  </span><br><span class="line">  ]  <span class="comment">-- 指定行分隔符、存储文件格式或采用自定义存储格式</span></span><br><span class="line">  [LOCATION hdfs_path]  <span class="comment">-- 指定表的存储位置</span></span><br><span class="line">  [TBLPROPERTIES (property_name<span class="operator">=</span>property_value, ...)]  <span class="comment">--指定表的属性</span></span><br><span class="line">  [<span class="keyword">AS</span> select_statement];   <span class="comment">--从查询结果创建表</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-内部表">2.2 内部表</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">  empno <span class="type">INT</span>,</span><br><span class="line">  ename STRING,</span><br><span class="line">  job STRING,</span><br><span class="line">  mgr <span class="type">INT</span>,</span><br><span class="line">  hiredate <span class="type">TIMESTAMP</span>,</span><br><span class="line">  sal <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">  comm <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">  deptno <span class="type">INT</span>)</span><br><span class="line">  <span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> &quot;\t&quot;;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-外部表">2.3 外部表</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> emp_external(</span><br><span class="line">  empno <span class="type">INT</span>,</span><br><span class="line">  ename STRING,</span><br><span class="line">  job STRING,</span><br><span class="line">  mgr <span class="type">INT</span>,</span><br><span class="line">  hiredate <span class="type">TIMESTAMP</span>,</span><br><span class="line">  sal <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">  comm <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">  deptno <span class="type">INT</span>)</span><br><span class="line">  <span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> &quot;\t&quot;</span><br><span class="line">  LOCATION <span class="string">&#x27;/hive/emp_external&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>使用 <code>desc format  emp_external</code> 命令可以查看表的详细信息如下：</p>
<div align="center"> <img width='700px' src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-external-table.png"/> </div>
<h3 id="2-4-分区表">2.4 分区表</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> emp_partition(</span><br><span class="line">  empno <span class="type">INT</span>,</span><br><span class="line">  ename STRING,</span><br><span class="line">  job STRING,</span><br><span class="line">  mgr <span class="type">INT</span>,</span><br><span class="line">  hiredate <span class="type">TIMESTAMP</span>,</span><br><span class="line">  sal <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">  comm <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line">  )</span><br><span class="line">  PARTITIONED <span class="keyword">BY</span> (deptno <span class="type">INT</span>)   <span class="comment">-- 按照部门编号进行分区</span></span><br><span class="line">  <span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> &quot;\t&quot;</span><br><span class="line">  LOCATION <span class="string">&#x27;/hive/emp_partition&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-分桶表">2.5 分桶表</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> emp_bucket(</span><br><span class="line">  empno <span class="type">INT</span>,</span><br><span class="line">  ename STRING,</span><br><span class="line">  job STRING,</span><br><span class="line">  mgr <span class="type">INT</span>,</span><br><span class="line">  hiredate <span class="type">TIMESTAMP</span>,</span><br><span class="line">  sal <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">  comm <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">  deptno <span class="type">INT</span>)</span><br><span class="line">  CLUSTERED <span class="keyword">BY</span>(empno) SORTED <span class="keyword">BY</span>(empno <span class="keyword">ASC</span>) <span class="keyword">INTO</span> <span class="number">4</span> BUCKETS  <span class="comment">--按照员工编号散列到四个 bucket 中</span></span><br><span class="line">  <span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> &quot;\t&quot;</span><br><span class="line">  LOCATION <span class="string">&#x27;/hive/emp_bucket&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-倾斜表">2.6 倾斜表</h3>
<p>通过指定一个或者多个列经常出现的值（严重偏斜），Hive 会自动将涉及到这些值的数据拆分为单独的文件。在查询时，如果涉及到倾斜值，它就直接从独立文件中获取数据，而不是扫描所有文件，这使得性能得到提升。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> emp_skewed(</span><br><span class="line">  empno <span class="type">INT</span>,</span><br><span class="line">  ename STRING,</span><br><span class="line">  job STRING,</span><br><span class="line">  mgr <span class="type">INT</span>,</span><br><span class="line">  hiredate <span class="type">TIMESTAMP</span>,</span><br><span class="line">  sal <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">  comm <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line">  )</span><br><span class="line">  SKEWED <span class="keyword">BY</span> (empno) <span class="keyword">ON</span> (<span class="number">66</span>,<span class="number">88</span>,<span class="number">100</span>)  <span class="comment">--指定 empno 的倾斜值 66,88,100</span></span><br><span class="line">  <span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> &quot;\t&quot;</span><br><span class="line">  LOCATION <span class="string">&#x27;/hive/emp_skewed&#x27;</span>;   </span><br></pre></td></tr></table></figure>
<h3 id="2-7-临时表">2.7 临时表</h3>
<p>临时表仅对当前 session 可见，临时表的数据将存储在用户的暂存目录中，并在会话结束后删除。如果临时表与永久表表名相同，则对该表名的任何引用都将解析为临时表，而不是永久表。临时表还具有以下两个限制：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>不支持分区列；</p>
</li>
<li class="lvl-2">
<p>不支持创建索引。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TEMPORARY <span class="keyword">TABLE</span> emp_temp(</span><br><span class="line">  empno <span class="type">INT</span>,</span><br><span class="line">  ename STRING,</span><br><span class="line">  job STRING,</span><br><span class="line">  mgr <span class="type">INT</span>,</span><br><span class="line">  hiredate <span class="type">TIMESTAMP</span>,</span><br><span class="line">  sal <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">  comm <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line">  )</span><br><span class="line">  <span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> &quot;\t&quot;;</span><br></pre></td></tr></table></figure>
<h3 id="2-8-CTAS创建表">2.8 CTAS创建表</h3>
<p>支持从查询语句的结果创建表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp_copy <span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> deptno<span class="operator">=</span><span class="string">&#x27;20&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-9-复制表结构">2.9 复制表结构</h3>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [TEMPORARY] [<span class="keyword">EXTERNAL</span>] <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [db_name.]table_name  <span class="comment">--创建表表名</span></span><br><span class="line">   <span class="keyword">LIKE</span> existing_table_or_view_name  <span class="comment">--被复制表的表名</span></span><br><span class="line">   [LOCATION hdfs_path]; <span class="comment">--存储位置</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TEMPORARY <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span>  IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>  emp_co  <span class="keyword">LIKE</span> emp</span><br></pre></td></tr></table></figure>
<h3 id="2-10-加载数据到表">2.10 加载数据到表</h3>
<p>加载数据到表中属于 DML 操作，这里为了方便大家测试，先简单介绍一下加载本地数据到表中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 加载数据到 emp 表中</span></span><br><span class="line">load data <span class="keyword">local</span> inpath &quot;/usr/file/emp.txt&quot; <span class="keyword">into</span> <span class="keyword">table</span> emp;</span><br></pre></td></tr></table></figure>
<p>其中 emp.txt 的内容如下，你可以直接复制使用，也可以到本仓库的<a href="https://gitee.com/oicio/BigData-Notes/tree/master/resources">resources</a> 目录下载：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">7369	SMITH	CLERK	7902	1980-12-17 00:00:00	800.00		20</span><br><span class="line">7499	ALLEN	SALESMAN	7698	1981-02-20 00:00:00	1600.00	300.00	30</span><br><span class="line">7521	WARD	SALESMAN	7698	1981-02-22 00:00:00	1250.00	500.00	30</span><br><span class="line">7566	JONES	MANAGER	7839	1981-04-02 00:00:00	2975.00		20</span><br><span class="line">7654	MARTIN	SALESMAN	7698	1981-09-28 00:00:00	1250.00	1400.00	30</span><br><span class="line">7698	BLAKE	MANAGER	7839	1981-05-01 00:00:00	2850.00		30</span><br><span class="line">7782	CLARK	MANAGER	7839	1981-06-09 00:00:00	2450.00		10</span><br><span class="line">7788	SCOTT	ANALYST	7566	1987-04-19 00:00:00	1500.00		20</span><br><span class="line">7839	KING	PRESIDENT		1981-11-17 00:00:00	5000.00		10</span><br><span class="line">7844	TURNER	SALESMAN	7698	1981-09-08 00:00:00	1500.00	0.00	30</span><br><span class="line">7876	ADAMS	CLERK	7788	1987-05-23 00:00:00	1100.00		20</span><br><span class="line">7900	JAMES	CLERK	7698	1981-12-03 00:00:00	950.00		30</span><br><span class="line">7902	FORD	ANALYST	7566	1981-12-03 00:00:00	3000.00		20</span><br><span class="line">7934	MILLER	CLERK	7782	1982-01-23 00:00:00	1300.00		10</span><br></pre></td></tr></table></figure>
<p>加载后可查询表中数据：</p>
<div align="center"> <img width='700px' src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-select-emp.png"/> </div>
<h2 id="三、修改表">三、修改表</h2>
<h3 id="3-1-重命名表">3.1 重命名表</h3>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name RENAME <span class="keyword">TO</span> new_table_name;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp_temp RENAME <span class="keyword">TO</span> new_emp; <span class="comment">--把 emp_temp 表重命名为 new_emp</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-修改列">3.2 修改列</h3>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name [<span class="keyword">PARTITION</span> partition_spec] CHANGE [<span class="keyword">COLUMN</span>] col_old_name col_new_name column_type</span><br><span class="line">  [COMMENT col_comment] [<span class="keyword">FIRST</span><span class="operator">|</span>AFTER column_name] [CASCADE<span class="operator">|</span>RESTRICT];</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 修改字段名和类型</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp_temp CHANGE empno empno_new <span class="type">INT</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 修改字段 sal 的名称 并将其放置到 empno 字段后</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp_temp CHANGE sal sal_new <span class="type">decimal</span>(<span class="number">7</span>,<span class="number">2</span>)  AFTER ename;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为字段增加注释</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp_temp CHANGE mgr mgr_new <span class="type">INT</span> COMMENT <span class="string">&#x27;this is column mgr&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-新增列">3.3 新增列</h3>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp_temp <span class="keyword">ADD</span> COLUMNS (address STRING COMMENT <span class="string">&#x27;home address&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="四、清空表-删除表">四、清空表/删除表</h2>
<h3 id="4-1-清空表">4.1 清空表</h3>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 清空整个表或表指定分区中的数据</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> table_name [<span class="keyword">PARTITION</span> (partition_column <span class="operator">=</span> partition_col_value,  ...)];</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>目前只有内部表才能执行 TRUNCATE 操作，外部表执行时会抛出异常 <code>Cannot truncate non-managed table XXXX</code>。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> emp_mgt_ptn <span class="keyword">PARTITION</span> (deptno<span class="operator">=</span><span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<h3 id="4-2-删除表">4.2 删除表</h3>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [IF <span class="keyword">EXISTS</span>] table_name [PURGE]; </span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>内部表：不仅会删除表的元数据，同时会删除 HDFS 上的数据；</p>
</li>
<li class="lvl-2">
<p>外部表：只会删除表的元数据，不会删除 HDFS 上的数据；</p>
</li>
<li class="lvl-2">
<p>删除视图引用的表时，不会给出警告（但视图已经无效了，必须由用户删除或重新创建）。</p>
</li>
</ul>
<h2 id="五、其他命令">五、其他命令</h2>
<h3 id="5-1-Describe">5.1 Describe</h3>
<p>查看数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span><span class="operator">|</span><span class="keyword">Desc</span> DATABASE [EXTENDED] db_name;  <span class="comment">--EXTENDED 是否显示额外属性</span></span><br></pre></td></tr></table></figure>
<p>查看表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span><span class="operator">|</span><span class="keyword">Desc</span> [EXTENDED<span class="operator">|</span>FORMATTED] table_name <span class="comment">--FORMATTED 以友好的展现方式查看表详情</span></span><br></pre></td></tr></table></figure>
<h3 id="5-2-Show">5.2 Show</h3>
<p><strong>1. 查看数据库列表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 语法</span></span><br><span class="line"><span class="keyword">SHOW</span> (DATABASES<span class="operator">|</span>SCHEMAS) [<span class="keyword">LIKE</span> <span class="string">&#x27;identifier_with_wildcards&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 示例：</span></span><br><span class="line"><span class="keyword">SHOW</span> DATABASES <span class="keyword">like</span> <span class="string">&#x27;hive*&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>LIKE 子句允许使用正则表达式进行过滤，但是 SHOW 语句当中的 LIKE 子句只支持 <code>*</code>（通配符）和 <code>|</code>（条件或）两个符号。例如 <code>employees</code>，<code>emp *</code>，<code>emp * | * ees</code>，所有这些都将匹配名为 <code>employees</code> 的数据库。</p>
<p><strong>2. 查看表的列表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 语法</span></span><br><span class="line"><span class="keyword">SHOW</span> TABLES [<span class="keyword">IN</span> database_name] [<span class="string">&#x27;identifier_with_wildcards&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 示例</span></span><br><span class="line"><span class="keyword">SHOW</span> TABLES <span class="keyword">IN</span> <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>
<p><strong>3. 查看视图列表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VIEWS [<span class="keyword">IN</span><span class="operator">/</span><span class="keyword">FROM</span> database_name] [<span class="keyword">LIKE</span> <span class="string">&#x27;pattern_with_wildcards&#x27;</span>];   <span class="comment">--仅支持 Hive 2.2.0 +</span></span><br></pre></td></tr></table></figure>
<p><strong>4. 查看表的分区列表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> PARTITIONS table_name;</span><br></pre></td></tr></table></figure>
<p><strong>5. 查看表/视图的创建语句</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ([db_name.]table_name<span class="operator">|</span>view_name);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>hive</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive 常用DML操作</title>
    <url>/posts/8e3ba3ed.html</url>
    <content><![CDATA[<h2 id="一、加载文件数据到表">一、加载文件数据到表</h2>
<h3 id="1-1-语法">1.1 语法</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">LOAD DATA [LOCAL] INPATH &#x27;filepath&#x27; [OVERWRITE] </span><br><span class="line">INTO TABLE tablename [PARTITION (partcol1=val1, partcol2=val2 ...)]</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>LOCAL</code> 关键字代表从本地文件系统加载文件，省略则代表从 HDFS 上加载文件：</p>
</li>
</ul>
<ul class="lvl-0">
<li class="lvl-2">
<p>从本地文件系统加载文件时， <code>filepath</code> 可以是绝对路径也可以是相对路径 (建议使用绝对路径)；</p>
</li>
<li class="lvl-2">
<p>从 HDFS 加载文件时候，<code>filepath</code> 为文件完整的 URL 地址：如 <code>hdfs://namenode:port/user/hive/project/ data1</code></p>
</li>
</ul>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>filepath</code> 可以是文件路径 (在这种情况下 Hive 会将文件移动到表中)，也可以目录路径 (在这种情况下，Hive 会将该目录中的所有文件移动到表中)；</p>
</li>
<li class="lvl-2">
<p>如果使用 OVERWRITE 关键字，则将删除目标表（或分区）的内容，使用新的数据填充；不使用此关键字，则数据以追加的方式加入；</p>
</li>
<li class="lvl-2">
<p>加载的目标可以是表或分区。如果是分区表，则必须指定加载数据的分区；</p>
</li>
<li class="lvl-2">
<p>加载文件的格式必须与建表时使用 <code> STORED AS</code> 指定的存储格式相同。</p>
</li>
</ul>
<blockquote>
<p>使用建议：</p>
<p><strong>不论是本地路径还是 URL 都建议使用完整的</strong>。虽然可以使用不完整的 URL 地址，此时 Hive 将使用 hadoop 中的 <a href="http://fs.default.name">fs.default.name</a> 配置来推断地址，但是为避免不必要的错误，建议使用完整的本地路径或 URL 地址；</p>
<p><strong>加载对象是分区表时建议显示指定分区</strong>。在 Hive 3.0 之后，内部将加载 (LOAD) 重写为 INSERT AS SELECT，此时如果不指定分区，INSERT AS SELECT 将假设最后一组列是分区列，如果该列不是表定义的分区，它将抛出错误。为避免错误，还是建议显示指定分区。</p>
</blockquote>
<h3 id="1-2-示例">1.2 示例</h3>
<p>新建分区表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp_ptn(</span><br><span class="line">  empno <span class="type">INT</span>,</span><br><span class="line">  ename STRING,</span><br><span class="line">  job STRING,</span><br><span class="line">  mgr <span class="type">INT</span>,</span><br><span class="line">  hiredate <span class="type">TIMESTAMP</span>,</span><br><span class="line">  sal <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">  comm <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line">  )</span><br><span class="line">  PARTITIONED <span class="keyword">BY</span> (deptno <span class="type">INT</span>)   <span class="comment">-- 按照部门编号进行分区</span></span><br><span class="line">  <span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> &quot;\t&quot;;</span><br></pre></td></tr></table></figure>
<p>从 HDFS 上加载数据到分区表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">LOAD DATA  INPATH &quot;hdfs://hadoop001:8020/mydir/emp.txt&quot; OVERWRITE <span class="keyword">INTO</span> <span class="keyword">TABLE</span> emp_ptn <span class="keyword">PARTITION</span> (deptno<span class="operator">=</span><span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>emp.txt 文件可在本仓库的 resources 目录中下载</p>
</blockquote>
<p>加载后表中数据如下,分区列 deptno 全部赋值成 20：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-emp-ptn.png"/> </div>
<h2 id="二、查询结果插入到表">二、查询结果插入到表</h2>
<h3 id="2-1-语法">2.1 语法</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> tablename1 [<span class="keyword">PARTITION</span> (partcol1<span class="operator">=</span>val1, partcol2<span class="operator">=</span>val2 ...) [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>]]   </span><br><span class="line">select_statement1 <span class="keyword">FROM</span> from_statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tablename1 [<span class="keyword">PARTITION</span> (partcol1<span class="operator">=</span>val1, partcol2<span class="operator">=</span>val2 ...)] </span><br><span class="line">select_statement1 <span class="keyword">FROM</span> from_statement;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>Hive 0.13.0 开始，建表时可以通过使用 TBLPROPERTIES（“immutable”=“true”）来创建不可变表 (immutable table) ，如果不可以变表中存在数据，则 INSERT INTO 失败。（注：INSERT OVERWRITE 的语句不受 <code>immutable</code> 属性的影响）;</p>
</li>
<li class="lvl-2">
<p>可以对表或分区执行插入操作。如果表已分区，则必须通过指定所有分区列的值来指定表的特定分区；</p>
</li>
<li class="lvl-2">
<p>从 Hive 1.1.0 开始，TABLE 关键字是可选的；</p>
</li>
<li class="lvl-2">
<p>从 Hive 1.2.0 开始 ，可以采用 INSERT INTO tablename(z，x，c1) 指明插入列；</p>
</li>
<li class="lvl-2">
<p>可以将 SELECT 语句的查询结果插入多个表（或分区），称为多表插入。语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> from_statement</span><br><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> tablename1 </span><br><span class="line">[<span class="keyword">PARTITION</span> (partcol1<span class="operator">=</span>val1, partcol2<span class="operator">=</span>val2 ...) [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>]] select_statement1</span><br><span class="line">[<span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> tablename2 [<span class="keyword">PARTITION</span> ... [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>]] select_statement2]</span><br><span class="line">[<span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tablename2 [<span class="keyword">PARTITION</span> ...] select_statement2] ...;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-2-动态插入分区">2.2 动态插入分区</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> tablename <span class="keyword">PARTITION</span> (partcol1[<span class="operator">=</span>val1], partcol2[<span class="operator">=</span>val2] ...) </span><br><span class="line">select_statement <span class="keyword">FROM</span> from_statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tablename <span class="keyword">PARTITION</span> (partcol1[<span class="operator">=</span>val1], partcol2[<span class="operator">=</span>val2] ...) </span><br><span class="line">select_statement <span class="keyword">FROM</span> from_statement;</span><br></pre></td></tr></table></figure>
<p>在向分区表插入数据时候，分区列名是必须的，但是列值是可选的。如果给出了分区列值，我们将其称为静态分区，否则它是动态分区。动态分区列必须在 SELECT 语句的列中最后指定，并且与它们在 PARTITION() 子句中出现的顺序相同。</p>
<p>注意：Hive 0.9.0 之前的版本动态分区插入是默认禁用的，而 0.9.0 之后的版本则默认启用。以下是动态分区的相关配置：</p>
<table>
<thead>
<tr>
<th>配置</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>hive.exec.dynamic.partition</code></td>
<td><code>true</code></td>
<td>需要设置为 true 才能启用动态分区插入</td>
</tr>
<tr>
<td><code>hive.exec.dynamic.partition.mode</code></td>
<td><code>strict</code></td>
<td>在严格模式 (strict) 下，用户必须至少指定一个静态分区，以防用户意外覆盖所有分区，在非严格模式下，允许所有分区都是动态的</td>
</tr>
<tr>
<td><code>hive.exec.max.dynamic.partitions.pernode</code></td>
<td>100</td>
<td>允许在每个 mapper/reducer 节点中创建的最大动态分区数</td>
</tr>
<tr>
<td><code>hive.exec.max.dynamic.partitions</code></td>
<td>1000</td>
<td>允许总共创建的最大动态分区数</td>
</tr>
<tr>
<td><code>hive.exec.max.created.files</code></td>
<td>100000</td>
<td>作业中所有 mapper/reducer 创建的 HDFS 文件的最大数量</td>
</tr>
<tr>
<td><code>hive.error.on.empty.partition</code></td>
<td><code>false</code></td>
<td>如果动态分区插入生成空结果，是否抛出异常</td>
</tr>
</tbody>
</table>
<h3 id="2-3-示例">2.3 示例</h3>
<ol>
<li class="lvl-3">
<p>新建 emp 表，作为查询对象表</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">    empno <span class="type">INT</span>,</span><br><span class="line">    ename STRING,</span><br><span class="line">    job STRING,</span><br><span class="line">    mgr <span class="type">INT</span>,</span><br><span class="line">    hiredate <span class="type">TIMESTAMP</span>,</span><br><span class="line">    sal <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">    comm <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">    deptno <span class="type">INT</span>)</span><br><span class="line">    <span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> &quot;\t&quot;;</span><br><span class="line">    </span><br><span class="line"> <span class="comment">-- 加载数据到 emp 表中 这里直接从本地加载</span></span><br><span class="line">load data <span class="keyword">local</span> inpath &quot;/usr/file/emp.txt&quot; <span class="keyword">into</span> <span class="keyword">table</span> emp;</span><br></pre></td></tr></table></figure>
<p>​	完成后 <code>emp</code> 表中数据如下：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-emp.png"/> </div>
<ol start="2">
<li class="lvl-3">
<p>为清晰演示，先清空 <code>emp_ptn</code> 表中加载的数据：</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> emp_ptn;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>静态分区演示：从 <code>emp</code> 表中查询部门编号为 20 的员工数据，并插入 <code>emp_ptn</code> 表中，语句如下：</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> emp_ptn <span class="keyword">PARTITION</span> (deptno<span class="operator">=</span><span class="number">20</span>) </span><br><span class="line"><span class="keyword">SELECT</span> empno,ename,job,mgr,hiredate,sal,comm <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> deptno<span class="operator">=</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>​	完成后 <code>emp_ptn</code> 表中数据如下：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-emp-deptno-20.png"/> </div>
<ol start="4">
<li class="lvl-3">
<p>接着演示动态分区：</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 由于我们只有一个分区，且还是动态分区，所以需要关闭严格默认。因为在严格模式下，用户必须至少指定一个静态分区</span></span><br><span class="line"><span class="keyword">set</span> hive.exec.dynamic.partition.mode<span class="operator">=</span>nonstrict;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 动态分区   此时查询语句的最后一列为动态分区列，即 deptno</span></span><br><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> emp_ptn <span class="keyword">PARTITION</span> (deptno) </span><br><span class="line"><span class="keyword">SELECT</span> empno,ename,job,mgr,hiredate,sal,comm,deptno <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> deptno<span class="operator">=</span><span class="number">30</span>;</span><br></pre></td></tr></table></figure>
<p>​	完成后 <code>emp_ptn</code> 表中数据如下：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-emp-deptno-20-30.png"/> </div>
<h2 id="三、使用SQL语句插入值">三、使用SQL语句插入值</h2>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tablename [<span class="keyword">PARTITION</span> (partcol1[<span class="operator">=</span>val1], partcol2[<span class="operator">=</span>val2] ...)] </span><br><span class="line"><span class="keyword">VALUES</span> ( <span class="keyword">value</span> [, <span class="keyword">value</span> ...] )</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用时必须为表中的每个列都提供值。不支持只向部分列插入值（可以为缺省值的列提供空值来消除这个弊端）；</p>
</li>
<li class="lvl-2">
<p>如果目标表表支持 ACID 及其事务管理器，则插入后自动提交；</p>
</li>
<li class="lvl-2">
<p>不支持支持复杂类型 (array, map, struct, union) 的插入。</p>
</li>
</ul>
<h2 id="四、更新和删除数据">四、更新和删除数据</h2>
<h3 id="4-1-语法">4.1 语法</h3>
<p>更新和删除的语法比较简单，和关系型数据库一致。需要注意的是这两个操作都只能在支持 ACID 的表，也就是事务表上才能执行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 更新</span></span><br><span class="line"><span class="keyword">UPDATE</span> tablename <span class="keyword">SET</span> <span class="keyword">column</span> <span class="operator">=</span> <span class="keyword">value</span> [, <span class="keyword">column</span> <span class="operator">=</span> <span class="keyword">value</span> ...] [<span class="keyword">WHERE</span> expression]</span><br><span class="line"></span><br><span class="line"><span class="comment">--删除</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tablename [<span class="keyword">WHERE</span> expression]</span><br></pre></td></tr></table></figure>
<h3 id="4-2-示例">4.2 示例</h3>
<p><strong>1. 修改配置</strong></p>
<p>首先需要更改 <code>hive-site.xml</code>，添加如下配置，开启事务支持，配置完成后需要重启 Hive 服务。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.support.concurrency<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.enforce.bucketing<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.exec.dynamic.partition.mode<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>nonstrict<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.txn.manager<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.hive.ql.lockmgr.DbTxnManager<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.compactor.initiator.on<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.in.test<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>2. 创建测试表</strong></p>
<p>创建用于测试的事务表，建表时候指定属性 <code>transactional = true</code> 则代表该表是事务表。需要注意的是，按照<a href="https://cwiki.apache.org/confluence/display/Hive/Hive+Transactions">官方文档</a> 的说明，目前 Hive 中的事务表有以下限制：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>必须是 buckets Table;</p>
</li>
<li class="lvl-2">
<p>仅支持 ORC 文件格式；</p>
</li>
<li class="lvl-2">
<p>不支持 LOAD DATA …语句。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp_ts(  </span><br><span class="line">  empno <span class="type">int</span>,  </span><br><span class="line">  ename String</span><br><span class="line">)</span><br><span class="line">CLUSTERED <span class="keyword">BY</span> (empno) <span class="keyword">INTO</span> <span class="number">2</span> BUCKETS STORED <span class="keyword">AS</span> ORC</span><br><span class="line">TBLPROPERTIES (&quot;transactional&quot;<span class="operator">=</span>&quot;true&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>3. 插入测试数据</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> emp_ts  <span class="keyword">VALUES</span> (<span class="number">1</span>,&quot;ming&quot;),(<span class="number">2</span>,&quot;hong&quot;);</span><br></pre></td></tr></table></figure>
<p>插入数据依靠的是 MapReduce 作业，执行成功后数据如下：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-emp-ts.png"/> </div>
<p><strong>4. 测试更新和删除</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--更新数据</span></span><br><span class="line"><span class="keyword">UPDATE</span> emp_ts <span class="keyword">SET</span> ename <span class="operator">=</span> &quot;lan&quot;  <span class="keyword">WHERE</span>  empno<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--删除数据</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> emp_ts <span class="keyword">WHERE</span> empno<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>更新和删除数据依靠的也是 MapReduce 作业，执行成功后数据如下：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-emp-ts-2.png"/> </div>
<h2 id="五、查询结果写出到文件系统">五、查询结果写出到文件系统</h2>
<h3 id="5-1-语法">5.1 语法</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> OVERWRITE [<span class="keyword">LOCAL</span>] DIRECTORY directory1</span><br><span class="line">  [<span class="type">ROW</span> FORMAT row_format] [STORED <span class="keyword">AS</span> file_format] </span><br><span class="line">  <span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ...</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>OVERWRITE 关键字表示输出文件存在时，先删除后再重新写入；</p>
</li>
<li class="lvl-2">
<p>和 Load 语句一样，建议无论是本地路径还是 URL 地址都使用完整的；</p>
</li>
<li class="lvl-2">
<p>写入文件系统的数据被序列化为文本，其中列默认由^A 分隔，行由换行符分隔。如果列不是基本类型，则将其序列化为 JSON 格式。其中行分隔符不允许自定义，但列分隔符可以自定义，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 定义列分隔符为&#x27;\t&#x27; </span></span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">local</span> directory <span class="string">&#x27;./test-04&#x27;</span> </span><br><span class="line"><span class="type">row</span> format delimited </span><br><span class="line">FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\t&#x27;</span></span><br><span class="line">COLLECTION ITEMS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;,&#x27;</span></span><br><span class="line">MAP KEYS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;:&#x27;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> src;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="5-2-示例">5.2 示例</h3>
<p>这里我们将上面创建的 <code>emp_ptn</code> 表导出到本地文件系统，语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">LOCAL</span> DIRECTORY <span class="string">&#x27;/usr/file/ouput&#x27;</span></span><br><span class="line"><span class="type">ROW</span> FORMAT DELIMITED</span><br><span class="line">FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\t&#x27;</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp_ptn;</span><br></pre></td></tr></table></figure>
<p>导出结果如下：</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-ouput.png"/> </div>
<blockquote>
<p>原文：<a href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>hive</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive数据查询实战</title>
    <url>/posts/a8d1717b.html</url>
    <content><![CDATA[<h2 id="一、数据准备">一、数据准备</h2>
<p>为了演示查询操作，这里需要预先创建三张表，并加载测试数据。</p>
<blockquote>
<p>数据文件 emp.txt 和 dept.txt 可以从本仓库的<a href="https://gitee.com/oicio/BigData-Notes/tree/master/resources">resources</a> 目录下载。</p>
</blockquote>
<h3 id="1-1-员工表">1.1 员工表</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> <span class="comment">-- 建表语句</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">                    empno <span class="type">INT</span>,     <span class="comment">-- 员工表编号</span></span><br><span class="line">                    ename STRING,  <span class="comment">-- 员工姓名</span></span><br><span class="line">                    job STRING,    <span class="comment">-- 职位类型</span></span><br><span class="line">                    mgr <span class="type">INT</span>,</span><br><span class="line">                    hiredate <span class="type">TIMESTAMP</span>,  <span class="comment">--雇佣日期</span></span><br><span class="line">                    sal <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),  <span class="comment">--工资</span></span><br><span class="line">                    comm <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">                    deptno <span class="type">INT</span>)   <span class="comment">--部门编号</span></span><br><span class="line">    <span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> &quot;\t&quot;;</span><br><span class="line"></span><br><span class="line"><span class="comment">--加载数据</span></span><br><span class="line">LOAD DATA <span class="keyword">LOCAL</span> INPATH &quot;/usr/file/emp.txt&quot; OVERWRITE <span class="keyword">INTO</span> <span class="keyword">TABLE</span> emp;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-部门表">1.2 部门表</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建表语句</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept(</span><br><span class="line">    deptno <span class="type">INT</span>,   <span class="comment">--部门编号</span></span><br><span class="line">    dname STRING,  <span class="comment">--部门名称</span></span><br><span class="line">    loc STRING    <span class="comment">--部门所在的城市</span></span><br><span class="line">)</span><br><span class="line"><span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> &quot;\t&quot;;</span><br><span class="line"></span><br><span class="line"><span class="comment">--加载数据</span></span><br><span class="line">LOAD DATA <span class="keyword">LOCAL</span> INPATH &quot;/usr/file/dept.txt&quot; OVERWRITE <span class="keyword">INTO</span> <span class="keyword">TABLE</span> dept;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-分区表">1.3 分区表</h3>
<p>这里需要额外创建一张分区表，主要是为了演示分区查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> emp_ptn(</span><br><span class="line">      empno <span class="type">INT</span>,</span><br><span class="line">      ename STRING,</span><br><span class="line">      job STRING,</span><br><span class="line">      mgr <span class="type">INT</span>,</span><br><span class="line">      hiredate <span class="type">TIMESTAMP</span>,</span><br><span class="line">      sal <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">      comm <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line">  )</span><br><span class="line"> PARTITIONED <span class="keyword">BY</span> (deptno <span class="type">INT</span>)   <span class="comment">-- 按照部门编号进行分区</span></span><br><span class="line"> <span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> &quot;\t&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--加载数据</span></span><br><span class="line">LOAD DATA <span class="keyword">LOCAL</span> INPATH &quot;/usr/file/emp.txt&quot; OVERWRITE <span class="keyword">INTO</span> <span class="keyword">TABLE</span> emp_ptn <span class="keyword">PARTITION</span> (deptno<span class="operator">=</span><span class="number">20</span>)</span><br><span class="line">LOAD DATA <span class="keyword">LOCAL</span> INPATH &quot;/usr/file/emp.txt&quot; OVERWRITE <span class="keyword">INTO</span> <span class="keyword">TABLE</span> emp_ptn <span class="keyword">PARTITION</span> (deptno<span class="operator">=</span><span class="number">30</span>)</span><br><span class="line">LOAD DATA <span class="keyword">LOCAL</span> INPATH &quot;/usr/file/emp.txt&quot; OVERWRITE <span class="keyword">INTO</span> <span class="keyword">TABLE</span> emp_ptn <span class="keyword">PARTITION</span> (deptno<span class="operator">=</span><span class="number">40</span>)</span><br><span class="line">LOAD DATA <span class="keyword">LOCAL</span> INPATH &quot;/usr/file/emp.txt&quot; OVERWRITE <span class="keyword">INTO</span> <span class="keyword">TABLE</span> emp_ptn <span class="keyword">PARTITION</span> (deptno<span class="operator">=</span><span class="number">50</span>)</span><br></pre></td></tr></table></figure>
<h2 id="二、单表查询">二、单表查询</h2>
<h3 id="2-1-SELECT">2.1 SELECT</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询表中全部数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-WHERE">2.2 WHERE</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询 10 号部门中员工编号大于 7782 的员工信息 </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empno <span class="operator">&gt;</span> <span class="number">7782</span> <span class="keyword">AND</span> deptno <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-DISTINCT">2.3  DISTINCT</h3>
<p>Hive 支持使用 DISTINCT 关键字去重。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询所有工作类型</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> job <span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-分区查询">2.4 分区查询</h3>
<p>分区查询 (Partition Based Queries)，可以指定某个分区或者分区范围。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询分区表中部门编号在[20,40]之间的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> emp_ptn.<span class="operator">*</span> <span class="keyword">FROM</span> emp_ptn</span><br><span class="line"><span class="keyword">WHERE</span> emp_ptn.deptno <span class="operator">&gt;=</span> <span class="number">20</span> <span class="keyword">AND</span> emp_ptn.deptno <span class="operator">&lt;=</span> <span class="number">40</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-LIMIT">2.5 LIMIT</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询薪资最高的 5 名员工</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">ORDER</span> <span class="keyword">BY</span> sal <span class="keyword">DESC</span> LIMIT <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-GROUP-BY">2.6 GROUP BY</h3>
<p>Hive 支持使用 GROUP BY 进行分组聚合操作。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.map.aggr<span class="operator">=</span><span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询各个部门薪酬综合</span></span><br><span class="line"><span class="keyword">SELECT</span> deptno,<span class="built_in">SUM</span>(sal) <span class="keyword">FROM</span> emp <span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno;</span><br></pre></td></tr></table></figure>
<p><code>hive.map.aggr</code> 控制程序如何进行聚合。默认值为 false。如果设置为 true，Hive 会在 map 阶段就执行一次聚合。这可以提高聚合效率，但需要消耗更多内存。</p>
<h3 id="2-7-ORDER-AND-SORT">2.7 ORDER AND SORT</h3>
<p>可以使用 ORDER BY 或者 Sort BY 对查询结果进行排序，排序字段可以是整型也可以是字符串：如果是整型，则按照大小排序；如果是字符串，则按照字典序排序。ORDER BY 和 SORT BY 的区别如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用 ORDER BY 时会有一个 Reducer 对全部查询结果进行排序，可以保证数据的全局有序性；</p>
</li>
<li class="lvl-2">
<p>使用 SORT BY 时只会在每个 Reducer 中进行排序，这可以保证每个 Reducer 的输出数据是有序的，但不能保证全局有序。</p>
</li>
</ul>
<p>由于 ORDER BY 的时间可能很长，如果你设置了严格模式 (hive.mapred.mode = strict)，则其后面必须再跟一个 <code>limit</code> 子句。</p>
<blockquote>
<p>注 ：hive.mapred.mode 默认值是 nonstrict ，也就是非严格模式。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询员工工资，结果按照部门升序，按照工资降序排列</span></span><br><span class="line"><span class="keyword">SELECT</span> empno, deptno, sal <span class="keyword">FROM</span> emp <span class="keyword">ORDER</span> <span class="keyword">BY</span> deptno <span class="keyword">ASC</span>, sal <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-8-HAVING">2.8 HAVING</h3>
<p>可以使用 HAVING 对分组数据进行过滤。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询工资总和大于 9000 的所有部门</span></span><br><span class="line"><span class="keyword">SELECT</span> deptno,<span class="built_in">SUM</span>(sal) <span class="keyword">FROM</span> emp <span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno <span class="keyword">HAVING</span> <span class="built_in">SUM</span>(sal)<span class="operator">&gt;</span><span class="number">9000</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-9-DISTRIBUTE-BY">2.9 DISTRIBUTE BY</h3>
<p>如果想要把具有相同 Key 值的数据分发到同一个 Reducer 进行处理，这可以使用 DISTRIBUTE BY 字句。需要注意的是，DISTRIBUTE BY 虽然能把具有相同 Key 值的数据分发到同一个 Reducer，但是不能保证数据在 Reducer 上是有序的。情况如下：</p>
<p>把以下 5 个数据发送到两个 Reducer 上进行处理：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">k1</span></span><br><span class="line"><span class="attr">k2</span></span><br><span class="line"><span class="attr">k4</span></span><br><span class="line"><span class="attr">k3</span></span><br><span class="line"><span class="attr">k1</span></span><br></pre></td></tr></table></figure>
<p>Reducer1 得到如下乱序数据：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">k1</span></span><br><span class="line"><span class="attr">k2</span></span><br><span class="line"><span class="attr">k1</span></span><br></pre></td></tr></table></figure>
<p>Reducer2 得到数据如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">k4</span></span><br><span class="line"><span class="attr">k3</span></span><br></pre></td></tr></table></figure>
<p>如果想让 Reducer 上的数据是有序的，可以结合 <code>SORT BY</code> 使用 (示例如下)，或者使用下面我们将要介绍的 CLUSTER BY。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 将数据按照部门分发到对应的 Reducer 上处理</span></span><br><span class="line"><span class="keyword">SELECT</span> empno, deptno, sal <span class="keyword">FROM</span> emp DISTRIBUTE <span class="keyword">BY</span> deptno SORT <span class="keyword">BY</span> deptno <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-10-CLUSTER-BY">2.10 CLUSTER BY</h3>
<p>如果 <code>SORT BY</code> 和 <code>DISTRIBUTE BY</code> 指定的是相同字段，且 SORT BY 排序规则是 ASC，此时可以使用 <code>CLUSTER BY</code> 进行替换，同时 <code>CLUSTER BY</code> 可以保证数据在全局是有序的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empno, deptno, sal <span class="keyword">FROM</span> emp CLUSTER  <span class="keyword">BY</span> deptno ;</span><br></pre></td></tr></table></figure>
<h2 id="三、多表联结查询">三、多表联结查询</h2>
<p>Hive 支持内连接，外连接，左外连接，右外连接，笛卡尔连接，这和传统数据库中的概念是一致的，可以参见下图。</p>
<p>需要特别强调：JOIN 语句的关联条件必须用 ON 指定，不能用 WHERE 指定，否则就会先做笛卡尔积，再过滤，这会导致你得不到预期的结果 (下面的演示会有说明)。</p>
<div align="center"> <img width="600px"  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/sql-join.jpg"/> </div>
<h3 id="3-1-INNER-JOIN">3.1 INNER JOIN</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询员工编号为 7369 的员工的详细信息</span></span><br><span class="line"><span class="keyword">SELECT</span> e.<span class="operator">*</span>,d.<span class="operator">*</span> <span class="keyword">FROM</span> </span><br><span class="line">emp e <span class="keyword">JOIN</span> dept d</span><br><span class="line"><span class="keyword">ON</span> e.deptno <span class="operator">=</span> d.deptno </span><br><span class="line"><span class="keyword">WHERE</span> empno<span class="operator">=</span><span class="number">7369</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--如果是三表或者更多表连接，语法如下</span></span><br><span class="line"><span class="keyword">SELECT</span> a.val, b.val, c.val <span class="keyword">FROM</span> a <span class="keyword">JOIN</span> b <span class="keyword">ON</span> (a.key <span class="operator">=</span> b.key1) <span class="keyword">JOIN</span> c <span class="keyword">ON</span> (c.key <span class="operator">=</span> b.key1)</span><br></pre></td></tr></table></figure>
<h3 id="3-2-LEFT-OUTER-JOIN">3.2 LEFT OUTER  JOIN</h3>
<p>LEFT OUTER  JOIN 和 LEFT  JOIN 是等价的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 左连接</span></span><br><span class="line"><span class="keyword">SELECT</span> e.<span class="operator">*</span>,d.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> emp e <span class="keyword">LEFT</span> <span class="keyword">OUTER</span>  <span class="keyword">JOIN</span>  dept d</span><br><span class="line"><span class="keyword">ON</span> e.deptno <span class="operator">=</span> d.deptno;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-RIGHT-OUTER-JOIN">3.3 RIGHT OUTER  JOIN</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--右连接</span></span><br><span class="line"><span class="keyword">SELECT</span> e.<span class="operator">*</span>,d.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> emp e <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span>  dept d</span><br><span class="line"><span class="keyword">ON</span> e.deptno <span class="operator">=</span> d.deptno;</span><br></pre></td></tr></table></figure>
<p>执行右连接后，由于 40 号部门下没有任何员工，所以此时员工信息为 NULL。这个查询可以很好的复述上面提到的——JOIN 语句的关联条件必须用 ON 指定，不能用 WHERE 指定。你可以把 ON 改成 WHERE，你会发现无论如何都查不出 40 号部门这条数据，因为笛卡尔运算不会有 (NULL, 40) 这种情况。</p>
<div align="center"> <img width="700px"   src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-right-join.png"/> </div>
### 3.4 FULL OUTER  JOIN 
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.<span class="operator">*</span>,d.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> emp e <span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span>  dept d</span><br><span class="line"><span class="keyword">ON</span> e.deptno <span class="operator">=</span> d.deptno;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-LEFT-SEMI-JOIN">3.5 LEFT SEMI JOIN</h3>
<p>LEFT SEMI JOIN （左半连接）是 IN/EXISTS 子查询的一种更高效的实现。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>JOIN 子句中右边的表只能在 ON 子句中设置过滤条件;</p>
</li>
<li class="lvl-2">
<p>查询结果只包含左边表的数据，所以只能 SELECT 左表中的列。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询在纽约办公的所有员工信息</span></span><br><span class="line"><span class="keyword">SELECT</span> emp.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> emp <span class="keyword">LEFT</span> SEMI <span class="keyword">JOIN</span> dept </span><br><span class="line"><span class="keyword">ON</span> emp.deptno <span class="operator">=</span> dept.deptno <span class="keyword">AND</span> dept.loc<span class="operator">=</span>&quot;NEW YORK&quot;;</span><br><span class="line"></span><br><span class="line"><span class="comment">--上面的语句就等价于</span></span><br><span class="line"><span class="keyword">SELECT</span> emp.<span class="operator">*</span> <span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> emp.deptno <span class="keyword">IN</span> (<span class="keyword">SELECT</span> deptno <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> loc<span class="operator">=</span>&quot;NEW YORK&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="3-6-JOIN">3.6 JOIN</h3>
<p>笛卡尔积连接，这个连接日常的开发中可能很少遇到，且性能消耗比较大，基于这个原因，如果在严格模式下 (hive.mapred.mode = strict)，Hive 会阻止用户执行此操作。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">JOIN</span> dept;</span><br></pre></td></tr></table></figure>
<h2 id="四、JOIN优化">四、JOIN优化</h2>
<h3 id="4-1-STREAMTABLE">4.1 STREAMTABLE</h3>
<p>在多表进行联结的时候，如果每个 ON 字句都使用到共同的列（如下面的 <code>b.key</code>），此时 Hive 会进行优化，将多表 JOIN 在同一个 map / reduce 作业上进行。同时假定查询的最后一个表（如下面的 c 表）是最大的一个表，在对每行记录进行 JOIN 操作时，它将尝试将其他的表缓存起来，然后扫描最后那个表进行计算。因此用户需要保证查询的表的大小从左到右是依次增加的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">`<span class="keyword">SELECT</span> a.val, b.val, c.val <span class="keyword">FROM</span> a <span class="keyword">JOIN</span> b <span class="keyword">ON</span> (a.key <span class="operator">=</span> b.key) <span class="keyword">JOIN</span> c <span class="keyword">ON</span> (c.key <span class="operator">=</span> b.key)`</span><br></pre></td></tr></table></figure>
<p>然后，用户并非需要总是把最大的表放在查询语句的最后面，Hive 提供了 <code>/*+ STREAMTABLE() */</code> 标志，用于标识最大的表，示例如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ STREAMTABLE(d) */</span>  e.<span class="operator">*</span>,d.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> emp e <span class="keyword">JOIN</span> dept d</span><br><span class="line"><span class="keyword">ON</span> e.deptno <span class="operator">=</span> d.deptno</span><br><span class="line"><span class="keyword">WHERE</span> job<span class="operator">=</span><span class="string">&#x27;CLERK&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-MAPJOIN">4.2 MAPJOIN</h3>
<p>如果所有表中只有一张表是小表，那么 Hive 把这张小表加载到内存中。这时候程序会在 map 阶段直接拿另外一个表的数据和内存中表数据做匹配，由于在 map 就进行了 JOIN 操作，从而可以省略 reduce 过程，这样效率可以提升很多。Hive 中提供了 <code>/*+ MAPJOIN() */</code> 来标记小表，示例如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ MAPJOIN(d) */</span> e.<span class="operator">*</span>,d.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> emp e <span class="keyword">JOIN</span> dept d</span><br><span class="line"><span class="keyword">ON</span> e.deptno <span class="operator">=</span> d.deptno</span><br><span class="line"><span class="keyword">WHERE</span> job<span class="operator">=</span><span class="string">&#x27;CLERK&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="五、SELECT的其他用途">五、SELECT的其他用途</h2>
<p>查看当前数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> current_database()</span><br></pre></td></tr></table></figure>
<h2 id="六、本地模式">六、本地模式</h2>
<p>在上面演示的语句中，大多数都会触发 MapReduce, 少部分不会触发，比如 <code>select * from emp limit 5</code> 就不会触发 MR，此时 Hive 只是简单的读取数据文件中的内容，然后格式化后进行输出。在需要执行 MapReduce 的查询中，你会发现执行时间可能会很长，这时候你可以选择开启本地模式。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--本地模式默认关闭，需要手动开启此功能</span></span><br><span class="line"><span class="keyword">SET</span> hive.exec.mode.local.auto<span class="operator">=</span><span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>启用后，Hive 将分析查询中每个 map-reduce 作业的大小，如果满足以下条件，则可以在本地运行它：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>作业的总输入大小低于：hive.exec.mode.local.auto.inputbytes.max（默认为 128MB）；</p>
</li>
<li class="lvl-2">
<p>map-tasks 的总数小于：hive.exec.mode.local.auto.tasks.max（默认为 4）；</p>
</li>
<li class="lvl-2">
<p>所需的 reduce 任务总数为 1 或 0。</p>
</li>
</ul>
<p>因为我们测试的数据集很小，所以你再次去执行上面涉及 MR 操作的查询，你会发现速度会有显著的提升。</p>
<blockquote>
<p>原文：<a href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>hive</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive条件与日期函数汇总</title>
    <url>/posts/b9b34c29.html</url>
    <content><![CDATA[<h2 id="条件函数">条件函数</h2>
<h3 id="assert-true-BOOLEAN-condition">assert_true(BOOLEAN condition)</h3>
<ul class="lvl-0">
<li class="lvl-2">解释</li>
</ul>
<p>如果condition不为true，则抛出异常，否则返回null</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> assert_true(<span class="number">1</span><span class="operator">&lt;</span><span class="number">2</span>) <span class="comment">-- 返回null</span></span><br><span class="line"><span class="keyword">select</span> assert_true(<span class="number">1</span><span class="operator">&gt;</span><span class="number">2</span>) <span class="comment">-- 抛出异常</span></span><br></pre></td></tr></table></figure>
<h3 id="coalesce-T-v1-T-v2-…">coalesce(T v1, T v2, …)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回第一个不为null的值，如果都为null，则返回null</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">coalesce</span>(<span class="keyword">null</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="keyword">null</span>)  <span class="comment">-- 返回1</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">coalesce</span>(<span class="number">1</span>,<span class="keyword">null</span>) <span class="comment">-- 返回1</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">coalesce</span>(<span class="keyword">null</span>,<span class="keyword">null</span>) <span class="comment">-- 返回null</span></span><br></pre></td></tr></table></figure>
<h3 id="if-BOOLEAN-testCondition-valueTrue-valueFalseOrNull">if(BOOLEAN testCondition,valueTrue, valueFalseOrNull)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>如果testCondition条件为true，则返回第一个值，否则返回第二个值</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> if(<span class="number">1</span> <span class="keyword">is</span> <span class="keyword">null</span>,<span class="number">0</span>,<span class="number">1</span>)  <span class="comment">-- 返回1</span></span><br><span class="line"><span class="keyword">select</span> if(<span class="keyword">null</span> <span class="keyword">is</span> <span class="keyword">null</span>,<span class="number">0</span>,<span class="number">1</span>) <span class="comment">-- 返回0</span></span><br></pre></td></tr></table></figure>
<h3 id="isnotnull-a">isnotnull(a)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>如果参数a不为null，则返回true，否则返回false</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> isnotnull(<span class="number">1</span>) <span class="comment">-- 返回true</span></span><br><span class="line"><span class="keyword">select</span> isnotnull(<span class="keyword">null</span>) <span class="comment">-- 返回false</span></span><br></pre></td></tr></table></figure>
<h3 id="isnull-a">isnull(a)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>与isnotnull相反，如果参数a为null，则返回true，否则返回false</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> isnull(<span class="keyword">null</span>) <span class="comment">-- 返回true</span></span><br><span class="line"><span class="keyword">select</span> isnull(<span class="number">1</span>) <span class="comment">-- 返回false</span></span><br></pre></td></tr></table></figure>
<h3 id="nullif-a-b">nullif(a, b)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>如果参数a=b，返回null，否则返回a值(Hive2.2.0版本)</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">nullif</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">-- 返回1</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">nullif</span>(<span class="number">1</span>,<span class="number">1</span>) <span class="comment">-- 返回null</span></span><br></pre></td></tr></table></figure>
<h3 id="nvl-T-value-T-default-value">nvl(T value, T default_value)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>如果value的值为null，则返回default_value默认值，否则返回value的值。在null值判断时，可以使用if函数给定默认值，也可以使用此函数给定默认值，使用该函数sql特别简洁。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> nvl(<span class="number">1</span>,<span class="number">0</span>) <span class="comment">-- 返回1</span></span><br><span class="line"><span class="keyword">select</span> nvl(<span class="keyword">null</span>,<span class="number">0</span>) <span class="comment">-- 返回0</span></span><br></pre></td></tr></table></figure>
<h2 id="日期函数">日期函数</h2>
<h3 id="add-months-DATE-STRING-TIMESTAMP-start-date-INT-num-months">add_months(DATE|STRING|TIMESTAMP start_date, INT num_months)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>  start_date参数可以是string, date 或者timestamp类型，num_months参数时int类型。返回一个日期，该日期是在start_date基础之上加上num_months个月，即start_date之后null_months个月的一个日期。如果start_date的时间部分的数据会被忽略。注意：如果start_date所在月份的天数大于结果日期月的天数，则返回结果月的最后一天的日期。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> add_months(&quot;2020-05-20&quot;,<span class="number">2</span>); <span class="comment">-- 返回2020-07-20</span></span><br><span class="line"><span class="keyword">select</span> add_months(&quot;2020-05-20&quot;,<span class="number">8</span>); <span class="comment">-- 返回2021-01-20</span></span><br><span class="line"><span class="keyword">select</span> add_months(&quot;2020-05-31&quot;,<span class="number">1</span>); <span class="comment">-- 返回2020-06-30,5月有31天，6月只有30天，所以返回下一个月的最后一天</span></span><br></pre></td></tr></table></figure>
<h3 id="current-date">current_date</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回查询时刻的当前日期</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">current_date</span>() <span class="comment">-- 返回当前查询日期2020-05-20</span></span><br></pre></td></tr></table></figure>
<h3 id="current-timestamp">current_timestamp()</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回查询时刻的当前时间</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">current_timestamp</span>() <span class="comment">-- 2020-05-20 14:40:47.273</span></span><br></pre></td></tr></table></figure>
<h3 id="datediff-STRING-enddate-STRING-startdate">datediff(STRING enddate, STRING startdate)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回开始日期startdate与结束日期enddate之前相差的天数</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> datediff(&quot;2020-05-20&quot;,&quot;2020-05-21&quot;); <span class="comment">-- 返回-1</span></span><br><span class="line"><span class="keyword">select</span> datediff(&quot;2020-05-21&quot;,&quot;2020-05-20&quot;); <span class="comment">-- 返回1</span></span><br></pre></td></tr></table></figure>
<h3 id="date-add-DATE-startdate-INT-days">date_add(DATE startdate, INT days)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>在startdate基础上加上几天，然后返回加上几天之后的一个日期</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> date_add(&quot;2020-05-20&quot;,<span class="number">1</span>); <span class="comment">-- 返回2020-05-21,1表示加1天</span></span><br><span class="line"><span class="keyword">select</span> date_add(&quot;2020-05-20&quot;,<span class="number">-1</span>); <span class="comment">-- 返回2020-05-19，-1表示减一天</span></span><br></pre></td></tr></table></figure>
<h3 id="date-sub-DATE-startdate-INT-days">date_sub(DATE startdate, INT days)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>在startdate基础上减去几天，然后返回减去几天之后的一个日期,功能与date_add很类似</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> date_sub(&quot;2020-05-20&quot;,<span class="number">1</span>); <span class="comment">-- 返回2020-05-19,1表示减1天</span></span><br><span class="line"><span class="keyword">select</span> date_sub(&quot;2020-05-20&quot;,<span class="number">-1</span>); <span class="comment">-- 返回2020-05-21，-1表示加1天</span></span><br></pre></td></tr></table></figure>
<h3 id="date-format-DATE-TIMESTAMP-STRING-ts-STRING-fmt">date_format(DATE|TIMESTAMP|STRING ts, STRING fmt)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>将date/timestamp/string类型的值转换为一个具体格式化的字符串。支持java的SimpleDateFormat格式，第二个参数fmt必须是一个常量</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> date_format(<span class="string">&#x27;2020-05-20&#x27;</span>, <span class="string">&#x27;yyyy&#x27;</span>); <span class="comment">-- 返回2020</span></span><br><span class="line"><span class="keyword">select</span> date_format(<span class="string">&#x27;2020-05-20&#x27;</span>, <span class="string">&#x27;MM&#x27;</span>); <span class="comment">-- 返回05</span></span><br><span class="line"><span class="keyword">select</span> date_format(<span class="string">&#x27;2020-05-20&#x27;</span>, <span class="string">&#x27;dd&#x27;</span>); <span class="comment">-- 返回20</span></span><br><span class="line"><span class="comment">-- 返回2020年05月20日 00时00分00秒</span></span><br><span class="line"><span class="keyword">select</span> date_format(<span class="string">&#x27;2020-05-20&#x27;</span>, <span class="string">&#x27;yyyy年MM月dd日 HH时mm分ss秒&#x27;</span>) ;</span><br><span class="line"><span class="keyword">select</span> date_format(<span class="string">&#x27;2020-05-20&#x27;</span>, <span class="string">&#x27;yy/MM/dd&#x27;</span>) <span class="comment">-- 返回 20/05/20</span></span><br></pre></td></tr></table></figure>
<h3 id="dayofmonth-STRING-date">dayofmonth(STRING date)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回一个日期或时间的天,与day()函数功能相同</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> dayofmonth(<span class="string">&#x27;2020-05-20&#x27;</span>) <span class="comment">-- 返回20</span></span><br></pre></td></tr></table></figure>
<h3 id="extract-field-FROM-source">extract(field FROM source)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>  提取 day, dayofweek, hour, minute, month, quarter, second, week 或者year的值，field可以选择day, dayofweek, hour, minute, month, quarter, second, week 或者year，source必须是一个date、timestamp或者可以转为 date 、timestamp的字符串。注意：Hive 2.2.0版本之后支持该函数</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="string">&#x27;2020-05-20 15:21:34.467&#x27;</span>); <span class="comment">-- 返回2020，年</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(quarter <span class="keyword">from</span> <span class="string">&#x27;2020-05-20 15:21:34.467&#x27;</span>); <span class="comment">-- 返回2，季度</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(<span class="keyword">month</span> <span class="keyword">from</span> <span class="string">&#x27;2020-05-20 15:21:34.467&#x27;</span>); <span class="comment">-- 返回05，月份</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(week <span class="keyword">from</span> <span class="string">&#x27;2020-05-20 15:21:34.467&#x27;</span>); <span class="comment">-- 返回21，同weekofyear，一年中的第几周</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(dayofweek <span class="keyword">from</span> <span class="string">&#x27;2020-05-20 15:21:34.467&#x27;</span>); <span class="comment">-- 返回4,代表星期三</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(<span class="keyword">day</span> <span class="keyword">from</span> <span class="string">&#x27;2020-05-20 15:21:34.467&#x27;</span>); <span class="comment">-- 返回20，天</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(<span class="keyword">hour</span> <span class="keyword">from</span> <span class="string">&#x27;2020-05-20 15:21:34.467&#x27;</span>); <span class="comment">-- 返回15，小时</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(<span class="keyword">minute</span> <span class="keyword">from</span> <span class="string">&#x27;2020-05-20 15:21:34.467&#x27;</span>); <span class="comment">-- 返回21，分钟</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(<span class="keyword">second</span> <span class="keyword">from</span> <span class="string">&#x27;2020-05-20 15:21:34.467&#x27;</span>); <span class="comment">-- 返回34，秒</span></span><br></pre></td></tr></table></figure>
<h4 id="year-STRING-date">year(STRING date)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回时间的年份,可以用extract函数替代</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">year</span>(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>); <span class="comment">-- 返回2020</span></span><br></pre></td></tr></table></figure>
<h4 id="quarter-DATE-TIMESTAMP-STRING-a">quarter(DATE|TIMESTAMP|STRING a)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回给定时间或日期的季度，1至4个季度,可以用extract函数替代</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> quarter(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>); <span class="comment">-- 返回2，第2季度</span></span><br></pre></td></tr></table></figure>
<h4 id="month-STRING-date">month(STRING date)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回时间的月份,可以用extract函数替代</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">month</span>(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>) <span class="comment">-- 返回5</span></span><br></pre></td></tr></table></figure>
<h4 id="day-STRING-date">day(STRING date)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回一个日期或者时间的天,可以用extract函数替代</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">day</span>(&quot;2020-05-20&quot;); <span class="comment">-- 返回20</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">day</span>(&quot;2020-05-20 15:05:27.5&quot;); <span class="comment">-- 返回20</span></span><br></pre></td></tr></table></figure>
<h4 id="hour-STRING-date">hour(STRING date)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回一个时间的小时,可以用extract函数替代</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">hour</span>(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>);<span class="comment">-- 返回15</span></span><br></pre></td></tr></table></figure>
<h4 id="minute-STRING-date">minute(STRING date)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回一个时间的分钟值,可以用extract函数替代</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">minute</span>(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>); <span class="comment">-- 返回21</span></span><br></pre></td></tr></table></figure>
<h4 id="second-STRING-date">second(STRING date)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回一个时间的秒,可以用extract函数替代</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">second</span>(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>); <span class="comment">--返回34</span></span><br></pre></td></tr></table></figure>
<h3 id="from-unixtime-BIGINT-unixtime-STRING-format">from_unixtime(BIGINT unixtime [, STRING format])</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>将Unix时间戳转换为字符串格式的时间(比如yyyy-MM-dd HH:mm:ss格式)</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> from_unixtime(<span class="number">1589960708</span>); <span class="comment">-- 返回2020-05-20 15:45:08</span></span><br><span class="line"><span class="keyword">select</span> from_unixtime(<span class="number">1589960708</span>, <span class="string">&#x27;yyyy-MM-dd hh:mm:ss&#x27;</span>); <span class="comment">-- -- 返回2020-05-20 15:45:08</span></span><br><span class="line"><span class="keyword">select</span> from_unixtime(<span class="number">1589960708</span>, <span class="string">&#x27;yyyy-MM-dd&#x27;</span>); <span class="comment">-- 返回2020-05-20</span></span><br></pre></td></tr></table></figure>
<h3 id="from-utc-timestamp-T-a-STRING-timezone">from_utc_timestamp(T a, STRING timezone)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>转换为特定时区的时间</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> from_utc_timestamp(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>,<span class="string">&#x27;PST&#x27;</span>); <span class="comment">-- 返回2020-05-20 08:21:34.0</span></span><br><span class="line"><span class="keyword">select</span> from_utc_timestamp(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>,<span class="string">&#x27;GMT&#x27;</span>); <span class="comment">-- 返回2020-05-20 15:21:34.0</span></span><br><span class="line"><span class="keyword">select</span> from_utc_timestamp(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>,<span class="string">&#x27;UTC&#x27;</span>); <span class="comment">-- 返回2020-05-20 15:21:34.0</span></span><br><span class="line"><span class="keyword">select</span> from_utc_timestamp(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>,<span class="string">&#x27;DST&#x27;</span>); <span class="comment">-- 返回2020-05-20 15:21:34.0</span></span><br><span class="line"><span class="keyword">select</span> from_utc_timestamp(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>,<span class="string">&#x27;CST&#x27;</span>); <span class="comment">-- 返回2020-05-20 10:21:34.0</span></span><br></pre></td></tr></table></figure>
<h3 id="last-day-STRING-date">last_day(STRING date)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回给定时间或日期所在月的最后一天，参数可以是’yyyy-MM-dd HH:mm:ss’ 或者 ‘yyyy-MM-dd’类型，时间部分会被忽略</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> last_day(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>); <span class="comment">-- 返回2020-05-31</span></span><br><span class="line"><span class="keyword">select</span> last_day(<span class="string">&#x27;2020-05-20&#x27;</span>); <span class="comment">-- 返回2020-05-31</span></span><br></pre></td></tr></table></figure>
<h3 id="to-date-STRING-timestamp">to_date(STRING timestamp)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回一个字符串时间的日期部分，去掉时间部分，2.1.0之前版本返回的是string，2.1.0版本及之后返回的是date</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> to_date(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>); <span class="comment">-- 返回2020-05-20</span></span><br><span class="line"><span class="keyword">select</span> to_date(<span class="string">&#x27;2020-05-20&#x27;</span>); <span class="comment">-- 返回2020-05-20</span></span><br></pre></td></tr></table></figure>
<h3 id="to-utc-timestamp-T-a-STRING-timezone">to_utc_timestamp(T a, STRING timezone)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>转换为世界标准时间UTC的时间戳,与from_utc_timestamp类似</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> to_utc_timestamp(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>, <span class="string">&#x27;GMT&#x27;</span>); <span class="comment">-- 返回2020-05-20 15:21:34.0</span></span><br></pre></td></tr></table></figure>
<h3 id="trunc-STRING-date-STRING-format">trunc(STRING date, STRING format)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>截断日期到指定的日期精度，仅支持月（MONTH/MON/MM）或者年（YEAR/YYYY/YY）</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> trunc(<span class="string">&#x27;2020-05-20&#x27;</span>, <span class="string">&#x27;YY&#x27;</span>);   <span class="comment">-- 返回2020-01-01，返回年的1月1日</span></span><br><span class="line"><span class="keyword">select</span> trunc(<span class="string">&#x27;2020-05-20&#x27;</span>, <span class="string">&#x27;MM&#x27;</span>);   <span class="comment">-- 返回2020-05-01，返回月的第一天</span></span><br><span class="line"><span class="keyword">select</span> trunc(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>, <span class="string">&#x27;MM&#x27;</span>);   <span class="comment">-- 返回2020-05-01</span></span><br></pre></td></tr></table></figure>
<h3 id="unix-timestamp-STRING-date-STRING-pattern">unix_timestamp([STRING date [, STRING pattern]])</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>参数时可选的，当参数为空时，返回当前Unix是时间戳，精确到秒。可以指定一个具体的日期，转换为Unix时间戳格式</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 返回1589959294</span></span><br><span class="line"><span class="keyword">select</span> unix_timestamp(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>,<span class="string">&#x27;yyyy-MM-dd hh:mm:ss&#x27;</span>);</span><br><span class="line"><span class="comment">-- 返回1589904000</span></span><br><span class="line"><span class="keyword">select</span> unix_timestamp(<span class="string">&#x27;2020-05-20&#x27;</span>,<span class="string">&#x27;yyyy-MM-dd&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="weekofyear-STRING-date">weekofyear(STRING date)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回一个日期或时间在一年中的第几周，可以用extract替代</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> weekofyear(<span class="string">&#x27;2020-05-20 15:21:34&#x27;</span>); <span class="comment">-- 返回21，第21周</span></span><br><span class="line"><span class="keyword">select</span> weekofyear(<span class="string">&#x27;2020-05-20&#x27;</span>); <span class="comment">-- 返回21，第21周</span></span><br></pre></td></tr></table></figure>
<h3 id="next-day-STRING-start-date-STRING-day-of-week">next_day(STRING start_date, STRING day_of_week)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>参数start_date可以是一个时间或日期，day_of_week表示星期几，比如Mo表示星期一，Tu表示星期二，Wed表示星期三，Thur表示星期四，Fri表示星期五，Sat表示星期六，Sun表示星期日。如果指定的星期几在该日期所在的周且在该日期之后，则返回当周的星期几日期，如果指定的星期几不在该日期所在的周，则返回下一个星期几对应的日期</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> next_day(<span class="string">&#x27;2020-05-20&#x27;</span>,<span class="string">&#x27;Mon&#x27;</span>);<span class="comment">-- 返回当前日期的下一个周一日期:2020-05-25</span></span><br><span class="line"><span class="keyword">select</span> next_day(<span class="string">&#x27;2020-05-20&#x27;</span>,<span class="string">&#x27;Tu&#x27;</span>);<span class="comment">-- 返回当前日期的下一个周二日期:2020-05-26</span></span><br><span class="line"><span class="keyword">select</span> next_day(<span class="string">&#x27;2020-05-20&#x27;</span>,<span class="string">&#x27;Wed&#x27;</span>);<span class="comment">-- 返回当前日期的下一个周三日期:2020-05-27</span></span><br><span class="line"><span class="comment">-- 2020-05-20为周三，指定的参数为周四，所以返回当周的周四就是2020-05-21</span></span><br><span class="line"><span class="keyword">select</span> next_day(<span class="string">&#x27;2020-05-20&#x27;</span>,<span class="string">&#x27;Th&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> next_day(<span class="string">&#x27;2020-05-20&#x27;</span>,<span class="string">&#x27;Fri&#x27;</span>);<span class="comment">-- 返回周五日期2020-05-22</span></span><br><span class="line"><span class="keyword">select</span> next_day(<span class="string">&#x27;2020-05-20&#x27;</span>,<span class="string">&#x27;Sat&#x27;</span>); <span class="comment">-- 返回周六日期2020-05-23</span></span><br><span class="line"><span class="keyword">select</span> next_day(<span class="string">&#x27;2020-05-20&#x27;</span>,<span class="string">&#x27;Sun&#x27;</span>); <span class="comment">-- 返回周六日期2020-05-24</span></span><br></pre></td></tr></table></figure>
<p>该函数比较重要：比如取当前日期所在的周一和周日，通过长用在按周进行汇总数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> date_add(next_day(<span class="string">&#x27;2020-05-20&#x27;</span>,<span class="string">&#x27;MO&#x27;</span>),<span class="number">-7</span>); <span class="comment">-- 返回当前日期的周一日期2020-05-18</span></span><br><span class="line"><span class="keyword">select</span> date_add(next_day(<span class="string">&#x27;2020-05-20&#x27;</span>,<span class="string">&#x27;MO&#x27;</span>),<span class="number">-1</span>); <span class="comment">-- 返回当前日期的周日日期2020-05-24</span></span><br></pre></td></tr></table></figure>
<h3 id="months-between-DATE-TIMESTAMP-STRING-date1-…-date2">months_between(DATE|TIMESTAMP|STRING date1, … date2)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解释</p>
</li>
</ul>
<p>返回 date1 和 date2 的月份差。如果date1大于date2，返回正值，否则返回负值，如果是相减是整数月，则返回一个整数，否则会返回小数</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用案例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> months_between(<span class="string">&#x27;2020-05-20&#x27;</span>,<span class="string">&#x27;2020-05-20&#x27;</span>); <span class="comment">-- 返回0</span></span><br><span class="line"><span class="keyword">select</span> months_between(<span class="string">&#x27;2020-05-20&#x27;</span>,<span class="string">&#x27;2020-06-20&#x27;</span>); <span class="comment">-- 返回-1</span></span><br><span class="line"><span class="comment">-- 相差的整数月</span></span><br><span class="line"><span class="keyword">select</span> months_between(<span class="string">&#x27;2020-06-30&#x27;</span>,<span class="string">&#x27;2020-05-31&#x27;</span>); <span class="comment">-- 返回1</span></span><br><span class="line"><span class="comment">-- 非整数月，一个月差一天</span></span><br><span class="line"><span class="keyword">select</span> months_between(<span class="string">&#x27;2020-06-29&#x27;</span>,<span class="string">&#x27;2020-05-31&#x27;</span>); <span class="comment">-- 返回0.93548387</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>hive</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive常用查询函数</title>
    <url>/posts/682cece4.html</url>
    <content><![CDATA[<h2 id="1-空字段赋值NVL函数">1 空字段赋值NVL函数</h2>
<p>1.函数说明<br>
  NVL：给值为NULL的数据赋值，它的格式是NVL( string1, replace_with)。它的功能是如果string1为NULL，则NVL函数返回replace_with的值，否则返回string1的值，如果两个参数都为NULL ，则返回NULL。</p>
<p>2.数据准备：采用员工表</p>
<p>3.查询：如果员工的comm为NULL，则用-1代替</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; select nvl(comm,-1) from emp;</span><br></pre></td></tr></table></figure>
<p>4.查询：如果员工的comm为NULL，则用领导id代替</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; select nvl(comm,mgr) from emp;</span><br></pre></td></tr></table></figure>
<h2 id="2-CASE-WHEN函数">2.CASE WHEN函数</h2>
<ol>
<li class="lvl-3">
<p>数据准备</p>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">name</th>
<th style="text-align:center">dept_id</th>
<th style="text-align:center">sex</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">悟空</td>
<td style="text-align:center">A</td>
<td style="text-align:center">男</td>
</tr>
<tr>
<td style="text-align:center">大海</td>
<td style="text-align:center">A</td>
<td style="text-align:center">男</td>
</tr>
<tr>
<td style="text-align:center">宋宋</td>
<td style="text-align:center">B</td>
<td style="text-align:center">男</td>
</tr>
<tr>
<td style="text-align:center">凤姐</td>
<td style="text-align:center">A</td>
<td style="text-align:center">女</td>
</tr>
<tr>
<td style="text-align:center">婷姐</td>
<td style="text-align:center">B</td>
<td style="text-align:center">女</td>
</tr>
<tr>
<td style="text-align:center">婷婷</td>
<td style="text-align:center">B</td>
<td style="text-align:center">女</td>
</tr>
</tbody>
</table>
<p>2．需求求出不同部门男女各多少人。结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A     2       1</span><br><span class="line">B     1       2</span><br></pre></td></tr></table></figure>
<p>3．创建本地emp_sex.txt，导入数据<br>
[ihadu@hadoop102 datas]$ vi emp_sex.txt<br>
悟空	A	男大海	A	男宋宋	B	男凤姐	A	女婷姐	B	女婷婷	B	女</p>
<p>4．创建hive表并导入数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp_sex(</span><br><span class="line">name string,</span><br><span class="line">dept_id string,</span><br><span class="line">sex string)</span><br><span class="line"><span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> &quot;\t&quot;;</span><br><span class="line"></span><br><span class="line">load data <span class="keyword">local</span> inpath <span class="string">&#x27;/opt/module/datas/emp_sex.txt&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> emp_sex;</span><br></pre></td></tr></table></figure>
<p>5．按需求查询数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">  dept_id,</span><br><span class="line">  <span class="built_in">sum</span>(<span class="keyword">case</span> sex <span class="keyword">when</span> <span class="string">&#x27;男&#x27;</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) male_count,</span><br><span class="line">  <span class="built_in">sum</span>(<span class="keyword">case</span> sex <span class="keyword">when</span> <span class="string">&#x27;女&#x27;</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) female_count</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  emp_sex</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">  dept_id;</span><br></pre></td></tr></table></figure>
<h2 id="3-行转列">3.行转列</h2>
<p>1．相关函数说明<br>
  CONCAT(string A/col, string B/col…)：返回输入字符串连接后的结果，支持任意个输入字符串;<br>
  CONCAT_WS(separator, str1, str2,…)：它是一个特殊形式的 CONCAT()。第一个参数剩余参数间的分隔符。分隔符可以是与剩余参数一样的字符串。如果分隔符是 NULL，返回值也将为 NULL。这个函数会跳过分隔符参数后的任何 NULL 和空字符串。分隔符将被加到被连接的字符串之间;<br>
  COLLECT_SET(col)：函数只接受基本数据类型，它的主要作用是将某字段的值进行去重汇总，产生array类型字段。</p>
<p>2．数据准备</p>
<table>
<thead>
<tr>
<th style="text-align:center">name</th>
<th style="text-align:center">constellation</th>
<th style="text-align:center">blood_type</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">孙悟空</td>
<td style="text-align:center">白羊座</td>
<td style="text-align:center">A</td>
</tr>
<tr>
<td style="text-align:center">大海</td>
<td style="text-align:center">射手座</td>
<td style="text-align:center">A</td>
</tr>
<tr>
<td style="text-align:center">宋宋</td>
<td style="text-align:center">白羊座</td>
<td style="text-align:center">B</td>
</tr>
<tr>
<td style="text-align:center">猪八戒</td>
<td style="text-align:center">白羊座</td>
<td style="text-align:center">A</td>
</tr>
<tr>
<td style="text-align:center">凤姐</td>
<td style="text-align:center">射手座</td>
<td style="text-align:center">A</td>
</tr>
</tbody>
</table>
<p>3．需求把星座和血型一样的人归类到一起。结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">射手座,A            大海|凤姐</span><br><span class="line">白羊座,A            孙悟空|猪八戒</span><br><span class="line">白羊座,B            宋宋</span><br></pre></td></tr></table></figure>
<p>4．创建本地constellation.txt，导入数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ihadu@hadoop102 datas]$ vi person_info.txt</span><br><span class="line">孙悟空	白羊座	A</span><br><span class="line">大海	 射手座	A</span><br><span class="line">宋宋	 白羊座	B</span><br><span class="line">猪八戒   白羊座	A</span><br><span class="line">凤姐	  射手座	A</span><br></pre></td></tr></table></figure>
<p>5．创建hive表并导入数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> person_info(</span><br><span class="line">name string,</span><br><span class="line">constellation string,</span><br><span class="line">blood_type string)</span><br><span class="line"><span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> &quot;\t&quot;;</span><br><span class="line"></span><br><span class="line">load data <span class="keyword">local</span> inpath “<span class="operator">/</span>opt<span class="operator">/</span><span class="keyword">module</span><span class="operator">/</span>datas<span class="operator">/</span>person_info.txt” <span class="keyword">into</span> <span class="keyword">table</span> person_info;</span><br></pre></td></tr></table></figure>
<p>6．按需求查询数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    t1.base,</span><br><span class="line">    concat_ws(<span class="string">&#x27;|&#x27;</span>, collect_set(t1.name)) name</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span></span><br><span class="line">        name,</span><br><span class="line">        concat(constellation, &quot;,&quot;, blood_type) base</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">        person_info) t1</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">    t1.base;</span><br></pre></td></tr></table></figure>
<h2 id="4-列转行">4.列转行</h2>
<p>1．函数说明<br>
Explode(col)：将hive一列中复杂的array或者map结构拆分成多行。</p>
<p>Lateral view<br>
用法：LATERAL VIEW udtf(expression) tableAlias AS columnAlias<br>
解释：用于和split, explode等UDTF一起使用，它能够将一列数据拆成多行数据，在此基础上可以对拆分后的数据进行聚合。</p>
<p>2．数据准备</p>
<table>
<thead>
<tr>
<th style="text-align:center">movie</th>
<th style="text-align:center">category</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">《金刚川》</td>
<td style="text-align:center">悬疑,动作,科幻,剧情</td>
</tr>
<tr>
<td style="text-align:center">《我和我的家乡》</td>
<td style="text-align:center">悬疑,警匪,动作,心理,剧情</td>
</tr>
<tr>
<td style="text-align:center">《心灵奇旅》</td>
<td style="text-align:center">战争,动作,灾难</td>
</tr>
</tbody>
</table>
<p>3．需求将电影分类中的数组数据展开。结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">《金刚川》      悬疑</span><br><span class="line">《金刚川》      动作</span><br><span class="line">《金刚川》      科幻</span><br><span class="line">《金刚川》      剧情</span><br><span class="line">《我和我的家乡》   悬疑</span><br><span class="line">《我和我的家乡》   警匪</span><br><span class="line">《我和我的家乡》   动作</span><br><span class="line">《我和我的家乡》   心理</span><br><span class="line">《我和我的家乡》   剧情</span><br><span class="line">《心灵奇旅》      战争</span><br><span class="line">《心灵奇旅》      动作</span><br><span class="line">《心灵奇旅》      灾难</span><br></pre></td></tr></table></figure>
<p>4．创建本地movie.txt，导入数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ihadu@hadoop102 datas]$ vi movie.txt</span><br><span class="line">《疑犯追踪》	悬疑,动作,科幻,剧情</span><br><span class="line">《Lie to me》	悬疑,警匪,动作,心理,剧情</span><br><span class="line">《战狼2》	战争,动作,灾难</span><br></pre></td></tr></table></figure>
<p>5．创建hive表并导入数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> movie_info(</span><br><span class="line">    movie string,</span><br><span class="line">    category <span class="keyword">array</span><span class="operator">&lt;</span>string<span class="operator">&gt;</span>)</span><br><span class="line"><span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> &quot;\t&quot;</span><br><span class="line">collection items terminated <span class="keyword">by</span> &quot;,&quot;;</span><br><span class="line"></span><br><span class="line">load data <span class="keyword">local</span> inpath &quot;/opt/module/datas/movie.txt&quot; <span class="keyword">into</span> <span class="keyword">table</span> movie_info;</span><br></pre></td></tr></table></figure>
<p>6．按需求查询数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    movie,</span><br><span class="line">    category_name</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    movie_info <span class="keyword">lateral</span> <span class="keyword">view</span> explode(category) table_tmp <span class="keyword">as</span> category_name;</span><br></pre></td></tr></table></figure>
<h2 id="5-窗口函数">5.窗口函数</h2>
<p>1．相关函数说明<br>
OVER()：指定分析函数工作的数据窗口大小，这个数据窗口大小可能会随着行的变而变化<br>
CURRENT ROW：当前行<br>
n PRECEDING：往前n行数据<br>
n FOLLOWING：往后n行数据<br>
UNBOUNDED：起点，UNBOUNDED PRECEDING 表示从前面的起点， UNBOUNDED FOLLOWING表示到后面的终点<br>
LAG(col,n)：往前第n行数据<br>
LEAD(col,n)：往后第n行数据<br>
NTILE(n)：把有序分区中的行分发到指定数据的组中，各个组有编号，编号从1开始，对于每一行，NTILE返回此行所属的组的编号。注意：n必须为int类型。</p>
<p>2．数据准备：name，orderdate，cost</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jack,2017-01-01,10</span><br><span class="line">tony,2017-01-02,15</span><br><span class="line">jack,2017-02-03,23</span><br><span class="line">tony,2017-01-04,29</span><br><span class="line">jack,2017-01-05,46</span><br><span class="line">jack,2017-04-06,42</span><br><span class="line">tony,2017-01-07,50</span><br><span class="line">jack,2017-01-08,55</span><br><span class="line">mart,2017-04-08,62</span><br><span class="line">mart,2017-04-09,68</span><br><span class="line">neil,2017-05-10,12</span><br><span class="line">mart,2017-04-11,75</span><br><span class="line">neil,2017-06-12,80</span><br><span class="line">mart,2017-04-13,94</span><br></pre></td></tr></table></figure>
<p>3．需求（1）查询在2017年4月份购买过的顾客及总人数（2）查询顾客的购买明细及月购买总额（3）上述的场景,要将cost按照日期进行累加（4）查询顾客上次的购买时间（5）查询前20%时间的订单信息</p>
<p>4．创建本地business.txt，导入数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ihadu@hadoop102 datas]$ vi business.txt</span><br></pre></td></tr></table></figure>
<p>5．创建hive表并导入数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> business(</span><br><span class="line">name string,</span><br><span class="line">orderdate string,</span><br><span class="line">cost <span class="type">int</span></span><br><span class="line">) <span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line"></span><br><span class="line">load data <span class="keyword">local</span> inpath &quot;/opt/module/datas/business.txt&quot; <span class="keyword">into</span> <span class="keyword">table</span> business;</span><br></pre></td></tr></table></figure>
<p>6．按需求查询数据（1）查询在2017年4月份购买过的顾客及总人数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">over</span> ()</span><br><span class="line"><span class="keyword">from</span> business</span><br><span class="line"><span class="keyword">where</span> <span class="built_in">substring</span>(orderdate,<span class="number">1</span>,<span class="number">7</span>) <span class="operator">=</span> <span class="string">&#x27;2017-04&#x27;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> name;</span><br></pre></td></tr></table></figure>
<p>（2）查询顾客的购买明细及月购买总额</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">	name,</span><br><span class="line">	orderdate,</span><br><span class="line">	cost,</span><br><span class="line">	<span class="built_in">sum</span>(cost) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">month</span>(orderdate))</span><br><span class="line"><span class="keyword">from</span> business;</span><br></pre></td></tr></table></figure>
<p>（3）上述的场景,要将cost按照日期进行累加</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name,orderdate,cost,</span><br><span class="line"><span class="built_in">sum</span>(cost) <span class="keyword">over</span>() <span class="keyword">as</span> sample1,<span class="comment">--所有行相加</span></span><br><span class="line"><span class="built_in">sum</span>(cost) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> name) <span class="keyword">as</span> sample2,<span class="comment">--按name分组，组内数据相加</span></span><br><span class="line"><span class="built_in">sum</span>(cost) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> name <span class="keyword">order</span> <span class="keyword">by</span> orderdate) <span class="keyword">as</span> sample3,<span class="comment">--按name分组，组内数据累加</span></span><br><span class="line"><span class="built_in">sum</span>(cost) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> name <span class="keyword">order</span> <span class="keyword">by</span> orderdate <span class="keyword">rows</span> <span class="keyword">between</span> UNBOUNDED PRECEDING <span class="keyword">and</span> <span class="keyword">current</span> <span class="type">row</span> ) <span class="keyword">as</span> sample4 ,<span class="comment">--和sample3一样,由起点到当前行的聚合</span></span><br><span class="line"><span class="built_in">sum</span>(cost) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> name <span class="keyword">order</span> <span class="keyword">by</span> orderdate <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">1</span> PRECEDING <span class="keyword">and</span> <span class="keyword">current</span> <span class="type">row</span>) <span class="keyword">as</span> sample5, <span class="comment">--当前行和前面一行做聚合</span></span><br><span class="line"><span class="built_in">sum</span>(cost) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> name <span class="keyword">order</span> <span class="keyword">by</span> orderdate <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">1</span> PRECEDING <span class="keyword">AND</span> <span class="number">1</span> FOLLOWING ) <span class="keyword">as</span> sample6,<span class="comment">--当前行和前边一行及后面一行</span></span><br><span class="line"><span class="built_in">sum</span>(cost) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> name <span class="keyword">order</span> <span class="keyword">by</span> orderdate <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">current</span> <span class="type">row</span> <span class="keyword">and</span> UNBOUNDED FOLLOWING ) <span class="keyword">as</span> sample7 <span class="comment">--当前行及后面所有行</span></span><br><span class="line"><span class="keyword">from</span> business;</span><br></pre></td></tr></table></figure>
<p>（4）查看顾客上次的购买时间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name,orderdate,cost,</span><br><span class="line"><span class="built_in">lag</span>(orderdate,<span class="number">1</span>,<span class="string">&#x27;1900-01-01&#x27;</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> name <span class="keyword">order</span> <span class="keyword">by</span> orderdate ) <span class="keyword">as</span> time1,</span><br><span class="line"><span class="built_in">lag</span>(orderdate,<span class="number">2</span>) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> name <span class="keyword">order</span> <span class="keyword">by</span> orderdate) <span class="keyword">as</span> time2</span><br><span class="line"><span class="keyword">from</span> business;</span><br></pre></td></tr></table></figure>
<p>（5）查询前20%时间的订单信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> name,orderdate,cost, <span class="built_in">ntile</span>(<span class="number">5</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> orderdate) sorted</span><br><span class="line">    <span class="keyword">from</span> business</span><br><span class="line">) t</span><br><span class="line"><span class="keyword">where</span> sorted <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>6.Rank函数<br>
1．函数说明</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>RANK() 排序相同时会重复，总数不会变</p>
</li>
<li class="lvl-2">
<p>DENSE_RANK() 排序相同时会重复，总数会减少</p>
</li>
<li class="lvl-2">
<p>ROW_NUMBER() 会根据顺序计算</p>
</li>
</ul>
<p>2．数据准备</p>
<table>
<thead>
<tr>
<th style="text-align:center">name</th>
<th style="text-align:center">subject</th>
<th style="text-align:center">score</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">孙悟空</td>
<td style="text-align:center">语文</td>
<td style="text-align:center">87</td>
</tr>
<tr>
<td style="text-align:center">孙悟空</td>
<td style="text-align:center">数学</td>
<td style="text-align:center">95</td>
</tr>
<tr>
<td style="text-align:center">孙悟空</td>
<td style="text-align:center">英语</td>
<td style="text-align:center">68</td>
</tr>
<tr>
<td style="text-align:center">大海</td>
<td style="text-align:center">语文</td>
<td style="text-align:center">94</td>
</tr>
<tr>
<td style="text-align:center">大海</td>
<td style="text-align:center">数学</td>
<td style="text-align:center">56</td>
</tr>
<tr>
<td style="text-align:center">大海</td>
<td style="text-align:center">英语</td>
<td style="text-align:center">84</td>
</tr>
<tr>
<td style="text-align:center">宋宋</td>
<td style="text-align:center">语文</td>
<td style="text-align:center">64</td>
</tr>
<tr>
<td style="text-align:center">宋宋</td>
<td style="text-align:center">数学</td>
<td style="text-align:center">86</td>
</tr>
<tr>
<td style="text-align:center">宋宋</td>
<td style="text-align:center">英语</td>
<td style="text-align:center">84</td>
</tr>
<tr>
<td style="text-align:center">婷婷</td>
<td style="text-align:center">语文</td>
<td style="text-align:center">65</td>
</tr>
<tr>
<td style="text-align:center">婷婷</td>
<td style="text-align:center">数学</td>
<td style="text-align:center">85</td>
</tr>
<tr>
<td style="text-align:center">婷婷</td>
<td style="text-align:center">英语</td>
<td style="text-align:center">78</td>
</tr>
</tbody>
</table>
<p>3．需求计算每门学科成绩排名。</p>
<p>4．创建本地movie.txt，导入数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ihadu@hadoop102 datas]$ vi score.txt</span><br></pre></td></tr></table></figure>
<p>5．创建hive表并导入数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> score(</span><br><span class="line">name string,</span><br><span class="line">subject string, </span><br><span class="line">score <span class="type">int</span>) </span><br><span class="line"><span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> &quot;\t&quot;;</span><br><span class="line">load data <span class="keyword">local</span> inpath <span class="string">&#x27;/opt/module/datas/score.txt&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> score;</span><br></pre></td></tr></table></figure>
<p>6．按需求查询数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name,</span><br><span class="line">subject,</span><br><span class="line">score,</span><br><span class="line"><span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> subject <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) rp,</span><br><span class="line"><span class="built_in">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> subject <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) drp,</span><br><span class="line"><span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> subject <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) rmp</span><br><span class="line"><span class="keyword">from</span> score;</span><br></pre></td></tr></table></figure>
<p>查询结果：</p>
<pre><code class="language-shell">name    subject score   rp      drp     rmp
孙悟空  数学    95      1       1       1
宋宋    数学    86      2       2       2
婷婷    数学    85      3       3       3
大海    数学    56      4       4       4
宋宋    英语    84      1       1       1
大海    英语    84      1       1       2
婷婷    英语    78      3       2       3
孙悟空  英语    68      4       3       4
大海    语文    94      1       1       1
孙悟空  语文    87      2       2       2
婷婷    语文    65      3       3       3
宋宋    语文    64      4       4       4
</code></pre>
<blockquote>
<p>原文：<a href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>hive</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux环境下Hive的安装</title>
    <url>/posts/ca6cd067.html</url>
    <content><![CDATA[<h2 id="一、安装Hive">一、安装Hive</h2>
<h3 id="1-1-下载并解压">1.1 下载并解压</h3>
<p>下载所需版本的 Hive，这里我下载版本为 <code>cdh5.15.2</code>。下载地址：<a href="http://archive.cloudera.com/cdh5/cdh/5/">http://archive.cloudera.com/cdh5/cdh/5/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">下载后进行解压</span></span><br><span class="line"> tar -zxvf hive-1.1.0-cdh5.15.2.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="1-2-配置环境变量">1.2 配置环境变量</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">vim /etc/profile</span></span><br></pre></td></tr></table></figure>
<p>添加环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HIVE_HOME=/usr/app/hive-1.1.0-cdh5.15.2</span><br><span class="line">export PATH=$HIVE_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>使得配置的环境变量立即生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">source</span> /etc/profile</span></span><br></pre></td></tr></table></figure>
<h3 id="1-3-修改配置">1.3 修改配置</h3>
<p><strong>1. <a href="http://hive-env.sh">hive-env.sh</a></strong></p>
<p>进入安装目录下的 <code>conf/</code> 目录，拷贝 Hive 的环境配置模板 <code>flume-env.sh.template</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp hive-env.sh.template hive-env.sh</span><br></pre></td></tr></table></figure>
<p>修改 <code>hive-env.sh</code>，指定 Hadoop 的安装路径：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HADOOP_HOME=/usr/app/hadoop-2.6.0-cdh5.15.2</span><br></pre></td></tr></table></figure>
<p><strong>2. hive-site.xml</strong></p>
<p>新建 hive-site.xml 文件，内容如下，主要是配置存放元数据的 MySQL 的地址、驱动、用户名和密码等信息：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>jdbc:mysql://hadoop001:3306/hadoop_hive?createDatabaseIfNotExist=true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-4-拷贝数据库驱动">1.4 拷贝数据库驱动</h3>
<p>将 MySQL 驱动包拷贝到 Hive 安装目录的 <code>lib</code> 目录下, MySQL 驱动的下载地址为：<a href="https://dev.mysql.com/downloads/connector/j/">https://dev.mysql.com/downloads/connector/j/</a>  , 在本仓库的<a href="https://gitee.com/oicio/BigData-Notes/tree/master/resources">resources</a> 目录下我也上传了一份，有需要的可以自行下载。</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-mysql.png"/> </div>
<h3 id="1-5-初始化元数据库">1.5 初始化元数据库</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>当使用的 hive 是 1.x 版本时，可以不进行初始化操作，Hive 会在第一次启动的时候会自动进行初始化，但不会生成所有的元数据信息表，只会初始化必要的一部分，在之后的使用中用到其余表时会自动创建；</p>
</li>
<li class="lvl-2">
<p>当使用的 hive 是 2.x 版本时，必须手动初始化元数据库。初始化命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">schematool 命令在安装目录的 bin 目录下，由于上面已经配置过环境变量，在任意位置执行即可</span></span><br><span class="line">schematool -dbType mysql -initSchema</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里我使用的是 CDH 的 <code>hive-1.1.0-cdh5.15.2.tar.gz</code>，对应 <code>Hive 1.1.0</code> 版本，可以跳过这一步。</p>
<h3 id="1-6-启动">1.6 启动</h3>
<p>由于已经将 Hive 的 bin 目录配置到环境变量，直接使用以下命令启动，成功进入交互式命令行后执行 <code>show databases</code> 命令，无异常则代表搭建成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">hive</span></span><br></pre></td></tr></table></figure>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-install-2.png"/> </div>
<p>在 Mysql 中也能看到 Hive 创建的库和存放元数据信息的表</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-mysql-tables.png"/> </div>
<h2 id="二、HiveServer2-beeline">二、HiveServer2/beeline</h2>
<p>Hive 内置了 HiveServer 和 HiveServer2 服务，两者都允许客户端使用多种编程语言进行连接，但是 HiveServer 不能处理多个客户端的并发请求，因此产生了 HiveServer2。HiveServer2（HS2）允许远程客户端可以使用各种编程语言向 Hive 提交请求并检索结果，支持多客户端并发访问和身份验证。HS2 是由多个服务组成的单个进程，其包括基于 Thrift 的 Hive 服务（TCP 或 HTTP）和用于 Web UI 的 Jetty Web 服务。</p>
<p>HiveServer2 拥有自己的 CLI 工具——Beeline。Beeline 是一个基于 SQLLine 的 JDBC 客户端。由于目前 HiveServer2 是 Hive 开发维护的重点，所以官方更加推荐使用 Beeline 而不是 Hive CLI。以下主要讲解 Beeline 的配置方式。</p>
<h3 id="2-1-修改Hadoop配置">2.1 修改Hadoop配置</h3>
<p>修改 hadoop 集群的 core-site.xml 配置文件，增加如下配置，指定 hadoop 的 root 用户可以代理本机上所有的用户。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.proxyuser.root.hosts<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>*<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.proxyuser.root.groups<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>*<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>之所以要配置这一步，是因为 hadoop 2.0 以后引入了安全伪装机制，使得 hadoop 不允许上层系统（如 hive）直接将实际用户传递到 hadoop 层，而应该将实际用户传递给一个超级代理，由该代理在 hadoop 上执行操作，以避免任意客户端随意操作 hadoop。如果不配置这一步，在之后的连接中可能会抛出 <code>AuthorizationException</code> 异常。</p>
<blockquote>
<p>关于 Hadoop 的用户代理机制，可以参考：<a href="https://blog.csdn.net/u012948976/article/details/49904675#%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E8%A7%A3%E8%AF%BB">hadoop 的用户代理机制</a> 或 <a href="http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-common/Superusers.html">Superusers Acting On Behalf Of Other Users</a></p>
</blockquote>
<h3 id="2-2-启动hiveserver2">2.2 启动hiveserver2</h3>
<p>由于上面已经配置过环境变量，这里直接启动即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">nohup</span> hiveserver2 &amp;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-使用beeline">2.3 使用beeline</h3>
<p>可以使用以下命令进入 beeline 交互式命令行，出现 <code>Connected</code> 则代表连接成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">beeline -u jdbc:hive2://hadoop001:10000 -n root</span></span><br></pre></td></tr></table></figure>
<div align="center"> <img src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-beeline-cli.png"/> </div>
<blockquote>
<p>原文：<a href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>hive</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive的简介及核心概念</title>
    <url>/posts/43fb02f4.html</url>
    <content><![CDATA[<h2 id="一、简介-2">一、简介</h2>
<p>Hive 是一个构建在 Hadoop 之上的数据仓库，它可以将结构化的数据文件映射成表，并提供类 SQL 查询功能，用于查询的 SQL 语句会被转化为 MapReduce 作业，然后提交到 Hadoop 上运行。</p>
<p><strong>特点</strong>：</p>
<ol>
<li class="lvl-3">
<p>简单、容易上手 (提供了类似 sql 的查询语言 hql)，使得精通 sql 但是不了解 Java 编程的人也能很好地进行大数据分析；</p>
</li>
<li class="lvl-3">
<p>灵活性高，可以自定义用户函数 (UDF) 和存储格式；</p>
</li>
<li class="lvl-3">
<p>为超大的数据集设计的计算和存储能力，集群扩展容易;</p>
</li>
<li class="lvl-3">
<p>统一的元数据管理，可与 presto／impala／sparksql 等共享数据；</p>
</li>
<li class="lvl-3">
<p>执行延迟高，不适合做数据的实时处理，但适合做海量数据的离线处理。</p>
</li>
</ol>
<h2 id="二、Hive的体系架构">二、Hive的体系架构</h2>
<div align="center"> <img width="600px" src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive体系架构.png"/> </div>
<h3 id="2-1-command-line-shell-thrift-jdbc">2.1 command-line shell &amp; thrift/jdbc</h3>
<p>可以用 command-line shell 和 thrift／jdbc 两种方式来操作数据：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>command-line shell</strong>：通过 hive 命令行的的方式来操作数据；</p>
</li>
<li class="lvl-2">
<p><strong>thrift／jdbc</strong>：通过 thrift 协议按照标准的 JDBC 的方式操作数据。</p>
</li>
</ul>
<h3 id="2-2-Metastore">2.2 Metastore</h3>
<p>在 Hive 中，表名、表结构、字段名、字段类型、表的分隔符等统一被称为元数据。所有的元数据默认存储在 Hive 内置的 derby 数据库中，但由于 derby 只能有一个实例，也就是说不能有多个命令行客户端同时访问，所以在实际生产环境中，通常使用 MySQL 代替 derby。</p>
<p>Hive 进行的是统一的元数据管理，就是说你在 Hive 上创建了一张表，然后在 presto／impala／sparksql 中都是可以直接使用的，它们会从 Metastore 中获取统一的元数据信息，同样的你在 presto／impala／sparksql 中创建一张表，在 Hive 中也可以直接使用。</p>
<h3 id="2-3-HQL的执行流程">2.3 HQL的执行流程</h3>
<p>Hive 在执行一条 HQL 的时候，会经过以下步骤：</p>
<ol>
<li class="lvl-3">
<p>语法解析：Antlr 定义 SQL 的语法规则，完成 SQL 词法，语法解析，将 SQL 转化为抽象 语法树 AST Tree；</p>
</li>
<li class="lvl-3">
<p>语义解析：遍历 AST Tree，抽象出查询的基本组成单元 QueryBlock；</p>
</li>
<li class="lvl-3">
<p>生成逻辑执行计划：遍历 QueryBlock，翻译为执行操作树 OperatorTree；</p>
</li>
<li class="lvl-3">
<p>优化逻辑执行计划：逻辑层优化器进行 OperatorTree 变换，合并不必要的 ReduceSinkOperator，减少 shuffle 数据量；</p>
</li>
<li class="lvl-3">
<p>生成物理执行计划：遍历 OperatorTree，翻译为 MapReduce 任务；</p>
</li>
<li class="lvl-3">
<p>优化物理执行计划：物理层优化器进行 MapReduce 任务的变换，生成最终的执行计划。</p>
</li>
</ol>
<blockquote>
<p>关于 Hive SQL 的详细执行流程可以参考美团技术团队的文章：<a href="https://tech.meituan.com/2014/02/12/hive-sql-to-mapreduce.html">Hive SQL 的编译过程</a></p>
</blockquote>
<h2 id="三、数据类型">三、数据类型</h2>
<h3 id="3-1-基本数据类型">3.1 基本数据类型</h3>
<p>Hive 表中的列支持以下基本数据类型：</p>
<table>
<thead>
<tr>
<th>大类</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Integers（整型）</strong></td>
<td>TINYINT—1 字节的有符号整数 <br/>SMALLINT—2 字节的有符号整数<br/> INT—4 字节的有符号整数<br/> BIGINT—8 字节的有符号整数</td>
</tr>
<tr>
<td><strong>Boolean（布尔型）</strong></td>
<td>BOOLEAN—TRUE/FALSE</td>
</tr>
<tr>
<td><strong>Floating point numbers（浮点型）</strong></td>
<td>FLOAT— 单精度浮点型 <br/>DOUBLE—双精度浮点型</td>
</tr>
<tr>
<td><strong>Fixed point numbers（定点数）</strong></td>
<td>DECIMAL—用户自定义精度定点数，比如 DECIMAL(7,2)</td>
</tr>
<tr>
<td><strong>String types（字符串）</strong></td>
<td>STRING—指定字符集的字符序列<br/> VARCHAR—具有最大长度限制的字符序列 <br/>CHAR—固定长度的字符序列</td>
</tr>
<tr>
<td><strong>Date and time types（日期时间类型）</strong></td>
<td>TIMESTAMP —  时间戳 <br/>TIMESTAMP WITH LOCAL TIME ZONE — 时间戳，纳秒精度<br/> DATE—日期类型</td>
</tr>
<tr>
<td><strong>Binary types（二进制类型）</strong></td>
<td>BINARY—字节序列</td>
</tr>
</tbody>
</table>
<blockquote>
<p>TIMESTAMP 和 TIMESTAMP WITH LOCAL TIME ZONE 的区别如下：</p>
<ul class="lvl-1">
<li class="lvl-2"><strong>TIMESTAMP WITH LOCAL TIME ZONE</strong>：用户提交时间给数据库时，会被转换成数据库所在的时区来保存。查询时则按照查询客户端的不同，转换为查询客户端所在时区的时间。</li>
<li class="lvl-2"><strong>TIMESTAMP</strong> ：提交什么时间就保存什么时间，查询时也不做任何转换。</li>
</ul>
</blockquote>
<h3 id="3-2-隐式转换">3.2 隐式转换</h3>
<p>Hive 中基本数据类型遵循以下的层次结构，按照这个层次结构，子类型到祖先类型允许隐式转换。例如 INT 类型的数据允许隐式转换为 BIGINT 类型。额外注意的是：按照类型层次结构允许将 STRING 类型隐式转换为 DOUBLE 类型。</p>
<div align="center"> <img  src="https://oicio-picgo.oss-cn-hangzhou.aliyuncs.com/ihadu/img/hive-data-type.png"/> </div>
<h3 id="3-3-复杂类型">3.3 复杂类型</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>STRUCT</strong></td>
<td>类似于对象，是字段的集合，字段的类型可以不同，可以使用 <code>名称.字段名</code> 方式进行访问</td>
<td>STRUCT (‘xiaoming’, 12 , ‘2018-12-12’)</td>
</tr>
<tr>
<td><strong>MAP</strong></td>
<td>键值对的集合，可以使用 <code> 名称[key]</code> 的方式访问对应的值</td>
<td>map(‘a’, 1, ‘b’, 2)</td>
</tr>
<tr>
<td><strong>ARRAY</strong></td>
<td>数组是一组具有相同类型和名称的变量的集合，可以使用 <code> 名称[index]</code> 访问对应的值</td>
<td>ARRAY(‘a’, ‘b’, ‘c’, ‘d’)</td>
</tr>
</tbody>
</table>
<h3 id="3-4-示例">3.4 示例</h3>
<p>如下给出一个基本数据类型和复杂数据类型的使用示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students(</span><br><span class="line">  name      STRING,   <span class="comment">-- 姓名</span></span><br><span class="line">  age       <span class="type">INT</span>,      <span class="comment">-- 年龄</span></span><br><span class="line">  subject   <span class="keyword">ARRAY</span><span class="operator">&lt;</span>STRING<span class="operator">&gt;</span>,   <span class="comment">--学科</span></span><br><span class="line">  score     MAP<span class="operator">&lt;</span>STRING,<span class="type">FLOAT</span><span class="operator">&gt;</span>,  <span class="comment">--各个学科考试成绩</span></span><br><span class="line">  address   STRUCT<span class="operator">&lt;</span>houseNumber:<span class="type">int</span>, street:STRING, city:STRING, province：STRING<span class="operator">&gt;</span>  <span class="comment">--家庭居住地址</span></span><br><span class="line">) <span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> &quot;\t&quot;;</span><br></pre></td></tr></table></figure>
<h2 id="四、内容格式">四、内容格式</h2>
<p>当数据存储在文本文件中，必须按照一定格式区别行和列，如使用逗号作为分隔符的 CSV 文件 (Comma-Separated Values) 或者使用制表符作为分隔值的 TSV 文件 (Tab-Separated Values)。但此时也存在一个缺点，就是正常的文件内容中也可能出现逗号或者制表符。</p>
<p>所以 Hive 默认使用了几个平时很少出现的字符，这些字符一般不会作为内容出现在文件中。Hive 默认的行和列分隔符如下表所示。</p>
<table>
<thead>
<tr>
<th>分隔符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>\n</strong></td>
<td>对于文本文件来说，每行是一条记录，所以可以使用换行符来分割记录</td>
</tr>
<tr>
<td><strong>^A (Ctrl+A)</strong></td>
<td>分割字段 (列)，在 CREATE TABLE 语句中也可以使用八进制编码 <code>\001</code> 来表示</td>
</tr>
<tr>
<td><strong>^B</strong></td>
<td>用于分割 ARRAY 或者 STRUCT 中的元素，或者用于 MAP 中键值对之间的分割，<br/>在 CREATE TABLE 语句中也可以使用八进制编码 <code>\002</code> 表示</td>
</tr>
<tr>
<td><strong>^C</strong></td>
<td>用于 MAP 中键和值之间的分割，在 CREATE TABLE 语句中也可以使用八进制编码 <code>\003</code> 表示</td>
</tr>
</tbody>
</table>
<p>使用示例如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> page_view(viewTime <span class="type">INT</span>, userid <span class="type">BIGINT</span>)</span><br><span class="line"> <span class="type">ROW</span> FORMAT DELIMITED</span><br><span class="line">   FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\001&#x27;</span></span><br><span class="line">   COLLECTION ITEMS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\002&#x27;</span></span><br><span class="line">   MAP KEYS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\003&#x27;</span></span><br><span class="line"> STORED <span class="keyword">AS</span> SEQUENCEFILE;</span><br></pre></td></tr></table></figure>
<h2 id="五、存储格式">五、存储格式</h2>
<h3 id="5-1-支持的存储格式">5.1 支持的存储格式</h3>
<p>Hive 会在 HDFS 为每个数据库上创建一个目录，数据库中的表是该目录的子目录，表中的数据会以文件的形式存储在对应的表目录下。Hive 支持以下几种文件存储格式：</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>TextFile</strong></td>
<td>存储为纯文本文件。 这是 Hive 默认的文件存储格式。这种存储方式数据不做压缩，磁盘开销大，数据解析开销大。</td>
</tr>
<tr>
<td><strong>SequenceFile</strong></td>
<td>SequenceFile 是 Hadoop API 提供的一种二进制文件，它将数据以&lt;key,value&gt;的形式序列化到文件中。这种二进制文件内部使用 Hadoop 的标准的 Writable 接口实现序列化和反序列化。它与 Hadoop API 中的 MapFile 是互相兼容的。Hive 中的 SequenceFile 继承自 Hadoop API 的 SequenceFile，不过它的 key 为空，使用 value 存放实际的值，这样是为了避免 MR 在运行 map 阶段进行额外的排序操作。</td>
</tr>
<tr>
<td><strong>RCFile</strong></td>
<td>RCFile 文件格式是 FaceBook 开源的一种 Hive 的文件存储格式，首先将表分为几个行组，对每个行组内的数据按列存储，每一列的数据都是分开存储。</td>
</tr>
<tr>
<td><strong>ORC Files</strong></td>
<td>ORC 是在一定程度上扩展了 RCFile，是对 RCFile 的优化。</td>
</tr>
<tr>
<td><strong>Avro Files</strong></td>
<td>Avro 是一个数据序列化系统，设计用于支持大批量数据交换的应用。它的主要特点有：支持二进制序列化方式，可以便捷，快速地处理大量数据；动态语言友好，Avro 提供的机制使动态语言可以方便地处理 Avro 数据。</td>
</tr>
<tr>
<td><strong>Parquet</strong></td>
<td>Parquet 是基于 Dremel 的数据模型和算法实现的，面向分析型业务的列式存储格式。它通过按列进行高效压缩和特殊的编码技术，从而在降低存储空间的同时提高了 IO 效率。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>以上压缩格式中 ORC 和 Parquet 的综合性能突出，使用较为广泛，推荐使用这两种格式。</p>
</blockquote>
<h3 id="5-2-指定存储格式">5.2 指定存储格式</h3>
<p>通常在创建表的时候使用 <code>STORED AS</code> 参数指定：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> page_view(viewTime <span class="type">INT</span>, userid <span class="type">BIGINT</span>)</span><br><span class="line"> <span class="type">ROW</span> FORMAT DELIMITED</span><br><span class="line">   FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\001&#x27;</span></span><br><span class="line">   COLLECTION ITEMS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\002&#x27;</span></span><br><span class="line">   MAP KEYS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\003&#x27;</span></span><br><span class="line"> STORED <span class="keyword">AS</span> SEQUENCEFILE;</span><br></pre></td></tr></table></figure>
<p>各个存储文件类型指定方式如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>STORED AS TEXTFILE</p>
</li>
<li class="lvl-2">
<p>STORED AS SEQUENCEFILE</p>
</li>
<li class="lvl-2">
<p>STORED AS ORC</p>
</li>
<li class="lvl-2">
<p>STORED AS PARQUET</p>
</li>
<li class="lvl-2">
<p>STORED AS AVRO</p>
</li>
<li class="lvl-2">
<p>STORED AS RCFILE</p>
</li>
</ul>
<h2 id="六、内部表和外部表">六、内部表和外部表</h2>
<p>内部表又叫做管理表 (Managed/Internal Table)，创建表时不做任何指定，默认创建的就是内部表。想要创建外部表 (External Table)，则需要使用 External 进行修饰。 内部表和外部表主要区别如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>内部表</th>
<th>外部表</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据存储位置</td>
<td>内部表数据存储的位置由 hive.metastore.warehouse.dir 参数指定，默认情况下表的数据存储在 HDFS 的 <code>/user/hive/warehouse/数据库名.db/表名/</code>  目录下</td>
<td>外部表数据的存储位置创建表时由 <code>Location</code> 参数指定；</td>
</tr>
<tr>
<td>导入数据</td>
<td>在导入数据到内部表，内部表将数据移动到自己的数据仓库目录下，数据的生命周期由 Hive 来进行管理</td>
<td>外部表不会将数据移动到自己的数据仓库目录下，只是在元数据中存储了数据的位置</td>
</tr>
<tr>
<td>删除表</td>
<td>删除元数据（metadata）和文件</td>
<td>只删除元数据（metadata）</td>
</tr>
</tbody>
</table>
<blockquote>
<p>原文：<a href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a>                         |</p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>hive</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive自定义UDF函数</title>
    <url>/posts/f43f73d6.html</url>
    <content><![CDATA[<h3 id="1-Hive自定义函数介绍">1. Hive自定义函数介绍</h3>
<p>当Hive提供的内置函数无法满足你的业务处理需要时，此时可以考虑使用用户自定义函数（UDF: user-defined function）。<br>
Hive 中常用的UDF有如下三种:</p>
<ul class="lvl-0">
<li class="lvl-2">UDF<br>
一条记录使用函数后输出还是一条记录，比如:upper/substr;</li>
<li class="lvl-2">UDAF(User-Defined Aggregation Funcation)<br>
多条记录使用函数后输出还是一条记录，比如: count/max/min/sum/avg;</li>
<li class="lvl-2">UDTF(User-Defined Table-Generating Functions)<br>
一条记录使用函数后输出多条记录，比如: lateral view explore();</li>
</ul>
<h3 id="2-Hive自定义函数开发">2. Hive自定义函数开发</h3>
<p>需求:开发自定义函数，使得在指定字段前加上“Hello:”字样。Hive 中 UDF函数开发步骤:<br>
(1）继承UDF 类。<br>
(2）重写evaluate方法，该方法支持重载，每行记录执行一次evaluate方法。</p>
<h4 id="注意：">注意：</h4>
<p>1 UDF必须要有返回值,可以是null,但是不能为 void.<br>
2 推荐使用 Text/LongWritable等Hadoop的类型,而不是Java类型(当然使用 Java类型也是可以的)。</p>
<p>功能实现:</p>
<h5 id="添加依赖包。">添加依赖包。</h5>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hadoop.version</span>&gt;</span>2.6.0-cdh5.7.0<span class="tag">&lt;/<span class="name">hadoop.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hive.version</span>&gt;</span>1.1.0-cdh5.7.0<span class="tag">&lt;/<span class="name">hive.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--CDH 版本建议大家添加一个repository--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>cloudera<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repository.cloudera.com/artifactory/cloudera-repos/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Hadoop依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupld</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-common<span class="tag">&lt;/<span class="name">artifactld</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$ &#123;hadoop.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--Hive依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupld</span>&gt;</span>org.apache.hive<span class="tag">&lt;/<span class="name">groupld</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hive-exec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$ &#123; hive.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupld</span>&gt;</span>org.apacne.hive<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactld</span>&gt;</span>hive-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$ &#123; hive.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="开发UDF函数。">开发UDF函数。</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kgc.bigdata.hadoop.hive;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.exec.UDF;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*功能:输入xxx，输出:Hello: xxx</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*开发UDF 函数的步骤</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">* 1) extends UDF</span></span><br><span class="line"><span class="comment">*2）重写evaluate方法，注意该方法是支持重载的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloUDF</span> <span class="keyword">extends</span> <span class="title class_">UDF</span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*对于UDF 函数的evaluate的参数和返回值，个人建议使用Writable* <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Text <span class="title function_">evaluate</span><span class="params">(Text name)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot;Hello: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> Text <span class="title function_">evaluate</span><span class="params">(Text name,IntWritable age)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot;Hello: &quot;</span> +name + <span class="string">&quot; , age :&quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">/功能测试</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">HelloUDF</span> <span class="variable">udf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloUDF</span>(</span><br><span class="line">System.out.println(udf.evaluate(<span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot;zhangsan&quot;</span>)));</span><br><span class="line">System.out.println(udf.evaluate(<span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot;zhangsan&quot;</span>), <span class="keyword">new</span> <span class="title class_">IntWritable</span>(<span class="number">20</span>)));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3）编译jar包上传到服务器。<br>
(4)将自定义UDF 函数添加到Hive 中去。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">add JAR/home/hadoop/lib/hive-1.0.jar;</span><br><span class="line">create temporary function sayHello as &#x27;com.kgc.bigdata.hadoop.hive.HelloUDF&#x27;;</span><br></pre></td></tr></table></figure>
<p>(5)使用自定义函数。<br>
//通过show functions可以看到我们自定义的sayHello函数show functions;<br>
//将员工表的ename作为自定义UDF函数的参数值，即可查看到最终的输出结果</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> empno, ename, sayHello(ename) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/heibaiying/BigData-Notes">https://github.com/heibaiying/BigData-Notes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>hive</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Eclat算法</title>
    <url>/posts/4e5a78ed.html</url>
    <content><![CDATA[<h2 id="Eclat算法-Eclat-Algorithm">Eclat算法(Eclat Algorithm)</h2>
<p>Eclat算法是一种深度优先算法,采用垂直数据表示形式,在概念格理论的基础上利用基于前缀的等价关系将搜索空间(概念格)划分为较小的子空间(子概念格)。</p>
<h3 id="Eclat算法原理">Eclat算法原理</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>垂直数据表示</p>
</li>
</ul>
<p>支持度的计算需要访问数据库。在大多数算法中,考虑数据库中事务(即记录)的表示形式。从概念上讲,这样的数据库可以用一个二进制的二维矩阵来表示,矩阵的每一行代表数据库的一条事务,每一列代表项目。传统的数据挖掘算法多采用水平数据表示,在水平数据表示中,数据库的一条事务由事务标识符(TID)和项目组成。事务由TID唯一标识,一条事务可以包含一个项目或多个项目。Apriori、FP?Growth等算法都是采用此种表示方法。定义1(Tidset)?设有项目X,包含项目X的所有事务的标识符的集合称为项目X的Tidset。在这种数据表示方法中,数据库的事务由项目和该项目的Tidset组成,该事务由项目唯一标识。Tidset垂直数据表示:数据库中的每一条记录由一个项目及其所出现过的所有事务记录的列表(即Tidset表)构成。这样使得任何一个频繁项集的支持度计数都可以通过对Tidset交集运算求得。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>支持度计数方法</p>
</li>
</ul>
<p>Eclat算法采用方法二计算支持度。对候选k项集进行支持度计算时,不需再次扫描数据库,仅在一次扫描数据库后得到每个1项集的支持度,而候选k项集的支持度就是在对k-1项集进行交集操作后得到的该k项集Tidset中元素的个数。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>概念格理论</p>
</li>
</ul>
<p>Eclat算法在概念格理论的基础上,利用基于前缀的等价关系将搜索空间(概念格)划分为较小的子空间(子概念格),各子概念格采用自底向上的搜索方法独立产生频繁项集。</p>
<h3 id="eclat算法不足">eclat算法不足</h3>
<p>在Eclat算法中,它由2个集合的并集产生新的候选集,通过计算这2个项集的Tidset的交集快速得到候选集的支持度,因此,当Tidset的规模庞大时将出现以下问题:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>1.求Tidset的交集的操作将消耗大量时间,影响了算法的效率;</p>
</li>
<li class="lvl-2">
<p>2.Tidset的规模相当庞大,消耗系统大量的内存。</p>
</li>
</ul>
<h3 id="应用案例">应用案例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">tidlists = &#123;<span class="number">1</span>: &#123;&#125;&#125;;</span><br><span class="line">min_sup = <span class="built_in">float</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">min_conf = <span class="built_in">float</span>(sys.argv[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Reading dataset.&#x27;</span>)</span><br><span class="line">dataset = <span class="built_in">open</span>(sys.argv[<span class="number">3</span>])</span><br><span class="line">tid = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> dataset:</span><br><span class="line">    line = line.strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(line) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    items = line.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        item = (item,)</span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> tidlists[<span class="number">1</span>]:</span><br><span class="line">            tidlists[<span class="number">1</span>][item] = <span class="built_in">set</span>()</span><br><span class="line">        tidlists[<span class="number">1</span>][item].add(tid)</span><br><span class="line"></span><br><span class="line">    tid += <span class="number">1</span></span><br><span class="line">dataset.close()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Dataset reading done.&#x27;</span>)</span><br><span class="line">transactions = tid</span><br><span class="line">min_sup_count = min_sup * transactions</span><br><span class="line"></span><br><span class="line">n_items = <span class="built_in">len</span>(tidlists[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Number of items: &#123;&#125;.&#x27;</span>.<span class="built_in">format</span>(n_items))</span><br><span class="line"></span><br><span class="line">tidlists[<span class="number">1</span>] = &#123;k:v <span class="keyword">for</span> k,v <span class="keyword">in</span> tidlists[<span class="number">1</span>].items() <span class="keyword">if</span> <span class="built_in">len</span>(v) &gt;= min_sup_count&#125;</span><br><span class="line"></span><br><span class="line">n_frequent_items = <span class="built_in">len</span>(tidlists[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Number of requent items: &#123;&#125;. Removed &#123;&#125;.&#x27;</span>.<span class="built_in">format</span>(n_frequent_items, n_items - n_frequent_items))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">has_same_prefix</span>(<span class="params">itemset1, itemset2, n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">min</span>(<span class="built_in">len</span>(itemset1), <span class="built_in">len</span>(itemset2))):</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> itemset1[i] != itemset2[i]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eclat</span>():</span><br><span class="line">    k = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Searching for &#123;&#125;-itemsets.&#x27;</span>.<span class="built_in">format</span>(k))</span><br><span class="line">        tidlists[k] = &#123;&#125;</span><br><span class="line">        combination_counter = <span class="number">0</span></span><br><span class="line">        <span class="comment">#n_combinations = math.factorial(len(tidlists[k-1]))/(2 * math.factorial(len(tidlists[k-1])-2))</span></span><br><span class="line">        <span class="comment">#print(&#x27;Possible number of combinations: &#123;&#125;.&#x27;.format(n_combinations))</span></span><br><span class="line">        <span class="keyword">for</span> itemset1, itemset2 <span class="keyword">in</span> itertools.combinations(tidlists[k-<span class="number">1</span>].keys(), r=<span class="number">2</span>):</span><br><span class="line">            combination_counter += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> has_same_prefix(itemset1, itemset2, k-<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            tidlist1, tidlist2 = tidlists[k-<span class="number">1</span>][itemset1], tidlists[k-<span class="number">1</span>][itemset2]</span><br><span class="line">            intersection = tidlist1.intersection(tidlist2)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(intersection) &lt; min_sup_count:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            tidlists[k][<span class="built_in">tuple</span>(<span class="built_in">list</span>(itemset1) + [itemset2[<span class="built_in">len</span>(itemset2)-<span class="number">1</span>]])] = intersection</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(tidlists[k]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">del</span> tidlists[k]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Number of frequent &#123;&#125;-itemsets: &#123;&#125;.&#x27;</span>.<span class="built_in">format</span>(k, <span class="built_in">len</span>(tidlists[k])))</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    out = <span class="built_in">open</span>(sys.argv[<span class="number">4</span>], <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    <span class="comment"># Print results</span></span><br><span class="line">    out.write(<span class="string">&#x27;itemsets\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k):</span><br><span class="line">        <span class="comment">#print(&#x27;Frequent &#123;&#125;-itemsets&#x27;.format(i))</span></span><br><span class="line">        <span class="keyword">for</span> (itemset, tidlist) <span class="keyword">in</span> tidlists[i].items():</span><br><span class="line">            out.write(<span class="string">&#x27; &#x27;</span>.join(itemset1) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            out.write(<span class="built_in">str</span>(<span class="built_in">len</span>(tidlist)/transactions) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    out.write(<span class="string">&#x27;rules\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k):</span><br><span class="line">        <span class="comment">#print(&#x27;Frequent &#123;&#125;-itemsets&#x27;.format(i))</span></span><br><span class="line">        <span class="keyword">for</span> (itemset, tidlist) <span class="keyword">in</span> tidlists[i].items():</span><br><span class="line">            subsets = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(itemset)):</span><br><span class="line">                subsets = subsets + <span class="built_in">list</span>(itertools.combinations(itemset, j))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> subset <span class="keyword">in</span> subsets:</span><br><span class="line">                difference = <span class="built_in">set</span>(itemset).difference(subset)</span><br><span class="line">                confidence = <span class="built_in">len</span>(tidlist)/<span class="built_in">len</span>(tidlists[<span class="built_in">len</span>(subset)][<span class="built_in">tuple</span>(subset)])</span><br><span class="line">                <span class="keyword">if</span> confidence &lt; min_conf:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                out.write(<span class="string">&#x27; &#x27;</span>.join(subset) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                out.write(<span class="string">&#x27; &#x27;</span>.join(difference) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                out.write(<span class="built_in">str</span>(confidence) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    out.close()</span><br><span class="line">    </span><br><span class="line">eclat()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>关联规则学习算法</category>
      </categories>
      <tags>
        <tag>关联规则学习</tag>
      </tags>
  </entry>
  <entry>
    <title>FP-growth算法</title>
    <url>/posts/3441abb0.html</url>
    <content><![CDATA[<h2 id="FP-growth算法-FP-Growth-Algorithm">FP-growth算法(FP-Growth Algorithm)</h2>
<p>FP-growth算法是基于Apriori原理的，通过将数据集存储在FP（Frequent Pattern)树上发现频繁项集，但不能发现数据之间的关联规则。FP-growth算法只需要对数据库进行两次扫描，而Apriori算法在求每个潜在的频繁项集时都需要扫描一次数据集，所以说Apriori算法是高效的。其中算法发现频繁项集的过程是：</p>
<ul class="lvl-0">
<li class="lvl-2">1.构建FP树；</li>
<li class="lvl-2">2.从FP树中挖掘频繁项集。</li>
</ul>
<h3 id="构建FP树">构建FP树</h3>
<p>FP表示的是频繁模式，其通过链接来连接相似元素，被连起来的元素可以看成是一个链表。将事务数据表中的各个事务对应的数据项按照支持度排序后，把每个事务中的数据项按降序依次插入到一棵以 NULL为根节点的树中，同时在每个结点处记录该结点出现的支持度。</p>
<p>FP-growth算法的流程为：首先构造FP树，然后利用它来挖掘频繁项集。在构造FP树时，需要对数据集扫描两边，第一遍扫描用来统计频率，第二遍扫描至考虑频繁项集。下面举例对FP树加以说明。</p>
<p>假设存在的一个事务数据样例为,构建FP树的步骤如下：</p>
<table>
<thead>
<tr>
<th>事务ID</th>
<th>事务中的元素</th>
</tr>
</thead>
<tbody>
<tr>
<td>001</td>
<td>r,z,h,j,p</td>
</tr>
<tr>
<td>002</td>
<td>z,y,x,w,v,u,t,s</td>
</tr>
<tr>
<td>003</td>
<td>z</td>
</tr>
<tr>
<td>004</td>
<td>r,x,n,o,s</td>
</tr>
<tr>
<td>005</td>
<td>y,r,x,z,q,t,p</td>
</tr>
<tr>
<td>006</td>
<td>y,z,x,e,q,s,t,m</td>
</tr>
</tbody>
</table>
<p>结合Apriori算法中最小支持度的阈值，在此将最小支持度定义为3，结合上表中的数据，那些不满足最小支持度要求的将不会出现在最后的FP树中，据此构建FP树，并采用一个头指针表来指向给定类型的第一个实例，快速访问FP树中的所有元素，构建的带头指针的FP树如下:</p>
<p align="center">
<img width="300" align="center" src="/img/images/249.jpg" />
</p>
<p>结合绘制的带头指针表的FP树，对表中数据进行过滤，排序如下：</p>
<table>
<thead>
<tr>
<th>事务ID</th>
<th>事务ID</th>
<th>过滤和重排序后的事务</th>
</tr>
</thead>
<tbody>
<tr>
<td>001</td>
<td>r,z,h,j,p</td>
<td>z,r</td>
</tr>
<tr>
<td>002</td>
<td>z,y,x,w,v,u,t,s</td>
<td>z,x,y,s,t</td>
</tr>
<tr>
<td>003</td>
<td>z</td>
<td>z</td>
</tr>
<tr>
<td>004</td>
<td>r,x,n,o,s</td>
<td>x,s,r</td>
</tr>
<tr>
<td>005</td>
<td>y,r,x,z,q,t,p</td>
<td>z,x,y,r,t</td>
</tr>
<tr>
<td>006</td>
<td>y,z,x,e,q,s,t,m</td>
<td>z,x,y,s,t</td>
</tr>
</tbody>
</table>
<p>在对数据项过滤排序了之后，就可以构建FP树了，从NULL开始，向其中不断添加过滤排序后的频繁项集。过程可表示为：</p>
<p align="center">
<img width="300" align="center" src="/img/images/250.jpg" />
</p>
<p>因而我们可以实现FP树的构建，我们知道，在第二次扫描数据集时会构建一棵FP树，并采用一个容器来保存树。首先创建一个类来保存树的每一个节点：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">treeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nameValue, numOccur, parentNode</span>):</span><br><span class="line">        self.name = nameValue</span><br><span class="line">        self.count = numOccur</span><br><span class="line">        self.nodeLink = <span class="literal">None</span></span><br><span class="line">        self.parent = parentNode      <span class="comment">#needs to be updated</span></span><br><span class="line">        self.children = &#123;&#125; </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inc</span>(<span class="params">self,numOccur</span>):</span><br><span class="line">        self.count += numOccur</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">disp</span>(<span class="params">self,ind = <span class="number">1</span></span>):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27; &#x27;</span>*ind,self.name,<span class="string">&#x27; &#x27;</span>,self.count</span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> self.children.values():</span><br><span class="line">            child.disp(ind+<span class="number">1</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">#test</span></span><br><span class="line"><span class="string">rootNode = treeNode(&#x27;pyramid&#x27;,9,None)</span></span><br><span class="line"><span class="string">rootNode.children[&#x27;eye&#x27;] = treeNode(&#x27;eye&#x27;,13,None)</span></span><br><span class="line"><span class="string">a = rootNode.disp()</span></span><br><span class="line"><span class="string">print a</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p align="center">
<img width="500" align="center" src="/img/images/251.jpg" />
</p>
<p>这样，FP树对应的数据结构就建好了，现在就可以构建FP树了，FP树的构建函数如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#FP构建函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createTree</span>(<span class="params">dataSet,minSup = <span class="number">1</span></span>):</span><br><span class="line">    headerTable = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> trans <span class="keyword">in</span> dataSet:</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> trans:</span><br><span class="line">            headerTable[item] = headerTable.get(item,<span class="number">0</span>) + dataSet[trans]<span class="comment">#记录每个元素项出现的频度</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> headerTable.keys():</span><br><span class="line">        <span class="keyword">if</span> headerTable[k] &lt; minSup:</span><br><span class="line">            <span class="keyword">del</span>(headerTable[k])</span><br><span class="line">    freqItemSet = <span class="built_in">set</span>(headerTable.keys())</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(freqItemSet) == <span class="number">0</span>:<span class="comment">#不满足最小值支持度要求的除去</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>,<span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> headerTable:</span><br><span class="line">        headerTable[k] = [headerTable[k],<span class="literal">None</span>]</span><br><span class="line">    retTree = treeNode(<span class="string">&#x27;Null Set&#x27;</span>,<span class="number">1</span>,<span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">for</span> tranSet,count <span class="keyword">in</span> dataSet.items():</span><br><span class="line">        localD = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> tranSet:</span><br><span class="line">            <span class="keyword">if</span> item <span class="keyword">in</span> freqItemSet:</span><br><span class="line">                localD[item] = headerTable[item][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(localD) &gt; <span class="number">0</span>:</span><br><span class="line">            orderedItems = [v[<span class="number">0</span>] <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">sorted</span>(localD.items(),key = <span class="keyword">lambda</span> p:p[<span class="number">1</span>],reverse = <span class="literal">True</span>)]</span><br><span class="line">            updateTree(orderedItems,retTree,headerTable,count)</span><br><span class="line">    <span class="keyword">return</span> retTree,headerTable</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">updateTree</span>(<span class="params">items, inTree, headerTable, count</span>):</span><br><span class="line">    <span class="keyword">if</span> items[<span class="number">0</span>] <span class="keyword">in</span> inTree.children:</span><br><span class="line">        inTree.children[items[<span class="number">0</span>]].inc(count) </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        inTree.children[items[<span class="number">0</span>]] = treeNode(items[<span class="number">0</span>], count, inTree)</span><br><span class="line">        <span class="keyword">if</span> headerTable[items[<span class="number">0</span>]][<span class="number">1</span>] == <span class="literal">None</span>:</span><br><span class="line">            headerTable[items[<span class="number">0</span>]][<span class="number">1</span>] = inTree.children[items[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            updateHeader(headerTable[items[<span class="number">0</span>]][<span class="number">1</span>], inTree.children[items[<span class="number">0</span>]])</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(items) &gt; <span class="number">1</span>:</span><br><span class="line">        updateTree(items[<span class="number">1</span>::], inTree.children[items[<span class="number">0</span>]], headerTable, count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">updateHeader</span>(<span class="params">nodeToTest, targetNode</span>):   </span><br><span class="line">    <span class="keyword">while</span> (nodeToTest.nodeLink != <span class="literal">None</span>):</span><br><span class="line">        nodeToTest = nodeToTest.nodeLink</span><br><span class="line">    nodeToTest.nodeLink = targetNode</span><br></pre></td></tr></table></figure>
<p>在应用示例之前还需要一个真正的数据集，结合之前的数据自定义数据集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">loadSimpDat</span>():</span><br><span class="line">    simpDat = [[<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;p&#x27;</span>],</span><br><span class="line">               [<span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;s&#x27;</span>],</span><br><span class="line">               [<span class="string">&#x27;z&#x27;</span>],</span><br><span class="line">               [<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;s&#x27;</span>],</span><br><span class="line">               [<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;p&#x27;</span>],</span><br><span class="line">               [<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;m&#x27;</span>]]</span><br><span class="line">    <span class="keyword">return</span> simpDat</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createInitSet</span>(<span class="params">dataSet</span>):</span><br><span class="line">    retDict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> trans <span class="keyword">in</span> dataSet:</span><br><span class="line">        retDict[<span class="built_in">frozenset</span>(trans)] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> retDict</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">simpDat = loadSimpDat()</span><br><span class="line">initSet  = createInitSet(simpDat)</span><br><span class="line">myFPtree,myHeaderTab = createTree(initSet,<span class="number">3</span>)</span><br><span class="line">a = myFPtree.disp()</span><br><span class="line"><span class="built_in">print</span> a</span><br></pre></td></tr></table></figure>
<p>这样就构建了FP树，接下来就是使用它来进行频繁项集的挖掘。</p>
<h3 id="从FP树中挖掘频繁项集">从FP树中挖掘频繁项集</h3>
<p>在构建了FP树之后，就可以抽取频繁项集了，这里的思想和Apriori算法大致类似，首先从氮元素项集合开始，然后在此基础上逐步构建更大的集合。大致分为三个步骤：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>1.从FP树中获得条件模式基；</p>
</li>
<li class="lvl-2">
<p>2.利用条件模式基，构建一个条件FP树；</p>
</li>
<li class="lvl-2">
<p>3.迭代重复1和2，直到树包含一个元素项为止。首先，获取条件模式基。条件模式基是以所查找元素项为结尾的路径集合，表示的是所查找的元素项与树根节点之间的所有内容。结合构建FP树绘制的图，r的前缀路径就是{x,s}、{z,x,y}和{z},其中的每条前缀路径都与一个计数值有关，该计数值表示的是每条路径上r的数目。为了得到这些前缀路径，结合之前所得到的头指针表，头指针表中包含相同类型元素链表的起始指针，根据每一个元素项都可以上溯到这棵树直到根节点为止。该过程对应的如下：</p>
</li>
</ul>
<p align="center">
<img width="500" align="center" src="/img/images/252.jpg" />
</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ascendTree</span>(<span class="params">leafNode, prefixPath</span>): <span class="comment">#ascends from leaf node to root</span></span><br><span class="line">    <span class="keyword">if</span> leafNode.parent != <span class="literal">None</span>:</span><br><span class="line">        prefixPath.append(leafNode.name)</span><br><span class="line">        ascendTree(leafNode.parent, prefixPath)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">findPrefixPath</span>(<span class="params">basePat, treeNode</span>): <span class="comment">#treeNode comes from header table</span></span><br><span class="line">    condPats = &#123;&#125;</span><br><span class="line">    <span class="keyword">while</span> treeNode != <span class="literal">None</span>:</span><br><span class="line">        prefixPath = []</span><br><span class="line">        ascendTree(treeNode, prefixPath)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(prefixPath) &gt; <span class="number">1</span>: </span><br><span class="line">            condPats[<span class="built_in">frozenset</span>(prefixPath[<span class="number">1</span>:])] = treeNode.count</span><br><span class="line">        treeNode = treeNode.nodeLink</span><br><span class="line">    <span class="keyword">return</span> condPats</span><br><span class="line"></span><br><span class="line"><span class="comment">#test</span></span><br><span class="line">simpDat = loadSimpDat()</span><br><span class="line">initSet  = createInitSet(simpDat)</span><br><span class="line">myFPtree,myHeaderTab = createTree(initSet,<span class="number">3</span>)</span><br><span class="line">a = myFPtree.disp()</span><br><span class="line">b = findPrefixPath(<span class="string">&#x27;x&#x27;</span>,myHeaderTab[<span class="string">&#x27;x&#x27;</span>][<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span> b</span><br></pre></td></tr></table></figure>
<p>运行示例，与所给数据一致。接下来就可以创建条件FP树了。对于每一个频繁项，都需要创建一棵条件FP树，使用刚才创建的条件模式基作为输入，采用相同的建树代码来构建树，相应的递归发现频繁项、发现条件模式基和另外的条件树。对应的递归查找频繁项集的函数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mineTree</span>(<span class="params">inTree, headerTable, minSup, preFix, freqItemList</span>):</span><br><span class="line">    bigL = [v[<span class="number">0</span>] <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">sorted</span>(headerTable.items(), key=<span class="keyword">lambda</span> p: p[<span class="number">1</span>])]<span class="comment">#(sort header table)</span></span><br><span class="line">    <span class="keyword">for</span> basePat <span class="keyword">in</span> bigL:</span><br><span class="line">        newFreqSet = preFix.copy()</span><br><span class="line">        newFreqSet.add(basePat)</span><br><span class="line">        freqItemList.append(newFreqSet)</span><br><span class="line">        condPattBases = findPrefixPath(basePat, headerTable[basePat][<span class="number">1</span>])</span><br><span class="line">        myCondTree, myHead = createTree(condPattBases, minSup)</span><br><span class="line">        <span class="keyword">if</span> myHead != <span class="literal">None</span>:            </span><br><span class="line">            mineTree(myCondTree, myHead, minSup, newFreqSet, freqItemList)</span><br></pre></td></tr></table></figure>
<p>结合之前的数据验证发现没有错误。</p>
<h3 id="应用示例">应用示例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -* </span></span><br><span class="line"><span class="comment"># 树节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">treeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nameValue, numOccur, parentNode</span>):</span><br><span class="line">        self.name = nameValue</span><br><span class="line">        self.count = numOccur         <span class="comment"># 计数值</span></span><br><span class="line">        self.nodeLink = <span class="literal">None</span>          <span class="comment"># 连接相似变量</span></span><br><span class="line">        self.parent = parentNode      <span class="comment">#needs to be updated</span></span><br><span class="line">        self.children = &#123;&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inc</span>(<span class="params">self, numOccur</span>):</span><br><span class="line">        self.count += numOccur</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归输出树节点</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">disp</span>(<span class="params">self, ind=<span class="number">1</span></span>):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;  &#x27;</span>*ind, self.name, <span class="string">&#x27; &#x27;</span>, self.count</span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> self.children.values():</span><br><span class="line">            child.disp(ind+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据 dataSet 创建 FP-growth 树</span></span><br><span class="line"><span class="comment"># 参数 minSup 指的是最小支持度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createTree</span>(<span class="params">dataSet, minSup=<span class="number">1</span></span>): </span><br><span class="line">    headerTable = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历所有元素项, 记录其出现次数</span></span><br><span class="line">    <span class="comment"># 内容类似为 &#123;&#x27;t&#x27;: 3, &#x27;w&#x27;: 1, &#x27;v&#x27;: 1, &#x27;y&#x27;: 3, &#x27;x&#x27;: 4, &#x27;z&#x27;: 5&#125;</span></span><br><span class="line">    <span class="keyword">for</span> trans <span class="keyword">in</span> dataSet:</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> trans:</span><br><span class="line">            headerTable[item] = headerTable.get(item, <span class="number">0</span>) + dataSet[trans]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 移除未达到最小支持度的元素项</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> headerTable.keys():  </span><br><span class="line">        <span class="keyword">if</span> headerTable[k] &lt; minSup: </span><br><span class="line">            <span class="keyword">del</span>(headerTable[k])</span><br><span class="line"></span><br><span class="line">    freqItemSet = <span class="built_in">set</span>(headerTable.keys())</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(freqItemSet) == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">None</span>  <span class="comment"># 没有达到最小支持度的元素项, 返回</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 格式化后格式为: </span></span><br><span class="line">    <span class="comment"># &#123;&#x27;t&#x27;: [3, None], &#x27;y&#x27;: [3, None], &#x27;x&#x27;: [4, None], &#x27;z&#x27;: [5, None]&#125;</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> headerTable:</span><br><span class="line">        headerTable[k] = [headerTable[k], <span class="literal">None</span>] </span><br><span class="line"></span><br><span class="line">    retTree = treeNode(<span class="string">&#x27;Null Set&#x27;</span>, <span class="number">1</span>, <span class="literal">None</span>)     <span class="comment"># 只包含空值的根节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> tranSet, count <span class="keyword">in</span> dataSet.items():      <span class="comment"># count 都初始化为 1</span></span><br><span class="line">        localD = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> tranSet:                    <span class="comment"># 取满足最小支持度的元素项</span></span><br><span class="line">            <span class="keyword">if</span> item <span class="keyword">in</span> freqItemSet:</span><br><span class="line">                localD[item] = headerTable[item][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对每个项集中的元素项, 按支持度从大到小排序</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(localD) &gt; <span class="number">0</span>:</span><br><span class="line">            orderedItems = [v[<span class="number">0</span>] <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">sorted</span>(localD.items(), </span><br><span class="line">                            key=<span class="keyword">lambda</span> p: p[<span class="number">1</span>], reverse=<span class="literal">True</span>)]</span><br><span class="line">            updateTree(orderedItems, retTree, headerTable, count)   <span class="comment"># 填充树</span></span><br><span class="line">    <span class="keyword">return</span> retTree, headerTable                 <span class="comment"># 返回树与各个元素的头指针</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 items 使树生长, FP-growth 的来历</span></span><br><span class="line"><span class="comment"># inTree 为树的根节点</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">updateTree</span>(<span class="params">items, inTree, headerTable, count</span>):</span><br><span class="line">    <span class="comment"># 如果 items 的第一个元素是 树的第一层子节点, 则将此子节点对应的计算 加1</span></span><br><span class="line">    <span class="keyword">if</span> items[<span class="number">0</span>] <span class="keyword">in</span> inTree.children:</span><br><span class="line">        inTree.children[items[<span class="number">0</span>]].inc(count) </span><br><span class="line">    <span class="keyword">else</span>:   <span class="comment"># 如果此节点不存在, 则给树添加新子节点</span></span><br><span class="line">        inTree.children[items[<span class="number">0</span>]] = treeNode(items[<span class="number">0</span>], count, inTree)</span><br><span class="line">        <span class="comment"># 更新头指针表</span></span><br><span class="line">        <span class="keyword">if</span> headerTable[items[<span class="number">0</span>]][<span class="number">1</span>] == <span class="literal">None</span>: </span><br><span class="line">            headerTable[items[<span class="number">0</span>]][<span class="number">1</span>] = inTree.children[items[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            updateHeader(headerTable[items[<span class="number">0</span>]][<span class="number">1</span>], inTree.children[items[<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对除去第一个元素之外的 items 递归建树</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(items) &gt; <span class="number">1</span>:</span><br><span class="line">        updateTree(items[<span class="number">1</span>::], inTree.children[items[<span class="number">0</span>]], headerTable, count)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新头指针链表, targetNode 接到 nodeToTest 所指链表的最后</span></span><br><span class="line"><span class="comment"># 这里不用递归, 因为递归在链表长度过长时, 可能会栈溢出</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">updateHeader</span>(<span class="params">nodeToTest, targetNode</span>):   </span><br><span class="line">    <span class="keyword">while</span> (nodeToTest.nodeLink != <span class="literal">None</span>):    </span><br><span class="line">        nodeToTest = nodeToTest.nodeLink</span><br><span class="line">    nodeToTest.nodeLink = targetNode</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代上溯整棵树</span></span><br><span class="line"><span class="comment"># 即将叶节点到根节点的所有元素都存到 prefixPath 中</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ascendTree</span>(<span class="params">leafNode, prefixPath</span>): </span><br><span class="line">    <span class="keyword">if</span> leafNode.parent != <span class="literal">None</span>:</span><br><span class="line">        prefixPath.append(leafNode.name)</span><br><span class="line">        ascendTree(leafNode.parent, prefixPath)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按给定元素项生成一个条件模式基</span></span><br><span class="line"><span class="comment"># 遍历头指针链表, 对每一个元素都向根节点上溯, 记录找到的前缀式及元素出现次数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">findPrefixPath</span>(<span class="params">basePat, treeNode</span>): <span class="comment">#treeNode comes from header table</span></span><br><span class="line">    condPats = &#123;&#125;</span><br><span class="line">    <span class="comment"># 遍历以 treeNode 为头节点的头指针链表</span></span><br><span class="line">    <span class="keyword">while</span> treeNode != <span class="literal">None</span>:</span><br><span class="line">        prefixPath = []</span><br><span class="line">        ascendTree(treeNode, prefixPath)</span><br><span class="line">        <span class="comment"># 保存前缀及其次数</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(prefixPath) &gt; <span class="number">1</span>: </span><br><span class="line">            condPats[<span class="built_in">frozenset</span>(prefixPath[<span class="number">1</span>:])] = treeNode.count</span><br><span class="line">        treeNode = treeNode.nodeLink</span><br><span class="line">    <span class="keyword">return</span> condPats</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归查找频繁项集</span></span><br><span class="line"><span class="comment"># 参 freqItemList 返回频繁项集列表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mineTree</span>(<span class="params">inTree, headerTable, minSup, preFix, freqItemList</span>):</span><br><span class="line">    <span class="comment"># 头指针按其元素项出现的频率从小到大进行排序</span></span><br><span class="line">    bigL = [v[<span class="number">0</span>] <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">sorted</span>(headerTable.items(), key=<span class="keyword">lambda</span> p: p[<span class="number">1</span>])]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> basePat <span class="keyword">in</span> bigL:  <span class="comment">#start from bottom of header table</span></span><br><span class="line">        newFreqSet = preFix.copy()   <span class="comment"># 生成一个频繁项集</span></span><br><span class="line">        newFreqSet.add(basePat)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创造条件基</span></span><br><span class="line">        freqItemList.append(newFreqSet)  <span class="comment"># 繁频项集添加到参数中, 以待最后返回</span></span><br><span class="line">        condPattBases = findPrefixPath(basePat, headerTable[basePat][<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建条件 FP 树</span></span><br><span class="line">        myCondTree, myHead = createTree(condPattBases, minSup)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归挖掘条件 FP 树</span></span><br><span class="line">        <span class="keyword">if</span> myHead != <span class="literal">None</span>:</span><br><span class="line">            mineTree(myCondTree, myHead, minSup, newFreqSet, freqItemList)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loadSimpDat</span>():</span><br><span class="line">    simpDat = [[<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;p&#x27;</span>],</span><br><span class="line">               [<span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;s&#x27;</span>],</span><br><span class="line">               [<span class="string">&#x27;z&#x27;</span>],</span><br><span class="line">               [<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;s&#x27;</span>],</span><br><span class="line">               [<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;p&#x27;</span>],</span><br><span class="line">               [<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;m&#x27;</span>]]</span><br><span class="line">    <span class="keyword">return</span> simpDat</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化每个项集的次数为 1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createInitSet</span>(<span class="params">dataSet</span>):</span><br><span class="line">    retDict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> trans <span class="keyword">in</span> dataSet:</span><br><span class="line">        retDict[<span class="built_in">frozenset</span>(trans)] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> retDict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 建树</span></span><br><span class="line">    simpDat = loadSimpDat()</span><br><span class="line">    initSet = createInitSet(simpDat)</span><br><span class="line">    myFPtree, myHeaderTab = createTree(initSet, <span class="number">3</span>)          <span class="comment"># 3 为最小支持度</span></span><br><span class="line">    myFPtree.disp()  <span class="comment"># 显示树</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据树挖掘 频繁项集</span></span><br><span class="line">    freqItems = []</span><br><span class="line">    mineTree(myFPtree, myHeaderTab, <span class="number">3</span>, <span class="built_in">set</span>([]), freqItems)  <span class="comment"># 3 为最小支持度</span></span><br><span class="line">    <span class="built_in">print</span> freqItems</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>关联规则学习算法</category>
      </categories>
      <tags>
        <tag>关联规则学习</tag>
      </tags>
  </entry>
  <entry>
    <title>先验算法</title>
    <url>/posts/bc0acbbf.html</url>
    <content><![CDATA[<h2 id="先验算法-Apriori-Algorithm">先验算法(Apriori Algorithm)</h2>
<p>Apriori算法是一种挖掘关联规则的频繁项集算法，其核心思想是通过候选集生成和情节的向下封闭检测两个阶段来挖掘频繁项集。 Apriori（先验的，推测的）算法应用广泛，可用于消费市场价格分析，猜测顾客的消费习惯；网络安全领域中的入侵检测技术；可用在用于高校管理中，根据挖掘规则可以有效地辅助学校管理部门有针对性的开展贫困助学工作；也可用在移动通信领域中，指导运营商的业务运营和辅助业务提供商的决策制定。</p>
<p>在计算机科学以及数据挖掘领域中， 先验算法是关联式规则中的经典算法之一。先验算法的设计目的是为了处理包含交易信息内容的数据库（例如,顾客购买的商品清单，或者网页常访清单。）而其他的算法则是设计用来寻找无交易信息（如Winepi算法和Minepi算法）或无时间标记（如DNA测序）的数据之间的联系规则。</p>
<p>在关联式规则中,一般对于给定的项目集合（例如，零售交易集合，每个集合都列出的单个商品的购买信息），算法通常尝试在项目集合中找出至少有C个相同的子集。先验算法采用自底向上的处理方法，即频繁子集每次只扩展一个对象（该步骤被称为候选集产生），并且候选集由数据进行检验。当不再产生符合条件的扩展对象时，算法终止。</p>
<p>先验算法采用广度优先搜索算法进行搜索并采用树结构来对候选项目集进行高效计数。它通过长度为k-1的候选项目集来产生长度为k的候选项目集，然后从中删除包含不常见子模式的候选项。根据向下封闭性引理,该候选项目集包含所有长度为k的频繁项目集。之后，就可以通过扫描交易数据库来决定候选项目集中的频繁项目集。</p>
<p>虽然先验算法具有显著的历史地位，但是其中的一些低效与权衡弊端也进而引致了许多其他的算法的产生。候选集产生过程生成了大量的子集（先验算法在每次对数据库进行扫描之前总是尝试加载尽可能多的候选集）。并且自底而上的子集浏览过程（本质上为宽度优先的子集格遍历）也直到遍历完所有<img width="100" align="center" src="/img/images/248.jpg" />个可能的子集之后才寻找任意最大子集S。</p>
<p>Apriori算法中的一些低效与权衡弊端也进而引致了许多其他的算法的产生，例如FP-growth算法。候选集产生过程生成了大量的子集（先验算法在每次对数据库进行扫描之前总是尝试加载尽可能多的候选集）。并且自底而上的子集浏览过程（本质上为宽度优先的子集格遍历）也直到遍历完所有 <img width="100" align="center" src="/img/images/248.jpg" />个可能的子集之后才寻找任意最大子集S。</p>
<h3 id="应用示例-2">应用示例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apriori</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    关联分析的目标包括两项：发现频繁项集和发现关联规则</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    频繁项集：</span></span><br><span class="line"><span class="string">        对于包含N种物品的数据集共有2^N-1种项集组合。</span></span><br><span class="line"><span class="string">        支持度(support)</span></span><br><span class="line"><span class="string">            一个项集的支持度被定义为数据集中包含该项集的记录所占的比例。</span></span><br><span class="line"><span class="string">        Apriori算法：如果某个项集是频繁的，那么它的所有子集也是频繁的。</span></span><br><span class="line"><span class="string">        如果一个项集是非频繁集，那么它的所有超集也是非频繁集。</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_createC1</span>(<span class="params">self, dataSet</span>):</span><br><span class="line">        C1 = []</span><br><span class="line">        <span class="keyword">for</span> transaction <span class="keyword">in</span> dataSet:</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> transaction:</span><br><span class="line">                <span class="keyword">if</span> [item] <span class="keyword">not</span> <span class="keyword">in</span> C1:</span><br><span class="line">                    C1.append([item])</span><br><span class="line">        C1.sort()</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>(<span class="built_in">frozenset</span>, C1) <span class="comment"># use frozen set so we can use it as a key in a dict</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_scanD</span>(<span class="params">self, D, Ck, minSupport=<span class="number">0.5</span></span>):</span><br><span class="line">        ssCnt = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> tid <span class="keyword">in</span> D:</span><br><span class="line">            <span class="keyword">for</span> can <span class="keyword">in</span> Ck:</span><br><span class="line">                <span class="keyword">if</span> can.issubset(tid):</span><br><span class="line">                    <span class="keyword">if</span> can <span class="keyword">in</span> ssCnt:</span><br><span class="line">                        ssCnt[can] += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        ssCnt[can] = <span class="number">1</span></span><br><span class="line">                    <span class="comment"># if can not in ssCnt:</span></span><br><span class="line">                    <span class="comment">#     ssCnt[can] = 0</span></span><br><span class="line">                    <span class="comment"># ssCnt[can] += 1</span></span><br><span class="line">        <span class="comment"># print ssCnt</span></span><br><span class="line">        numItems = <span class="built_in">len</span>(D)</span><br><span class="line">        retList = []</span><br><span class="line">        supportK = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> ssCnt:</span><br><span class="line">            support = ssCnt[key]/<span class="built_in">float</span>(numItems) <span class="comment"># 计算支持度</span></span><br><span class="line">            <span class="keyword">if</span> support &gt;= minSupport:</span><br><span class="line">                retList.append(key)</span><br><span class="line">            supportK[key] = support</span><br><span class="line">        <span class="keyword">return</span> retList, supportK</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">aprioriGen</span>(<span class="params">self, Lk, k</span>): <span class="comment"># k&gt;=2</span></span><br><span class="line">        retList = []</span><br><span class="line">        lenLk = <span class="built_in">len</span>(Lk)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lenLk):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, lenLk):</span><br><span class="line">                L1 = <span class="built_in">list</span>(Lk[i])[:k-<span class="number">2</span>]</span><br><span class="line">                L2 = <span class="built_in">list</span>(Lk[j])[:k-<span class="number">2</span>]</span><br><span class="line">                L1.sort()</span><br><span class="line">                L2.sort()</span><br><span class="line">                <span class="keyword">if</span> L1 == L2: <span class="comment"># if first k-2 elements are equal. when k is 3, &#123;0,1&#125;,&#123;0,2&#125;,&#123;1,2&#125;→&#123;0,1&#125;U&#123;0,2&#125;→&#123;0,1,2&#125;</span></span><br><span class="line">                    retList.append(Lk[i] | Lk[j])</span><br><span class="line">        <span class="keyword">return</span> retList</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">apriori</span>(<span class="params">self, dataSet, minSupport=<span class="number">0.5</span></span>): <span class="comment"># minSupport 最小支持度</span></span><br><span class="line">        D = <span class="built_in">map</span>(<span class="built_in">set</span>, dataSet) <span class="comment"># 转换为集合set</span></span><br><span class="line">        C1 = self._createC1(dataSet) <span class="comment"># 创建C1，转换为集合frozenset</span></span><br><span class="line">        L1, supp1 = self._scanD(D, C1, minSupport) <span class="comment"># 基于C1和minSupport创建L1</span></span><br><span class="line">        L = []</span><br><span class="line">        supportData = &#123;&#125;</span><br><span class="line">        L.append(L1)</span><br><span class="line">        supportData.update(supp1)</span><br><span class="line">        k = <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(L[k-<span class="number">2</span>]) &gt; <span class="number">1</span>:</span><br><span class="line">            Ck = self.aprioriGen(L[k-<span class="number">2</span>], k) <span class="comment"># 创建Ck</span></span><br><span class="line">            Lk, suppK = self._scanD(D, Ck, minSupport) <span class="comment"># 基于Ck和minSupport创建Lk</span></span><br><span class="line">            L.append(Lk)</span><br><span class="line">            supportData.update(suppK)</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> L, supportData</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    关联规则：→</span></span><br><span class="line"><span class="string">        可信度(confidence)：也称置信度</span></span><br><span class="line"><span class="string">            可信度(尿布→葡萄酒) = 支持度(&#123;尿布,葡萄酒&#125;)/支持度(&#123;尿布&#125;)</span></span><br><span class="line"><span class="string">        如果某条规则并不满足最小可信度要求，那么该规则的所有子集也不会满足最小可信度要求。</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_calcConf</span>(<span class="params">self, freqSet, H, supportData, brl, minConf=<span class="number">0.7</span></span>): <span class="comment"># H为出现在右部的规则列表，如&#123;0&#125;,&#123;1&#125;</span></span><br><span class="line">        prunedH = []</span><br><span class="line">        <span class="keyword">for</span> conseq <span class="keyword">in</span> H:</span><br><span class="line">            conf = supportData[freqSet]/supportData[freqSet-conseq] <span class="comment"># 计算可信度</span></span><br><span class="line">            <span class="keyword">if</span> conf &gt;= minConf:</span><br><span class="line">                <span class="built_in">print</span> freqSet-conseq, <span class="string">&#x27;--&gt;&#x27;</span>, conseq, <span class="string">&#x27;conf:&#x27;</span>, conf</span><br><span class="line">                brl.append((freqSet-conseq, conseq, conf))</span><br><span class="line">                prunedH.append(conseq)</span><br><span class="line">        <span class="keyword">return</span> prunedH</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_rulesFromConseq</span>(<span class="params">self, freqSet, H, supportData, brl, minConf=<span class="number">0.7</span></span>): <span class="comment"># H为出现在右部的规则列表，如&#123;0&#125;,&#123;1&#125;</span></span><br><span class="line">        m = <span class="built_in">len</span>(H[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(freqSet) &gt; (m+<span class="number">1</span>):</span><br><span class="line">            Hmp1 = self.aprioriGen(H, m+<span class="number">1</span>) <span class="comment"># 合并规则</span></span><br><span class="line">            Hmp = self._calcConf(freqSet, Hmp1, supportData, brl, minConf) <span class="comment"># Hmp为出现在右部的合并规则列表，如&#123;0,1&#125;</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(Hmp) &gt; <span class="number">1</span>: <span class="comment"># 如果规则列表长度大于1，则进一步合并</span></span><br><span class="line">                self._rulesFromConseq(freqSet, Hmp, supportData, brl, minConf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateRules</span>(<span class="params">self, L, supportData, minConf=<span class="number">0.7</span></span>): <span class="comment"># minConf 最小可信度</span></span><br><span class="line">        bigRuleList = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(L)): <span class="comment"># 从包含两个或者更多元素的项集开始规则构建过程</span></span><br><span class="line">            <span class="keyword">for</span> freqSet <span class="keyword">in</span> L[i]:</span><br><span class="line">                H1 = [<span class="built_in">frozenset</span>([item]) <span class="keyword">for</span> item <span class="keyword">in</span> freqSet] <span class="comment"># 构建只包含单个元素的列表，即出现在规则右部的规则列表，如&#123;0&#125;,&#123;1&#125;</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">1</span>:</span><br><span class="line">                    self._rulesFromConseq(freqSet, H1, supportData, bigRuleList, minConf) <span class="comment"># 生成候选规则</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self._calcConf(freqSet, H1, supportData, bigRuleList, minConf) <span class="comment"># 对规则进行评估</span></span><br><span class="line">        <span class="keyword">return</span> bigRuleList</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loadDataSet</span>():</span><br><span class="line">    <span class="keyword">return</span> [[<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">2</span>, <span class="number">5</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    dataSet = loadDataSet()</span><br><span class="line">    ap = Apriori()</span><br><span class="line">    L, suppData = ap.apriori(dataSet, minSupport=<span class="number">0.5</span>)</span><br><span class="line">    <span class="built_in">print</span> L</span><br><span class="line">    <span class="built_in">print</span> suppData</span><br><span class="line">    rules = ap.generateRules(L, suppData, minConf=<span class="number">0.6</span>)</span><br><span class="line">    <span class="built_in">print</span> rules</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>关联规则学习算法</category>
      </categories>
      <tags>
        <tag>关联规则学习</tag>
      </tags>
  </entry>
  <entry>
    <title>关联规则学习简介</title>
    <url>/posts/2050ed59.html</url>
    <content><![CDATA[<h2 id="关联规则学习-Association-Rule-Learning">关联规则学习(Association Rule Learning)</h2>
<p>关联规则学习（英语：Association rule learning）是一种在大型数据库中发现变量之间的有趣性关系的方法。它的目的是利用一些有趣性的量度来识别数据库中发现的强规则。基于强规则的概念，Rakesh Agrawal等人引入了关联规则以发现由超市的POS系统记录的大批交易数据中产品之间的规律性。例如，从销售数据中发现的规则 {洋葱, 土豆}→{汉堡} 会表明如果顾客一起买洋葱和土豆，他们也有可能买汉堡的肉。此类信息可以作为做出促销定价或产品植入等营销活动决定的根据。除了上面购物篮分析中的例子以外， 关联规则如今还被用在许多应用领域中，包括网络用法挖掘、入侵检测、连续生产及生物信息学中。与序列挖掘相比，关联规则学习通常不考虑在事务中、或事务间的项目的顺序。</p>
<p>根据关联规则所处理的值的类型</p>
<p>如果考虑关联规则中的数据项是否出现，则这种关联规则是布尔关联规则（Boolean association rules）。例如上面的例子。如果关联规则中的数据项是数量型的，这种关联规则是数量关联规则（quantitative association rules）。例如年龄(“20-25”)=&gt;购买(“网球拍”)，年龄是一个数量型的数据项。在这种关联规则中，一般将数量离散化（discretize）为区间。根据关联规则所涉及的数据维数</p>
<p>如果关联规则各项只涉及一个维，则它是单维关联规则（single-dimensional association rules），例如购买(“网球拍”)=&gt;购买(“网球”)只涉及“购买”一个维度。如果关联规则涉及两个或两个以上维度，则它是多维关联规则（multi-dimensional association rules），例如年龄(“20-25”)=&gt;购买(“网球拍”)涉及“年龄”和“购买”两个维度。根据关联规则所涉及的抽象层次</p>
<p>如果不涉及不同层次的数据项，得到的是单层关联规则（single-level association rules）。在不同抽象层次中挖掘出的关联规则称为广义关联规则（generalized association rules）。例如年龄(“20-25”)=&gt;购买(“HEAD网球拍”)和年龄(“20-25”) =&gt;购买(“网球拍”)是广义关联规则，因为&quot;HEAD网球拍&quot;和&quot;网球拍&quot;属于不同的抽象层次。</p>
<p>关联规则学习(Association Rule Learning) 的应用算法：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>先验算法(Apriori Algorithm)</p>
</li>
<li class="lvl-2">
<p>Eclat算法(Eclat Algorithm)</p>
</li>
<li class="lvl-2">
<p>FP-growth算法(FP-Growth Algorithm)</p>
</li>
</ul>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>关联规则学习算法</category>
      </categories>
  </entry>
  <entry>
    <title>ID3算法</title>
    <url>/posts/a6473758.html</url>
    <content><![CDATA[<h2 id="ID3算法-Iterative-Dichotomiser-3">ID3算法(Iterative Dichotomiser 3)</h2>
<p>ID3算法是决策树的一种，它是基于奥卡姆剃刀原理的，即用尽量用较少的东西做更多的事。ID3算法,即Iterative Dichotomiser3，迭代二叉树三代，是Ross Quinlan发明的一种决策树算法，这个算法的基础就是上面提到的奥卡姆剃刀原理，越是小型的决策树越优于大的决策树，尽管如此，也不总是生成最小的树型结构，而是一个启发式算法。</p>
<p>ID3算法的核心思想就是以信息增益来度量属性的选择，选择分裂后信息增益最大的属性进行分裂。信息增益是属性选择中的一个重要指标，它定义为一个属性能够为分类系统带来多少信息，带来的信息越多，该属性就越重要。而信息量，就是熵。熵定义为信息量的期望值。</p>
<p>熵越大，一个变量的不确定性越大，它带来的信息量就越大。 计算信息熵的公式为：</p>
<p align="center">
<img width="300" align="center" src="/img/images/176.jpg" />
</p>
<p>其中p为出现c分类时的概率。</p>
<p>那么如何计算一个属性的信息增益？ 首先我们需要先根据信息熵公式计算出系统的平均熵值H©，然后根据某个属性计算条件熵：</p>
<p align="center">
<img width="300" align="center" src="/img/images/177.jpg" />
</p>
<p>这是指属性X被固定时的条件熵。因为X可能的取值有n种,因此在计算条件熵时需要计算n个值，然后取均值（通过概率计算）。通过将某分类的系统熵减去某个属性的条件熵，从而得到该属性的信息增益：</p>
<p align="center">
<img width="300" align="center" src="/img/images/178.jpg" />
</p>
<p>在信息论中一个属性的信息增益越大，表明该属性对样本的熵减少能力越强，也就是说确定这个属性会使系统越稳定有序（熵越小系统越稳定），那么该分区的纯度也就越高。</p>
<p>机器学习中，决策树是一个预测模型；他代表的是对象属性与对象值之间的一种映射关系。树中每个节点表示某个对象，而每个分叉路径则代表的某个可能的属性值，而每个叶结点则对应从根节点到该叶节点所经历的路径所表示的对象的值。</p>
<p>决策树仅有单一输出，若欲有复数输出，可以建立独立的决策树以处理不同输出。 数据挖掘中决策树是一种经常要用到的技术，可以用于分析数据，同样也可以用来作预测。 从数据产生决策树的机器学习技术叫做决策树学习,就是决策树。</p>
<p>通常一个决策树会包含三种类型的节点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>决策节点：通常用矩形框来表示</p>
</li>
<li class="lvl-2">
<p>机会节点：通常用圆圈来表示</p>
</li>
<li class="lvl-2">
<p>终结点：通常用三角形来表示</p>
</li>
</ul>
<h3 id="应用案例-2">应用案例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log </span><br><span class="line"><span class="keyword">from</span> anytree <span class="keyword">import</span> Node, RenderTree</span><br><span class="line"><span class="keyword">from</span> anytree.dotexport <span class="keyword">import</span> RenderTreeGraph</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_decision_tree_id3</span>(<span class="params">df, y_col</span>):</span><br><span class="line">    <span class="comment"># 计算H(C)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">h_value</span>():</span><br><span class="line">        h = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> df.groupby(y_col).size().div(<span class="built_in">len</span>(df)):</span><br><span class="line">            h += -v * log(v, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算某一个属性的信息增益</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_info_gain_byc</span>(<span class="params">column, df, y_col</span>):</span><br><span class="line">        <span class="comment"># 计算p(column)</span></span><br><span class="line">        probs = df.groupby(column).size().div(<span class="built_in">len</span>(df))</span><br><span class="line">        v = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> index1, v1 <span class="keyword">in</span> probs.iteritems():</span><br><span class="line">            tmp_df = df[df[column] == index1]</span><br><span class="line">            tmp_probs = tmp_df.groupby(y_col).size().div(<span class="built_in">len</span>(tmp_df))</span><br><span class="line">            tmp_v = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> v2 <span class="keyword">in</span> tmp_probs:</span><br><span class="line">                <span class="comment"># 计算H(C|X=xi)</span></span><br><span class="line">                tmp_v += -v2 * log(v2, <span class="number">2</span>)</span><br><span class="line">            <span class="comment"># 计算H(y_col|column)</span></span><br><span class="line">            v += v1 * tmp_v</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取拥有最大信息增益的属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_max_info_gain</span>(<span class="params">df, y_col</span>):</span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        h = h_value()</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">filter</span>(<span class="keyword">lambda</span> c: c != y_col, df.columns):</span><br><span class="line">            <span class="comment"># 计算H(y_col) - H(y_col|column)</span></span><br><span class="line">            d[c] = h - get_info_gain_byc(c, df, y_col)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(d, key=d.get)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成决策树</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">train_decision_tree</span>(<span class="params">node, df, y_col</span>):</span><br><span class="line">        c = get_max_info_gain(df, y_col)</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> pd.unique(df[c]):</span><br><span class="line">            gb = df[df[c] == v].groupby(y_col)</span><br><span class="line">            curr_node = Node(<span class="string">&#x27;%s-%s&#x27;</span> % (c, v), parent=node)</span><br><span class="line">            <span class="comment"># 如果属性没有用完</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(df.columns) &gt; <span class="number">2</span>:</span><br><span class="line">                <span class="comment"># 如果分区纯度是100%，则生成类别叶子节点</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(gb) == <span class="number">1</span>:</span><br><span class="line">                    Node(df[df[c] == v].groupby(c)[y_col].first().iloc[<span class="number">0</span>], parent=curr_node)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果分区不纯则继续递归</span></span><br><span class="line">                    train_decision_tree(curr_node, df[df[c] == v].drop(c, axis=<span class="number">1</span>), y_col)</span><br><span class="line">            <span class="comment"># 如果属性用完，则选择数量最多的类别实例作为类别叶子结点</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                Node(df[df[c] == v].groupby(y_col).size().idxmax(), parent=curr_node)</span><br><span class="line"></span><br><span class="line">    root_node = Node(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">    train_decision_tree(root_node, df, y_col)</span><br><span class="line">    <span class="keyword">return</span> root_node</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;~/allele.csv&#x27;</span>)</span><br><span class="line">root_node = create_decision_tree_id3(df, <span class="string">&#x27;buys_computer&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> pre, fill, node <span class="keyword">in</span> RenderTree(root_node):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s%s&quot;</span> % (pre, node.name))</span><br><span class="line">    </span><br><span class="line">RenderTreeGraph(root_node).to_picture(<span class="string">&quot;decision_tree_id3.png&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="优缺点-5">优缺点</h4>
<p>优点：决策树ID3算法易于理解,能处理数据型的也能处理常规型的数据,还可以在相对较短的时间内能够对大型的数据集做出可行且较好的结果。</p>
<p>缺点：决策树ID3算法比较偏向于选择属性值多的类别。</p>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>决策树算法</category>
      </categories>
      <tags>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title>决策树算法简介</title>
    <url>/posts/fa7e608f.html</url>
    <content><![CDATA[<h2 id="决策树（Decision-Tree）">决策树（Decision Tree）</h2>
<p>决策树（Decision Tree）是应用于分类的一种树结构。其中的每个内部节点（internal node）代表对某个属性的一次测试判别，一个分枝代表一个测试结果，叶子（leaf）代表某个类（class）或者类的分布（class distribution）。最顶层的节点是根结点。可以将决策树理解为一个if-then规则的集合，由决策树的根节点到叶节点的每一条路径构建一条规则。</p>
<p>最早的决策树算法是由Hunt等人于1966年提出的CLS。当前最有影响的决策树算法是Quinlan于1986年提出的ID3和1993年提出的C4.5。ID3只能处理离散型描述属性，它选择信息增益最大的属性划分训练样本，其目的是进行分枝时系统的熵最小，从而提高算法的运算速度和精确度。ID3算法的主要缺陷是，用信息增益作为选择分枝属性的标准时，偏向于取值较多的属性，而在某些情况下，这类属性可能不会提供太多有价值的信息。C4.5是ID3算法的改进算法，不仅可以处理离散型描述属性，还能处理连续性描述属性。C4.5采用了信息增益比作为选择分枝属性的标准，弥补了ID3算法的不足。</p>
<p>决策树经常在运筹学中使用，特别是在决策分析中，它帮助确定一个能最可能达到目标的策略。如果在实际中，决策不得不在没有完备知识的情况下被在线采用，一个决策树应该平行概率模型作为最佳的选择模型或在线选择模型算法。决策树的另一个使用是作为计算条件概率的描述性手段。</p>
<p>决策树（Decision Tree）这里的应用算法有：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>分类和回归树（CART）</p>
</li>
<li class="lvl-2">
<p>ID3算法(Iterative Dichotomiser 3)</p>
</li>
<li class="lvl-2">
<p>CHAID（Chi-squared Automatic Interaction Detection</p>
</li>
<li class="lvl-2">
<p>随机森林（Random Forest）</p>
</li>
<li class="lvl-2">
<p>多元自适应回归样条（MARS）</p>
</li>
<li class="lvl-2">
<p>梯度推进机（Gradient Boosting Machine， GBM）</p>
</li>
</ul>
<h3 id="决策树的优点">决策树的优点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>便于理解和解释。树的结构可以可视化出来。</p>
</li>
<li class="lvl-2">
<p>训练需要的数据少。其他机器学习模型通常需要数据规范化，比如构建虚拟变量和移除缺失值,不过请注意，这种模型不支持缺失值。</p>
</li>
<li class="lvl-2">
<p>由于训练决策树的数据点的数量导致了决策树的使用开销呈指数分布(训练树模型的时间复杂度是参与训练数据点的对数值)。</p>
</li>
<li class="lvl-2">
<p>能够处理数值型数据和分类数据。其他的技术通常只能用来专门分析某一种变量类型的数据集。详情请参阅算法。</p>
</li>
<li class="lvl-2">
<p>能够处理多路输出的问题。</p>
</li>
<li class="lvl-2">
<p>使用白盒模型。如果某种给定的情况在该模型中是可以观察的，那么就可以轻易的通过布尔逻辑来解释这种情况。相比之下，在黑盒模型中的结果就是很难说明清 楚地。</p>
</li>
<li class="lvl-2">
<p>可以通过数值统计测试来验证该模型。这对事解释验证该模型的可靠性成为可能。</p>
</li>
<li class="lvl-2">
<p>即使该模型假设的结果与真实模型所提供的数据有些违反，其表现依旧良好。</p>
</li>
</ul>
<h3 id="决策树的缺点">决策树的缺点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>决策树模型容易产生一个过于复杂的模型,这样的模型对数据的泛化性能会很差。这就是所谓的过拟合.一些策略像剪枝、设置叶节点所需的最小样本数或设置数的最大深度是避免出现 该问题最为有效地方法。</p>
</li>
<li class="lvl-2">
<p>决策树可能是不稳定的，因为数据中的微小变化可能会导致完全不同的树生成。这个问题可以通过决策树的集成来得到缓解</p>
</li>
<li class="lvl-2">
<p>在多方面性能最优和简单化概念的要求下，学习一棵最优决策树通常是一个NP难问题。因此，实际的决策树学习算法是基于启发式算法，例如在每个节点进 行局部最优决策的贪心算法。这样的算法不能保证返回全局最优决策树。这个问题可以通过集成学习来训练多棵决策树来缓解,这多棵决策树一般通过对特征和样本有放回的随机采样来生成。</p>
</li>
<li class="lvl-2">
<p>有些概念很难被决策树学习到,因为决策树很难清楚的表述这些概念。例如XOR，奇偶或者复用器的问题。</p>
</li>
<li class="lvl-2">
<p>如果某些类在问题中占主导地位会使得创建的决策树有偏差。因此，建议在拟合前先对数据集进行平衡。</p>
</li>
</ul>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>决策树算法</category>
      </categories>
      <tags>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title>多元自适应回归样条</title>
    <url>/posts/65f5458.html</url>
    <content><![CDATA[<h2 id="多元自适应回归样条（MARS）">多元自适应回归样条（MARS）</h2>
<p>多元自适应回归样条(Multivariate Adaptive Regression Splines,MARS)是由美国的统计学家Jerome Friedman于1991年提出的一种数据分析方法。 该方法以样条函数的张量积作为基函数,分为前向过程、后向剪枝过程与模型选取三个步骤。其优点在于能够处理数据量大、维度高的数据,而且计算快捷、模型精确。在一般回归分析理论和样条理论的基础上,系统地研究了MARS的建模过程,提出引入Bernstein基函数建模的思想,并针对冶金工业领域一类数据分析其成分优化问题,应用该方法进行建模和预测。</p>
<p>在前向过程中,通过自适应的选取节点对数据进行分割,每选取一个节点就生成两个新的基函数,前向过程结束后生成一个过拟合的模型。后向剪枝过程中在保证模型准确度的前提下,删除过拟合模型中对模型贡献度小的基函数,最后选取一个最优的模型作为回归模型。 研究过程中对采集的原始数据进行了消除负差、剔除异常数据、数据标准化等预处理工作,选取精华样本,分别建立了线性模型、非线性模型、神经网络模型等,并与MARS方法做比较。得到如下结论:由于模型的限制,线性回归模型精度较低,与实际经验不符; 神经网络对部分元素的描述优于线性回归模型,但不能得出相应的显式表达式,同时线性回归与神经网络都未能考虑变量间的交互作用;MARS模型对问题的描述比较符合实际经验,同时能够反映元素间的交互作用,能够对两个变量做可视化处理,并能够给出显式表达式。 论文以数据科学为背景,属于问题驱动的应用数学研究,不仅对多元自适应回归方法进行了理论探索,也为工业领域的数据分析与优化提供了理论依据。</p>
<p>MARS是回归的自适应过程，非常适合高维问题（比如，存在大量的输入）。可以从两个角度来理解它，首先，它可以看成是逐步线性回归的推广，其次，也可以看成是为了提高CART在回归中的效果而进行的改进。我们从第一种观点引入MARS，接着与CART联系起来。</p>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>决策树算法</category>
      </categories>
      <tags>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title>分类和回归树</title>
    <url>/posts/d6466ff6.html</url>
    <content><![CDATA[<h2 id="分类和回归树（CART）">分类和回归树（CART）</h2>
<p>分类回归树(Classification And Regression Tree, CART)模型是决策树学习方法的一种，CART既可以用于分类计算，也可以用于回归。</p>
<p>不同于C4.5，CART本质是对特征空间进行二元划分（即CART生成的决策树是一棵二叉树），并能够对标量属性（nominal attribute）与连续属性（continuous attribute）进行分裂。<br>
CART决策树是结构简洁的二叉树，采用一种二分递归分割的技术，将当前的样本集分为两个子样本集，使得生成的每个非叶子的节点都有两个分支。</p>
<p>CART算法包括两个过程：</p>
<ol>
<li class="lvl-3">
<p>决策树的生成：基于训练数据集生成决策树，生成的决策树要尽量的大；</p>
</li>
<li class="lvl-3">
<p>决策树的剪枝：用验证数据集对以生成的树进行剪枝并选择最优子树，此时用损失函数最小作为剪枝的标准。</p>
</li>
</ol>
<p>1.决策树的生成决策树的生成就是递归的构建二叉决策树的过程。对回归树用平方误差最小化准则，对分类树用基尼指数最小化原则，进行特征选择，生成二叉树。</p>
<p>主要的原理如下：(1)分类树原理：分类树采用基尼指数（Gini index, Gini）选择最优特征，同时决定该特征的最优二值切分点。基尼指数定义为：</p>
<p align="center">
<img width="200" align="center" src="/img/images/56.jpg" />
</p>
<p>对于给定样本集合D，其基尼指数的计算为：</p>
<p align="center">
<img width="200" align="center" src="/img/images/57.jpg" />
</p>
如果样本集合D根据特征A是否取某一可能值a被分割成D1和D2两部分，即：<img width="300" align="center" src="/img/images/60.jpg" />,D2=D-D1
则在特征A的条件下，集合D的基尼指数计算公式为：
<p align="center">
<img width="200" align="center" src="/img/images/58.jpg" />
</p>
基尼指数Gini(D)表示集合D的不确定性，基尼指数Gini(D,A)表示经A=a分割后集合D的不确定性。基尼指数值越大，样本集合的不确定性也就越大。
（2）回归树原理：回归树用平方误差最小化准则，进行特征选择，生成二叉树。将输入空间划分为M个区域R1，R2，…，Rm，则生成的回归树模型表示为：
<p align="center">
<img width="200" align="center" src="/img/images/59.jpg" />
</p>
其中cm表示单元Rm上的最小误差平方的最优解.
<p>2、决策树的剪枝</p>
<p>CART算法对于决策树剪枝方法，采用代价复杂度模型，通过交叉验证来估计对预测样本集的误分类损失，产生最小交叉验证误分类估计树。</p>
<p>CART剪枝算法主要由两步组成：首先从生成算法产生的决策树T0底端开始不断剪枝，直到T0的根节点，形成一个子树序列{T0，T1，… ，Tn}；然后通过交叉验证法在独立的验证数据集上对子树序列进行测试，从中选择最优子树。</p>
<h3 id="相关应用-6">相关应用</h3>
<p>分类回归树本质上也是一种决策树算法；而决策树分类器具有很好的准确性，已被成功的应用于许多的应用领域的分类，如医学、制造和生产、金融分析、天文学与分子生物学等；具体的包括欺诈监测、针对销售、性能预测、制造和医疗整段。决策树是许多商业规则归纳系统的基础。</p>
<h3 id="优缺点-6">优缺点</h3>
<p>优点：可以生成易于理解的规则；计算量相对来说不大；可处理连续和离散字段；最终结果可清晰显示字段的重要性程度。</p>
<p>缺点：对连续字段难以预测；处理时间序列数据，前期预处理步骤多；当类别太多，错误可能增加的较快。</p>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>决策树算法</category>
      </categories>
      <tags>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title>梯度推进机</title>
    <url>/posts/89ee03fd.html</url>
    <content><![CDATA[<h2 id="梯度推进机（Gradient-Boosting-Machine-GBM）">梯度推进机（Gradient Boosting Machine,GBM）</h2>
<p>梯度推进理论核心是梯度推移理论。它认为，不同国家或不同地区间存在着产业梯度和经济梯度，存在梯度地区技术经济势差，就存在着技术经济推移的动力，就会形成生产力的空间推移。梯度推进是一种用于回归和分类问题的机器学习技术，该技术以弱预测模型（通常为决策树）的集合的形式产生预测模型。它像其他增强方法那样以阶段式方式构建模型，并且通过允许优化任意可微损失函数来推广它们。</p>
<p>梯度提升通常用于作为基础学习者的固定大小的决策树（特别是CART树）。对于这种特殊情况，弗里德曼提出了对梯度提升方法的修改，该方法可以提高每个基础学习者的适应质量。</p>
<p>梯度推进理论梯度提升将弱“学习者”以迭代的方式组合成一个强大的学习者。在最小二乘回归设置中解释最容易，其目标是“教”一个模型F预测表单的值<img width="70" align="center" src="/img/images/180.jpg" />通过最小化均方误差<img width="70" align="center" src="/img/images/181.jpg" />，在输出变量的一些实际值的训练集上进行平均y。</p>
<p>在每个阶段 m，<img width="100" align="center" src="/img/images/182.jpg" />，梯度提升，可以假定存在一些不完善的模型<img width="30" align="center" src="/img/images/183.jpg" />（首先，可以使用一个非常弱的模型，它可以预测训练集中的平均值y).梯度提升算法进一步改进<img width="30" align="center" src="/img/images/183.jpg" />通过构建一个新的模型来增加一个估计器h来提供一个更好的模型：<img width="200" align="center" src="/img/images/184.jpg" />.寻找h梯度增强解决方案从观察到完美的h意味着开始</p>
<p align="center">
<img width="400" align="center" src="/img/images/185.jpg" />
</p>
<p>或者等同地，</p>
<p align="center">
<img width="200" align="center" src="/img/images/186.jpg" />
</p>
<p>因此，梯度升压将适合h到残余<img width="100" align="center" src="/img/images/187.jpg" />。就像其他增强型变体一样，<img width="60" align="center" src="/img/images/188.jpg" />学会纠正其前任 <img width="30" align="center" src="/img/images/183.jpg" />.把这个想法推广到除了平方误差之外的损失函数 - 以及分类和排序问题 - 从观察残差开始<img width="100" align="center" src="/img/images/187.jpg" />对于给定的模型是平方误差损失函数的负梯度(相对于F(x)) <img width="100" align="center" src="/img/images/190.jpg" /> 。所以，梯度增强是一种梯度下降算法; 并推广它需要“插入”不同的损失及其梯度。</p>
<h3 id="梯度提升">梯度提升</h3>
<p>梯度提升通常用于作为基础学习者的固定大小的决策树（特别是CART树）。对于这种特殊情况，弗里德曼提出了对梯度提升方法的修改，该方法可以提高每个基础学习者的适应质量。</p>
<p>第m步中的通用梯度提升将适合决策树<img width="40" align="center" src="/img/images/191.jpg" />伪残差。让<img width="30" align="center" src="/img/images/192.jpg" />是它的叶子的数量。树将输入空间分成<img width="30" align="center" src="/img/images/192.jpg" />不相交的地区<img width="30" align="center" src="/img/images/193.jpg" />，…，<img width="40" align="center" src="/img/images/194.jpg" />并预测每个地区的恒定值。使用指标符号，输出<img width="40" align="center" src="/img/images/191.jpg" />对于输入x可以写成总和：</p>
<p align="center">
<img width="200" align="center" src="/img/images/195.jpg" />
</p>
<p>哪里<img width="40" align="center" src="/img/images/196.jpg" />是该地区预测的价值<img width="40" align="center" src="/img/images/197.jpg" />。</p>
<p>然后是系数<img width="30" align="center" src="/img/images/196.jpg" />乘以某个值<img width="30" align="center" src="/img/images/198.jpg" />，使用线搜索选择以便最小化损失函数，并且模型更新如下：</p>
<p align="center">
<img width="650" align="center" src="/img/images/199.jpg" />
</p>
<p>弗里德曼提出修改这个算法，以便它选择一个单独的最优值<img width="40" align="center" src="/img/images/201.jpg" />对于每个树的区域，而不是一个<img width="40" align="center" src="/img/images/198.jpg" />为整棵树。他称修改后的算法为“TreeBoost”。系数<img width="40" align="center" src="/img/images/196.jpg" />从树形拟合过程可以简单地被丢弃并且模型更新规则变为：</p>
<p align="center">
<img width="650" align="center" src="/img/images/200.jpg" />
</p>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>决策树算法</category>
      </categories>
      <tags>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title>卡方自动交互检测算法</title>
    <url>/posts/81cf7cc1.html</url>
    <content><![CDATA[<h2 id="卡方自动交互检测算法-CHAID（Chi-squared-Automatic-Interaction-Detection">卡方自动交互检测算法 CHAID（Chi-squared Automatic Interaction Detection)</h2>
<p>卡方自动交互检测法（chi-squared automatic interaction detector, CHAID）最早由Kass于1980年提出，是一个用来发现变量之间关系的工具，是一种基于调整后的显着性检验（邦费罗尼检验）决策树技术。</p>
<p>其核心思想是：根据给定的反应变量和解释变量对样本进行最优分割，按照卡方检验的显著性进行多元列联表的自动判断分组。利用卡方自动交互检测法可以快速、有效地挖掘出主要的影响因素，它不仅可以处理非线性和高度相关的数据，而且可以将缺失值考虑在内，能克服传统的参数检验方法在这些方面的限制。</p>
<p>在实践中，CHAID经常使用在直销的背景下，选择消费者群体，并预测他们的反应，一些变量如何影响其他变量，而其他早期应用是在医学和精神病学的研究领域。</p>
<p>CHAID分析构建了一个预测模型，或树，以帮助确定给定因变量，变量如何最好地合来解释结果。CHAID分析，名义，有序和连续数据可以使用，在连续预测类别被分成大致相等的若干观测。CHAID对每个分类预测创建了交叉表，直到达到最好的结果，无法继续分类为止。在CHAID技术中，我们可以直观地看到在树的分割变量和相关因子之间的关系。决策树或分类树的展开，始于确定作为根节点的目标变量或因变量。 CHAID分析将目标变量分割成两个或两个以上的类被称为根节点，或者父节点，然后使用统计算法将节点分为子节点。不同于回归分析，CHAID技术并不要求数据是正态分布.</p>
<p>CHAID的优势是它的结果是非常直观的易于理解的。由于默认情况下CHAID采用多路分割，需要相当大的样本量，来有效地开展工作，而小样本组受访者可以迅速分为太小了的组，而无法可靠的分析。</p>
<p>CHAID决策树的构成包括：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>根节点：根节点包含因变量或目标变量。例如，CHAID使用于，银行根据年龄，收入，信用卡等，来预测信用卡风险。在这个例子中，信用卡风险是目标变量，其余变量是预测变量。</p>
</li>
<li class="lvl-2">
<p>父节点：该算法将目标变量分割成两个或多个分类。这些分类被称为父节点或者初始节点。在银行的例子中，父节点是高，中，低三个分类。</p>
</li>
<li class="lvl-2">
<p>子节点：CHAID分析树中独立变量分类低于父节点的分类被称为子节点。</p>
</li>
<li class="lvl-2">
<p>终端节点：CHAID分析树最后一个分类被称为终端节点。 CHAID分析树中，主要的影响变量排在前面，次要的排在后面。因此，它被称为终端节点。</p>
</li>
</ul>
<h3 id="CHAID的优点">CHAID的优点</h3>
<ol>
<li class="lvl-3">
<p>可产生多分枝的决策树</p>
</li>
<li class="lvl-3">
<p>目标变量可以定距或定类</p>
</li>
<li class="lvl-3">
<p>从统计显著性角度确定分支变量和分割值，进而优化树的分枝过程</p>
</li>
<li class="lvl-3">
<p>建立在因果关系探讨中，依据目标变量实现对输入变量众多水平划分</p>
</li>
</ol>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>决策树算法</category>
      </categories>
      <tags>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title>随机森林</title>
    <url>/posts/41b133f5.html</url>
    <content><![CDATA[<h2 id="随机森林（Random-Forest）">随机森林（Random Forest）</h2>
<p>随机森林是一个包含多个决策树的分类器，并且其输出的类别是由个别树输出的类别的众数而定。 Leo Breiman和Adele Cutler发展出推论出随机森林的算法。而&quot;Random Forests&quot;是他们的商标。这个术语是1995年由贝尔实验室的Tin Kam Ho所提出的随机决策森林（random decision forests）而来的。这个方法则是结合Breimans的&quot;Bootstrap aggregating&quot;想法和Ho的&quot;random subspace method&quot; 以建造决策树的集合。</p>
<p>随机森林通过集成学习的思想将多棵树集成的一种算法，它的基本单元是决策树，而它的本质属于机器学习的一大分支——集成学习（Ensemble Learning）方法。随机森林的名称中有两个关键词，一个是“随机”，一个就是&quot;森林&quot;。&quot;森林&quot;我们很好理解，一棵叫做树，那么成百上千棵就可以叫做森林了，这样的比喻还是很贴切的，其实这也是随机森林的主要思想–集成思想的体现。其实从直观角度来解释，每棵决策树都是一个分类器（假设现在针对的是分类问题），那么对于一个输入样本，N棵树会有N个分类结果。而随机森林集成了所有的分类投票结果，将投票次数最多的类别指定为最终的输出，这就是一种最简单的 Bagging 思想。</p>
<p align="center">
<img width="700" align="center" src="/img/images/179.jpg" />
</p>
<p>随机森林是一种很灵活实用的方法，它有如下几个特点:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在当前所有算法中，具有极好的准确率;</p>
</li>
<li class="lvl-2">
<p>能够有效地运行在大数据集上;</p>
</li>
<li class="lvl-2">
<p>能够处理具有高维特征的输入样本，而且不需要降维;</p>
</li>
<li class="lvl-2">
<p>能够评估各个特征在分类问题上的重要性;</p>
</li>
<li class="lvl-2">
<p>在生成过程中，能够获取到内部生成误差的一种无偏估计;</p>
</li>
<li class="lvl-2">
<p>对于缺省值问题也能够获得很好得结果;</p>
</li>
</ul>
<h3 id="应用案例-3">应用案例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_moons, make_circles, make_classification</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier, AdaBoostClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br><span class="line"><span class="keyword">from</span> sklearn.lda <span class="keyword">import</span> LDA</span><br><span class="line"><span class="keyword">from</span> sklearn.qda <span class="keyword">import</span> QDA</span><br><span class="line"></span><br><span class="line">h = <span class="number">.02</span>  <span class="comment"># step size in the mesh</span></span><br><span class="line"></span><br><span class="line">names = [<span class="string">&quot;Nearest Neighbors&quot;</span>, <span class="string">&quot;Linear SVM&quot;</span>, <span class="string">&quot;RBF SVM&quot;</span>, <span class="string">&quot;Decision Tree&quot;</span>,</span><br><span class="line">         <span class="string">&quot;Random Forest&quot;</span>, <span class="string">&quot;AdaBoost&quot;</span>, <span class="string">&quot;Naive Bayes&quot;</span>, <span class="string">&quot;LDA&quot;</span>, <span class="string">&quot;QDA&quot;</span>]</span><br><span class="line">classifiers = [</span><br><span class="line">    KNeighborsClassifier(<span class="number">3</span>),</span><br><span class="line">    SVC(kernel=<span class="string">&quot;linear&quot;</span>, C=<span class="number">0.025</span>),</span><br><span class="line">    SVC(gamma=<span class="number">2</span>, C=<span class="number">1</span>),</span><br><span class="line">    DecisionTreeClassifier(max_depth=<span class="number">5</span>),</span><br><span class="line">    RandomForestClassifier(max_depth=<span class="number">5</span>, n_estimators=<span class="number">10</span>, max_features=<span class="number">1</span>),</span><br><span class="line">    AdaBoostClassifier(),</span><br><span class="line">    GaussianNB(),</span><br><span class="line">    LDA(),</span><br><span class="line">    QDA()]</span><br><span class="line"></span><br><span class="line">X, y = make_classification(n_features=<span class="number">2</span>, n_redundant=<span class="number">0</span>, n_informative=<span class="number">2</span>,</span><br><span class="line">                           random_state=<span class="number">1</span>, n_clusters_per_class=<span class="number">1</span>)</span><br><span class="line">rng = np.random.RandomState(<span class="number">2</span>)</span><br><span class="line">X += <span class="number">2</span> * rng.uniform(size=X.shape)</span><br><span class="line">linearly_separable = (X, y)</span><br><span class="line"></span><br><span class="line">datasets = [make_moons(noise=<span class="number">0.3</span>, random_state=<span class="number">0</span>),</span><br><span class="line">            make_circles(noise=<span class="number">0.2</span>, factor=<span class="number">0.5</span>, random_state=<span class="number">1</span>),</span><br><span class="line">            linearly_separable</span><br><span class="line">            ]</span><br><span class="line"></span><br><span class="line">figure = plt.figure(figsize=(<span class="number">27</span>, <span class="number">9</span>))</span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="comment"># iterate over datasets</span></span><br><span class="line"><span class="keyword">for</span> ds <span class="keyword">in</span> datasets:</span><br><span class="line">    <span class="comment"># preprocess dataset, split into training and test part</span></span><br><span class="line">    X, y = ds</span><br><span class="line">    X = StandardScaler().fit_transform(X)</span><br><span class="line">    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">.4</span>)</span><br><span class="line"></span><br><span class="line">    x_min, x_max = X[:, <span class="number">0</span>].<span class="built_in">min</span>() - <span class="number">.5</span>, X[:, <span class="number">0</span>].<span class="built_in">max</span>() + <span class="number">.5</span></span><br><span class="line">    y_min, y_max = X[:, <span class="number">1</span>].<span class="built_in">min</span>() - <span class="number">.5</span>, X[:, <span class="number">1</span>].<span class="built_in">max</span>() + <span class="number">.5</span></span><br><span class="line">    xx, yy = np.meshgrid(np.arange(x_min, x_max, h),</span><br><span class="line">                         np.arange(y_min, y_max, h))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># just plot the dataset first</span></span><br><span class="line">    cm = plt.cm.RdBu</span><br><span class="line">    cm_bright = ListedColormap([<span class="string">&#x27;#FF0000&#x27;</span>, <span class="string">&#x27;#0000FF&#x27;</span>])</span><br><span class="line">    ax = plt.subplot(<span class="built_in">len</span>(datasets), <span class="built_in">len</span>(classifiers) + <span class="number">1</span>, i)</span><br><span class="line">    <span class="comment"># Plot the training points</span></span><br><span class="line">    ax.scatter(X_train[:, <span class="number">0</span>], X_train[:, <span class="number">1</span>], c=y_train, cmap=cm_bright)</span><br><span class="line">    <span class="comment"># and testing points</span></span><br><span class="line">    ax.scatter(X_test[:, <span class="number">0</span>], X_test[:, <span class="number">1</span>], c=y_test, cmap=cm_bright, alpha=<span class="number">0.6</span>)</span><br><span class="line">    ax.set_xlim(xx.<span class="built_in">min</span>(), xx.<span class="built_in">max</span>())</span><br><span class="line">    ax.set_ylim(yy.<span class="built_in">min</span>(), yy.<span class="built_in">max</span>())</span><br><span class="line">    ax.set_xticks(())</span><br><span class="line">    ax.set_yticks(())</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># iterate over classifiers</span></span><br><span class="line">    <span class="keyword">for</span> name, clf <span class="keyword">in</span> <span class="built_in">zip</span>(names, classifiers):</span><br><span class="line">        ax = plt.subplot(<span class="built_in">len</span>(datasets), <span class="built_in">len</span>(classifiers) + <span class="number">1</span>, i)</span><br><span class="line">        clf.fit(X_train, y_train)</span><br><span class="line">        score = clf.score(X_test, y_test)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Plot the decision boundary. For that, we will assign a color to each</span></span><br><span class="line">        <span class="comment"># point in the mesh [x_min, m_max]x[y_min, y_max].</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">hasattr</span>(clf, <span class="string">&quot;decision_function&quot;</span>):</span><br><span class="line">            Z = clf.decision_function(np.c_[xx.ravel(), yy.ravel()])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            Z = clf.predict_proba(np.c_[xx.ravel(), yy.ravel()])[:, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Put the result into a color plot</span></span><br><span class="line">        Z = Z.reshape(xx.shape)</span><br><span class="line">        ax.contourf(xx, yy, Z, cmap=cm, alpha=<span class="number">.8</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Plot also the training points</span></span><br><span class="line">        ax.scatter(X_train[:, <span class="number">0</span>], X_train[:, <span class="number">1</span>], c=y_train, cmap=cm_bright)</span><br><span class="line">        <span class="comment"># and testing points</span></span><br><span class="line">        ax.scatter(X_test[:, <span class="number">0</span>], X_test[:, <span class="number">1</span>], c=y_test, cmap=cm_bright,</span><br><span class="line">                   alpha=<span class="number">0.6</span>)</span><br><span class="line"></span><br><span class="line">        ax.set_xlim(xx.<span class="built_in">min</span>(), xx.<span class="built_in">max</span>())</span><br><span class="line">        ax.set_ylim(yy.<span class="built_in">min</span>(), yy.<span class="built_in">max</span>())</span><br><span class="line">        ax.set_xticks(())</span><br><span class="line">        ax.set_yticks(())</span><br><span class="line">        ax.set_title(name)</span><br><span class="line">        ax.text(xx.<span class="built_in">max</span>() - <span class="number">.3</span>, yy.<span class="built_in">min</span>() + <span class="number">.3</span>, (<span class="string">&#x27;%.2f&#x27;</span> % score).lstrip(<span class="string">&#x27;0&#x27;</span>),</span><br><span class="line">                size=<span class="number">15</span>, horizontalalignment=<span class="string">&#x27;right&#x27;</span>)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">figure.subplots_adjust(left=<span class="number">.02</span>, right=<span class="number">.98</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="优点-5">优点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>随机森林对于很多种数据，它可以产生高准确度的分类器。</p>
</li>
<li class="lvl-2">
<p>随机森林可以处理大量的输入变量。</p>
</li>
<li class="lvl-2">
<p>随机森林可以在决定类别时，评估变量的重要性。</p>
</li>
<li class="lvl-2">
<p>在建造森林时，它可以在内部对于一般化后的误差产生不偏差的估计。</p>
</li>
<li class="lvl-2">
<p>随机森林包含一个好方法可以估计丢失的数据，并且，如果有很大一部分的数据丢失，仍可以维持准确度。</p>
</li>
<li class="lvl-2">
<p>它提供一个实验方法，可以去侦测variable interactions。</p>
</li>
<li class="lvl-2">
<p>对于不平衡的分类数据集来说，它可以平衡误差。</p>
</li>
<li class="lvl-2">
<p>它计算各例中的亲近度，对于数据挖掘、侦测离群点（outlier）和将数据可视化非常有用。</p>
</li>
<li class="lvl-2">
<p>它可被延伸应用在未标记的数据上，这类数据通常是使用非监督式聚类。也可侦测偏离者和观看数据。</p>
</li>
<li class="lvl-2">
<p>学习过程是很快速的。</p>
</li>
</ul>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>决策树算法</category>
      </categories>
      <tags>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归</title>
    <url>/posts/40997091.html</url>
    <content><![CDATA[<h2 id="线性回归-3">线性回归</h2>
<p>线性回归是最简单的回归方法，它的目标是使用超平面拟合数据集，即学习一个线性模型以尽可能准确的预测实值输出标记。线性回归是利用数理统计中回归分析，来确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法，运用十分广泛。其表达形式为y = w’x+e，e为误差服从均值为0的正态分布。回归分析中，只包括一个自变量和一个因变量，且二者的关系可用一条直线近似表示，这种回归分析称为一元线性回归分析。如果回归分析中包括两个或两个以上的自变量，且因变量和自变量之间是线性关系，则称为多元线性回归分析。</p>
<h3 id="单变量模型">单变量模型</h3>
<p>模型</p>
<p align="center">
<img width="230" align="center" src="/img/images/131.jpg" />
</p>
线性模型(linear model)
简单, 易于建模, 但却蕴含着机器学习的重要思想.由于w直观地表达了各属性在预测中的重要性, 所以线性模型有着很好的可解释性(comprehensibility).
<p>目标函数（最小二乘参数估计）</p>
<p align="center">
<img width="260" align="center" src="/img/images/130.jpg" />
</p>
<h3 id="多变量模型">多变量模型</h3>
<p>多变量时可以表示为矩阵</p>
<p align="center">
<img width="270" align="center" src="/img/images/132.jpg" />
</p>
<p>目标函数为</p>
<p align="center">
<img width="270" align="center" src="/img/images/133.jpg" />
</p>
<p>当$X^TX$为满秩矩阵时，可以得到最优解</p>
<p align="center">
<img width="240" align="center" src="/img/images/134.jpg" />
</p>
<p>注意：</p>
<p>1.多变量时需要对输入数据作归一化，如<img width="140" align="center" src="/img/images/135.jpg" /></p>
<p>2.实际计算过程中（如使用梯度下降算法）学习率的选择方法</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>收敛慢时，增大学习率</p>
</li>
<li class="lvl-2">
<p>不收敛时，减小学习率</p>
</li>
<li class="lvl-2">
<p>学习率的选择范围一般为…, 0.001, 0.01, 0.1, 1, 10, …</p>
</li>
</ul>
<h3 id="代码例子">代码例子</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Indicate the matplotlib to show the graphics inline</span></span><br><span class="line">%matplotlib inline </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt <span class="comment"># import matplotlib</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment"># import numpy</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">trX = np.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">101</span>) <span class="comment">#Create a linear space of 101 points between 1 and 1</span></span><br><span class="line">trY = <span class="number">2</span> * trX + np.random.randn(*trX.shape) * <span class="number">0.4</span> + <span class="number">0.2</span> <span class="comment">#Create The y function based on the x axis</span></span><br><span class="line">plt.figure() <span class="comment"># Create a new figure</span></span><br><span class="line">plt.scatter(trX,trY) <span class="comment">#Plot a scatter draw of the random datapoints</span></span><br><span class="line">plt.plot (trX, <span class="number">.2</span> + <span class="number">2</span> * trX) <span class="comment"># Draw one line with the line function</span></span><br></pre></td></tr></table></figure>
<p align="center">
<img width="300" align="center" src="/img/images/127.jpg" />
</p>
<h3 id="单变量示例">单变量示例</h3>
<p align="center">
<img width="300" align="center" src="/img/images/128.jpg" />
</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># h(X)= b + wX</span></span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">model</span>(<span class="params">X, w, b</span>):</span><br><span class="line">    <span class="keyword">return</span> tf.mul(X, w) + b</span><br><span class="line"></span><br><span class="line">trX = np.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">101</span>).astype(np.float32)</span><br><span class="line"><span class="comment"># create a y value which is approximately linear but with some random noise</span></span><br><span class="line">trY = <span class="number">2</span> * trX + np.random.randn(*trX.shape) * <span class="number">0.33</span> + <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create a shared variable (like theano.shared) for the weight matrix</span></span><br><span class="line">w = tf.Variable(tf.random_uniform([<span class="number">1</span>], -<span class="number">1.0</span>, <span class="number">1.0</span>))</span><br><span class="line">b = tf.Variable(tf.zeros([<span class="number">1</span>]))</span><br><span class="line">cost = tf.reduce_mean(tf.square(trY-model(trX, w, b)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># construct an optimizer to minimize cost and fit line to my data</span></span><br><span class="line">train_op = tf.train.GradientDescentOptimizer(<span class="number">0.01</span>).minimize(cost)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Launch the graph in a session</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="comment"># you need to initialize variables (in this case just variable W)</span></span><br><span class="line">    tf.initialize_all_variables().run()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        sess.run(train_op)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;w should be something around [2]: &quot;</span>, sess.run(w)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;b should be something around [10]:&quot;</span>, sess.run(b)</span><br><span class="line"></span><br><span class="line">    plt.plot(trX, trY, <span class="string">&quot;ro&quot;</span>, label=<span class="string">&quot;Orinal data&quot;</span>)</span><br><span class="line">    plt.plot(trX, w.<span class="built_in">eval</span>()*trX + b.<span class="built_in">eval</span>(), label=<span class="string">&quot;Fitted line&quot;</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Plot with pandas</span></span><br><span class="line">    <span class="comment">#import pandas as pd</span></span><br><span class="line">    <span class="comment">#fig, axes = plt.subplots(nrows=1, ncols=1)</span></span><br><span class="line">    <span class="comment">#pd.DataFrame(&#123;&#x27;x&#x27;:trX,&#x27;y&#x27;:trY&#125;).plot.scatter(x=&#x27;x&#x27;, y=&#x27;y&#x27;, ax=axes, color=&#x27;red&#x27;)</span></span><br><span class="line">    <span class="comment">#pd.DataFrame(&#123;&#x27;x&#x27;:trX,&#x27;y&#x27;:w.eval()*trX + b.eval()&#125;).plot.scatter(x=&#x27;x&#x27;, y=&#x27;y&#x27;, ax=axes, color=&#x27;blue&#x27;)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">w should be something around [<span class="number">2</span>]:  [ <span class="number">2.00981951</span>]</span><br><span class="line">b should be something around [<span class="number">10</span>]: [ <span class="number">9.98865509</span>]</span><br></pre></td></tr></table></figure>
<p align="center">
<img width="300" align="center" src="/img/images/129.jpg" />
</p>
<h3 id="多变量示例">多变量示例</h3>
<p>多变量其实就是输入变成了矩阵：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># h(X)= B + WX</span></span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">model</span>(<span class="params">X, w, b</span>):</span><br><span class="line">    <span class="keyword">return</span> tf.mul(w, X) + b</span><br><span class="line"></span><br><span class="line">trX = np.mgrid[-<span class="number">1</span>:<span class="number">1</span>:<span class="number">0.01</span>, -<span class="number">10</span>:<span class="number">10</span>:<span class="number">0.1</span>].reshape(<span class="number">2</span>, -<span class="number">1</span>).T</span><br><span class="line">trW = np.array([<span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line">trY = trW*trX + np.random.randn(*trX.shape) + [<span class="number">20</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line">w = tf.Variable(np.array([<span class="number">1.</span>, <span class="number">1.</span>]).astype(np.float32))</span><br><span class="line">b = tf.Variable(np.array([[<span class="number">1.</span>, <span class="number">1.</span>]]).astype(np.float32))</span><br><span class="line">cost = tf.reduce_mean(tf.square(trY-model(trX, w, b))) </span><br><span class="line"></span><br><span class="line"><span class="comment"># construct an optimizer to minimize cost and fit line to my data</span></span><br><span class="line">train_op = tf.train.GradientDescentOptimizer(<span class="number">0.05</span>).minimize(cost)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Launch the graph in a session</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="comment"># you need to initialize variables (in this case just variable W)</span></span><br><span class="line">    tf.initialize_all_variables().run()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">99</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;Cost at step&quot;</span>, i, <span class="string">&quot;is:&quot;</span>, cost.<span class="built_in">eval</span>()</span><br><span class="line">        sess.run(train_op)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;w should be something around [3, 5]: &quot;</span>, sess.run(w)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;b should be something around [20,100]:&quot;</span>, sess.run(b)</span><br><span class="line">Cost at step <span class="number">0</span> <span class="keyword">is</span>: <span class="number">5329.87</span></span><br><span class="line">Cost at step <span class="number">99</span> <span class="keyword">is</span>: <span class="number">1.22204</span></span><br><span class="line">Cost at step <span class="number">198</span> <span class="keyword">is</span>: <span class="number">0.998043</span></span><br><span class="line">Cost at step <span class="number">297</span> <span class="keyword">is</span>: <span class="number">0.997083</span></span><br><span class="line">Cost at step <span class="number">396</span> <span class="keyword">is</span>: <span class="number">0.997049</span></span><br><span class="line">Cost at step <span class="number">495</span> <span class="keyword">is</span>: <span class="number">0.997049</span></span><br><span class="line">Cost at step <span class="number">594</span> <span class="keyword">is</span>: <span class="number">0.997049</span></span><br><span class="line">Cost at step <span class="number">693</span> <span class="keyword">is</span>: <span class="number">0.997049</span></span><br><span class="line">Cost at step <span class="number">792</span> <span class="keyword">is</span>: <span class="number">0.997049</span></span><br><span class="line">Cost at step <span class="number">891</span> <span class="keyword">is</span>: <span class="number">0.997049</span></span><br><span class="line">Cost at step <span class="number">990</span> <span class="keyword">is</span>: <span class="number">0.997049</span></span><br><span class="line">w should be something around [<span class="number">3</span>, <span class="number">5</span>]:  [ <span class="number">3.00108743</span>  <span class="number">5.00054932</span>]</span><br><span class="line">b should be something around [<span class="number">20</span>,<span class="number">100</span>]: [[  <span class="number">20.00317383</span>  <span class="number">100.00382233</span>]]</span><br><span class="line">tensorflow示例</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># initialize variables/model parameters</span></span><br><span class="line">W = tf.Variable(tf.zeros([<span class="number">2</span>, <span class="number">1</span>]), name=<span class="string">&quot;weights&quot;</span>)</span><br><span class="line">b = tf.Variable(<span class="number">0.</span>, name=<span class="string">&quot;bias&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inference</span>(<span class="params">X</span>):</span><br><span class="line">    <span class="comment"># compute inference model over data X and return the result</span></span><br><span class="line">    <span class="keyword">return</span> tf.matmul(X, W) + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loss</span>(<span class="params">X, Y</span>):</span><br><span class="line">    <span class="comment"># compute loss over training data X and expected outputs Y</span></span><br><span class="line">    Y_predicted = inference(X)</span><br><span class="line">    <span class="keyword">return</span> tf.reduce_sum(tf.squared_difference(Y, Y_predicted))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inputs</span>():</span><br><span class="line">    <span class="comment"># read/generate input training data X and expected outputs Y</span></span><br><span class="line">    weight_age = [[<span class="number">84</span>, <span class="number">46</span>], [<span class="number">73</span>, <span class="number">20</span>], [<span class="number">65</span>, <span class="number">52</span>], [<span class="number">70</span>, <span class="number">30</span>], [<span class="number">76</span>, <span class="number">57</span>], [<span class="number">69</span>, <span class="number">25</span>], [<span class="number">63</span>, <span class="number">28</span>], [<span class="number">72</span>, <span class="number">36</span>], [<span class="number">79</span>, <span class="number">57</span>], [<span class="number">75</span>, <span class="number">44</span>], [<span class="number">27</span>, <span class="number">24</span>], [<span class="number">89</span>, <span class="number">31</span>], [<span class="number">65</span>, <span class="number">52</span>], [<span class="number">57</span>, <span class="number">23</span>], [<span class="number">59</span>, <span class="number">60</span>], [<span class="number">69</span>, <span class="number">48</span>], [<span class="number">60</span>, <span class="number">34</span>], [<span class="number">79</span>, <span class="number">51</span>], [<span class="number">75</span>, <span class="number">50</span>], [<span class="number">82</span>, <span class="number">34</span>], [<span class="number">59</span>, <span class="number">46</span>], [<span class="number">67</span>, <span class="number">23</span>], [<span class="number">85</span>, <span class="number">37</span>], [<span class="number">55</span>, <span class="number">40</span>], [<span class="number">63</span>, <span class="number">30</span>]]</span><br><span class="line">    blood_fat_content = [<span class="number">354</span>, <span class="number">190</span>, <span class="number">405</span>, <span class="number">263</span>, <span class="number">451</span>, <span class="number">302</span>, <span class="number">288</span>, <span class="number">385</span>, <span class="number">402</span>, <span class="number">365</span>, <span class="number">209</span>, <span class="number">290</span>, <span class="number">346</span>, <span class="number">254</span>, <span class="number">395</span>, <span class="number">434</span>, <span class="number">220</span>, <span class="number">374</span>, <span class="number">308</span>, <span class="number">220</span>, <span class="number">311</span>, <span class="number">181</span>, <span class="number">274</span>, <span class="number">303</span>, <span class="number">244</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tf.to_float(weight_age), tf.to_float(blood_fat_content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">total_loss</span>):</span><br><span class="line">    <span class="comment"># train / adjust model parameters according to computed total loss</span></span><br><span class="line">    learning_rate = <span class="number">0.000001</span></span><br><span class="line">    <span class="keyword">return</span> tf.train.GradientDescentOptimizer(learning_rate).minimize(total_loss)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate</span>(<span class="params">sess, X, Y</span>):</span><br><span class="line">    <span class="comment"># evaluate the resulting trained model</span></span><br><span class="line">    <span class="built_in">print</span> sess.run(inference([[<span class="number">80.</span>, <span class="number">25.</span>]])) <span class="comment"># ~ 303</span></span><br><span class="line">    <span class="built_in">print</span> sess.run(inference([[<span class="number">65.</span>, <span class="number">25.</span>]])) <span class="comment"># ~ 256</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a saver.</span></span><br><span class="line"><span class="comment"># saver = tf.train.Saver()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Launch the graph in a session, setup boilerplate</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    tf.initialize_all_variables().run()</span><br><span class="line"></span><br><span class="line">    X, Y = inputs()</span><br><span class="line"></span><br><span class="line">    total_loss = loss(X, Y)</span><br><span class="line">    train_op = train(total_loss)</span><br><span class="line"></span><br><span class="line">    coord = tf.train.Coordinator()</span><br><span class="line">    threads = tf.train.start_queue_runners(sess=sess, coord=coord)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># actual training loop</span></span><br><span class="line">    training_steps = <span class="number">1000</span></span><br><span class="line">    <span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(training_steps):</span><br><span class="line">        sess.run([train_op])</span><br><span class="line">        <span class="comment"># for debugging and learning purposes, see how the loss gets decremented</span></span><br><span class="line">        <span class="comment"># through training steps</span></span><br><span class="line">        <span class="keyword">if</span> step % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;loss at step &quot;</span>, step, <span class="string">&quot;:&quot;</span>, sess.run([total_loss])</span><br><span class="line">        <span class="comment"># save training checkpoints in case loosing them</span></span><br><span class="line">        <span class="comment"># if step % 1000 == 0:</span></span><br><span class="line">        <span class="comment">#     saver.save(sess, &#x27;my-model&#x27;, global_step=step)</span></span><br><span class="line"></span><br><span class="line">    evaluate(sess, X, Y)</span><br><span class="line">    coord.request_stop()</span><br><span class="line">    coord.join(threads)</span><br><span class="line">    <span class="comment"># saver.save(sess, &#x27;my-model&#x27;, global_step=training_steps)</span></span><br></pre></td></tr></table></figure>
<h3 id="输出：">输出：</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss at step  <span class="number">0</span> : [<span class="number">54929292.0</span>]</span><br><span class="line">loss at step  <span class="number">10</span> :  [<span class="number">14629748.0</span>]</span><br><span class="line">loss at step  <span class="number">20</span> :  [<span class="number">7090800.0</span>]</span><br><span class="line">loss at step  <span class="number">30</span> :  [<span class="number">5680201.0</span>]</span><br><span class="line">loss at step  <span class="number">40</span> :  [<span class="number">5416011.0</span>]</span><br><span class="line">loss at step  <span class="number">50</span> :  [<span class="number">5366280.5</span>]</span><br><span class="line">loss at step  <span class="number">60</span> :  [<span class="number">5356678.0</span>]</span><br><span class="line">loss at step  <span class="number">70</span> :  [<span class="number">5354588.0</span>]</span><br><span class="line">loss at step  <span class="number">80</span> :  [<span class="number">5353913.0</span>]</span><br><span class="line">loss at step  <span class="number">90</span> :  [<span class="number">5353510.0</span>]</span><br><span class="line">loss at step  <span class="number">100</span> : [<span class="number">5353166.0</span>]</span><br><span class="line">loss at step  <span class="number">110</span> : [<span class="number">5352839.5</span>]</span><br><span class="line">loss at step  <span class="number">120</span> : [<span class="number">5352525.0</span>]</span><br><span class="line">loss at step  <span class="number">130</span> : [<span class="number">5352218.5</span>]</span><br><span class="line">loss at step  <span class="number">140</span> : [<span class="number">5351921.0</span>]</span><br><span class="line">loss at step  <span class="number">150</span> : [<span class="number">5351631.5</span>]</span><br><span class="line">loss at step  <span class="number">160</span> : [<span class="number">5351349.0</span>]</span><br><span class="line">loss at step  <span class="number">170</span> : [<span class="number">5351075.0</span>]</span><br><span class="line">loss at step  <span class="number">180</span> : [<span class="number">5350808.0</span>]</span><br><span class="line">loss at step  <span class="number">190</span> : [<span class="number">5350549.5</span>]</span><br><span class="line">loss at step  <span class="number">200</span> : [<span class="number">5350297.0</span>]</span><br><span class="line">loss at step  <span class="number">210</span> : [<span class="number">5350050.5</span>]</span><br><span class="line">loss at step  <span class="number">220</span> : [<span class="number">5349814.0</span>]</span><br><span class="line">loss at step  <span class="number">230</span> : [<span class="number">5349580.5</span>]</span><br><span class="line">loss at step  <span class="number">240</span> : [<span class="number">5349356.0</span>]</span><br><span class="line">loss at step  <span class="number">250</span> : [<span class="number">5349134.0</span>]</span><br><span class="line">loss at step  <span class="number">260</span> : [<span class="number">5348922.0</span>]</span><br><span class="line">loss at step  <span class="number">270</span> : [<span class="number">5348712.5</span>]</span><br><span class="line">loss at step  <span class="number">280</span> : [<span class="number">5348511.5</span>]</span><br><span class="line">loss at step  <span class="number">290</span> : [<span class="number">5348313.5</span>]</span><br><span class="line">loss at step  <span class="number">300</span> : [<span class="number">5348123.5</span>]</span><br><span class="line">loss at step  <span class="number">310</span> : [<span class="number">5347935.0</span>]</span><br><span class="line">loss at step  <span class="number">320</span> : [<span class="number">5347753.5</span>]</span><br><span class="line">loss at step  <span class="number">330</span> : [<span class="number">5347577.5</span>]</span><br><span class="line">loss at step  <span class="number">340</span> : [<span class="number">5347405.0</span>]</span><br><span class="line">loss at step  <span class="number">350</span> : [<span class="number">5347237.0</span>]</span><br><span class="line">loss at step  <span class="number">360</span> : [<span class="number">5347073.0</span>]</span><br><span class="line">loss at step  <span class="number">370</span> : [<span class="number">5346915.0</span>]</span><br><span class="line">loss at step  <span class="number">380</span> : [<span class="number">5346761.0</span>]</span><br><span class="line">loss at step  <span class="number">390</span> : [<span class="number">5346611.0</span>]</span><br><span class="line">loss at step  <span class="number">400</span> : [<span class="number">5346464.5</span>]</span><br><span class="line">loss at step  <span class="number">410</span> : [<span class="number">5346320.5</span>]</span><br><span class="line">loss at step  <span class="number">420</span> : [<span class="number">5346182.5</span>]</span><br><span class="line">loss at step  <span class="number">430</span> : [<span class="number">5346047.5</span>]</span><br><span class="line">loss at step  <span class="number">440</span> : [<span class="number">5345914.0</span>]</span><br><span class="line">loss at step  <span class="number">450</span> : [<span class="number">5345786.0</span>]</span><br><span class="line">loss at step  <span class="number">460</span> : [<span class="number">5345662.0</span>]</span><br><span class="line">loss at step  <span class="number">470</span> : [<span class="number">5345539.5</span>]</span><br><span class="line">loss at step  <span class="number">480</span> : [<span class="number">5345420.5</span>]</span><br><span class="line">loss at step  <span class="number">490</span> : [<span class="number">5345305.5</span>]</span><br><span class="line">loss at step  <span class="number">500</span> : [<span class="number">5345193.0</span>]</span><br><span class="line">loss at step  <span class="number">510</span> : [<span class="number">5345082.5</span>]</span><br><span class="line">loss at step  <span class="number">520</span> : [<span class="number">5344976.5</span>]</span><br><span class="line">loss at step  <span class="number">530</span> : [<span class="number">5344871.0</span>]</span><br><span class="line">loss at step  <span class="number">540</span> : [<span class="number">5344771.0</span>]</span><br><span class="line">loss at step  <span class="number">550</span> : [<span class="number">5344670.5</span>]</span><br><span class="line">loss at step  <span class="number">560</span> : [<span class="number">5344574.5</span>]</span><br><span class="line">loss at step  <span class="number">570</span> : [<span class="number">5344480.5</span>]</span><br><span class="line">loss at step  <span class="number">580</span> : [<span class="number">5344388.0</span>]</span><br><span class="line">loss at step  <span class="number">590</span> : [<span class="number">5344298.0</span>]</span><br><span class="line">loss at step  <span class="number">600</span> : [<span class="number">5344212.0</span>]</span><br><span class="line">loss at step  <span class="number">610</span> : [<span class="number">5344127.0</span>]</span><br><span class="line">loss at step  <span class="number">620</span> : [<span class="number">5344042.5</span>]</span><br><span class="line">loss at step  <span class="number">630</span> : [<span class="number">5343962.0</span>]</span><br><span class="line">loss at step  <span class="number">640</span> : [<span class="number">5343882.0</span>]</span><br><span class="line">loss at step  <span class="number">650</span> : [<span class="number">5343805.5</span>]</span><br><span class="line">loss at step  <span class="number">660</span> : [<span class="number">5343729.5</span>]</span><br><span class="line">loss at step  <span class="number">670</span> : [<span class="number">5343657.0</span>]</span><br><span class="line">loss at step  <span class="number">680</span> : [<span class="number">5343584.0</span>]</span><br><span class="line">loss at step  <span class="number">690</span> : [<span class="number">5343514.5</span>]</span><br><span class="line">loss at step  <span class="number">700</span> : [<span class="number">5343446.5</span>]</span><br><span class="line">loss at step  <span class="number">710</span> : [<span class="number">5343380.0</span>]</span><br><span class="line">loss at step  <span class="number">720</span> : [<span class="number">5343314.5</span>]</span><br><span class="line">loss at step  <span class="number">730</span> : [<span class="number">5343250.0</span>]</span><br><span class="line">loss at step  <span class="number">740</span> : [<span class="number">5343187.5</span>]</span><br><span class="line">loss at step  <span class="number">750</span> : [<span class="number">5343128.0</span>]</span><br><span class="line">loss at step  <span class="number">760</span> : [<span class="number">5343067.5</span>]</span><br><span class="line">loss at step  <span class="number">770</span> : [<span class="number">5343010.5</span>]</span><br><span class="line">loss at step  <span class="number">780</span> : [<span class="number">5342952.5</span>]</span><br><span class="line">loss at step  <span class="number">790</span> : [<span class="number">5342897.5</span>]</span><br><span class="line">loss at step  <span class="number">800</span> : [<span class="number">5342843.0</span>]</span><br><span class="line">loss at step  <span class="number">810</span> : [<span class="number">5342791.5</span>]</span><br><span class="line">loss at step  <span class="number">820</span> : [<span class="number">5342738.5</span>]</span><br><span class="line">loss at step  <span class="number">830</span> : [<span class="number">5342688.5</span>]</span><br><span class="line">loss at step  <span class="number">840</span> : [<span class="number">5342638.5</span>]</span><br><span class="line">loss at step  <span class="number">850</span> : [<span class="number">5342589.5</span>]</span><br><span class="line">loss at step  <span class="number">860</span> : [<span class="number">5342543.0</span>]</span><br><span class="line">loss at step  <span class="number">870</span> : [<span class="number">5342496.5</span>]</span><br><span class="line">loss at step  <span class="number">880</span> : [<span class="number">5342449.5</span>]</span><br><span class="line">loss at step  <span class="number">890</span> : [<span class="number">5342406.0</span>]</span><br><span class="line">loss at step  <span class="number">900</span> : [<span class="number">5342363.0</span>]</span><br><span class="line">loss at step  <span class="number">910</span> : [<span class="number">5342319.5</span>]</span><br><span class="line">loss at step  <span class="number">920</span> : [<span class="number">5342277.5</span>]</span><br><span class="line">loss at step  <span class="number">930</span> : [<span class="number">5342236.0</span>]</span><br><span class="line">loss at step  <span class="number">940</span> : [<span class="number">5342197.5</span>]</span><br><span class="line">loss at step  <span class="number">950</span> : [<span class="number">5342157.0</span>]</span><br><span class="line">loss at step  <span class="number">960</span> : [<span class="number">5342118.5</span>]</span><br><span class="line">loss at step  <span class="number">970</span> : [<span class="number">5342080.5</span>]</span><br><span class="line">loss at step  <span class="number">980</span> : [<span class="number">5342043.0</span>]</span><br><span class="line">loss at step  <span class="number">990</span> : [<span class="number">5342007.5</span>]</span><br><span class="line">[[ <span class="number">318.77984619</span>]]</span><br><span class="line">[[ <span class="number">266.52853394</span>]]</span><br></pre></td></tr></table></figure>
<h3 id="sklearn示例">sklearn示例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow.contrib.learn.python.learn <span class="keyword">as</span> learn</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets, metrics, preprocessing</span><br><span class="line"></span><br><span class="line">boston = datasets.load_boston()</span><br><span class="line">x = preprocessing.StandardScaler().fit_transform(boston.data)</span><br><span class="line">feature_columns = learn.infer_real_valued_columns_from_input(x)</span><br><span class="line">regressor = learn.LinearRegressor(feature_columns=feature_columns)</span><br><span class="line">regressor.fit(x, boston.target, steps=<span class="number">200</span>, batch_size=<span class="number">32</span>)</span><br><span class="line">boston_predictions = <span class="built_in">list</span>(regressor.predict(x, as_iterable=<span class="literal">True</span>))</span><br><span class="line">score = metrics.mean_squared_error(boston_predictions, boston.target)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;MSE: %f&quot;</span> % score)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>回归算法</category>
      </categories>
      <tags>
        <tag>回归算法</tag>
      </tags>
  </entry>
  <entry>
    <title>回归算法简介</title>
    <url>/posts/7675743b.html</url>
    <content><![CDATA[<h2 id="回归算法">回归算法</h2>
<p>回归方法是对数值型连续随机变量进行预测和建模的监督学习算法。其特点是标注的数据集具有数值型的目标变量。回归的目的是预测数值型的目标值。最直接的办法是依据输入写出一个目标值的计算公式，该公式就是所谓的回归方程（regression equation）。求回归方程中的回归系数的过程就是回归。</p>
<p>常用的回归方法包括:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>线性回归：使用超平面拟合数据集</p>
</li>
<li class="lvl-2">
<p>最近邻算法：通过搜寻最相似的训练样本来预测新样本的值</p>
</li>
<li class="lvl-2">
<p>决策树和回归树：将数据集分割为不同分支而实现分层学习</p>
</li>
<li class="lvl-2">
<p>集成方法：组合多个弱学习算法构造一种强学习算法，如随机森林（RF）和梯度提升树（GBM）等</p>
</li>
<li class="lvl-2">
<p>深度学习：使用多层神经网络学习复杂模型</p>
</li>
</ul>
<h3 id="如何应用">如何应用</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>收集数据：可以使用任何方法。</p>
</li>
<li class="lvl-2">
<p>准备数据：回归需要数值型数据，标称型数据将被转换成二值型数据。</p>
</li>
<li class="lvl-2">
<p>分析数据：绘出数据的可视化二维图将有助于对数据做出理解和分析，在采用缩减法求得新回归系数之后，可以将新拟合线绘在图上作为对比。</p>
</li>
<li class="lvl-2">
<p>训练算法：找到回归系数。</p>
</li>
<li class="lvl-2">
<p>测试算法：使用 R2 或者预测值和数据的拟合度，来分析模型的效果。</p>
</li>
<li class="lvl-2">
<p>使用算法：使用回归，可以在给定输入的时候预测出一个数值，这是对分类方法的提升，因为这样可以预测连续型数据而不仅仅是离散的类别标签。</p>
</li>
</ul>
<h3 id="优缺点-7">优缺点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>优点：结果容易理解，计算上不复杂。</p>
</li>
<li class="lvl-2">
<p>缺点：对非线性的数据拟合不好。</p>
</li>
<li class="lvl-2">
<p>适用数据范围：数值型和标称型。</p>
</li>
</ul>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>回归算法</category>
      </categories>
      <tags>
        <tag>回归算法</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑回归</title>
    <url>/posts/f9b01ad8.html</url>
    <content><![CDATA[<h2 id="逻辑回归">逻辑回归</h2>
<p>逻辑回归对应线性回归，但旨在解决分类问题，即将模型的输出转换为0/1值。逻辑回归直接对分类的可能性进行建模，无需事先假设数据的分布。</p>
<p>最理想的转换函数是单位阶跃函数（也称Heaviside函数），但单位阶跃函数是不连续的，没法在实际计算中使用。故而，在分类过程中更常使用对数几率函数（即sigmoid函数）：</p>
<p align="center">
<img width="230" align="center" src="/img/images/136.jpg" />
</p>
<p>这样，模型就变成了</p>
<p align="center">
<img width="240" align="center" src="/img/images/137.jpg" />
</p>
<p>如果将$y$看作是样本$x$作为正例的可能性，那么可以得到反应$x$作为正例的相对可能性对数几率（logit）</p>
<p align="center">
<img width="190" align="center" src="/img/images/138.jpg" />
</p>
<h3 id="逻辑回归算法">逻辑回归算法</h3>
<p>可以使用极大似然估计法来估计参数$w$和$b$</p>
<p>假设<img width="190" align="center" src="/img/images/139.jpg" />，似然函数为<img width="200" align="center" src="/img/images/140.jpg" />，那么对数似然函数为<img width="460" align="center" src="/img/images/141.jpg" />，<img width="460" align="center" src="/img/images/142.jpg" /><br>
然后就可以使用梯度下降算法、牛顿法或者BFGS等拟牛顿法来求解了。</p>
<h3 id="正则化">正则化</h3>
<p>在模型过于复杂的情况下，模型会学习到很多特征，从而导致可能把所有训练样本都拟合到，这样就导致了过拟合。解决过拟合可以从两个方面入手，一是减少模型复杂度，一是增加训练集个数。而正则化就是减少模型复杂度的一个方法。</p>
<p>一般是在目标函数(经验风险)中加上一个正则化项<img width="40" align="center" src="/img/images/144.jpg" />，即</p>
<img width="460" align="center" src="/img/images/143.jpg" />
而这个正则化项一般会采用L1范数或者L2范数。其形式分别为：<img width="300" align="center" src="/img/images/145.jpg" />
<h3 id="类别不均衡问题">类别不均衡问题</h3>
<p>类别不均衡是指分类任务中不同类别的训练样例数目差别很大的情况。解决这类问题的基本思路是“再缩放（rescaling）”，即令</p>
<p><img width="200" align="center" src="/img/images/146.jpg" /> 其中，$m<sup>-$为反例数目，$m</sup>+$为正例数目）</p>
<p>然而，这个方法的实际操作却很难。实际使用上通常使用的方法：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>欠采样：去除一些样例使得不同类别的训练样例数目平衡。注意随机丢弃样例可能会导致丢失一些重要信息。</p>
</li>
<li class="lvl-2">
<p>过采样：增加一些样例使得不同类别的训练样例数目平衡。注意不能简单对原样本重复采样，否则会导致严重的过拟合</p>
</li>
<li class="lvl-2">
<p>直接基于原始训练集进行学习，但在使用最终模型预测时使用再缩放（也称为阈值移动）</p>
</li>
</ul>
<h3 id="示例代码">示例代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># initialize variables/model parameters</span></span><br><span class="line">W = tf.Variable(tf.zeros([<span class="number">5</span>, <span class="number">1</span>]), name=<span class="string">&quot;weights&quot;</span>)</span><br><span class="line">b = tf.Variable(<span class="number">0.</span>, name=<span class="string">&quot;bias&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_csv</span>(<span class="params">batch_size, file_name, record_defaults</span>):</span><br><span class="line">    filename_queue = tf.train.string_input_producer(</span><br><span class="line">        [os.path.dirname(__file__) + <span class="string">&quot;/&quot;</span> + file_name])</span><br><span class="line"></span><br><span class="line">    reader = tf.TextLineReader(skip_header_lines=<span class="number">1</span>)</span><br><span class="line">    key, value = reader.read(filename_queue)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># decode_csv will convert a Tensor from type string (the text line) in</span></span><br><span class="line">    <span class="comment"># a tuple of tensor columns with the specified defaults, which also</span></span><br><span class="line">    <span class="comment"># sets the data type for each column</span></span><br><span class="line">    decoded = tf.decode_csv(value, record_defaults=record_defaults)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># batch actually reads the file and loads &quot;batch_size&quot; rows in a single</span></span><br><span class="line">    <span class="comment"># tensor</span></span><br><span class="line">    <span class="keyword">return</span> tf.train.shuffle_batch(decoded,</span><br><span class="line">                                  batch_size=batch_size,</span><br><span class="line">                                  capacity=batch_size * <span class="number">50</span>,</span><br><span class="line">                                  min_after_dequeue=batch_size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inference</span>(<span class="params">X</span>):</span><br><span class="line">    <span class="comment"># compute inference model over data X and return the result</span></span><br><span class="line">    <span class="keyword">return</span> tf.sigmoid(tf.matmul(X, W) + b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loss</span>(<span class="params">X, Y</span>):</span><br><span class="line">    <span class="comment"># compute loss over training data X and expected outputs Y</span></span><br><span class="line">    <span class="keyword">return</span> tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(</span><br><span class="line">        tf.matmul(X, W) + b, Y))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inputs</span>():</span><br><span class="line">    <span class="comment"># data is downloaded from https://www.kaggle.com/c/titanic/data.</span></span><br><span class="line">    passenger_id, survived, pclass, name, sex, age, sibsp, parch, ticket, fare,\</span><br><span class="line">        cabin, embarked = read_csv(<span class="number">100</span>,</span><br><span class="line">                                   <span class="string">&quot;train.csv&quot;</span>,</span><br><span class="line">                                   [[<span class="number">0.0</span>], [<span class="number">0.0</span>], [<span class="number">0</span>], [<span class="string">&quot;&quot;</span>],</span><br><span class="line">                                    [<span class="string">&quot;&quot;</span>], [<span class="number">0.0</span>], [<span class="number">0.0</span>], [<span class="number">0.0</span>],</span><br><span class="line">                                    [<span class="string">&quot;&quot;</span>], [<span class="number">0.0</span>], [<span class="string">&quot;&quot;</span>], [<span class="string">&quot;&quot;</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># convert categorical data</span></span><br><span class="line">    is_first_class = tf.to_float(tf.equal(pclass, [<span class="number">1</span>]))</span><br><span class="line">    is_second_class = tf.to_float(tf.equal(pclass, [<span class="number">2</span>]))</span><br><span class="line">    is_third_class = tf.to_float(tf.equal(pclass, [<span class="number">3</span>]))</span><br><span class="line">    gender = tf.to_float(tf.equal(sex, [<span class="string">&quot;female&quot;</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Finally we pack all the features in a single matrix;</span></span><br><span class="line">    <span class="comment"># We then transpose to have a matrix with one example per row and one</span></span><br><span class="line">    <span class="comment"># feature per column.</span></span><br><span class="line">    features = tf.transpose(</span><br><span class="line">        tf.pack([is_first_class,</span><br><span class="line">                 is_second_class,</span><br><span class="line">                 is_third_class,</span><br><span class="line">                 gender,</span><br><span class="line">                 age]))</span><br><span class="line">    survived = tf.reshape(survived, [<span class="number">100</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> features, survived</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">total_loss</span>):</span><br><span class="line">    <span class="comment"># train / adjust model parameters according to computed total loss</span></span><br><span class="line">    learning_rate = <span class="number">0.01</span></span><br><span class="line">    <span class="keyword">return</span> tf.train.GradientDescentOptimizer(learning_rate).minimize(</span><br><span class="line">        total_loss)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate</span>(<span class="params">sess, X, Y</span>):</span><br><span class="line">    <span class="comment"># evaluate the resulting trained model</span></span><br><span class="line">    predicted = tf.cast(inference(X) &gt; <span class="number">0.5</span>, tf.float32)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> sess.run(tf.reduce_mean(tf.cast(tf.equal(predicted, Y), tf.float32)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a saver.</span></span><br><span class="line"><span class="comment"># saver = tf.train.Saver()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Launch the graph in a session, setup boilerplate</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    tf.initialize_all_variables().run()</span><br><span class="line"></span><br><span class="line">    X, Y = inputs()</span><br><span class="line"></span><br><span class="line">    total_loss = loss(X, Y)</span><br><span class="line">    train_op = train(total_loss)</span><br><span class="line"></span><br><span class="line">    coord = tf.train.Coordinator()</span><br><span class="line">    threads = tf.train.start_queue_runners(sess=sess, coord=coord)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># actual training loop</span></span><br><span class="line">    training_steps = <span class="number">1000</span></span><br><span class="line">    <span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(training_steps):</span><br><span class="line">        sess.run([train_op])</span><br><span class="line">        <span class="comment"># for debugging and learning purposes, see how the loss gets decremented</span></span><br><span class="line">        <span class="comment"># through training steps</span></span><br><span class="line">        <span class="keyword">if</span> step % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;loss at step &quot;</span>, step, <span class="string">&quot;:&quot;</span>, sess.run([total_loss])</span><br><span class="line">        <span class="comment"># save training checkpoints in case loosing them</span></span><br><span class="line">        <span class="comment"># if step % 1000 == 0:</span></span><br><span class="line">        <span class="comment">#     saver.save(sess, &#x27;my-model&#x27;, global_step=step)</span></span><br><span class="line"></span><br><span class="line">    evaluate(sess, X, Y)</span><br><span class="line">    coord.request_stop()</span><br><span class="line">    coord.join(threads)</span><br><span class="line">    <span class="comment"># saver.save(sess, &#x27;my-model&#x27;, global_step=training_steps)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">loss at step  <span class="number">0</span> : [<span class="number">1.0275139</span>]</span><br><span class="line">loss at step  <span class="number">100</span> : [<span class="number">1.389969</span>]</span><br><span class="line">loss at step  <span class="number">200</span> : [<span class="number">1.4667224</span>]</span><br><span class="line">loss at step  <span class="number">300</span> : [<span class="number">0.67178178</span>]</span><br><span class="line">loss at step  <span class="number">400</span> : [<span class="number">0.568793</span>]</span><br><span class="line">loss at step  <span class="number">500</span> : [<span class="number">0.48835525</span>]</span><br><span class="line">loss at step  <span class="number">600</span> : [<span class="number">1.0899736</span>]</span><br><span class="line">loss at step  <span class="number">700</span> : [<span class="number">0.84278578</span>]</span><br><span class="line">loss at step  <span class="number">800</span> : [<span class="number">1.0500686</span>]</span><br><span class="line">loss at step  <span class="number">900</span> : [<span class="number">0.89417559</span>]</span><br><span class="line"><span class="number">0.72</span></span><br></pre></td></tr></table></figure>
<h3 id="minst回归示例">minst回归示例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> input_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># Import MINST data</span></span><br><span class="line">mnist = input_data.read_data_sets(<span class="string">&quot;../MNIST_data/&quot;</span>, one_hot=<span class="literal">True</span>)</span><br><span class="line">Extracting ../MNIST_data/train-images-idx3-ubyte.gz</span><br><span class="line">Extracting ../MNIST_data/train-labels-idx1-ubyte.gz</span><br><span class="line">Extracting ../MNIST_data/t10k-images-idx3-ubyte.gz</span><br><span class="line">Extracting ../MNIST_data/t10k-labels-idx1-ubyte.gz</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Parameters</span></span><br><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line">training_epochs = <span class="number">25</span></span><br><span class="line">batch_size = <span class="number">100</span></span><br><span class="line">display_step = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tf Graph Input</span></span><br><span class="line">x = tf.placeholder(<span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>, <span class="number">784</span>]) <span class="comment"># mnist data image of shape 28*28=784</span></span><br><span class="line">y = tf.placeholder(<span class="string">&quot;float&quot;</span>, [<span class="literal">None</span>, <span class="number">10</span>]) <span class="comment"># 0-9 digits recognition =&gt; 10 classes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create model</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_weights</span>(<span class="params">shape</span>):</span><br><span class="line">    <span class="keyword">return</span> tf.Variable(tf.random_normal(shape, stddev=<span class="number">0.01</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">model</span>(<span class="params">X, w</span>):</span><br><span class="line">    <span class="keyword">return</span> tf.matmul(X, w)</span><br><span class="line"></span><br><span class="line"><span class="comment"># like in linear regression, we need a shared variable weight matrix</span></span><br><span class="line"><span class="comment"># for logistic regression</span></span><br><span class="line">w = init_weights([<span class="number">784</span>, <span class="number">10</span>]) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Construct model</span></span><br><span class="line"><span class="comment"># compute mean cross entropy (softmax is applied internally)</span></span><br><span class="line">cost = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(model(x, w), y)) </span><br><span class="line">train_op = tf.train.GradientDescentOptimizer(learning_rate).minimize(cost) <span class="comment"># construct optimizer</span></span><br><span class="line">predict_op = tf.argmax(model(x, w), <span class="number">1</span>) <span class="comment"># at predict time, evaluate the argmax of the logistic regression</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Launch the graph</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    tf.initialize_all_variables().run()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Training cycle</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(training_epochs):</span><br><span class="line">        avg_cost = <span class="number">0.</span></span><br><span class="line">        total_batch = <span class="built_in">int</span>(mnist.train.num_examples/batch_size)</span><br><span class="line">        <span class="comment"># Loop over all batches</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(total_batch):</span><br><span class="line">            batch_xs, batch_ys = mnist.train.next_batch(batch_size)</span><br><span class="line">            <span class="comment"># Fit training using batch data</span></span><br><span class="line">            sess.run(train_op, feed_dict=&#123;x: batch_xs, y: batch_ys&#125;)</span><br><span class="line">            <span class="comment"># Compute average loss</span></span><br><span class="line">            avg_cost += sess.run(cost, feed_dict=&#123;x: batch_xs, y: batch_ys&#125;)/total_batch</span><br><span class="line">        <span class="comment"># Display logs per epoch step</span></span><br><span class="line">        <span class="keyword">if</span> epoch % display_step == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;Epoch:&quot;</span>, <span class="string">&#x27;%04d&#x27;</span> % (epoch+<span class="number">1</span>), <span class="string">&quot;cost=&quot;</span>, <span class="string">&quot;&#123;:.9f&#125;&quot;</span>.<span class="built_in">format</span>(avg_cost)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Optimization Finished!&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Test model</span></span><br><span class="line">    correct_prediction = tf.equal(predict_op, tf.argmax(y, <span class="number">1</span>))</span><br><span class="line">    <span class="comment"># Calculate accuracy</span></span><br><span class="line">    accuracy = tf.reduce_mean(tf.cast(correct_prediction, <span class="string">&quot;float&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Accuracy:&quot;</span>, accuracy.<span class="built_in">eval</span>(&#123;x: mnist.test.images, y: mnist.test.labels&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Epoch: 0001 cost= <span class="number">1.181141054</span></span><br><span class="line">Epoch: 0002 cost= <span class="number">0.664358092</span></span><br><span class="line">Epoch: 0003 cost= <span class="number">0.553026987</span></span><br><span class="line">Epoch: 0004 cost= <span class="number">0.499294951</span></span><br><span class="line">Epoch: 0005 cost= <span class="number">0.466518660</span></span><br><span class="line">Epoch: 0006 cost= <span class="number">0.443856266</span></span><br><span class="line">Epoch: 0007 cost= <span class="number">0.427351894</span></span><br><span class="line">Epoch: 0008 cost= <span class="number">0.414347254</span></span><br><span class="line">Epoch: 0009 cost= <span class="number">0.403219846</span></span><br><span class="line">Epoch: <span class="number">00</span>10 cost= <span class="number">0.394844531</span></span><br><span class="line">Epoch: 0011 cost= <span class="number">0.387121435</span></span><br><span class="line">Epoch: 0012 cost= <span class="number">0.380693078</span></span><br><span class="line">Epoch: 0013 cost= <span class="number">0.375634897</span></span><br><span class="line">Epoch: 0014 cost= <span class="number">0.369904718</span></span><br><span class="line">Epoch: 0015 cost= <span class="number">0.365776612</span></span><br><span class="line">Epoch: 0016 cost= <span class="number">0.361626607</span></span><br><span class="line">Epoch: 0017 cost= <span class="number">0.358361928</span></span><br><span class="line">Epoch: 0018 cost= <span class="number">0.354674878</span></span><br><span class="line">Epoch: 0019 cost= <span class="number">0.351685582</span></span><br><span class="line">Epoch: 0020 cost= <span class="number">0.349124772</span></span><br><span class="line">Epoch: 0021 cost= <span class="number">0.346287186</span></span><br><span class="line">Epoch: 0022 cost= <span class="number">0.344134942</span></span><br><span class="line">Epoch: 0023 cost= <span class="number">0.341778976</span></span><br><span class="line">Epoch: 0024 cost= <span class="number">0.340130984</span></span><br><span class="line">Epoch: 0025 cost= <span class="number">0.337454195</span></span><br><span class="line">Optimization Finished!</span><br><span class="line">Accuracy: <span class="number">0.9122</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="sklearn示例-2">sklearn示例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> tensorflow.contrib.layers.python.layers <span class="keyword">as</span> layers</span><br><span class="line"><span class="keyword">import</span> tensorflow.contrib.learn.python.learn <span class="keyword">as</span> learn</span><br><span class="line"></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_model</span>(<span class="params">features, labels</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;DNN with three hidden layers.&quot;&quot;&quot;</span></span><br><span class="line">  <span class="comment"># Convert the labels to a one-hot tensor of shape (length of features, 3) and</span></span><br><span class="line">  <span class="comment"># with a on-value of 1 for each one-hot vector of length 3.</span></span><br><span class="line">  labels = tf.one_hot(labels, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Create three fully connected layers respectively of size 10, 20, and 10.</span></span><br><span class="line">  features = layers.stack(features, layers.fully_connected, [<span class="number">10</span>, <span class="number">20</span>, <span class="number">10</span>])</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Create two tensors respectively for prediction and loss.</span></span><br><span class="line">  prediction, loss = (</span><br><span class="line">      tf.contrib.learn.models.logistic_regression(features, labels)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Create a tensor for training op.</span></span><br><span class="line">  train_op = tf.contrib.layers.optimize_loss(</span><br><span class="line">      loss, tf.contrib.framework.get_global_step(), optimizer=<span class="string">&#x27;Adagrad&#x27;</span>,</span><br><span class="line">      learning_rate=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="string">&#x27;class&#x27;</span>: tf.argmax(prediction, <span class="number">1</span>), <span class="string">&#x27;prob&#x27;</span>: prediction&#125;, loss, train_op</span><br><span class="line"></span><br><span class="line">classifier = learn.Estimator(model_fn=my_model)</span><br><span class="line">classifier.fit(iris.data, iris.target, steps=<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">y_predicted = [</span><br><span class="line">  p[<span class="string">&#x27;class&#x27;</span>] <span class="keyword">for</span> p <span class="keyword">in</span> classifier.predict(iris.data, as_iterable=<span class="literal">True</span>)]</span><br><span class="line">score = metrics.accuracy_score(iris.target, y_predicted)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Accuracy: &#123;0:f&#125;&#x27;</span>.<span class="built_in">format</span>(score))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>回归算法</category>
      </categories>
      <tags>
        <tag>回归算法</tag>
      </tags>
  </entry>
  <entry>
    <title>K-近邻算法</title>
    <url>/posts/2431c9eb.html</url>
    <content><![CDATA[<h2 id="K-近邻算法（KNN）">K-近邻算法（KNN）</h2>
<p>K近邻算法是一种基于类比的分类方法，主要通过给定的检验组与和它相似的训练组进行比较来学习。训练组用n个属性来描述，每个元组代表n维空间上的点。当给定一个未知元组时，K最近邻分类法搜索该模式空间，找出最接近未知元组的k个训练组，并将未知元组指派到模式空间中它的k个最近邻中的多数类中。</p>
<p>k近邻（k-Nearest Neighbors）采用向量空间模型来分类，是一种常用的监督学习方法。它的工作原理为：给定测试样本，基于某种距离度量找出训练集中与其最靠近的k个训练样本，然后基于这k个“邻居”的信息来进行预测。通常，在分类任务中可使用“投票法”，即选择这k个样本中出现最多的类别标记作为预测结果；在回归任务中可使用“平均法”，即将这k个样本的实值输出标记的平均值作为预测结果；还可基于距离远近进行加权平均或加权投票，距离越近的样本权重越大。</p>
<p>k近邻没有显式的训练过程，是“懒惰学习”的代表。此类学习技术在训练阶段仅仅是把样本保存起来，训练时间开销为零，待收到测试样本后再进行处理。</p>
<p>最近邻分类器虽然简单，但它的泛化错误率不超过贝叶斯最优分类器的错误率的两倍。</p>
<p>其中“最近邻”主要是以距离来度量的，一般使用欧几里得距离度量两个点或元组的距离，也可以使用曼哈顿距离或其他距离；欧几里得距离的主要计算公式如下：</p>
<p align="center">
<img width="200" align="center" src="/img/images/87.jpg" />
</p>
<p>注意：为了防止具有较大初始值域的属性比较小初始值域的属性的权重过大，在计算距离之前，需对每个属性值进行规范化。一般的规划方法有最小-最大规范化，零均值规范化，小数定标规范化等。</p>
<p>最小-最大规范化：将原始数据值映射到[0,1]空间中，假定minA和maxA分别是属性A的最小值和最大值，则规范化的公式为：</p>
<p align="center">
<img width="150" align="center" src="/img/images/88.jpg" />
</p>
零均值规范化：基于属性A的均值和标准差上的规范化方法，具体计算如下：
<p align="center">
<img width="80" align="center" src="/img/images/89.jpg" />
</p>
<p>小数定标规范化：通过移动属性A的小数点位置进行规范化，小数点的移动位数依赖于A的最大绝对值。具体计算如下：(其中j是使得MAX（ v’ ）&lt;1的最小整数)</p>
<p align="center">
<img width="50" align="center" src="/img/images/90.jpg" />
</p>
<p>最近邻数K的确定，主要原理是选取产生最小误差率的k值。每次从k=1开始，使用检验集估计分类器的误差率；每次都允许增加一个近邻，重复该过程，选择误差率最小的k值。</p>
<h3 id="应用案例-4">应用案例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets.samples_generator <span class="keyword">import</span> make_circles</span><br><span class="line"></span><br><span class="line">N=<span class="number">210</span></span><br><span class="line">K=<span class="number">2</span></span><br><span class="line">MAX_ITERS = <span class="number">1000</span></span><br><span class="line">cut=<span class="built_in">int</span>(N*<span class="number">0.7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成训练和测试数据集</span></span><br><span class="line">data, features = make_circles(n_samples=N, shuffle=<span class="literal">True</span>, noise= <span class="number">0.12</span>, factor=<span class="number">0.4</span>)</span><br><span class="line">tr_data, tr_features= data[:cut], features[:cut]</span><br><span class="line">te_data,te_features=data[cut:], features[cut:]</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.scatter(tr_data.transpose()[<span class="number">0</span>], tr_data.transpose()[<span class="number">1</span>], marker = <span class="string">&#x27;o&#x27;</span>, s = <span class="number">100</span>, c = tr_features, cmap=plt.cm.coolwarm )</span><br><span class="line">ax.set_title(<span class="string">&#x27;Train data&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line">points=tf.Variable(data)</span><br><span class="line">cluster_assignments = tf.Variable(tf.zeros([N], dtype=tf.int64))</span><br><span class="line"></span><br><span class="line">sess = tf.Session()</span><br><span class="line">sess.run(tf.initialize_all_variables())</span><br><span class="line"></span><br><span class="line">te_learned_features=[]</span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">zip</span>(te_data, te_features):</span><br><span class="line">    distances = tf.reduce_sum(tf.square(tf.sub(i , tr_data)),reduction_indices=<span class="number">1</span>)</span><br><span class="line">    neighbor = tf.arg_min(distances,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#print tr_features[sess.run(neighbor)]</span></span><br><span class="line">    te_learned_features.append(tr_features[sess.run(neighbor)])</span><br><span class="line"></span><br><span class="line">accuracy = tf.reduce_mean(tf.cast(tf.equal(te_learned_features, te_features), <span class="string">&quot;float&quot;</span>))</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.scatter(te_data.transpose()[<span class="number">0</span>], te_data.transpose()[<span class="number">1</span>], marker = <span class="string">&#x27;o&#x27;</span>, s = <span class="number">100</span>, c = te_learned_features,       cmap=plt.cm.coolwarm )</span><br><span class="line">ax.set_title(<span class="string">&#x27;Test result&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">end = time.time()</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Found in %.2f seconds&quot;</span> % (end-start))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Cluster assignments:&quot;</span>, test</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Accuracy:&quot;</span>, sess.run(accuracy)</span><br></pre></td></tr></table></figure>
<p align="center">
<img width="400" align="center" src="/img/images/156.jpg" />
</p>
<p align="center">
<img width="400" align="center" src="/img/images/157.jpg" />
</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Found <span class="keyword">in</span> <span class="number">6.73</span> seconds</span><br><span class="line">Cluster assignments: [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">Accuracy: <span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>基于实例的学习算法</category>
      </categories>
  </entry>
  <entry>
    <title>学习矢量化</title>
    <url>/posts/bafbd7ca.html</url>
    <content><![CDATA[<h2 id="学习矢量化">学习矢量化</h2>
<p>学习矢量量化（Learning Vector Quantization，简称LVQ），与1988年提出的一种用于模式分类的有监督学习算法，是一种结构简单、功能强大的有监督式神经网络分类算法。典型的学习矢量量化算法有：LVQ1、LVQ2、LVQ3，其中，前两种算法应用较为广泛，尤其以LVQ2应用最为广泛和有效。</p>
<p>学习矢量量化是一种结构简单、功能强大的有监督式神经网络分类方法。作为一种最近邻原型分类器，LVQ在训练过程中通过对神经元权向量（原型向量）的不断更新，对其学习率的不断调整，能够使不同类别权向量之间的边界逐步收敛至贝叶斯分类边界。算法中，对获胜神经元（最近邻权向量）的选取是通过计算输入样本和权向量之间的距离的大小来判断的。与矢量量化（VQ）相比，LVQ最突出的特点就是其具有自适应性</p>
<p>1.向量量化</p>
<p>向量量化的思路是，将高维输入空间分成若干不同的区域，对每个区域确定一个中心向量作为聚类的中心，与其处于同一区域的输入向量可用该中心向量来代表，从而形成了以各中心向量为聚类中心的点集。在图像处理领域常用各区域中心点（向量）的编码代替区域内的点来存储或传输，从而提出了各种基于向量量化的有损压缩技术，在二维输入平面上表示的中心向量分布称为Voronoi图，如图所示：</p>
<p align="center">
<img width="400" align="center" src="/img/images/147.jpg" />
</p>
<p>自组织映射可以起到聚类作用，但无法直接分类或识别，因此它只是自适应解决模式分类问题两步中的第一步。第二步：学习向量量化，采用监督机制，在训练中加入信号作为分类信息对权值进行细调，并对输出神经元预先指定其类别。</p>
<p>2.学习矢量量化网络结构与工作原理</p>
<p>学习矢量量化神经网络有三层组成：输入层，竞争层，线性输出层。</p>
<p align="center">
<img width="400" align="center" src="/img/images/148.jpg" />
</p>
<p>竞争层有m个神经元，输入层有n个神经元，两层之间完全连接。输出层每个神经元只与竞争层中的一组神经元连接，连接权重固定为1，训练过程中输入层和竞争层之间的权值逐渐被调整为聚类中心。当一个样本输入LVQ网络时，竞争层的神经元通过胜者为王学习规则产生获胜神经元，容许其输出为1，其它神经元输出为0。与获胜神经元所在组相连的输出神经元输出为1，而其它输出神经元为0，从而给出当前输入样本的模式类。将竞争层学习得到的类成为子类，而将输出层学习得到的类成为目标类。</p>
<p>3.学习矢量量化网络学习算法</p>
<p>学习矢量量化学习规则结合了竞争学习规则和有导师学习规则，所以样本集应当为{(xi，di)}。其中di为l维，对应输出层的l个神经元，它只有一个分量为1，其他分量均为0。通常把竞争层的每个神经元指定给一个输出神经元，相应的权值为1，从而得到输出层的权值。比如某LVQ网络竞争层6个神经元，输出层3个神经元，代表3类。若将竞争层的1，3指定为第一个输出神经元，2，5指定为第二个输出神经元，3，6指定为第三个输出神经元。则竞争层到输出层的权值矩阵为:</p>
<p align="center">
<img width="300" align="center" src="/img/images/149.jpg" />
</p>
<p>训练前预先定义好竞争层到输出层权重，从而指定了输出神经元类别，训练中不再改变。网络的学习通过改变输入层到竞争层的权重来进行。根据输入样本类别和获胜神经元所属类别，可判断当前分类是否正确。若分类正确，则将获胜神经元的权向量向输入向量方向调整，分类错误则向相反方向调整。</p>
<p align="center">
<img width="400" align="center" src="/img/images/150.jpg" />
</p>
<p>学习矢量量化网络学习算法的步骤如下:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>初始化。竞争层各神经元权值向量随机赋值小随机数，确定初始学习速率和训练次数。</p>
</li>
<li class="lvl-2">
<p>输入样本向量。</p>
</li>
<li class="lvl-2">
<p>寻找激活神经元。</p>
</li>
<li class="lvl-2">
<p>根据分类是否正确按照不同规则调整获胜神经元的权值，当网络分类结果与教师信号一致时，向输入样本方向调整权值：</p>
</li>
</ul>
<p align="center">
<img width="300" align="center" src="/img/images/151.jpg" />
</p>
<p>当网络分类结果与教师信号不一致时，向输入样本反方向调整权值：</p>
<p align="center">
<img width="300" align="center" src="/img/images/152.jpg" />
</p>
<p>其他非激活神经元权值保持不变。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>更新学习速率</p>
</li>
</ul>
<p align="center">
<img width="300" align="center" src="/img/images/153.jpg" />
</p>
* 当训练次数未达到设定的次数时，转到步骤输入样本向量输入下一个样本，重复各步骤直到达到设定训练次数为止。上述训练过程中，要保证η（t）为单调下降函数。
<p>学习矢量量化网络是SOFM网络一种有监督形式的扩展，两者有效结合可更好地发挥竞争学习和有监督学习的优点。</p>
<p>连接方式：</p>
<p>输入层与竞争层之间采用全连接的方式，竞争层与线性输出层之间采用部分连接的方式。竞争层神经元个数总是大于线性输出层神经元个数，每个竞争层神经元只与一个线性输出层神经元相连接且连接权值恒为1。但是，每个线性输出层神经元可以与多个竞争层神经元相连接。竞争层神经元与线性输出层神经元的值只能是1或0。当某个输入模式被送至网络时，与输入模式距离最近的竞争层神经元被激活，神经元的状态为“1”，而其他竞争层神经元的状态均为“0”。因此，与被激活神经元相连接的线性输出层神经元状态也为“1”，而其他线性输出层神经元的状态均为“0”</p>
<p>基本步骤为：</p>
<p>初始化输入层与竞争层之间的权值W_ij及学习率η(η&gt;0)。将输入向量<img width="200" align="center" src="/img/images/154.jpg" />送入到输入层，并计算竞争层神经元与输入向量的距离：<img width="200" align="center" src="/img/images/155.jpg" />。</p>
<h3 id="应用案例-5">应用案例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function [dw,ls] = learnlv3(w,p,z,n,a,t,e,gW,gA,d,lp,ls)</span><br><span class="line"> LEARNLV2 LVQ2 weight learning function.</span><br><span class="line"></span><br><span class="line"> Syntax</span><br><span class="line"> </span><br><span class="line"> [dW,LS] = learnlv3(w,p,n,a,T,lp,ls,Ttrain,C)</span><br><span class="line"> info = learnlv2(code)</span><br><span class="line"></span><br><span class="line"> Description</span><br><span class="line"></span><br><span class="line"> LEARNLV3 <span class="keyword">is</span> the OLVQ weight learning function.</span><br><span class="line"></span><br><span class="line"> LEARNLV2(W,P,Z,N,A,T,E,gW,gA,D,LP,LS) takes several inputs,</span><br><span class="line"> W - SxR weight matrix (<span class="keyword">or</span> Sx1 bias vector).</span><br><span class="line"> P - RxQ <span class="built_in">input</span> vectors (<span class="keyword">or</span> ones(<span class="number">1</span>,Q)).</span><br><span class="line"> Z - SxQ weighted <span class="built_in">input</span> vectors.</span><br><span class="line"> N - SxQ net <span class="built_in">input</span> vectors.</span><br><span class="line"> A - SxQ output vectors.</span><br><span class="line"> T - SxQ layer target vectors.</span><br><span class="line"> E - SxQ layer error vectors.</span><br><span class="line"> gW - SxR weight gradient <span class="keyword">with</span> respect to performance.</span><br><span class="line"> gA - SxQ output gradient <span class="keyword">with</span> respect to performance.</span><br><span class="line"> D - SxS neuron distances.</span><br><span class="line"> LP - Learning parameters, none, LP = [].</span><br><span class="line"> LS - Learning state, initially should be = [].</span><br><span class="line"> <span class="keyword">and</span> returns,</span><br><span class="line"> dW - SxR weight (<span class="keyword">or</span> bias) change matrix.</span><br><span class="line"> LS - New learning state.</span><br><span class="line"></span><br><span class="line"> Learning occurs according to LEARNLV1<span class="string">&#x27;s learning parameter,</span></span><br><span class="line"><span class="string"> shown here with its default value.</span></span><br><span class="line"><span class="string"> LP.lr - 0.01 - Learning rate</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> LEARNLV2(CODE) returns useful information for each CODE string:</span></span><br><span class="line"><span class="string"> &#x27;</span>pnames<span class="string">&#x27; - Returns names of learning parameters.</span></span><br><span class="line"><span class="string"> &#x27;</span>pdefaults<span class="string">&#x27; - Returns default learning parameters.</span></span><br><span class="line"><span class="string"> &#x27;</span>needg<span class="string">&#x27; - Returns 1 if this function uses gW or gA.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Examples</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Here we define a sample input P, output A, weight matrix W, and</span></span><br><span class="line"><span class="string"># output gradient gA for a layer with a 2-element input and 3 neurons.</span></span><br><span class="line"><span class="string"># We also define the learning rate LR.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> p = rand(2,1);</span></span><br><span class="line"><span class="string"> w = rand(3,2);</span></span><br><span class="line"><span class="string"> n = negdist(w,p);</span></span><br><span class="line"><span class="string"> a = compet(n);</span></span><br><span class="line"><span class="string"> gA = [-1;1; 1];</span></span><br><span class="line"><span class="string"> lp.lr = 0.5;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Since LEARNLV2 only needs these values to calculate a weight</span></span><br><span class="line"><span class="string"># change (see Algorithm below), we will use them to do so.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> dW = learnlv3(w,p,n,a,lp,Ttrain,C)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Network Use</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> dw(i,:) = +lr*(p-w(i,:)) if C(:,i) = Ttrain</span></span><br><span class="line"><span class="string"> = -lr*(p-w(i,:)) if C(:,i) ~= Ttrain</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># if C(:,i) ~= Ttrain then the index j is found of the neuron with the</span></span><br><span class="line"><span class="string"># greatest net input n(k), from the neurons whose C(:,k)=Ttrain. This</span></span><br><span class="line"><span class="string"># neuron&#x27;</span>s weights are updated <span class="keyword">as</span> follows:</span><br><span class="line"></span><br><span class="line"> dw(j,:) = +lr*(p-w(i,:))</span><br><span class="line"></span><br><span class="line"><span class="comment"># See also LEARNLV1, ADAPTWB, TRAINWB, ADAPT, TRAIN.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Mark Beale, 11-31-97</span></span><br><span class="line"><span class="comment"># Copyright (c) 1992-1998 by The MathWorks, Inc.</span></span><br><span class="line"><span class="comment"># Revision: 1.1.1.1 $</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># FUNCTION INFO</span></span><br><span class="line"><span class="keyword">if</span> isstr(w)</span><br><span class="line">  switch lower(w)</span><br><span class="line">  case <span class="string">&#x27;name&#x27;</span></span><br><span class="line">      dw = <span class="string">&#x27;Learning Vector Quantization 3&#x27;</span>;</span><br><span class="line">  case <span class="string">&#x27;pnames&#x27;</span></span><br><span class="line">    dw = &#123;<span class="string">&#x27;lr&#x27;</span>;<span class="string">&#x27;window&#x27;</span>&#125;;</span><br><span class="line">  case <span class="string">&#x27;pdefaults&#x27;</span></span><br><span class="line">    lp.lr = <span class="number">0.01</span>;</span><br><span class="line">    lp.window = <span class="number">0.25</span>;</span><br><span class="line">    dw = lp;</span><br><span class="line">  case <span class="string">&#x27;needg&#x27;</span></span><br><span class="line">    dw = <span class="number">1</span>;</span><br><span class="line">  otherwise</span><br><span class="line">    error(<span class="string">&#x27;NNET:Arguments&#x27;</span>,<span class="string">&#x27;Unrecognized code.&#x27;</span>)</span><br><span class="line">  end</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">[S,R] = size(w);</span><br><span class="line">Q = size(p,<span class="number">2</span>);</span><br><span class="line">pt = p<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">dw = zeros(S,R);</span></span><br><span class="line"><span class="string"> For each q...</span></span><br><span class="line"><span class="string">for q=1:Q</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Find closest neuron k1 </span></span><br><span class="line"><span class="string">  nq = n(:,q);</span></span><br><span class="line"><span class="string">  k1 = find(nq == max(nq));</span></span><br><span class="line"><span class="string">  k1 = k1(1);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Find next closest neuron k2 </span></span><br><span class="line"><span class="string">  nq(k1) = -inf;</span></span><br><span class="line"><span class="string">  k2 = find(nq == max(nq));</span></span><br><span class="line"><span class="string">  k2 = k2(1);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   and if x falls into the window...</span></span><br><span class="line"><span class="string">  d1 = abs(n(k1,q)); Shorter distance</span></span><br><span class="line"><span class="string">  d2 = abs(n(k2,q)); Greater distance</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  if d2/d1 &gt; ((1-lp.window)/(1+lp.window))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      then move incorrect neuron away from input,</span></span><br><span class="line"><span class="string">      and the correct neuron towards the input</span></span><br><span class="line"><span class="string">      ptq = pt(q,:);</span></span><br><span class="line"><span class="string">      if gA(k1,q) ~= gA(k2,q)</span></span><br><span class="line"><span class="string">          indicate the incorrect neuron with i, the other with j</span></span><br><span class="line"><span class="string">          if gA(k1,q) ~= 0</span></span><br><span class="line"><span class="string">              i = k1;</span></span><br><span class="line"><span class="string">              j = k2;</span></span><br><span class="line"><span class="string">          else</span></span><br><span class="line"><span class="string">              i = k2;</span></span><br><span class="line"><span class="string">              j = k1;</span></span><br><span class="line"><span class="string">          end</span></span><br><span class="line"><span class="string">          dw(i,:) = dw(i,:) - lp.lr*(ptq - w(i,:));</span></span><br><span class="line"><span class="string">          dw(j,:) = dw(j,:) + lp.lr*(ptq - w(j,:));</span></span><br><span class="line"><span class="string">      else</span></span><br><span class="line"><span class="string">          dw(k1,:) = dw(k1,:) + 0.11*lp.window*(ptq-w(k1,:));</span></span><br><span class="line"><span class="string">       dw(k2,:) = dw(k2,:) + 0.11*lp.window*(ptq-w(k2,:));</span></span><br><span class="line"><span class="string">      end</span></span><br><span class="line"><span class="string">  end</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>基于实例的学习算法</category>
      </categories>
  </entry>
  <entry>
    <title>局部加权学习算法</title>
    <url>/posts/368086e9.html</url>
    <content><![CDATA[<h2 id="局部加权学习算法（LWR）">局部加权学习算法（LWR）</h2>
<p>局部加权回归（LWR）是非参数学习方法。 首先参数学习方法是这样一种方法：在训练完成所有数据后得到一系列训练参数，然后根据训练参数来预测新样本的值，这时不再依赖之前的训练数据了，参数值是确定的。而非参数学习方法是这样一种算法：在预测新样本值时候每次都会重新训练数据得到新的参数值，也就是说每次预测新样本都会依赖训练数据集合，所以每次得到的参数值是不确定的。局部加权回归（LWR）是我们遇到的第一个non-parametric（非参数）学习算法，而线性回归则是我们遇到的以一个parametric（参数）学习算法。因为参数学习算法它有固定的明确的参数，所以参数一旦确定，就不会改变了，我们不需要在保留训练集中的训练样本。而非参数学习算法，每进行一次预测，就需要重新学习一组，是变化的，所以需要一直保留训练样本。因而，当训练集的容量较大时，非参数学习算法需要占用更多的存储空间，计算速度也较慢。所以有得必有失，效果好了，计算速度却降下来了。</p>
<h3 id="应用案例-6">应用案例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="comment"># linear_regression/regression.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">JLwr</span>(<span class="params">theta, X, y, x, c</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;局部加权线性回归的代价函数计算式</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        theta: 相关系数矩阵</span></span><br><span class="line"><span class="string">        X: 样本集矩阵</span></span><br><span class="line"><span class="string">        y: 标签集矩阵</span></span><br><span class="line"><span class="string">        x: 待预测输入</span></span><br><span class="line"><span class="string">        c: tau</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        预测代价</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    m,n = X.shape</span><br><span class="line">    summerize = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        diff = (X[i]-x)*(X[i]-x).T</span><br><span class="line">        w = np.exp(-diff/(<span class="number">2</span>*c*c))</span><br><span class="line">        predictDiff = np.power(y[i] - X[i]*theta,<span class="number">2</span>)</span><br><span class="line">        summerize = summerize + w*predictDiff</span><br><span class="line">    <span class="keyword">return</span> summerize</span><br><span class="line"></span><br><span class="line"><span class="meta">@exeTime</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lwr</span>(<span class="params">rate, maxLoop, epsilon, X, y, x, c=<span class="number">1</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;局部加权线性回归</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        rate: 学习率</span></span><br><span class="line"><span class="string">        maxLoop: 最大迭代次数</span></span><br><span class="line"><span class="string">        epsilon: 预测精度</span></span><br><span class="line"><span class="string">        X: 输入样本</span></span><br><span class="line"><span class="string">        y: 标签向量</span></span><br><span class="line"><span class="string">        x: 待预测向量</span></span><br><span class="line"><span class="string">        c: tau</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    m,n = X.shape</span><br><span class="line">    <span class="comment"># 初始化theta</span></span><br><span class="line">    theta = np.zeros((n,<span class="number">1</span>))</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    converged = <span class="literal">False</span></span><br><span class="line">    error = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    errors = []</span><br><span class="line">    thetas = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        thetas[j] = [theta[j,<span class="number">0</span>]]</span><br><span class="line">    <span class="comment"># 执行批量梯度下降</span></span><br><span class="line">    <span class="keyword">while</span> count&lt;=maxLoop:</span><br><span class="line">        <span class="keyword">if</span>(converged):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        count = count + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            deriv = (y-X*theta).T*X[:, j]/m</span><br><span class="line">            theta[j,<span class="number">0</span>] = theta[j,<span class="number">0</span>]+rate*deriv</span><br><span class="line">            thetas[j].append(theta[j,<span class="number">0</span>])</span><br><span class="line">        error = JLwr(theta, X, y, x, c)</span><br><span class="line">        errors.append(error[<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 如果已经收敛</span></span><br><span class="line">        <span class="keyword">if</span>(error &lt; epsilon):</span><br><span class="line">            converged = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> theta,errors,thetas</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="结果">结果</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="comment"># linear_regression/test_lwr.py</span></span><br><span class="line"><span class="keyword">import</span> regression</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.ticker <span class="keyword">as</span> mtick</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    srcX, y = regression.loadDataSet(<span class="string">&#x27;data/lwr.txt&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    m,n = srcX.shape</span><br><span class="line">    srcX = np.concatenate((srcX[:, <span class="number">0</span>], np.power(srcX[:, <span class="number">0</span>],<span class="number">2</span>)), axis=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 特征缩放</span></span><br><span class="line">    X = regression.standardize(srcX.copy())</span><br><span class="line">    X = np.concatenate((np.ones((m,<span class="number">1</span>)), X), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    rate = <span class="number">0.1</span></span><br><span class="line">    maxLoop = <span class="number">1000</span></span><br><span class="line">    epsilon = <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line">    predicateX = regression.standardize(np.matrix([[<span class="number">8</span>, <span class="number">64</span>]]))</span><br><span class="line"></span><br><span class="line">    predicateX = np.concatenate((np.ones((<span class="number">1</span>,<span class="number">1</span>)), predicateX), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    result, t = regression.lwr(rate, maxLoop, epsilon, X, y, predicateX, <span class="number">1</span>)</span><br><span class="line">    theta, errors, thetas = result</span><br><span class="line"></span><br><span class="line">    result2, t = regression.lwr(rate, maxLoop, epsilon, X, y, predicateX, <span class="number">0.1</span>)</span><br><span class="line">    theta2, errors2, thetas2 = result2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印特征点</span></span><br><span class="line">    fittingFig = plt.figure()</span><br><span class="line">    title = <span class="string">&#x27;polynomial with bgd: rate=%.2f, maxLoop=%d, epsilon=%.3f&#x27;</span>%(rate,maxLoop,epsilon)</span><br><span class="line">    ax = fittingFig.add_subplot(<span class="number">111</span>, title=title)</span><br><span class="line">    trainingSet = ax.scatter(srcX[:, <span class="number">0</span>].flatten().A[<span class="number">0</span>], y[:,<span class="number">0</span>].flatten().A[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> theta</span><br><span class="line">    <span class="built_in">print</span> theta2</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印拟合曲线</span></span><br><span class="line">    xx = np.linspace(<span class="number">1</span>, <span class="number">7</span>, <span class="number">50</span>)</span><br><span class="line">    xx2 = np.power(xx,<span class="number">2</span>)</span><br><span class="line">    yHat1 = []</span><br><span class="line">    yHat2 = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">        normalizedSize = (xx[i]-xx.mean())/xx.std(<span class="number">0</span>)</span><br><span class="line">        normalizedSize2 = (xx2[i]-xx2.mean())/xx2.std(<span class="number">0</span>)</span><br><span class="line">        x = np.matrix([[<span class="number">1</span>,normalizedSize, normalizedSize2]])</span><br><span class="line">        yHat1.append(regression.h(theta, x.T))</span><br><span class="line">        yHat2.append(regression.h(theta2, x.T))</span><br><span class="line">    fittingLine1, = ax.plot(xx, yHat1, color=<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">    fittingLine2, = ax.plot(xx, yHat2, color=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    ax.set_xlabel(<span class="string">&#x27;temperature&#x27;</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">&#x27;yield&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    plt.legend([trainingSet, fittingLine1, fittingLine2], [<span class="string">&#x27;Training Set&#x27;</span>, <span class="string">r&#x27;LWR with $\tau$=1&#x27;</span>, <span class="string">r&#x27;LWR with $\tau$=0.1&#x27;</span>])</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印误差曲线</span></span><br><span class="line">    errorsFig = plt.figure()</span><br><span class="line">    ax = errorsFig.add_subplot(<span class="number">111</span>)</span><br><span class="line">    ax.yaxis.set_major_formatter(mtick.FormatStrFormatter(<span class="string">&#x27;%.2e&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    ax.plot(<span class="built_in">range</span>(<span class="built_in">len</span>(errors)), errors)</span><br><span class="line">    ax.set_xlabel(<span class="string">&#x27;Number of iterations&#x27;</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">&#x27;Cost J&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<p>最后，我们分别对ττ取值  0.10.1  和  11 ，得到了不同的拟合曲线：</p>
<p align="center">
<img width="600" align="center" src="/img/images/159.jpg" />
</p>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>基于实例的学习算法</category>
      </categories>
  </entry>
  <entry>
    <title>自组织映射算法</title>
    <url>/posts/f4da17a5.html</url>
    <content><![CDATA[<h2 id="自组织映射算法（SOM）">自组织映射算法（SOM）</h2>
<p>自组织映射（SOM）或自组织特征映射（SOFM）是一种使用非监督式学习来产生训练样本的输入空间的一个低维（通常是二维）离散化的表示的人工神经网络（ANN）。自组织映射与其他人工神经网络的不同之处在于它使用一个邻近函数来保持输入控件的拓扑性质。</p>
<p>自组织映射（SOM）是一种非监督学习，一个常见的非监督式学习是数据聚类。在人工神经网络中，自组织映射（SOM）和适应性共振理论（ART）则是最常用的非监督式学习。</p>
<p>非监督式学习是一种机器学习的方式，并不需要人力来输入标签。它是监督式学习和强化学习等策略之外的一种选择。在监督式学习中，典型的任务是分类和回归分析，且需要使用到人工预先准备好的范例(base)。</p>
<p>自组织映射中学习的目标是使网络的不同部分对输入模式有相似的响应。这部分的灵感是来自于人类大脑皮层的不同部分处理视觉、听觉或其他感官信息的方式。</p>
<p align="center">
<img width="400" align="center" src="/img/images/158.jpg" />
</p>
<p>自组织映射的训练实例。蓝色斑点是训练数据的分布，而小白斑点是从该分布走出的目前的训练数据。起初SOM节点处在数据空间的任意位置。选择离训练数据最近的（用黄色高亮的）节点。它会向着训练数据移动，网格上它的邻居节点也会（在较小程度上）如此移动。经过多次迭代后的网格会趋于近似的数据分布。</p>
<p>神经元的权重初始化为小随机值或均匀采样自两个最大的主成分特征向量范围。用后一种方法初始化，学习的速率就会更快，因为初始的权重已经是SOM权重的一个很好的近似了。</p>
<p>必须提供给网络大量的能够实例向量来尽可能近地表示映射中期望的那些类型的向量。这些例子通常在迭代中数次使用。</p>
<p>训练采用竞争性学习。当训练样本提供给网络的时候，就会计算它与每个权重之间的欧氏距离。权重向量与输入最相似的神经元称作最佳匹配单元（BMU）。SOM栅格中BMU的权重以及与其邻近的神经元会向着输入向量调整。从BMU变化的量会随着（栅格中）时间和距离而降低。拥有权值 Wv(s) 的神经元v的更新公式为</p>
<p>Wv(s + 1) = Wv(s) + Θ(u, v, s) α(s)(D(t) - Wv(s)),</p>
<p>其中 s 为步长指数，t 是训练样本的指数，D(t) 是输入向量，u 是 D(t) 的BMU指数，α(s) 是一个单调递减的学习系数；Θ(u, v, s) 是在步长为 s 下给出神经元 u 和神经元 v 之间距离的邻近函数。 根据实现的不同，t 可以系统地（ 0, 1, 2…T-1，然后重复，T 为训练样本的大小），也可以随机从数据集中取出（Bootstrap抽样），或采用其他一些抽样方法（如jackknifing）。</p>
<p>邻近函数Θ(u, v, s)取决于BMU（神经元u）与神经元v之间的栅格距离。在最简单的形式中，对所有足够接近BMU的神经元都是1，其余都是0，但高斯函数也是一种常见的选择。不管函数形式如何，邻近函数都会随着时间收缩。 在起初邻域范围很大的时候，自组织发生在全局范围内。当邻域范围缩小到仅有两个神经元时，权值会收敛于局部估计值。在一些实现中，学习系数α会随着增加s而平稳减小，另一些实现（特别是t扫描训练数据集的情况）中步进式地下降，每 T 步一次。</p>
<p>对每个输入向量这个过程都会重复（通常很多次）循环λ。该网络把输入数据集中的类别或模式与相关联的输出节点拉近。如果可以重命名这些模式，这些名称就会附加到已训练的网络中的相关节点中。</p>
<p>在映射中，会有一个单一“获胜”神经元：该神经元的权重向量与输入向量最接近。这可以很容易由计算输入向量和权值向量的欧氏距离确定。</p>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>基于实例的学习算法</category>
      </categories>
  </entry>
  <entry>
    <title>基于核的算法简介</title>
    <url>/posts/f7032cc1.html</url>
    <content><![CDATA[<h2 id="基于核的算法">基于核的算法</h2>
<p>支持向量机通过某非线性变换 φ( x) ，将输入空间映射到高维特征空间。特征空间的维数可能非常高。如果支持向量机的求解只用到内积运算，而在低维输入空间又存在某个函数 K(x, x′) ，它恰好等于在高维空间中这个内积，即K( x, x′) =&lt;φ( x) ⋅φ( x′) &gt; 。那么支持向量机就不用计算复杂的非线性变换，而由这个函数 K(x, x′) 直接得到非线性变换的内积，使大大简化了计算。这样的函数 K(x, x′) 称为核函数。</p>
<p>早在1964年Aizermann等在势函数方法的研究中就将该技术引入到机器学习领域，但是直到1992年Vapnik等利用该技术成功地将线性SVMs推广到非线性SVMs时其潜力才得以充分挖掘。而核函数的理论则更为古老，Mercer定理可以追溯到1909年，再生核希尔伯特空间(ReproducingKernel Hilbert Space, RKHS)研究是在20世纪40年代开始的。</p>
<p>核函数包括线性核函数、多项式核函数、高斯核函数等，其中高斯核函数最常用，可以将数据映射到无穷维，也叫做径向基函数（Radial Basis Function 简称 RBF），是某种沿径向对称的标量函数。通常定义为空间中任一点x到某一中心xc之间欧氏距离的单调函数 ，可记作 k（||x-xc||）， 其作用往往是局部的，即当x远离xc时函数取值很小。</p>
<p>根据模式识别理论，低维空间线性不可分的模式通过非线性映射到高维特征空间则可能实现线性可分，但是如果直接采用这种技术在高维空间进行分类或回归，则存在确定非线性映射函数的形式和参数、特征空间维数等问题，而最大的障碍则是在高维特征空间运算时存在的“维数灾难”。采用核函数技术可以有效地解决这样问题。</p>
<p>基于核里的应用算法有：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>支持向量机（SVM）</p>
</li>
<li class="lvl-2">
<p>径向基函数（Radial Basis Function ，RBF)</p>
</li>
<li class="lvl-2">
<p>线性判别分析（Linear Discriminate Analysis ，LDA)</p>
</li>
</ul>
<p>核函数方法的特点:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>核函数的引入避免了“维数灾难”,大大减小了计算量。而输入空间的维数n对核函数矩阵无影响，因此，核函数方法可以有效处理高维输入。</p>
</li>
<li class="lvl-2">
<p>无需知道非线性变换函数的形式和参数。</p>
</li>
<li class="lvl-2">
<p>核函数的形式和参数的变化会隐式地改变从输入空间到特征空间的映射，进而对特征空间的性质产生影响，最终改变各种核函数方法的性能。</p>
</li>
<li class="lvl-2">
<p>核函数方法可以和不同的算法相结合，形成多种不同的基于核函数技术的方法，且这两部分的设计可以单独进行，并可以为不同的应用选择不同的核函数和算法。</p>
</li>
</ul>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>基于核的算法</category>
      </categories>
  </entry>
  <entry>
    <title>支持向量机</title>
    <url>/posts/280b588e.html</url>
    <content><![CDATA[<h2 id="支持向量机（SVM）">支持向量机（SVM）</h2>
<p>支持向量机(Support Vector Machine，SVM)是Corinna Cortes和Vapnik在1995年首先提出的，是一种监督式学习的方法，可广泛地应用于统计分类以及回归分析。支持向量机属于一般化线性分类器，这族分类器的特点是他们能够同时最小化经验误差与最大化几何边缘区，因此支持向量机也被称为最大边缘区分类器。</p>
<p>在机器学习中，支持向量机（SVM，还支持矢量网络）是与相关的学习算法有关的监督学习模型，可以分析数据，识别模式，用于分类和回归分析。支持向量机方法是建立在统计学习理论的VC维理论和结构风险最小原理基础上的，根据有限的样本信息在模型的复杂性（即对特定训练样本的学习精度）和学习能力（即无错误地识别任意样本的能力）之间寻求最佳折中，以求获得最好的推广能力 。</p>
<p>在机器学习中，支持向量机（SVM，还支持矢量网络）是与相关的学习算法有关的监督学习模型，可以分析数据，识别模式，用于分类和回归分析。给定一组训练样本，每个标记为属于两类，一个SVM训练算法建立了一个模型，分配新的实例为一类或其他类，使其成为非概率二元线性分类。一个SVM模型的例子，如在空间中的点，映射，使得所述不同的类别的例子是由一个明显的差距是尽可能宽划分的表示。新的实施例则映射到相同的空间中，并预测基于它们落在所述间隙侧上属于一个类别。除了进行线性分类，支持向量机可以使用所谓的核技巧，它们的输入隐含映射成高维特征空间中有效地进行非线性分类。</p>
<p>支持向量机将向量映射到一个更高维的空间里，在这个空间里建立有一个最大间隔超平面。在分开数据的超平面的两边建有两个互相平行的超平面。建立方向合适的分隔超平面使两个与之平行的超平面间的距离最大化。其假定为，平行超平面间的距离或差距越大，分类器的总误差越小。</p>
<p align="center">
<img width="530" align="center" src="/img/images/219.jpg" />
</p>
<h3 id="应用示例-3">应用示例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: utf8</span></span><br><span class="line"><span class="comment"># svm/smo.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> rbf_kernel</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">svm模型</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">linearKernel</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;线性核函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">X, A</span>):</span><br><span class="line">        <span class="keyword">return</span> X * A.T</span><br><span class="line">    <span class="keyword">return</span> calc</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rbfKernel</span>(<span class="params">delta</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;rbf核函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    gamma = <span class="number">1.0</span> / (<span class="number">2</span> * delta**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">X, A</span>):</span><br><span class="line">        <span class="keyword">return</span> np.mat(rbf_kernel(X, A, gamma=gamma))</span><br><span class="line">    <span class="keyword">return</span> calc</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getSmo</span>(<span class="params">X, y, C, tol, maxIter, kernel=linearKernel(<span class="params"></span>)</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;SMO</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        X 训练样本</span></span><br><span class="line"><span class="string">        y 标签集</span></span><br><span class="line"><span class="string">        C 正规化参数</span></span><br><span class="line"><span class="string">        tol 容忍值</span></span><br><span class="line"><span class="string">        maxIter 最大迭代次数</span></span><br><span class="line"><span class="string">        K 所用核函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        trainSimple 简化版训练算法</span></span><br><span class="line"><span class="string">        train 完整版训练算法</span></span><br><span class="line"><span class="string">        predict 预测函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 存放核函数的转化结果</span></span><br><span class="line">    K = kernel(X, X)</span><br><span class="line">    <span class="comment"># Cache存放预测误差，用以加快计算速度</span></span><br><span class="line">    ECache = np.zeros((m,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">X, alphas, b, supportVectorsIndex, supportVectors</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;计算权值向量</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            X 预测矩阵</span></span><br><span class="line"><span class="string">            alphas alphas</span></span><br><span class="line"><span class="string">            b b</span></span><br><span class="line"><span class="string">            supportVectorsIndex 支持向量坐标集</span></span><br><span class="line"><span class="string">            supportVectors 支持向量</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            predicts 预测结果</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        Ks = kernel(supportVectors, X)</span><br><span class="line">        predicts = (np.multiply(alphas[supportVectorsIndex], y[</span><br><span class="line">            supportVectorsIndex]).T * Ks + b).T</span><br><span class="line">        predicts = np.sign(predicts)</span><br><span class="line">        <span class="keyword">return</span> predicts</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">w</span>(<span class="params">alphas, b, supportVectorsIndex, supportVectors</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;计算权值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            alphas alphas</span></span><br><span class="line"><span class="string">            b b</span></span><br><span class="line"><span class="string">            supportVectorsIndex 支持向量坐标</span></span><br><span class="line"><span class="string">            supportVectors 支持向量</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            w 权值向量</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> (np.multiply(alphas[supportVectorsIndex], y[</span><br><span class="line">            supportVectorsIndex]).T * supportVectors).T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">E</span>(<span class="params">i, alphas, b</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;计算预测误差</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            i i</span></span><br><span class="line"><span class="string">            alphas alphas</span></span><br><span class="line"><span class="string">            b b</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            E_i 第i个样本的预测误差</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        FXi = <span class="built_in">float</span>(np.multiply(alphas, y).T * K[:, i]) + b</span><br><span class="line">        E = FXi - <span class="built_in">float</span>(y[i])</span><br><span class="line">        <span class="keyword">return</span> E</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">updateE</span>(<span class="params">i, alphas, b</span>):</span><br><span class="line">        ECache[i] = [<span class="number">1</span>, E(i, alphas, b)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">selectJRand</span>(<span class="params">i</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        j = i</span><br><span class="line">        <span class="keyword">while</span> j == i:</span><br><span class="line">            j = <span class="built_in">int</span>(np.random.uniform(<span class="number">0</span>, m))</span><br><span class="line">        <span class="keyword">return</span> j</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">selectJ</span>(<span class="params">i, Ei, alphas, b</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;选择权值 &#123;% math %&#125;\alpha^&#123;(i)&#125;&#123;% endmath %&#125;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        maxJ = <span class="number">0</span>; maxDist=<span class="number">0</span>; Ej = <span class="number">0</span></span><br><span class="line">        ECache[i] = [<span class="number">1</span>, Ei]</span><br><span class="line">        validCaches = np.nonzero(ECache[:, <span class="number">0</span>])[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(validCaches) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> validCaches:</span><br><span class="line">                <span class="keyword">if</span> k==i: <span class="keyword">continue</span></span><br><span class="line">                Ek = E(k, alphas, b)</span><br><span class="line">                dist = np.<span class="built_in">abs</span>(<span class="built_in">abs</span>(Ei-Ek))</span><br><span class="line">                <span class="keyword">if</span> maxDist &lt; dist:</span><br><span class="line">                    Ej = Ek</span><br><span class="line">                    maxJ = k</span><br><span class="line">                    maxDist = dist</span><br><span class="line">            <span class="keyword">return</span> maxJ, Ej</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">### 随机选择</span></span><br><span class="line">            j = selectJRand(i)</span><br><span class="line">            Ej = E(j, alphas, b)</span><br><span class="line">            <span class="keyword">return</span> j, Ej</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">select</span>(<span class="params">i, alphas, b</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;alpha对选择</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        Ei = E(i, alphas, b)</span><br><span class="line">        <span class="comment"># 选择违背KKT条件的，作为alpha2</span></span><br><span class="line">        Ri = y[i] * Ei</span><br><span class="line">        <span class="keyword">if</span> (Ri &lt; -tol <span class="keyword">and</span> alphas[i] &lt; C) <span class="keyword">or</span> \</span><br><span class="line">                (Ri &gt; tol <span class="keyword">and</span> alphas[i] &gt; <span class="number">0</span>):</span><br><span class="line">            <span class="comment"># 选择第二个参数</span></span><br><span class="line">            j = selectJRand(i)</span><br><span class="line">            Ej = E(j, alphas, b)</span><br><span class="line">            <span class="comment"># j, Ej = selectJ(i, Ei, alphas, b)</span></span><br><span class="line">            <span class="comment"># get bounds</span></span><br><span class="line">            <span class="keyword">if</span> y[i] != y[j]:</span><br><span class="line">                L = <span class="built_in">max</span>(<span class="number">0</span>, alphas[j] - alphas[i])</span><br><span class="line">                H = <span class="built_in">min</span>(C, C + alphas[j] - alphas[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                L = <span class="built_in">max</span>(<span class="number">0</span>, alphas[j] + alphas[i] - C)</span><br><span class="line">                H = <span class="built_in">min</span>(C, alphas[j] + alphas[i])</span><br><span class="line">            <span class="keyword">if</span> L == H:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>, alphas, b</span><br><span class="line">            Kii = K[i, i]</span><br><span class="line">            Kjj = K[j, j]</span><br><span class="line">            Kij = K[i, j]</span><br><span class="line">            eta = <span class="number">2.0</span> * Kij - Kii - Kjj</span><br><span class="line">            <span class="keyword">if</span> eta &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>, alphas, b</span><br><span class="line">            iOld = alphas[i].copy()</span><br><span class="line">            jOld = alphas[j].copy()</span><br><span class="line">            alphas[j] = jOld - y[j] * (Ei - Ej) / eta</span><br><span class="line">            <span class="keyword">if</span> alphas[j] &gt; H:</span><br><span class="line">                alphas[j] = H</span><br><span class="line">            <span class="keyword">elif</span> alphas[j] &lt; L:</span><br><span class="line">                alphas[j] = L</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(alphas[j] - jOld) &lt; tol:</span><br><span class="line">                alphas[j] = jOld</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>, alphas, b</span><br><span class="line">            alphas[i] = iOld + y[i] * y[j] * (jOld - alphas[j])</span><br><span class="line">            <span class="comment"># update ECache</span></span><br><span class="line">            updateE(i, alphas, b)</span><br><span class="line">            updateE(j, alphas, b)</span><br><span class="line">            <span class="comment"># update b</span></span><br><span class="line">            bINew = b - Ei - y[i] * (alphas[i] - iOld) * Kii - y[j] * \</span><br><span class="line">                (alphas[j] - jOld) * Kij</span><br><span class="line">            bJNew = b - Ej - y[i] * (alphas[i] - iOld) * Kij - y[j] * \</span><br><span class="line">                (alphas[j] - jOld) * Kjj</span><br><span class="line">            <span class="keyword">if</span> alphas[i] &gt; <span class="number">0</span> <span class="keyword">and</span> alphas[i] &lt; C:</span><br><span class="line">                bNew = bINew</span><br><span class="line">            <span class="keyword">elif</span> alphas[j] &gt; <span class="number">0</span> <span class="keyword">and</span> alphas[j] &lt; C:</span><br><span class="line">                bNew = bJNew</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                bNew = (bINew + bJNew) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>, alphas, b</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, alphas, b</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">train</span>():</span><br><span class="line">        <span class="string">&quot;&quot;&quot;完整版训练算法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            alphas alphas</span></span><br><span class="line"><span class="string">            w w</span></span><br><span class="line"><span class="string">            b b</span></span><br><span class="line"><span class="string">            supportVectorsIndex 支持向量的坐标集</span></span><br><span class="line"><span class="string">            supportVectors 支持向量</span></span><br><span class="line"><span class="string">            iterCount 迭代次数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        numChanged = <span class="number">0</span></span><br><span class="line">        examineAll = <span class="literal">True</span></span><br><span class="line">        iterCount = <span class="number">0</span></span><br><span class="line">        alphas = np.mat(np.zeros((m, <span class="number">1</span>)))</span><br><span class="line">        b = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 如果所有alpha都遵从 KKT 条件，则在整个训练集上迭代</span></span><br><span class="line">        <span class="comment"># 否则在处于边界内 (0, C) 的 alpha 中迭代</span></span><br><span class="line">        <span class="keyword">while</span> (numChanged &gt; <span class="number">0</span> <span class="keyword">or</span> examineAll) <span class="keyword">and</span> (iterCount &lt; maxIter):</span><br><span class="line">            numChanged = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> examineAll:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                    changed, alphas, b = select(i, alphas, b)</span><br><span class="line">                    numChanged += changed</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nonBoundIds = np.nonzero((alphas.A &gt; <span class="number">0</span>) * (alphas.A &lt; C))[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> nonBoundIds:</span><br><span class="line">                    changed, alphas, b = select(i, alphas, b)</span><br><span class="line">                    numChanged += changed</span><br><span class="line">            iterCount += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> examineAll:</span><br><span class="line">                examineAll = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> numChanged == <span class="number">0</span>:</span><br><span class="line">                examineAll = <span class="literal">True</span></span><br><span class="line">        supportVectorsIndex = np.nonzero(alphas.A &gt; <span class="number">0</span>)[<span class="number">0</span>]</span><br><span class="line">        supportVectors = np.mat(X[supportVectorsIndex])</span><br><span class="line">        <span class="keyword">return</span> alphas, w(alphas, b, supportVectorsIndex, supportVectors), b, \</span><br><span class="line">            supportVectorsIndex, supportVectors, iterCount</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trainSimple</span>():</span><br><span class="line">        <span class="string">&quot;&quot;&quot;简化版训练算法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            alphas alphas</span></span><br><span class="line"><span class="string">            w w</span></span><br><span class="line"><span class="string">            b b</span></span><br><span class="line"><span class="string">            supportVectorsIndex 支持向量的坐标集</span></span><br><span class="line"><span class="string">            supportVectors 支持向量</span></span><br><span class="line"><span class="string">            iterCount 迭代次数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        numChanged = <span class="number">0</span></span><br><span class="line">        iterCount = <span class="number">0</span></span><br><span class="line">        alphas = np.mat(np.zeros((m, <span class="number">1</span>)))</span><br><span class="line">        b = <span class="number">0</span></span><br><span class="line">        L = <span class="number">0</span></span><br><span class="line">        H = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> iterCount &lt; maxIter:</span><br><span class="line">            numChanged = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                Ei = E(i, alphas, b)</span><br><span class="line">                Ri = y[i] * Ei</span><br><span class="line">                <span class="comment"># 选择违背KKT条件的，作为alpha2</span></span><br><span class="line">                <span class="keyword">if</span> (Ri &lt; -tol <span class="keyword">and</span> alphas[i] &lt; C) <span class="keyword">or</span> \</span><br><span class="line">                        (Ri &gt; tol <span class="keyword">and</span> alphas[i] &gt; <span class="number">0</span>):</span><br><span class="line">                    <span class="comment"># 选择第二个参数</span></span><br><span class="line">                    j = selectJRand(i)</span><br><span class="line">                    Ej = E(j, alphas, b)</span><br><span class="line">                    <span class="comment"># get bounds</span></span><br><span class="line">                    <span class="keyword">if</span> y[i] != y[j]:</span><br><span class="line">                        L = <span class="built_in">max</span>(<span class="number">0</span>, alphas[j] - alphas[i])</span><br><span class="line">                        H = <span class="built_in">min</span>(C, C + alphas[j] - alphas[i])</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        L = <span class="built_in">max</span>(<span class="number">0</span>, alphas[j] + alphas[i] - C)</span><br><span class="line">                        H = <span class="built_in">min</span>(C, alphas[j] + alphas[i])</span><br><span class="line">                    <span class="keyword">if</span> L == H:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    Kii = K[i, i]</span><br><span class="line">                    Kjj = K[j, j]</span><br><span class="line">                    Kij = K[i, j]</span><br><span class="line">                    eta = <span class="number">2.0</span> * Kij - Kii - Kjj</span><br><span class="line">                    <span class="keyword">if</span> eta &gt;= <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    iOld = alphas[i].copy();</span><br><span class="line">                    jOld = alphas[j].copy()</span><br><span class="line">                    alphas[j] = jOld - y[j] * (Ei - Ej) / eta</span><br><span class="line">                    <span class="keyword">if</span> alphas[j] &gt; H:</span><br><span class="line">                        alphas[j] = H</span><br><span class="line">                    <span class="keyword">elif</span> alphas[j] &lt; L:</span><br><span class="line">                        alphas[j] = L</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">abs</span>(alphas[j] - jOld) &lt; tol:</span><br><span class="line">                        alphas[j] = jOld</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    alphas[i] = iOld + y[i] * y[j] * (jOld - alphas[j])</span><br><span class="line">                    <span class="comment"># update b</span></span><br><span class="line">                    bINew = b - Ei - y[i] * (alphas[i] - iOld) * Kii - y[j] * \</span><br><span class="line">                        (alphas[j] - jOld) * Kij</span><br><span class="line">                    bJNew = b - Ej - y[i] * (alphas[i] - iOld) * Kij - y[j] * \</span><br><span class="line">                        (alphas[j] - jOld) * Kjj</span><br><span class="line">                    <span class="keyword">if</span> alphas[i] &gt; <span class="number">0</span> <span class="keyword">and</span> alphas[i] &lt; C:</span><br><span class="line">                        b = bINew</span><br><span class="line">                    <span class="keyword">elif</span> alphas[j] &gt; <span class="number">0</span> <span class="keyword">and</span> alphas[j] &lt; C:</span><br><span class="line">                        b = bJNew</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        b = (bINew + bJNew) / <span class="number">2.0</span></span><br><span class="line">                    numChanged += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> numChanged == <span class="number">0</span>:</span><br><span class="line">                iterCount += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                iterCount = <span class="number">0</span></span><br><span class="line">        supportVectorsIndex = np.nonzero(alphas.A &gt; <span class="number">0</span>)[<span class="number">0</span>]</span><br><span class="line">        supportVectors = np.mat(X[supportVectorsIndex])</span><br><span class="line">        <span class="keyword">return</span> alphas, w(alphas, b, supportVectorsIndex, supportVectors), b, \</span><br><span class="line">            supportVectorsIndex, supportVectors, iterCount</span><br><span class="line">    <span class="keyword">return</span> trainSimple, train, predict</span><br></pre></td></tr></table></figure>
<p>相比于神经网络这样更先进的算法，支持向量机有两大主要优势：更高的速度、用更少的样本（千以内）取得更好的表现。这使得该算法非常适合文本分类问题。</p>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>基于核的算法</category>
      </categories>
  </entry>
  <entry>
    <title>径向基函数</title>
    <url>/posts/8e23bc3a.html</url>
    <content><![CDATA[<p>径向基函数（RBF，Radial Basis Function）神经网络，是一种对局部逼近的神经网络。是由J.Moody 和C.Darken于20世纪80年代末提出的一种神经网络，径向基函数方法在某种程度上利用了多维空间中传统的严格插值法的研究成果。在神经网络的背景下，隐藏单元提供一个“函数”集，该函数集在输入模式向量扩展至隐层空间时为其构建了一个任意的“基”；这个函数集中的函数就被称为径向基函数。径向基函数首先是在实多变量插值问题的解中引入的。径向基函数是目前数值分析研究中的一个主要领域之一。</p>
<p>最基本的径向基函数（RBF）神经网络的构成包括三层，其中每一层都有着完全不同的作用。输入层由一些感知单元组成，它们将网络与外界环境连接起来；第二层是网络中仅有的一个隐层，它的作用是从输入空间到隐层空间之间进行非线性变换，在大多数情况下，隐层空间有较高的维数；输出层是线性的，它为作用于输入层的激活模式提供响应。</p>
<p>基本的径向基函数RBF网络是具有单稳层的三层前馈网络。由于它模拟了人脑中局部调整、相互覆盖接受域（或称感受域，Receptive Field）的神经网络结构，因此，RBF网络是一种局部逼近网络，现已证明它能以任意精度逼近任一连续函数。</p>
<p>RBF 神经网络是一种三层前向网络，通过输入层空间到隐含层空间的非线性变换以及隐含层空间到输出层空间的线性变换，实现输入层空间到输出层空间的映射。这两个层间变换参数的学习可以分别进行，使得 RBF 神经网络的学习速度较快且可避免局部极小问题。</p>
<p>RBF(Radial Basis Function，径向基函数)是某种沿径向对称的标量函数，通常定义为空间中一点到某一中心之间欧氏距离的单调函数，最常用的径向基函数是高斯函数，形式为：</p>
<p align="center">
<img width="300" align="center" src="/img/images/7.jpg" />
</p>
<p>中为函数中心向量，为宽度向量。高斯函数的作用域表现出局部性，即当远离时函数取值较小。</p>
<p>如下图所示，RBF 神经网络的结构从左至右分为三层，依次是输入层、隐含层和输出层：</p>
<p align="center">
<img width="300" align="center" src="/img/images/8.jpg" />
</p>
<p>RBF神经网络结构图</p>
<p>网络的输出如下式所示：</p>
<p align="center">
<img width="300" align="center" src="/img/images/9.jpg" />
</p>
<p>与BP神经网络类似，理论上RBF神经网络对任何非线性连续映射能够用任意精度近似。但RBF神经网络有其自身的特点：</p>
<p>RBF 神经网络结构的物理意义比较明确。RBF 网络可以看成是输入层数据空间（通常是低维空间）到隐含层空间（通常是高维空间）的一种非线性映射，以及隐含层空间到输出层的线性映射。通过选择适当的非线性映射变换 RBF 函数，从而将原低维空间非线性不可分的问题转换成高维空间的近似线性可分的问题。</p>
<p>RBF 神经网络的学习分成两阶段，自组织学习阶段和监督学习阶段。在自组织学习阶段获取隐含层中心，在监督学习阶段获取隐含层到输出层之间的权值，各部分参数都可以快速学习，因此速度较快。</p>
<p>分阶段学习的 RBF 神经网络无局部极小值问题。由于 RBF 神经网络的学习与输入样本聚类中心密切相关，因此 RBF 神经网络比较适合应用于有类别特征的数据。</p>
<p>模型隐含层中心个数设定原则：</p>
<p>由于RBF神经网络的思想是将低维空间非线性不可分问题转换成高维空间线性可分问题，因此隐含层中心个数应该大于输入变量个数，一般设为输入变量个数的 2 倍以上。</p>
<p>由于隐含层中心点坐标代表了输入数据的聚类中心，因此隐含层中心个数应该大于输入数据集的按记录划分的类别个数，这样才能有效提取各种类别输入数据的特征。这需要对输入数据集的业务特征有一定了解，然后给出输入数据类别个数的大致范围。一般设隐含层中心个数为输入数据类别个数的 2 倍以上。</p>
<p>综合以上两个原则设定隐含层中心个数，然后可以根据训练和测试的效果，对中心个数进行适当调整。一般情况下，中心个数设得越多，训练的效果越好，但所需要的时间越长；而当中心个数多到一定程度的时候，增多中心个数对训练效果的改善已不大。另外，隐含层中心数应该不大于训练数据记录数。</p>
<h3 id="应用示例-4">应用示例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">kernelTrans</span>(<span class="params">X, A, kTup</span>):  <span class="comment"># calc the kernel or transform data to a higher dimensional space</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    核转换函数</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        X     dataMatIn数据集</span></span><br><span class="line"><span class="string">        A     dataMatIn数据集的第i行的数据</span></span><br><span class="line"><span class="string">        kTup  核函数的信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    m, n = shape(X)</span><br><span class="line">    K = mat(zeros((m, <span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">if</span> kTup[<span class="number">0</span>] == <span class="string">&#x27;lin&#x27;</span>:</span><br><span class="line">        <span class="comment"># linear kernel:   m*n * n*1 = m*1</span></span><br><span class="line">        K = X * A.T</span><br><span class="line">    <span class="keyword">elif</span> kTup[<span class="number">0</span>] == <span class="string">&#x27;rbf&#x27;</span>:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            deltaRow = X[j, :] - A</span><br><span class="line">            K[j] = deltaRow * deltaRow.T</span><br><span class="line">        <span class="comment"># 径向基函数的高斯版本</span></span><br><span class="line">        K = exp(K / (-<span class="number">1</span> * kTup[<span class="number">1</span>] ** <span class="number">2</span>))  <span class="comment"># divide in NumPy is element-wise not matrix like Matlab</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> NameError(<span class="string">&#x27;Houston We Have a Problem -- That Kernel is not recognized&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> K</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">smoP</span>(<span class="params">dataMatIn, classLabels, C, toler, maxIter, kTup=(<span class="params"><span class="string">&#x27;lin&#x27;</span>, <span class="number">0</span></span>)</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        dataMatIn    数据集</span></span><br><span class="line"><span class="string">        classLabels  类别标签</span></span><br><span class="line"><span class="string">        C   松弛变量(常量值)，允许有些数据点可以处于分隔面的错误一侧。</span></span><br><span class="line"><span class="string">            控制最大化间隔和保证大部分的函数间隔小于1.0这两个目标的权重。</span></span><br><span class="line"><span class="string">            可以通过调节该参数达到不同的结果。</span></span><br><span class="line"><span class="string">        toler   容错率</span></span><br><span class="line"><span class="string">        maxIter 退出前最大的循环次数</span></span><br><span class="line"><span class="string">        kTup    包含核函数信息的元组</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        b       模型的常量值</span></span><br><span class="line"><span class="string">        alphas  拉格朗日乘子</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个 optStruct 对象</span></span><br><span class="line">    oS = optStruct(mat(dataMatIn), mat(classLabels).transpose(), C, toler, kTup)</span><br><span class="line">    <span class="built_in">iter</span> = <span class="number">0</span></span><br><span class="line">    entireSet = <span class="literal">True</span></span><br><span class="line">    alphaPairsChanged = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 循环遍历：循环maxIter次 并且 （alphaPairsChanged存在可以改变 or 所有行遍历一遍）</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">iter</span> &lt; maxIter) <span class="keyword">and</span> ((alphaPairsChanged &gt; <span class="number">0</span>) <span class="keyword">or</span> (entireSet)):</span><br><span class="line">        alphaPairsChanged = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#  当entireSet=true or 非边界alpha对没有了；就开始寻找 alpha对，然后决定是否要进行else。</span></span><br><span class="line">        <span class="keyword">if</span> entireSet:</span><br><span class="line">            <span class="comment"># 在数据集上遍历所有可能的alpha</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(oS.m):</span><br><span class="line">                <span class="comment"># 是否存在alpha对，存在就+1</span></span><br><span class="line">                alphaPairsChanged += innerL(i, oS)</span><br><span class="line">                <span class="comment"># print(&quot;fullSet, iter: %d i:%d, pairs changed %d&quot; % (iter, i, alphaPairsChanged))</span></span><br><span class="line">            <span class="built_in">iter</span> += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对已存在 alpha对，选出非边界的alpha值，进行优化。</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 遍历所有的非边界alpha值，也就是不在边界0或C上的值。</span></span><br><span class="line">            nonBoundIs = nonzero((oS.alphas.A &gt; <span class="number">0</span>) * (oS.alphas.A &lt; C))[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nonBoundIs:</span><br><span class="line">                alphaPairsChanged += innerL(i, oS)</span><br><span class="line">                <span class="comment"># print(&quot;non-bound, iter: %d i:%d, pairs changed %d&quot; % (iter, i, alphaPairsChanged))</span></span><br><span class="line">            <span class="built_in">iter</span> += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果找到alpha对，就优化非边界alpha值，否则，就重新进行寻找，如果寻找一遍 遍历所有的行还是没找到，就退出循环。</span></span><br><span class="line">        <span class="keyword">if</span> entireSet:</span><br><span class="line">            entireSet = <span class="literal">False</span>  <span class="comment"># toggle entire set loop</span></span><br><span class="line">        <span class="keyword">elif</span> (alphaPairsChanged == <span class="number">0</span>):</span><br><span class="line">            entireSet = <span class="literal">True</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;iteration number: %d&quot;</span> % <span class="built_in">iter</span>)</span><br><span class="line">    <span class="keyword">return</span> oS.b, oS.alphas</span><br></pre></td></tr></table></figure>
<h3 id="RBF优点">RBF优点</h3>
<p>优点：</p>
<ol>
<li class="lvl-3">
<p>它具有唯一最佳的特性，且无局部极小问题存在；</p>
</li>
<li class="lvl-3">
<p>RBF神经网络具有较强的输入和输出映射功能，并且理论证明在前向网络中RBF神经网络是完成映射功能的最有效网络；</p>
</li>
<li class="lvl-3">
<p>分类能力好；</p>
</li>
<li class="lvl-3">
<p>学习过程收敛速度快。</p>
</li>
</ol>
<h3 id="RBF缺点">RBF缺点</h3>
<p>缺点：</p>
<ol>
<li class="lvl-3">
<p>没有能力来解释自己的推理过程和推理依据；</p>
</li>
<li class="lvl-3">
<p>当样本数据不足时，预测结果不太准确。</p>
</li>
</ol>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>基于核的算法</category>
      </categories>
  </entry>
  <entry>
    <title>线性判别分析</title>
    <url>/posts/2b64aa80.html</url>
    <content><![CDATA[<h2 id="线性判别分析（Linear-Discriminate-Analysis-，LDA">线性判别分析（Linear Discriminate Analysis ，LDA)</h2>
<p>线性判别式分析(Linear Discriminant Analysis, LDA)，也叫做Fisher线性判别(Fisher Linear Discriminant ,FLD)，是模式识别的经典算法，它是在1996年由Belhumeur引入模式识别和人工智能领域的。线性判别分析是一种经典的线性分类方法。它设法将数据集投影到一条直线上，使得同类样例的投影点尽可能接近，异类样例的投影点尽可能远。这样，在分类时，新样本同样投影到这条直线上，根据投影点的位置来确定类别。</p>
<p>由于LDA把原来N维的样本投影到了N-1维空间，因而也常被视为一种经典的降维技术。</p>
<p>预使得同类样例的投影点尽可能接近，可以让同类样例投影点的协方差尽可能小，即<img width="150" align="center" src="/img/images/220.jpg" />尽可能小。预使得异类样例的投影点尽可能远，可以让不同类样例的投影点尽可能远，即让类中心距离尽可能大，即<img width="150" align="center" src="/img/images/221.jpg" /> 尽可能大。这样，目标函数为<img width="150" align="center" src="/img/images/222.jpg" />.</p>
<p>其中类内散度矩阵<img width="460" align="center" src="/img/images/223.jpg" />,类间散度矩阵<img width="300" align="center" src="/img/images/224.jpg" />.</p>
<p>使用拉格朗日乘子法<img width="150" align="center" src="/img/images/225.jpg" />可以求解得到<img width="130" align="center" src="/img/images/226.jpg" />.</p>
<p>对多分类情况，<img width="150" align="center" src="/img/images/227.jpg" />，W的解是<img width="60" align="center" src="/img/images/228.jpg" />的N−1 个最大广义特征值所对应的特征向量组成的矩阵。</p>
<p>线性判别分析降维一般分为5个步骤：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>计算数据集中每个类别样本的均值向量。</p>
</li>
<li class="lvl-2">
<p>通过均值向量，计算类间散度矩阵<img width="50" align="center" src="/img/images/229.jpg" />和类内散度矩阵<img width="50" align="center" src="/img/images/230.jpg" />。</p>
</li>
<li class="lvl-2">
<p>对<img width="120" align="center" src="/img/images/231.jpg" />进行特征值求解， 求出<img width="60" align="center" src="/img/images/228.jpg" />的特征向量和特征值。</p>
</li>
<li class="lvl-2">
<p>对特征向量按照特征值的大小降序排列，并选择前K个特征向量组成投影矩阵W。</p>
</li>
<li class="lvl-2">
<p>通过D*K维的特征值矩阵将样本点投影到新的子空间中，<img width="60" align="center" src="/img/images/232.jpg" />.</p>
</li>
</ul>
<h3 id="应用示例-5">应用示例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># u may download data from (https://archive.ics.uci.edu/ml/datasets/Iris).</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;iris.data&#x27;</span>, header=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">feature_dict = &#123;i:label <span class="keyword">for</span> i,label <span class="keyword">in</span> <span class="built_in">zip</span>(</span><br><span class="line">                <span class="built_in">range</span>(<span class="number">4</span>),</span><br><span class="line">                  (<span class="string">&#x27;sepal length in cm&#x27;</span>,</span><br><span class="line">                  <span class="string">&#x27;sepal width in cm&#x27;</span>,</span><br><span class="line">                  <span class="string">&#x27;petal length in cm&#x27;</span>,</span><br><span class="line">                  <span class="string">&#x27;petal width in cm&#x27;</span>, ))&#125;</span><br><span class="line">df.columns = [l <span class="keyword">for</span> i,l <span class="keyword">in</span> <span class="built_in">sorted</span>(feature_dict.items())] + [<span class="string">&#x27;class label&#x27;</span>]</span><br><span class="line">df.dropna(how=<span class="string">&quot;all&quot;</span>, inplace=<span class="literal">True</span>) <span class="comment"># to drop the empty line at file-end</span></span><br><span class="line"></span><br><span class="line">df.tail()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line"></span><br><span class="line">X = df[[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]].values</span><br><span class="line">y = df[<span class="string">&#x27;class label&#x27;</span>].values</span><br><span class="line"></span><br><span class="line">enc = LabelEncoder()</span><br><span class="line">label_encoder = enc.fit(y)</span><br><span class="line">y = label_encoder.transform(y) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">label_dict = &#123;<span class="number">1</span>: <span class="string">&#x27;Setosa&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Versicolor&#x27;</span>, <span class="number">3</span>:<span class="string">&#x27;Virginica&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(nrows=<span class="number">2</span>, ncols=<span class="number">2</span>, figsize=(<span class="number">12</span>,<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax,cnt <span class="keyword">in</span> <span class="built_in">zip</span>(axes.ravel(), <span class="built_in">range</span>(<span class="number">4</span>)):  </span><br><span class="line"></span><br><span class="line">    <span class="comment"># set bin sizes</span></span><br><span class="line">    min_b = math.floor(np.<span class="built_in">min</span>(X[:,cnt]))</span><br><span class="line">    max_b = math.ceil(np.<span class="built_in">max</span>(X[:,cnt]))</span><br><span class="line">    bins = np.linspace(min_b, max_b, <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># plottling the histograms</span></span><br><span class="line">    <span class="keyword">for</span> lab,col <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>), (<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>)):</span><br><span class="line">        ax.hist(X[y==lab, cnt],</span><br><span class="line">                   color=col,</span><br><span class="line">                   label=<span class="string">&#x27;class %s&#x27;</span> %label_dict[lab],</span><br><span class="line">                   bins=bins,</span><br><span class="line">                   alpha=<span class="number">0.5</span>,)</span><br><span class="line">    ylims = ax.get_ylim()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># plot annotation</span></span><br><span class="line">    leg = ax.legend(loc=<span class="string">&#x27;upper right&#x27;</span>, fancybox=<span class="literal">True</span>, fontsize=<span class="number">8</span>)</span><br><span class="line">    leg.get_frame().set_alpha(<span class="number">0.5</span>)</span><br><span class="line">    ax.set_ylim([<span class="number">0</span>, <span class="built_in">max</span>(ylims)+<span class="number">2</span>])</span><br><span class="line">    ax.set_xlabel(feature_dict[cnt])</span><br><span class="line">    ax.set_title(<span class="string">&#x27;Iris histogram #%s&#x27;</span> %<span class="built_in">str</span>(cnt+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># hide axis ticks</span></span><br><span class="line">    ax.tick_params(axis=<span class="string">&quot;both&quot;</span>, which=<span class="string">&quot;both&quot;</span>, bottom=<span class="string">&quot;off&quot;</span>, top=<span class="string">&quot;off&quot;</span>,  </span><br><span class="line">            labelbottom=<span class="string">&quot;on&quot;</span>, left=<span class="string">&quot;off&quot;</span>, right=<span class="string">&quot;off&quot;</span>, labelleft=<span class="string">&quot;on&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># remove axis spines</span></span><br><span class="line">    ax.spines[<span class="string">&quot;top&quot;</span>].set_visible(<span class="literal">False</span>)  </span><br><span class="line">    ax.spines[<span class="string">&quot;right&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.spines[<span class="string">&quot;bottom&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.spines[<span class="string">&quot;left&quot;</span>].set_visible(<span class="literal">False</span>)    </span><br><span class="line"></span><br><span class="line">axes[<span class="number">0</span>][<span class="number">0</span>].set_ylabel(<span class="string">&#x27;count&#x27;</span>)</span><br><span class="line">axes[<span class="number">1</span>][<span class="number">0</span>].set_ylabel(<span class="string">&#x27;count&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fig.tight_layout()       </span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因此在实际应用中，我们对特征进行降维，除了使用类似于LDA的特征投影方法（或者叫extraction），特征选择（selection）也是一种较好的方式。</span></span><br><span class="line"><span class="comment"># 像上图这种低纬度的数据集，看一眼直方图我们就可以做出一定的判断。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># step1：计算D维特征样本的均值向量</span></span><br><span class="line">np.set_printoptions(precision=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">mean_vectors = []</span><br><span class="line"><span class="keyword">for</span> cl <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>):</span><br><span class="line">    mean_vectors.append(np.mean(X[y==cl], axis=<span class="number">0</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Mean Vector class %s: %s\n&#x27;</span> %(cl, mean_vectors[cl-<span class="number">1</span>]))</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># step2: 计算散度矩阵</span></span><br><span class="line"><span class="comment"># 计算类内散度矩阵：Sw</span></span><br><span class="line">S_W = np.zeros((<span class="number">4</span>,<span class="number">4</span>))</span><br><span class="line"><span class="keyword">for</span> cl,mv <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>), mean_vectors):</span><br><span class="line">    class_sc_mat = np.zeros((<span class="number">4</span>,<span class="number">4</span>))                  <span class="comment"># scatter matrix for every class</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> X[y == cl]:</span><br><span class="line">        row, mv = row.reshape(<span class="number">4</span>,<span class="number">1</span>), mv.reshape(<span class="number">4</span>,<span class="number">1</span>) <span class="comment"># make column vectors</span></span><br><span class="line">        class_sc_mat += (row-mv).dot((row-mv).T)</span><br><span class="line">    S_W += class_sc_mat                             <span class="comment"># sum class scatter matrices</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 计算类间三度矩阵:Sb</span></span><br><span class="line">overall_mean = np.mean(X, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">S_B = np.zeros((<span class="number">4</span>,<span class="number">4</span>))</span><br><span class="line"><span class="keyword">for</span> i,mean_vec <span class="keyword">in</span> <span class="built_in">enumerate</span>(mean_vectors):  </span><br><span class="line">    n = X[y==i+<span class="number">1</span>,:].shape[<span class="number">0</span>]</span><br><span class="line">    mean_vec = mean_vec.reshape(<span class="number">4</span>,<span class="number">1</span>) <span class="comment"># make column vector</span></span><br><span class="line">    overall_mean = overall_mean.reshape(<span class="number">4</span>,<span class="number">1</span>) <span class="comment"># make column vector</span></span><br><span class="line">    S_B += n * (mean_vec - overall_mean).dot((mean_vec - overall_mean).T)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;between-class Scatter Matrix:\n&#x27;</span>, S_B)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># step3：求解S?1WSB的特征值问题：</span></span><br><span class="line">eig_vals, eig_vecs = np.linalg.eig(np.linalg.inv(S_W).dot(S_B))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(eig_vals)):</span><br><span class="line">    eigvec_sc = eig_vecs[:,i].reshape(<span class="number">4</span>,<span class="number">1</span>)   </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\nEigenvector &#123;&#125;: \n&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>, eigvec_sc.real))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Eigenvalue &#123;:&#125;: &#123;:.2e&#125;&#x27;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>, eig_vals[i].real))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;within-class Scatter Matrix:\n&#x27;</span>, S_W)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># step4：选择新的特征空间</span></span><br><span class="line"><span class="comment"># 先将特征向量按照特征值的大小降序排列，线代中告诉我我们，矩阵乘法可以看做一种线性变换，而特征向量和特征值代表了变换后的方向以及该方向上的</span></span><br><span class="line"><span class="comment"># 缩放比例，因此特征值越大，说明这个方向在变换中越显著，也就是信息量最大。因此我们需要抛弃的是特征值较小的方向，因此我们只需要选取前topk个特征值</span></span><br><span class="line"><span class="comment"># 对应的特征向量，就得到了映射矩阵W</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Make a list of (eigenvalue, eigenvector) tuples</span></span><br><span class="line">eig_pairs = [(np.<span class="built_in">abs</span>(eig_vals[i]), eig_vecs[:,i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(eig_vals))]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sort the (eigenvalue, eigenvector) tuples from high to low</span></span><br><span class="line">eig_pairs = <span class="built_in">sorted</span>(eig_pairs, key=<span class="keyword">lambda</span> k: k[<span class="number">0</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Visually confirm that the list is correctly sorted by decreasing eigenvalues</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Eigenvalues in decreasing order:\n&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> eig_pairs:</span><br><span class="line">    <span class="built_in">print</span> (i[<span class="number">0</span>], i[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 从上面的特征值可以看到有2个特征值非常接近0，这2个值之所以接近0，一是代表了他们不包含信息量，第二是因为浮点运算的精确度问题。</span></span><br><span class="line"><span class="comment"># 实际上这2分特征值应该就是0， 因为在LDA中，如果有C类，线性判别式最多只有C-1个，因此对于之前3类的数据集，最多只有2个特征值。</span></span><br><span class="line"><span class="comment"># 由于类间散度矩阵S_B是不同类别C矩阵的和，而C矩阵的秩是1，对于最特殊的完美共线性情况（即所有样本点都在一条直线上），协方差矩阵的秩就会是1，</span></span><br><span class="line"><span class="comment"># 这就导致了只会有一个非0的特征值。</span></span><br><span class="line"><span class="comment"># 我们通过特征值的比例来体现方差的分布：</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Variance explained:\n&#x27;</span>)</span><br><span class="line">eigv_sum = <span class="built_in">sum</span>(eig_vals)</span><br><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">enumerate</span>(eig_pairs):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;eigenvalue &#123;0:&#125;: &#123;1:.2%&#125;&#x27;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>, (j[<span class="number">0</span>]/eigv_sum).real))</span><br><span class="line">    </span><br><span class="line">W = np.hstack((eig_pairs[<span class="number">0</span>][<span class="number">1</span>].reshape(<span class="number">4</span>,<span class="number">1</span>), eig_pairs[<span class="number">1</span>][<span class="number">1</span>].reshape(<span class="number">4</span>,<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># step5：将样本投影到新的空间</span></span><br><span class="line">X_lda = X.dot(W)</span><br><span class="line"><span class="keyword">assert</span> X_lda.shape == (<span class="number">150</span>,<span class="number">2</span>), <span class="string">&quot;The matrix is not 150x2 dimensional.&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_step_lda</span>():</span><br><span class="line"></span><br><span class="line">    ax = plt.subplot(<span class="number">111</span>)</span><br><span class="line">    <span class="keyword">for</span> label,marker,color <span class="keyword">in</span> <span class="built_in">zip</span>(</span><br><span class="line">        <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>),(<span class="string">&#x27;^&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;o&#x27;</span>),(<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>)):</span><br><span class="line"></span><br><span class="line">        plt.scatter(x=X_lda[:,<span class="number">0</span>].real[y == label],</span><br><span class="line">                y=X_lda[:,<span class="number">1</span>].real[y == label],</span><br><span class="line">                marker=marker,</span><br><span class="line">                color=color,</span><br><span class="line">                alpha=<span class="number">0.5</span>,</span><br><span class="line">                label=label_dict[label]</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">    plt.xlabel(<span class="string">&#x27;LD1&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;LD2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    leg = plt.legend(loc=<span class="string">&#x27;upper right&#x27;</span>, fancybox=<span class="literal">True</span>)</span><br><span class="line">    leg.get_frame().set_alpha(<span class="number">0.5</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;LDA: Iris projection onto the first 2 linear discriminants&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># hide axis ticks</span></span><br><span class="line">    plt.tick_params(axis=<span class="string">&quot;both&quot;</span>, which=<span class="string">&quot;both&quot;</span>, bottom=<span class="string">&quot;off&quot;</span>, top=<span class="string">&quot;off&quot;</span>,  </span><br><span class="line">            labelbottom=<span class="string">&quot;on&quot;</span>, left=<span class="string">&quot;off&quot;</span>, right=<span class="string">&quot;off&quot;</span>, labelleft=<span class="string">&quot;on&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># remove axis spines</span></span><br><span class="line">    ax.spines[<span class="string">&quot;top&quot;</span>].set_visible(<span class="literal">False</span>)  </span><br><span class="line">    ax.spines[<span class="string">&quot;right&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.spines[<span class="string">&quot;bottom&quot;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.spines[<span class="string">&quot;left&quot;</span>].set_visible(<span class="literal">False</span>)    </span><br><span class="line"></span><br><span class="line">    plt.grid()</span><br><span class="line">    plt.tight_layout</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">plot_step_lda()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>基于核的算法</category>
      </categories>
  </entry>
  <entry>
    <title>Lasso算法</title>
    <url>/posts/19dce597.html</url>
    <content><![CDATA[<h2 id="Lasso算法-least-absolute-shrinkage-and-selection-operator">Lasso算法(least absolute shrinkage and selection operator)</h2>
<p>Lasso算法（least absolute shrinkage and selection operator，又译最小绝对值收敛和选择算子、套索算法）是一种同时进行特征选择和正则化（数学）的回归分析方法，旨在增强统计模型的预测准确性和可解释性，最初由斯坦福大学统计学教授Robert Tibshirani于1996年基于Leo Breiman的非负参数推断(Nonnegative Garrote, NNG)提出[1][2]。</p>
<p>Lasso算法最初用于计算最小二乘法模型，这个简单的算法揭示了很多估计量的重要性质，如估计量与岭回归（Ridge regression，也叫Tikhonov regularization）和最佳子集选择的关系，Lasso系数估计值(estimate)和软阈值（soft thresholding）之间的联系。它也揭示了当协变量共线时，Lasso系数估计值不一定唯一（类似标准线性回归）。Lasso是一种缩减方法，将回归系数收缩在一定的区域内。Lasso的主要思想是构造一个一阶惩罚函数获得一个精确的模型, 通过最终确定一些变量的系数为0进行特征筛选。以两个变量为例，标准线性回归的cost function还是可以用二维平面的等值线表示，而约束条件则与岭回归的圆不同，Lasso的约束条件可以用方形表示，如图:</p>
<p align="center">
<img width="300" align="center" src="/img/images/172.jpg" />
</p>
<p>相比圆，方形的顶点更容易与抛物面相交，顶点就意味着对应的很多系数为0，而岭回归中的圆上的任意一点都很容易与抛物面相交很难得到正好等于0的系数。这也就意味着，lasso起到了很好的筛选变量的作用。</p>
<h3 id="应用案例-7">应用案例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets, linear_model, discriminant_analysis, cross_validation</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_data</span>():</span><br><span class="line">    diabetes = datasets.load_diabetes()</span><br><span class="line">    <span class="keyword">return</span> cross_validation.train_test_split(diabetes.data, diabetes.target, test_size=<span class="number">0.25</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_lasso</span>(<span class="params">*data</span>):</span><br><span class="line">    X_train, X_test, y_train, y_test = data</span><br><span class="line">    lassoRegression = linear_model.Lasso()</span><br><span class="line">    lassoRegression.fit(X_train, y_train)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;权重向量:%s, b的值为:%.2f&quot;</span> % (lassoRegression.coef_, lassoRegression.intercept_))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;损失函数的值:%.2f&quot;</span> % np.mean((lassoRegression.predict(X_test) - y_test) ** <span class="number">2</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;预测性能得分: %.2f&quot;</span> % lassoRegression.score(X_test, y_test))</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试不同的α值对预测性能的影响</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_lasso_alpha</span>(<span class="params">*data</span>):</span><br><span class="line">    X_train, X_test, y_train, y_test = data</span><br><span class="line">    alphas = [<span class="number">0.01</span>, <span class="number">0.02</span>, <span class="number">0.05</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">500</span>, <span class="number">1000</span>]</span><br><span class="line">    scores = []</span><br><span class="line">    <span class="keyword">for</span> i, alpha <span class="keyword">in</span> <span class="built_in">enumerate</span>(alphas):</span><br><span class="line">        lassoRegression = linear_model.Lasso(alpha=alpha)</span><br><span class="line">        lassoRegression.fit(X_train, y_train)</span><br><span class="line">        scores.append(lassoRegression.score(X_test, y_test))</span><br><span class="line">    <span class="keyword">return</span> alphas, scores</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_plot</span>(<span class="params">alphas, scores</span>):</span><br><span class="line">    figure = plt.figure()</span><br><span class="line">    ax = figure.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    ax.plot(alphas, scores)</span><br><span class="line">    ax.set_xlabel(<span class="string">r&quot;$\alpha$&quot;</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">r&quot;score&quot;</span>)</span><br><span class="line">    ax.set_xscale(<span class="string">&quot;log&quot;</span>)</span><br><span class="line">    ax.set_title(<span class="string">&quot;Ridge&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    X_train, X_test, y_train, y_test = load_data()</span><br><span class="line">    <span class="comment"># 使用默认的alpha</span></span><br><span class="line">    <span class="comment">#test_lasso(X_train, X_test, y_train, y_test)</span></span><br><span class="line">    <span class="comment"># 使用自己设置的alpha</span></span><br><span class="line">    alphas, scores = test_lasso_alpha(X_train, X_test, y_train, y_test)</span><br><span class="line">    show_plot(alphas, scores)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>正则化算法</category>
      </categories>
      <tags>
        <tag>正则化算法</tag>
      </tags>
  </entry>
  <entry>
    <title>岭回归</title>
    <url>/posts/7984890f.html</url>
    <content><![CDATA[<h2 id="岭回归（Ridge-Regression）">岭回归（Ridge Regression）</h2>
<p>岭回归(ridge regression, Tikhonov regularization)是一种专用于共线性数据分析的有偏估计回归方法，实质上是一种改良的最小二乘估计法，通过放弃最小二乘法的无偏性，以损失部分信息、降低精度为代价获得回归系数更为符合实际、更可靠的回归方法，对病态数据的拟合要强于最小二乘法。</p>
<p>岭回归，又称脊回归、吉洪诺夫正则化（Tikhonov regularization），是对不适定问题（ill-posed problem)进行回归分析时最经常使用的一种正则化方法。对于有些矩阵，矩阵中某个元素的一个很小的变动，会引起最后计算结果误差很大，这种矩阵称为“病态矩阵”。有些时候不正确的计算方法也会使一个正常的矩阵在运算中表现出病态。对于高斯消去法来说，如果主元（即对角线上的元素）上的元素很小，在计算时就会表现出病态的特征。</p>
<p>岭回归分析核心思想是采用最小二乘法原理来求解回归系数，最小二乘法思想背景：1801年，意大利天文学家朱赛普·皮亚齐发现了第一颗小行星谷神星。经过40天的跟踪观测后，由于谷神星运行至太阳背后，使得皮亚齐失去了谷神星的位置。随后全世界的科学家利用皮亚齐的观测数据开始寻找谷神星，但是根据大多数人计算的结果来寻找谷神星都没有结果。时年24岁的高斯计算了谷神星的轨道并进行了分析。奥地利天文学家海因里希·奥伯斯根据高斯计算出来的轨道重新发现了谷神星。</p>
<p>高斯使用的最小二乘法的方法发表于1809年他的著作《天体运动论》中，而法国科学家勒让德于1806年独立发现“最小二乘法”，但因不为世人所知而默默无闻。两人曾为谁最早创立最小二乘法原理发生争执。</p>
<p>1829年，高斯提供了最小二乘法的优化效果强于其他方法的证明，见高斯-马尔可夫定理。</p>
<p>回归分析中常用的最小二乘法是一种无偏估计。对于一个适定问题，X通常是列满秩的：</p>
<p align="center">
<img width="50" align="center" src="/img/images/160.jpg" />
</p>
采用最小二乘法，定义损失函数为残差的平方，最小化损失函数:
<p align="center">
<img width="70" align="center" src="/img/images/161.jpg" />
</p>
也可以采用梯度下降法进行求解优化，也可以采用如下公式进行直接求解：
<p align="center">
<img width="100" align="center" src="/img/images/162.jpg" />
</p>
<p>当X不是列满秩时，或者某些列之间的线性相关性比较大时，<img width="40" align="center" src="/img/images/164.jpg" />的行列式接近于0，即<img width="40" align="center" src="/img/images/164.jpg" />接近于奇异，上述问题变为一个不适定问题，此时，计算<img width="50" align="center" src="/img/images/165.jpg" />时误差会很大，传统的最小二乘法缺乏稳定性与可靠性。</p>
<p>因而，我们需要将不适定问题转化为适定问题：我们为上述损失函数加上一个正则化项，变为</p>
<p align="center">
<img width="200" align="center" src="/img/images/166.jpg" />
</p>
<p>其中，我们定义<img width="40" align="center" src="/img/images/167.jpg" />，于是：</p>
<p align="center">
<img width="200" align="center" src="/img/images/168.jpg" />
</p>
其中I是单位矩阵。
<p>随着的<img width="10" align="center" src="/img/images/169.jpg" />增大，<img width="30" align="center" src="/img/images/170.jpg" />各元素<img width="30" align="center" src="/img/images/171.jpg" />的绝对值均趋于不断变小，它们相对于正确值<img width="10" align="center" src="/img/images/163.jpg" />的偏差也越来越大。<img width="10" align="center" src="/img/images/169.jpg" />趋于无穷大时，<img width="30" align="center" src="/img/images/170.jpg" />趋于0。其中，<img width="30" align="center" src="/img/images/170.jpg" />随<img width="10" align="center" src="/img/images/169.jpg" />的改变而变化的轨迹，就称为岭迹。实际计算中可选非常多的  值，做出一个岭迹图，看看这个图在取哪个值的时候变稳定了，那就确定<img width="10" align="center" src="/img/images/169.jpg" />值了。岭回归是对最小二乘回归的一种补充，它损失了无偏性，来换取高的数值稳定性，从而得到较高的计算精度。</p>
<h3 id="相关应用-7">相关应用</h3>
<p>岭回归是在自变量组成的信息矩阵的主对角线元素上人为的加入一个非负因子k，使得矩阵行列式不为零，以降低对回归系数估计的误差，提高估计精确度以及模型的平稳性。它是最小二乘法的补充，岭回归可以修复病态矩阵，达到较好的效果。</p>
<p>近年来，岭回归在经济、工业生产、工程技术、环境保护等方面已有一定的应用。</p>
<h3 id="应用案例-8">应用案例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets, linear_model, discriminant_analysis, cross_validation</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_data</span>():</span><br><span class="line">    diabetes = datasets.load_diabetes()</span><br><span class="line">    <span class="keyword">return</span> cross_validation.train_test_split(diabetes.data, diabetes.target, test_size=<span class="number">0.25</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_ridge</span>(<span class="params">*data</span>):</span><br><span class="line">    X_train, X_test, y_train, y_test = data</span><br><span class="line">    ridgeRegression = linear_model.Ridge()</span><br><span class="line">    ridgeRegression.fit(X_train, y_train)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;权重向量:%s, b的值为:%.2f&quot;</span> % (ridgeRegression.coef_, ridgeRegression.intercept_))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;损失函数的值:%.2f&quot;</span> % np.mean((ridgeRegression.predict(X_test) - y_test) ** <span class="number">2</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;预测性能得分: %.2f&quot;</span> % ridgeRegression.score(X_test, y_test))</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试不同的α值对预测性能的影响</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_ridge_alpha</span>(<span class="params">*data</span>):</span><br><span class="line">    X_train, X_test, y_train, y_test = data</span><br><span class="line">    alphas = [<span class="number">0.01</span>, <span class="number">0.02</span>, <span class="number">0.05</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">500</span>, <span class="number">1000</span>]</span><br><span class="line">    scores = []</span><br><span class="line">    <span class="keyword">for</span> i, alpha <span class="keyword">in</span> <span class="built_in">enumerate</span>(alphas):</span><br><span class="line">        ridgeRegression = linear_model.Ridge(alpha=alpha)</span><br><span class="line">        ridgeRegression.fit(X_train, y_train)</span><br><span class="line">        scores.append(ridgeRegression.score(X_test, y_test))</span><br><span class="line">    <span class="keyword">return</span> alphas, scores</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_plot</span>(<span class="params">alphas, scores</span>):</span><br><span class="line">    figure = plt.figure()</span><br><span class="line">    ax = figure.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    ax.plot(alphas, scores)</span><br><span class="line">    ax.set_xlabel(<span class="string">r&quot;$\alpha$&quot;</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">r&quot;score&quot;</span>)</span><br><span class="line">    ax.set_xscale(<span class="string">&quot;log&quot;</span>)</span><br><span class="line">    ax.set_title(<span class="string">&quot;Ridge&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment">#X_train, X_test, y_train, y_test = load_data()</span></span><br><span class="line">    <span class="comment">#test_ridge(X_train, X_test, y_train, y_test)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#使用自己设置的alpha</span></span><br><span class="line">    X_train, X_test, y_train, y_test = load_data()</span><br><span class="line">    alphas, scores = test_ridge_alpha(X_train, X_test, y_train, y_test)</span><br><span class="line">    show_plot(alphas, scores)</span><br></pre></td></tr></table></figure>
<h3 id="优缺点-8">优缺点</h3>
<p>优点：可对变量之间共线性比较严重或病态数据偏多的数据类型作回归分析，对这类数据作回归得到的回归系数更符合实际，更可靠。另外，岭回归能让估计参数的波动范围变小，变的更稳定。</p>
<p>缺点：对系数的估计时，会损失部分信息、降低精度。同时岭回归方程的R平方值会稍低于普通的回归方法。</p>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>正则化算法</category>
      </categories>
      <tags>
        <tag>正则化算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最小角回归</title>
    <url>/posts/acfcd0c.html</url>
    <content><![CDATA[<h2 id="最小角回归（LARS）">最小角回归（LARS）</h2>
<p>最小角回归(LARS)是对高维数据的回归算法， 由 Bradley Efron, Trevor Hastie, Iain Johnstone 和 Robert Tibshirani 开发完成。 LARS 和逐步回归很像。在每一步，它寻找与响应最有关联的 预测。当有很多预测有相同的关联时，它没有继续利用相同的预测，而是在这些预测中找出应该等角的方向。</p>
<h3 id="示例应用">示例应用</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(__doc__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Author: Fabian Pedregosa &lt;fabian.pedregosa@inria.fr&gt;</span></span><br><span class="line"><span class="comment">#         Alexandre Gramfort &lt;alexandre.gramfort@inria.fr&gt;</span></span><br><span class="line"><span class="comment"># License: BSD 3 clause</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"></span><br><span class="line">diabetes = datasets.load_diabetes()</span><br><span class="line">X = diabetes.data</span><br><span class="line">y = diabetes.target</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Computing regularization path using the LARS ...&quot;</span>)</span><br><span class="line">alphas, _, coefs = linear_model.lars_path(X, y, method=<span class="string">&#x27;lasso&#x27;</span>, verbose=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">xx = np.<span class="built_in">sum</span>(np.<span class="built_in">abs</span>(coefs.T), axis=<span class="number">1</span>)</span><br><span class="line">xx /= xx[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">plt.plot(xx, coefs.T)</span><br><span class="line">ymin, ymax = plt.ylim()</span><br><span class="line">plt.vlines(xx, ymin, ymax, linestyle=<span class="string">&#x27;dashed&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;|coef| / max|coef|&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Coefficients&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;LASSO Path&#x27;</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;tight&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h3 id="优点和缺点-3">优点和缺点</h3>
<p>优点：</p>
<ol>
<li class="lvl-3">
<p>当 p &gt;&gt; n，该算法数值运算上非常有效。(例如当维度的数目远超点的个数)</p>
</li>
<li class="lvl-3">
<p>它在计算上和前向选择一样快，和普通最小二乘法有相同的运算复杂度。</p>
</li>
<li class="lvl-3">
<p>它产生了一个完整的分段线性的解决路径，在交叉验证或者其他相似的微调模型的方法上非常有用。</p>
</li>
<li class="lvl-3">
<p>如果两个变量对响应几乎有相等的联系，则它们的系数应该有相似的增长率。因此这个算法和我们直觉 上的判断一样，而且还更加稳定。</p>
</li>
<li class="lvl-3">
<p>它很容易修改并为其他估算器生成解，比如Least Absolute Shrinkage and Selection Operator。</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li class="lvl-3">
<p>因为 LARS 是建立在循环拟合剩余变量上的，所以它对噪声非常敏感。</p>
</li>
</ol>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>正则化算法</category>
      </categories>
      <tags>
        <tag>正则化算法</tag>
      </tags>
  </entry>
  <entry>
    <title>弹性网络</title>
    <url>/posts/a045611c.html</url>
    <content><![CDATA[<h2 id="弹性网络-Elastic-Net">弹性网络(Elastic Net)</h2>
<p>弹性网络是一种使用 L1，L2范数作为先验正则项训练的线性回归模型.这种组合允许学习到一个只有少量参数是非零稀疏的模型，就像 Lasso一样，但是它仍然保持一些像Ridge的正则性质。我们可利用 l1_ratio 参数控制L1和L2的凸组合。弹性网络是一不断叠代的方法。</p>
<p align="center">
<img width="300" align="center" src="/img/images/174.jpg" />
<img width="300" align="center" src="/img/images/175.jpg" />
</p>
弹性网络最妙的地方是它永远可以产生有效解。由于它不会产生交叉的路径，所以产生的解都相当不错。举例来说，对一个随机产生的50个城市的推销员问题，弹性网络的解只有比德宾和威尔萧的论文中所提的最具竞争力的演算法长2%（什么是最具竞争力的演算法？有人说是林－克尼根（Lin-Kernighan）演算法，也有人说是SA+OP）。但是弹性网络最吸引人的地方不在它的有效解，而在它收敛的速度。许多人试着去改善弹性网络收敛的速度，都有不错的结果。举例来说，柏尔（Burr）所提出的改良版可令50个城市的推销员问题的收敛次数由1250大幅降为30次。一个最佳化的弹性网络的速度会比林－克尼根快两倍。
<p>弹性网络在很多特征互相联系的情况下是非常有用的。Lasso 很可能只随机考虑这些特征中的一个，而弹性网络更倾向于选择两个。在实践中，Lasso 和 Ridge 之间权衡的一个优势是它允许在循环过程（Under rotate）中继承 Ridge 的稳定性。</p>
<p>在这里，最小化的目标函数是:</p>
<p align="center">
<img width="300" align="center" src="/img/images/173.jpg" />
</p>
<h3 id="应用案例-9">应用案例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(__doc__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Author: Alexandre Gramfort &lt;alexandre.gramfort@inria.fr&gt;</span></span><br><span class="line"><span class="comment"># License: BSD 3 clause</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> cycle</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> lasso_path, enet_path</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"></span><br><span class="line">diabetes = datasets.load_diabetes()</span><br><span class="line">X = diabetes.data</span><br><span class="line">y = diabetes.target</span><br><span class="line"></span><br><span class="line">X /= X.std(axis=<span class="number">0</span>)  <span class="comment"># Standardize data (easier to set the l1_ratio parameter)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute paths</span></span><br><span class="line"></span><br><span class="line">eps = <span class="number">5e-3</span>  <span class="comment"># the smaller it is the longer is the path</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Computing regularization path using the lasso...&quot;</span>)</span><br><span class="line">alphas_lasso, coefs_lasso, _ = lasso_path(X, y, eps, fit_intercept=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Computing regularization path using the positive lasso...&quot;</span>)</span><br><span class="line">alphas_positive_lasso, coefs_positive_lasso, _ = lasso_path(</span><br><span class="line">    X, y, eps, positive=<span class="literal">True</span>, fit_intercept=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Computing regularization path using the elastic net...&quot;</span>)</span><br><span class="line">alphas_enet, coefs_enet, _ = enet_path(</span><br><span class="line">    X, y, eps=eps, l1_ratio=<span class="number">0.8</span>, fit_intercept=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Computing regularization path using the positive elastic net...&quot;</span>)</span><br><span class="line">alphas_positive_enet, coefs_positive_enet, _ = enet_path(</span><br><span class="line">    X, y, eps=eps, l1_ratio=<span class="number">0.8</span>, positive=<span class="literal">True</span>, fit_intercept=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Display results</span></span><br><span class="line"></span><br><span class="line">plt.figure(<span class="number">1</span>)</span><br><span class="line">ax = plt.gca()</span><br><span class="line"></span><br><span class="line">colors = cycle([<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;k&#x27;</span>])</span><br><span class="line">neg_log_alphas_lasso = -np.log10(alphas_lasso)</span><br><span class="line">neg_log_alphas_enet = -np.log10(alphas_enet)</span><br><span class="line"><span class="keyword">for</span> coef_l, coef_e, c <span class="keyword">in</span> <span class="built_in">zip</span>(coefs_lasso, coefs_enet, colors):</span><br><span class="line">    l1 = plt.plot(neg_log_alphas_lasso, coef_l, c=c)</span><br><span class="line">    l2 = plt.plot(neg_log_alphas_enet, coef_e, linestyle=<span class="string">&#x27;--&#x27;</span>, c=c)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&#x27;-Log(alpha)&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;coefficients&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Lasso and Elastic-Net Paths&#x27;</span>)</span><br><span class="line">plt.legend((l1[-<span class="number">1</span>], l2[-<span class="number">1</span>]), (<span class="string">&#x27;Lasso&#x27;</span>, <span class="string">&#x27;Elastic-Net&#x27;</span>), loc=<span class="string">&#x27;lower left&#x27;</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;tight&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.figure(<span class="number">2</span>)</span><br><span class="line">ax = plt.gca()</span><br><span class="line">neg_log_alphas_positive_lasso = -np.log10(alphas_positive_lasso)</span><br><span class="line"><span class="keyword">for</span> coef_l, coef_pl, c <span class="keyword">in</span> <span class="built_in">zip</span>(coefs_lasso, coefs_positive_lasso, colors):</span><br><span class="line">    l1 = plt.plot(neg_log_alphas_lasso, coef_l, c=c)</span><br><span class="line">    l2 = plt.plot(neg_log_alphas_positive_lasso, coef_pl, linestyle=<span class="string">&#x27;--&#x27;</span>, c=c)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&#x27;-Log(alpha)&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;coefficients&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Lasso and positive Lasso&#x27;</span>)</span><br><span class="line">plt.legend((l1[-<span class="number">1</span>], l2[-<span class="number">1</span>]), (<span class="string">&#x27;Lasso&#x27;</span>, <span class="string">&#x27;positive Lasso&#x27;</span>), loc=<span class="string">&#x27;lower left&#x27;</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;tight&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.figure(<span class="number">3</span>)</span><br><span class="line">ax = plt.gca()</span><br><span class="line">neg_log_alphas_positive_enet = -np.log10(alphas_positive_enet)</span><br><span class="line"><span class="keyword">for</span> (coef_e, coef_pe, c) <span class="keyword">in</span> <span class="built_in">zip</span>(coefs_enet, coefs_positive_enet, colors):</span><br><span class="line">    l1 = plt.plot(neg_log_alphas_enet, coef_e, c=c)</span><br><span class="line">    l2 = plt.plot(neg_log_alphas_positive_enet, coef_pe, linestyle=<span class="string">&#x27;--&#x27;</span>, c=c)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&#x27;-Log(alpha)&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;coefficients&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Elastic-Net and positive Elastic-Net&#x27;</span>)</span><br><span class="line">plt.legend((l1[-<span class="number">1</span>], l2[-<span class="number">1</span>]), (<span class="string">&#x27;Elastic-Net&#x27;</span>, <span class="string">&#x27;positive Elastic-Net&#x27;</span>),</span><br><span class="line">           loc=<span class="string">&#x27;lower left&#x27;</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;tight&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>正则化算法</category>
      </categories>
      <tags>
        <tag>正则化算法</tag>
      </tags>
  </entry>
  <entry>
    <title>堆叠自动编码器</title>
    <url>/posts/28eb33c1.html</url>
    <content><![CDATA[<h2 id="堆叠自动编码器-Stacked-AutoEncoder">堆叠自动编码器(Stacked AutoEncoder)</h2>
<p>自从Hinton 2006年的工作之后，越来越多的研究者开始关注各种自编码器模型相应的堆叠模型。实际上，自编码器（Auto-Encoder）是一个较早的概念了，比如Hinton等人在1986, 1989年的工作。</p>
<p>自编码器可以理解为一个试图去还原其原始输入的系统。</p>
<p align="center">
<img width="300" align="center" src="/img/images/373.jpg" />
</p>
<p>图中，虚线蓝色框内就是一个自编码器模型，它由编码器（Encoder）和解码器（Decoder）两部分组成，本质上都是对输入信号做某种变换。编码器将输入信号x变换成编码信号y，而解码器将编码y转换成输出信号<img width="20" align="center" src="/img/images/374.jpg" />，即</p>
<p align="center">
<img width="300" align="center" src="/img/images/375.jpg" />
</p>
<p>而自编码器的目的是，让输出尽可能复现输入x.但是，这样问题就来了,如果f和g都是恒等映射，那就是<img width="70" align="center" src="/img/images/376.jpg" />,实际上事实确实如此，但这样的变换就没有什么用了，所以我们需要对中间信号y（也叫作“编码”）做一定的约束，这样，系统往往能学出很有趣的编码变换f和编码y。</p>
<p>在这里需要强调一点，对于自编码器，往往并不关系输出是什么，因常我们只需要关心中间层的编码，或者是从输入到编码的映射。在我们强迫编码y和输入x不同的情况下，系统还能够去复原原始信号x，那么说明编码y已经承载了原始数据的所有信息，但以一种不同的形式！这就是特征提取。这个是通过自动学出来的，事实上，自动学习原始数据的特征表达也是神经网络和深度学习的核心目的之一。</p>
<p>自编码器与神经网络，其中神经网络就是在对原始信号逐层地做非线性变换：</p>
<p align="center">
<img width="300" align="center" src="/img/images/377.jpg" />
</p>
<p>该网络把输入层数据<img width="70" align="center" src="/img/images/378.jpg" />转换到中间层（隐层）<img width="70" align="center" src="/img/images/379.jpg" />，再转换到输出层<img width="70" align="center" src="/img/images/380.jpg" />。图中的每个节点代表数据的一个维度（偏置项图中未标出）。每两层之间的变换都是“线性变化”+“非线性激活”，用公式表示即为。图中的每个节点代表数据的一个维度（偏置项图中未标出）。每两层之间的变换都是“线性变化”+“非线性激活”，用公式表示为:</p>
<p align="center">
<img width="300" align="center" src="/img/images/381.jpg" />
</p>
<p>神经网络通常可以用于分类，这样可以得道从输入层到输出层的变换函数。因此，我们需要定义一个目标函数来衡量当前的输出和真实结果的差异，利用该函数去逐步调整（如梯度下降）系统的参数<img width="130" align="center" src="/img/images/382.jpg" />，以使得整个网络尽可能去拟合训练数据。如果有正则约束的话，还同时要求模型尽量简单（以防止过拟合）。</p>
<p>但是自编码器怎么表示呢？</p>
<p>自编码器试图复现其原始输入，因此，在训练中，网络中的输出应与输入相同，即 y=x，因此，一个自编码器的输入、输出应有相同的结构，即：</p>
<p align="center">
<img width="300" align="center" src="/img/images/383.jpg" />
</p>
<p>这里我们可以利用训练数据训练这个网络，等训练结束后，这个网络即学习出了<img width="100" align="center" src="/img/images/384.jpg" />的能力。对我们来说，此时的h是至关重要的，因为它是在尽量不损失信息量的情况下，对原始数据的另一种表达。结合神经网络的惯例，我们再将自编码器的公式表示如下：（假设激活函数是sigmoid，用s表示）</p>
<p align="center">
<img width="300" align="center" src="/img/images/385.jpg" />
</p>
<p>其中，<img width="30" align="center" src="/img/images/386.jpg" />表示损失函数，结合数据的不同形式，可以是二次误差（squared error loss）或交叉熵误差（cross entropy loss）。如果<img width="30" align="center" src="/img/images/387.jpg" />，一般称为tied weights。</p>
<p>这里我们会给隐层加入一定的约束。从数据维度来看，常见以下两种情况：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>n&gt;p，即隐层维度小于输入数据维度。从x→h的变换是一种降维的操作，网络试图以更小的维度去描述原始数据而尽量不损失数据信息。实际上，当每两层之间的变换均为线性，且监督训练的误差是二次型误差时，该网络等价于PCA！</p>
</li>
<li class="lvl-2">
<p>n&lt;p ，即隐层维度大于输入数据维度。虽然我们同时约束h的表达尽量稀疏（有大量维度为0，未被激活），此时的编码器便是非常有名的“稀疏自编码器”。可为什么稀疏的表达就是好的？这是因为，有人尝试从人脑机理对比，人类神经系统在某一刺激下，大部分神经元是被抑制的。</p>
</li>
</ul>
<p>学习过深度学习的都明白，深度学习中深度网络的重要性在于其能够逐层地学习原始数据的多种表达。每一层的都以底一层的表达为基础，但往往更抽象，更加适合复杂的分类等任务。</p>
<p>堆叠自编码器实际上就在做这样的事情，如前所述，单个自编码器通过虚构<img width="30" align="center" src="/img/images/388.jpg" />的三层网络，能够学习出一种特征变化<img width="30" align="center" src="/img/images/389.jpg" />(这里用θ表示变换的参数，包括W,b和激活函数)。实际上，当训练结束后，输出层就没什么意义了，我们一般会将其去掉的，即将自编码器表示为:</p>
<p align="center">
<img width="500" align="center" src="/img/images/390.jpg" />
</p>
<p>自编码器模型这里表示为3层的神经网络，这是因为训练的需要，我们将原始数据作为假想的目标输出，以此构建监督误差来训练整个网络。等训练结束后，输出层就可以去掉了，而我们关心的只是从x到h的变换过程。</p>
<p>接下来的思路就很自然了——我们已经得到特征表达h，那么我们就可以将h再当做原始信息，训练一个新的自编码器，得到新的特征表达。</p>
<p>堆叠自编码器（Stacked Auto-Encoder, SAE）,这里Stacked就是逐层垒叠的意思，跟“栈”有点像，当把多个自编码器Stack起来之后就是如下的过程：</p>
<p align="center">
<img width="500" align="center" src="/img/images/391.jpg" />
</p>
<p>这里需要注意的是，整个网络的训练不是一蹴而就的，而是需要逐层进行。根据n,m,k结构，实际上我们是先训练网络n→m→n，得到n→m的变换，然后再训练<br>
m→k→m，得到m→k的变换。最终堆叠成SAE，即为n→m→k的结果，整个过程就像一层层往上构建网络，这个就是非常有名的<br>
layer-wise unsuperwised pre-training（逐层非监督预训练）。</p>
<p>稀疏自编码器如前所示，这种模型背后的思想是，高维而稀疏的表达是好的。一般而言h中哪些节点是被抑制的（对于sigmoid单元即输出为0），而是指定一个稀疏性参数ρ，，代表隐藏神经元的平均活跃程度（在训练集上取平均）。比如，当ρ=0.05时，可以认为隐层节点在95%的时间里都是被一直的，只有5%的机会被激活。实际上，为了满足这一条件，隐层神经元的活跃度需要接近于0。</p>
<p>既然要求平均激活度为ρ，那么我们只要引入一个度量，来衡量神经元i的实际激活度<img width="10" align="center" src="/img/images/394.jpg" />与期望激活度ρ之间的差异即可，然后将这个度量添加到目标函数作为正则，训练整个网络即可。那么，什么样的度量适合这个任务呢？了解过概率论、信息论基础的人应该清楚——相对熵，也就是KL散度（KL divergence）。因此，整个网络所添加的惩罚项：</p>
<p align="center">
<img width="300" align="center" src="/img/images/392.jpg" />
</p>
<p>我们可以从下图（摘自UFLDL）中直观理解KL散度作为惩罚项的含义。图中假设平均激活度ρ=0.2。</p>
<p align="center">
<img width="500" align="center" src="/img/images/393.jpg" />
</p>
<p>可以看出，当<img width="10" align="center" src="/img/images/394.jpg" />一旦偏离期望激活度ρ，这种误差便急剧增大，从而作为惩罚项添加到目标函数，指导整个网络学习出稀疏的特征表达。</p>
<p>降噪自编码器(Stacked Denoising Autoencoders)核心思想是，一个能够从中恢复出原始信号的表达未必是最好的，能够对“被污染/破坏”的原始数据编码、解码，然后还能恢复真正的原始数据，这样的特征才是好的。</p>
<p>假设原始数据x被我们“故意破坏”，比如加入高斯白噪，或者把某些维度数据抹掉，变成了<img width="20" align="center" src="/img/images/374.jpg" />，然后再对<img width="20" align="center" src="/img/images/374.jpg" />编码、解码，得到恢复信号<img width="100" align="center" src="/img/images/395.jpg" />，该恢复信号尽可能逼近未被污染的数据x。此时，监督训练的误差从<img width="120" align="center" src="/img/images/396.jpg" />变成了<img width="120" align="center" src="/img/images/397.jpg" />。</p>
<p>降噪自编码器的系统结构如下图:</p>
<p align="center">
<img width="300" align="center" src="/img/images/398.jpg" />
</p>
<p>深度学习兴起正式因为逐层预训练方法的提出，使得深度网络的训练成为可能。对于一个深度网络而言，这种逐层预训练的方法，正是前面介绍的这种堆叠自动编码器(Stacked AutoEncoder)。对于常见的分类任务，一般分为以下两个阶段：</p>
<ul class="lvl-0">
<li class="lvl-3">
<p>逐层预训练(layer-wise pre-training)</p>
</li>
<li class="lvl-3">
<p>微调(fune-tuning )</p>
</li>
</ul>
<p>上面讲述的的自动编码器，本质上都是非监督学习，自动编码器各层的输出都是原始数据的不同表达。对于分类任务，往往在自动编码器顶端再添加一分类层（如Softmax层），并结合有标注的训练数据，在误差函数的指导下，对系统的参数进行微调，以使得整个网络能够完成所需的分类任务。</p>
<p align="center">
<img width="300" align="center" src="/img/images/399.jpg" />
</p>
<p>对于微调过程，即可以只调整分类层的参数（此时相当于把整个SAE当做一个feature extractor），也可以调整整个网络的参数（适合训练数据量比较大的情况）。</p>
<p>但是为什么训练稀疏自编码器为什么一般都是三层的结构，实际上这里的三层是指训练单个自编码器所假想的3层神经网络，这对任何基于神经网络的编码器都是这样。多层的稀疏自编码器自然是有的，只不过是通过layer-wise pre-training这种方式逐层堆叠起来的，而不是直接去训练多层的网络。</p>
<p>实际上，这正是在训练深层神经网络中遇到的问题。直接去训练一个深层的自编码器，其实本质上就是在做深度网络的训练，由于梯度扩散等问题，这样的网络往往根本无法训练。这倒不是因为会破坏稀疏性等原因，只要网络能够训练，对模型施加的约束总能得到相应的结果。</p>
<p>但是为什么逐层预训练就可以使得深度网络的训练成为可能了呢？其实一个直观的解释是，预训练好的网络在一定程度上拟合了训练数据的结构，这使得整个网络的初始值是在一个合适的状态，便于有监督阶段加快迭代收敛。</p>
<h3 id="应用示例-6">应用示例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This piece of software is bound by The MIT License (MIT)</span></span><br><span class="line"><span class="comment"># Copyright (c) 2014 Siddharth Agrawal</span></span><br><span class="line"><span class="comment"># Code written by : Siddharth Agrawal</span></span><br><span class="line"><span class="comment"># Email ID : siddharth.950@gmail.com</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> scipy.io</span><br><span class="line"><span class="keyword">import</span> scipy.optimize</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; Returns elementwise sigmoid output of input array &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">x</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> / (<span class="number">1</span> + numpy.exp(-x)))</span><br><span class="line">    </span><br><span class="line"><span class="string">&quot;&quot;&quot; Returns the groundtruth matrix for a set of labels &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getGroundTruth</span>(<span class="params">labels</span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Prepare data needed to construct groundtruth matrix &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    labels = numpy.array(labels).flatten()</span><br><span class="line">    data   = numpy.ones(<span class="built_in">len</span>(labels))</span><br><span class="line">    indptr = numpy.arange(<span class="built_in">len</span>(labels)+<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Compute the groundtruth matrix and return &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    ground_truth = scipy.sparse.csr_matrix((data, labels, indptr))</span><br><span class="line">    ground_truth = numpy.transpose(ground_truth.todense())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ground_truth</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; The Sparse Autoencoder class &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SparseAutoencoder</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Initialization of Autoencoder object &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, visible_size, hidden_size, rho, lamda, beta</span>):</span><br><span class="line">    </span><br><span class="line">        <span class="string">&quot;&quot;&quot; Initialize parameters of the Autoencoder object &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">        self.visible_size = visible_size    <span class="comment"># number of input units</span></span><br><span class="line">        self.hidden_size = hidden_size      <span class="comment"># number of hidden units</span></span><br><span class="line">        self.rho = rho                      <span class="comment"># desired average activation of hidden units</span></span><br><span class="line">        self.lamda = lamda                  <span class="comment"># weight decay parameter</span></span><br><span class="line">        self.beta = beta                    <span class="comment"># weight of sparsity penalty term</span></span><br><span class="line">        </span><br><span class="line">        <span class="string">&quot;&quot;&quot; Set limits for accessing &#x27;theta&#x27; values &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        self.limit0 = <span class="number">0</span></span><br><span class="line">        self.limit1 = hidden_size * visible_size</span><br><span class="line">        self.limit2 = <span class="number">2</span> * hidden_size * visible_size</span><br><span class="line">        self.limit3 = <span class="number">2</span> * hidden_size * visible_size + hidden_size</span><br><span class="line">        self.limit4 = <span class="number">2</span> * hidden_size * visible_size + hidden_size + visible_size</span><br><span class="line">        </span><br><span class="line">        <span class="string">&quot;&quot;&quot; Initialize Neural Network weights randomly</span></span><br><span class="line"><span class="string">            W1, W2 values are chosen in the range [-r, r] &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        r = math.sqrt(<span class="number">6</span>) / math.sqrt(visible_size + hidden_size + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        rand = numpy.random.RandomState(<span class="built_in">int</span>(time.time()))</span><br><span class="line">        </span><br><span class="line">        W1 = numpy.asarray(rand.uniform(low = -r, high = r, size = (hidden_size, visible_size)))</span><br><span class="line">        W2 = numpy.asarray(rand.uniform(low = -r, high = r, size = (visible_size, hidden_size)))</span><br><span class="line">        </span><br><span class="line">        <span class="string">&quot;&quot;&quot; Bias values are initialized to zero &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        b1 = numpy.zeros((hidden_size, <span class="number">1</span>))</span><br><span class="line">        b2 = numpy.zeros((visible_size, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Create &#x27;theta&#x27; by unrolling W1, W2, b1, b2 &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        self.theta = numpy.concatenate((W1.flatten(), W2.flatten(),</span><br><span class="line">                                        b1.flatten(), b2.flatten()))</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Returns gradient of &#x27;theta&#x27; using Backpropagation algorithm &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sparseAutoencoderCost</span>(<span class="params">self, theta, <span class="built_in">input</span></span>):</span><br><span class="line">        </span><br><span class="line">        <span class="string">&quot;&quot;&quot; Extract weights and biases from &#x27;theta&#x27; input &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        W1 = theta[self.limit0 : self.limit1].reshape(self.hidden_size, self.visible_size)</span><br><span class="line">        W2 = theta[self.limit1 : self.limit2].reshape(self.visible_size, self.hidden_size)</span><br><span class="line">        b1 = theta[self.limit2 : self.limit3].reshape(self.hidden_size, <span class="number">1</span>)</span><br><span class="line">        b2 = theta[self.limit3 : self.limit4].reshape(self.visible_size, <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="string">&quot;&quot;&quot; Compute output layers by performing a feedforward pass</span></span><br><span class="line"><span class="string">            Computation is done for all the training inputs simultaneously &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        hidden_layer = sigmoid(numpy.dot(W1, <span class="built_in">input</span>) + b1)</span><br><span class="line">        output_layer = sigmoid(numpy.dot(W2, hidden_layer) + b2)</span><br><span class="line">        </span><br><span class="line">        <span class="string">&quot;&quot;&quot; Estimate the average activation value of the hidden layers &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        rho_cap = numpy.<span class="built_in">sum</span>(hidden_layer, axis = <span class="number">1</span>) / <span class="built_in">input</span>.shape[<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="string">&quot;&quot;&quot; Compute intermediate difference values using Backpropagation algorithm &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        diff = output_layer - <span class="built_in">input</span></span><br><span class="line">        </span><br><span class="line">        sum_of_squares_error = <span class="number">0.5</span> * numpy.<span class="built_in">sum</span>(numpy.multiply(diff, diff)) / <span class="built_in">input</span>.shape[<span class="number">1</span>]</span><br><span class="line">        weight_decay         = <span class="number">0.5</span> * self.lamda * (numpy.<span class="built_in">sum</span>(numpy.multiply(W1, W1)) +</span><br><span class="line">                                                   numpy.<span class="built_in">sum</span>(numpy.multiply(W2, W2)))</span><br><span class="line">        KL_divergence        = self.beta * numpy.<span class="built_in">sum</span>(self.rho * numpy.log(self.rho / rho_cap) +</span><br><span class="line">                                                    (<span class="number">1</span> - self.rho) * numpy.log((<span class="number">1</span> - self.rho) / (<span class="number">1</span> - rho_cap)))</span><br><span class="line">        cost                 = sum_of_squares_error + weight_decay + KL_divergence</span><br><span class="line">        </span><br><span class="line">        KL_div_grad = self.beta * (-(self.rho / rho_cap) + ((<span class="number">1</span> - self.rho) / (<span class="number">1</span> - rho_cap)))</span><br><span class="line">        </span><br><span class="line">        del_out = numpy.multiply(diff, numpy.multiply(output_layer, <span class="number">1</span> - output_layer))</span><br><span class="line">        del_hid = numpy.multiply(numpy.dot(numpy.transpose(W2), del_out) + numpy.transpose(numpy.matrix(KL_div_grad)), </span><br><span class="line">                                 numpy.multiply(hidden_layer, <span class="number">1</span> - hidden_layer))</span><br><span class="line">        </span><br><span class="line">        <span class="string">&quot;&quot;&quot; Compute the gradient values by averaging partial derivatives</span></span><br><span class="line"><span class="string">            Partial derivatives are averaged over all training examples &quot;&quot;&quot;</span></span><br><span class="line">            </span><br><span class="line">        W1_grad = numpy.dot(del_hid, numpy.transpose(<span class="built_in">input</span>))</span><br><span class="line">        W2_grad = numpy.dot(del_out, numpy.transpose(hidden_layer))</span><br><span class="line">        b1_grad = numpy.<span class="built_in">sum</span>(del_hid, axis = <span class="number">1</span>)</span><br><span class="line">        b2_grad = numpy.<span class="built_in">sum</span>(del_out, axis = <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        W1_grad = W1_grad / <span class="built_in">input</span>.shape[<span class="number">1</span>] + self.lamda * W1</span><br><span class="line">        W2_grad = W2_grad / <span class="built_in">input</span>.shape[<span class="number">1</span>] + self.lamda * W2</span><br><span class="line">        b1_grad = b1_grad / <span class="built_in">input</span>.shape[<span class="number">1</span>]</span><br><span class="line">        b2_grad = b2_grad / <span class="built_in">input</span>.shape[<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="string">&quot;&quot;&quot; Transform numpy matrices into arrays &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        W1_grad = numpy.array(W1_grad)</span><br><span class="line">        W2_grad = numpy.array(W2_grad)</span><br><span class="line">        b1_grad = numpy.array(b1_grad)</span><br><span class="line">        b2_grad = numpy.array(b2_grad)</span><br><span class="line">        </span><br><span class="line">        <span class="string">&quot;&quot;&quot; Unroll the gradient values and return as &#x27;theta&#x27; gradient &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        theta_grad = numpy.concatenate((W1_grad.flatten(), W2_grad.flatten(),</span><br><span class="line">                                        b1_grad.flatten(), b2_grad.flatten()))</span><br><span class="line">                                        </span><br><span class="line">        <span class="keyword">return</span> [cost, theta_grad]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; The Softmax Regression class &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SoftmaxRegression</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Initialization of Regressor object &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_size, num_classes, lamda</span>):</span><br><span class="line">    </span><br><span class="line">        <span class="string">&quot;&quot;&quot; Initialize parameters of the Regressor object &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">        self.input_size  = input_size  <span class="comment"># input vector size</span></span><br><span class="line">        self.num_classes = num_classes <span class="comment"># number of classes</span></span><br><span class="line">        self.lamda       = lamda       <span class="comment"># weight decay parameter</span></span><br><span class="line">        </span><br><span class="line">        <span class="string">&quot;&quot;&quot; Randomly initialize the class weights &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        rand = numpy.random.RandomState(<span class="built_in">int</span>(time.time()))</span><br><span class="line">        </span><br><span class="line">        self.theta = <span class="number">0.005</span> * numpy.asarray(rand.normal(size = (num_classes*input_size, <span class="number">1</span>)))</span><br><span class="line">        </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Returns the cost and gradient of &#x27;theta&#x27; at a particular &#x27;theta&#x27; &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">softmaxCost</span>(<span class="params">self, theta, <span class="built_in">input</span>, labels</span>):</span><br><span class="line">    </span><br><span class="line">        <span class="string">&quot;&quot;&quot; Compute the groundtruth matrix &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">        ground_truth = getGroundTruth(labels)</span><br><span class="line">        </span><br><span class="line">        <span class="string">&quot;&quot;&quot; Reshape &#x27;theta&#x27; for ease of computation &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        theta = theta.reshape(self.num_classes, self.input_size)</span><br><span class="line">        </span><br><span class="line">        <span class="string">&quot;&quot;&quot; Compute the class probabilities for each example &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        theta_x       = numpy.dot(theta, <span class="built_in">input</span>)</span><br><span class="line">        hypothesis    = numpy.exp(theta_x)      </span><br><span class="line">        probabilities = hypothesis / numpy.<span class="built_in">sum</span>(hypothesis, axis = <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="string">&quot;&quot;&quot; Compute the traditional cost term &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        cost_examples    = numpy.multiply(ground_truth, numpy.log(probabilities))</span><br><span class="line">        traditional_cost = -(numpy.<span class="built_in">sum</span>(cost_examples) / <span class="built_in">input</span>.shape[<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="string">&quot;&quot;&quot; Compute the weight decay term &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        theta_squared = numpy.multiply(theta, theta)</span><br><span class="line">        weight_decay  = <span class="number">0.5</span> * self.lamda * numpy.<span class="built_in">sum</span>(theta_squared)</span><br><span class="line">        </span><br><span class="line">        <span class="string">&quot;&quot;&quot; Add both terms to get the cost &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        cost = traditional_cost + weight_decay</span><br><span class="line">        </span><br><span class="line">        <span class="string">&quot;&quot;&quot; Compute and unroll &#x27;theta&#x27; gradient &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        theta_grad = -numpy.dot(ground_truth - probabilities, numpy.transpose(<span class="built_in">input</span>))</span><br><span class="line">        theta_grad = theta_grad / <span class="built_in">input</span>.shape[<span class="number">1</span>] + self.lamda * theta</span><br><span class="line">        theta_grad = numpy.array(theta_grad)</span><br><span class="line">        theta_grad = theta_grad.flatten()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [cost, theta_grad]</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; Loads the images from the provided file name &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loadMNISTImages</span>(<span class="params">file_name</span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Open the file &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    image_file = <span class="built_in">open</span>(file_name, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Read header information from the file &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    head1 = image_file.read(<span class="number">4</span>)</span><br><span class="line">    head2 = image_file.read(<span class="number">4</span>)</span><br><span class="line">    head3 = image_file.read(<span class="number">4</span>)</span><br><span class="line">    head4 = image_file.read(<span class="number">4</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Format the header information for useful data &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    num_examples = struct.unpack(<span class="string">&#x27;&gt;I&#x27;</span>, head2)[<span class="number">0</span>]</span><br><span class="line">    num_rows     = struct.unpack(<span class="string">&#x27;&gt;I&#x27;</span>, head3)[<span class="number">0</span>]</span><br><span class="line">    num_cols     = struct.unpack(<span class="string">&#x27;&gt;I&#x27;</span>, head4)[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Initialize dataset as array of zeros &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    dataset = numpy.zeros((num_rows*num_cols, num_examples))</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Read the actual image data &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    images_raw  = array.array(<span class="string">&#x27;B&#x27;</span>, image_file.read())</span><br><span class="line">    image_file.close()</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Arrange the data in columns &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_examples):</span><br><span class="line">    </span><br><span class="line">        limit1 = num_rows * num_cols * i</span><br><span class="line">        limit2 = num_rows * num_cols * (i + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        dataset[:, i] = images_raw[limit1 : limit2]</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Normalize and return the dataset &quot;&quot;&quot;</span>    </span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> dataset / <span class="number">255</span></span><br><span class="line"><span class="string">&quot;&quot;&quot; Loads the image labels from the provided file name &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loadMNISTLabels</span>(<span class="params">file_name</span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Open the file &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    label_file = <span class="built_in">open</span>(file_name, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Read header information from the file &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    head1 = label_file.read(<span class="number">4</span>)</span><br><span class="line">    head2 = label_file.read(<span class="number">4</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Format the header information for useful data &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    num_examples = struct.unpack(<span class="string">&#x27;&gt;I&#x27;</span>, head2)[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Initialize data labels as array of zeros &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    labels = numpy.zeros((num_examples, <span class="number">1</span>), dtype = numpy.<span class="built_in">int</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Read the label data &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    labels_raw = array.array(<span class="string">&#x27;b&#x27;</span>, label_file.read())</span><br><span class="line">    label_file.close()</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Copy and return the label data &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    labels[:, <span class="number">0</span>] = labels_raw[:]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> labels</span><br><span class="line">    </span><br><span class="line"><span class="string">&quot;&quot;&quot; Returns the hidden layer activations of the Autoencoder &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">feedForwardAutoencoder</span>(<span class="params">theta, hidden_size, visible_size, <span class="built_in">input</span></span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Define limits to access useful data &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    limit0 = <span class="number">0</span></span><br><span class="line">    limit1 = hidden_size * visible_size</span><br><span class="line">    limit2 = <span class="number">2</span> * hidden_size * visible_size</span><br><span class="line">    limit3 = <span class="number">2</span> * hidden_size * visible_size + hidden_size</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Access W1 and b1 from &#x27;theta&#x27; &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    W1 = theta[limit0 : limit1].reshape(hidden_size, visible_size)</span><br><span class="line">    b1 = theta[limit2 : limit3].reshape(hidden_size, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Compute the hidden layer activations &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    hidden_layer = <span class="number">1</span> / (<span class="number">1</span> + numpy.exp(-(numpy.dot(W1, <span class="built_in">input</span>) + b1)))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> hidden_layer</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; Returns a row of Stacked Autoencoder parameters &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stack2Params</span>(<span class="params">stack</span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Initialize an empty list of parameters &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    params = []</span><br><span class="line">    num_layers = <span class="built_in">len</span>(stack) / <span class="number">2</span></span><br><span class="line">	</span><br><span class="line">    <span class="string">&quot;&quot;&quot; For each layer in the neural network, append the corresponding parameters &quot;&quot;&quot;</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_layers):</span><br><span class="line">    </span><br><span class="line">        params = numpy.concatenate((params, numpy.array(stack[i, <span class="string">&quot;W&quot;</span>]).flatten()))</span><br><span class="line">        params = numpy.concatenate((params, numpy.array(stack[i, <span class="string">&quot;b&quot;</span>]).flatten()))</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> params</span><br><span class="line"><span class="string">&quot;&quot;&quot; Returns a stack of Stacked Autoencoder parameters &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">params2Stack</span>(<span class="params">params, net_config</span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Initialize an empty stack &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    stack  = &#123;&#125;</span><br><span class="line">    limit0 = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(net_config)-<span class="number">2</span>):</span><br><span class="line">    </span><br><span class="line">        <span class="string">&quot;&quot;&quot; Calculate limits of layer parameters, using neural network config &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">        limit1 = limit0 + net_config[i] * net_config[i+<span class="number">1</span>]</span><br><span class="line">        limit2 = limit1 + net_config[i+<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="string">&quot;&quot;&quot; Extract layer parameters, and store in the stack &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        stack[i, <span class="string">&quot;W&quot;</span>] = params[limit0 : limit1].reshape(net_config[i+<span class="number">1</span>], net_config[i])</span><br><span class="line">        stack[i, <span class="string">&quot;b&quot;</span>] = params[limit1 : limit2].reshape(net_config[i+<span class="number">1</span>], <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        limit0 = limit2</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> stack</span><br><span class="line">    </span><br><span class="line"><span class="string">&quot;&quot;&quot; Function for finetuning the Stacked Autoencoder &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stackedAutoencoderCost</span>(<span class="params">theta, net_config, lamda, data, labels</span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Calculate limits for Softmax parameters &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    input_size   = net_config[-<span class="number">2</span>]</span><br><span class="line">    num_classes  = net_config[-<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    limit0 = <span class="number">0</span></span><br><span class="line">    limit1 = num_classes * input_size</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Extract Softmax and layer parameters &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    softmax_theta = theta[limit0 : limit1].reshape(num_classes, input_size)</span><br><span class="line">    stack         = params2Stack(theta[limit1 :], net_config)</span><br><span class="line">    </span><br><span class="line">    num_layers = <span class="built_in">len</span>(stack) / <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Calculate activations for every layer &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    activation    = &#123;&#125;</span><br><span class="line">    activation[<span class="number">0</span>] = data</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_layers):</span><br><span class="line">    </span><br><span class="line">        activation[i+<span class="number">1</span>] = sigmoid(numpy.dot(stack[i, <span class="string">&quot;W&quot;</span>], activation[i]) + stack[i, <span class="string">&quot;b&quot;</span>])</span><br><span class="line">        </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Compute the groundtruth matrix &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    ground_truth = getGroundTruth(labels)</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Compute the class probabilities for each example &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    theta_x       = numpy.dot(softmax_theta, activation[num_layers])</span><br><span class="line">    hypothesis    = numpy.exp(theta_x)      </span><br><span class="line">    probabilities = hypothesis / numpy.<span class="built_in">sum</span>(hypothesis, axis = <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Compute the traditional cost term &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    cost_examples    = numpy.multiply(ground_truth, numpy.log(probabilities))</span><br><span class="line">    traditional_cost = -(numpy.<span class="built_in">sum</span>(cost_examples) / data.shape[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Compute the weight decay term &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    theta_squared = numpy.multiply(softmax_theta, softmax_theta)</span><br><span class="line">    weight_decay  = <span class="number">0.5</span> * lamda * numpy.<span class="built_in">sum</span>(theta_squared)</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Add both terms to get the cost &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    cost = traditional_cost + weight_decay</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Compute Softmax &#x27;theta&#x27; gradient &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    softmax_theta_grad = -numpy.dot(ground_truth - probabilities, numpy.transpose(activation[num_layers]))</span><br><span class="line">    softmax_theta_grad = softmax_theta_grad / data.shape[<span class="number">1</span>] + lamda * softmax_theta</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Compute intermediate difference values using Backpropagation algorithm &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    delta = &#123;&#125;    </span><br><span class="line">    delta[num_layers] = -numpy.multiply(numpy.dot(numpy.transpose(softmax_theta), ground_truth - probabilities),</span><br><span class="line">                                        numpy.multiply(activation[num_layers], <span class="number">1</span> - activation[num_layers]))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_layers-<span class="number">1</span>):</span><br><span class="line">    </span><br><span class="line">        index        = num_layers - i - <span class="number">1</span></span><br><span class="line">        delta[index] = numpy.multiply(numpy.dot(numpy.transpose(stack[index, <span class="string">&quot;W&quot;</span>]), delta[index+<span class="number">1</span>]),</span><br><span class="line">                                       numpy.multiply(activation[index], <span class="number">1</span> - activation[index]))</span><br><span class="line">                                       </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Compute the partial derivatives, with respect to the layer parameters &quot;&quot;&quot;</span></span><br><span class="line">                                       </span><br><span class="line">    stack_grad = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_layers):</span><br><span class="line">    </span><br><span class="line">        index = num_layers - i - <span class="number">1</span></span><br><span class="line">        stack_grad[index, <span class="string">&quot;W&quot;</span>] = numpy.dot(delta[index+<span class="number">1</span>], numpy.transpose(activation[index])) / data.shape[<span class="number">1</span>]</span><br><span class="line">        stack_grad[index, <span class="string">&quot;b&quot;</span>] = numpy.<span class="built_in">sum</span>(delta[index+<span class="number">1</span>], axis = <span class="number">1</span>) / data.shape[<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Concatenate the gradient values and return as &#x27;theta&#x27; gradient &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">    params_grad = stack2Params(stack_grad)</span><br><span class="line">    theta_grad  = numpy.concatenate((numpy.array(softmax_theta_grad).flatten(),</span><br><span class="line">                                     numpy.array(params_grad).flatten()))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [cost, theta_grad]</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; Returns predictions using the trained Stacked Autoencoder model &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stackedAutoencoderPredict</span>(<span class="params">theta, net_config, data</span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Calculate limits for Softmax parameters &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    input_size   = net_config[-<span class="number">2</span>]</span><br><span class="line">    num_classes  = net_config[-<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    limit0 = <span class="number">0</span></span><br><span class="line">    limit1 = num_classes * input_size</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Extract Softmax and layer parameters &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    softmax_theta = theta[limit0 : limit1].reshape(num_classes, input_size)</span><br><span class="line">    stack         = params2Stack(theta[limit1 :], net_config)</span><br><span class="line">    </span><br><span class="line">    num_layers = <span class="built_in">len</span>(stack) / <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Calculate the activations of the final layer &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    activation = data</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_layers):</span><br><span class="line">    </span><br><span class="line">        activation = sigmoid(numpy.dot(stack[i, <span class="string">&quot;W&quot;</span>], activation) + stack[i, <span class="string">&quot;b&quot;</span>])</span><br><span class="line">        </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Compute the class probabilities for each example &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">    theta_x       = numpy.dot(softmax_theta, activation)</span><br><span class="line">    hypothesis    = numpy.exp(theta_x)      </span><br><span class="line">    probabilities = hypothesis / numpy.<span class="built_in">sum</span>(hypothesis, axis = <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Give the predictions based on probability values &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    predictions       = numpy.zeros((data.shape[<span class="number">1</span>], <span class="number">1</span>))</span><br><span class="line">    predictions[:, <span class="number">0</span>] = numpy.argmax(probabilities, axis = <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> predictions</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; Loads data, trains the Stacked Autoencoder model and predicts classes for test data &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">executeStackedAutoencoder</span>():</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Define the parameters of the first Autoencoder &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    visible_size   = <span class="number">784</span>    <span class="comment"># size of input vector</span></span><br><span class="line">    hidden_size1   = <span class="number">200</span>    <span class="comment"># size of hidden layer vector of first autoencoder</span></span><br><span class="line">    hidden_size2   = <span class="number">200</span>    <span class="comment"># size of hidden layer vector of second autoencoder</span></span><br><span class="line">    rho            = <span class="number">0.1</span>    <span class="comment"># desired average activation of hidden units</span></span><br><span class="line">    lamda          = <span class="number">0.003</span>  <span class="comment"># weight decay parameter</span></span><br><span class="line">    beta           = <span class="number">3</span>      <span class="comment"># weight of sparsity penalty term</span></span><br><span class="line">    max_iterations = <span class="number">200</span>    <span class="comment"># number of optimization iterations</span></span><br><span class="line">    num_classes    = <span class="number">10</span>     <span class="comment"># number of classes</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Load MNIST images for training and testing &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    train_data    = loadMNISTImages(<span class="string">&#x27;train-images.idx3-ubyte&#x27;</span>)</span><br><span class="line">    train_labels  = loadMNISTLabels(<span class="string">&#x27;train-labels.idx1-ubyte&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Initialize the first Autoencoder with the above parameters &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    encoder1 = SparseAutoencoder(visible_size, hidden_size1, rho, lamda, beta)</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Run the L-BFGS algorithm to get the optimal parameter values &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    opt_solution   = scipy.optimize.minimize(encoder1.sparseAutoencoderCost, encoder1.theta, </span><br><span class="line">                                             args = (train_data,), method = <span class="string">&#x27;L-BFGS-B&#x27;</span>, </span><br><span class="line">                                             jac = <span class="literal">True</span>, options = &#123;<span class="string">&#x27;maxiter&#x27;</span>: max_iterations&#125;)</span><br><span class="line">    sae1_opt_theta = opt_solution.x</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Get the features corresponding to first Autoencoder &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    sae1_features = feedForwardAutoencoder(sae1_opt_theta, hidden_size1, visible_size, train_data)</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Initialize the second Autoencoder with the above parameters &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    encoder2 = SparseAutoencoder(hidden_size1, hidden_size2, rho, lamda, beta)</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Run the L-BFGS algorithm to get the optimal parameter values &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    opt_solution   = scipy.optimize.minimize(encoder2.sparseAutoencoderCost, encoder2.theta, </span><br><span class="line">                                             args = (sae1_features,), method = <span class="string">&#x27;L-BFGS-B&#x27;</span>, </span><br><span class="line">                                             jac = <span class="literal">True</span>, options = &#123;<span class="string">&#x27;maxiter&#x27;</span>: max_iterations&#125;)</span><br><span class="line">    sae2_opt_theta = opt_solution.x</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Get the features corresponding to second Autoencoder &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    sae2_features = feedForwardAutoencoder(sae2_opt_theta, hidden_size2, hidden_size1, sae1_features)</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Initialize Softmax Regressor with the above parameters &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    regressor = SoftmaxRegression(hidden_size2, num_classes, lamda)</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Run the L-BFGS algorithm to get the optimal parameter values &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    opt_solution      = scipy.optimize.minimize(regressor.softmaxCost, regressor.theta, </span><br><span class="line">                                                args = (sae2_features, train_labels,), method = <span class="string">&#x27;L-BFGS-B&#x27;</span>, </span><br><span class="line">                                                jac = <span class="literal">True</span>, options = &#123;<span class="string">&#x27;maxiter&#x27;</span>: max_iterations&#125;)</span><br><span class="line">    softmax_opt_theta = opt_solution.x</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Create a stack of the Stacked Autoencoder parameters &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    stack = &#123;&#125;</span><br><span class="line">    stack[<span class="number">0</span>, <span class="string">&quot;W&quot;</span>] = sae1_opt_theta[encoder1.limit0 : encoder1.limit1].reshape(hidden_size1, visible_size)</span><br><span class="line">    stack[<span class="number">1</span>, <span class="string">&quot;W&quot;</span>] = sae2_opt_theta[encoder2.limit0 : encoder2.limit1].reshape(hidden_size2, hidden_size1)</span><br><span class="line">    stack[<span class="number">0</span>, <span class="string">&quot;b&quot;</span>] = sae1_opt_theta[encoder1.limit2 : encoder1.limit3].reshape(hidden_size1, <span class="number">1</span>)</span><br><span class="line">    stack[<span class="number">1</span>, <span class="string">&quot;b&quot;</span>] = sae2_opt_theta[encoder2.limit2 : encoder2.limit3].reshape(hidden_size2, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Create a vector of the Stacked Autoencoder parameters for optimization &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    stack_params     = stack2Params(stack)</span><br><span class="line">    stacked_ae_theta = numpy.concatenate((softmax_opt_theta.flatten(), stack_params.flatten()))</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Create a neural network configuration, with number of units in each layer &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    net_config = [visible_size, hidden_size1, hidden_size2, num_classes]</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Load MNIST test images and labels &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    test_data   = loadMNISTImages(<span class="string">&#x27;t10k-images.idx3-ubyte&#x27;</span>) </span><br><span class="line">    test_labels = loadMNISTLabels(<span class="string">&#x27;t10k-labels.idx1-ubyte&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Get predictions after greedy training &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    predictions = stackedAutoencoderPredict(stacked_ae_theta, net_config, test_data)</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Print accuracy of the trained model &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    correct = test_labels[:, <span class="number">0</span>] == predictions[:, <span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;&quot;&quot;Accuracy after greedy training :&quot;&quot;&quot;</span>, numpy.mean(correct)</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Finetune the greedily trained model &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    opt_solution = scipy.optimize.minimize(stackedAutoencoderCost, stacked_ae_theta, </span><br><span class="line">                                           args = (net_config, lamda, train_data, train_labels,),</span><br><span class="line">                                           method = <span class="string">&#x27;L-BFGS-B&#x27;</span>, jac = <span class="literal">True</span>, options = &#123;<span class="string">&#x27;maxiter&#x27;</span>: max_iterations&#125;)</span><br><span class="line">    stacked_ae_opt_theta = opt_solution.x</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Get predictions after finetuning &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    predictions = stackedAutoencoderPredict(stacked_ae_opt_theta, net_config, test_data)</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot; Print accuracy of the trained model &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    correct = test_labels[:, <span class="number">0</span>] == predictions[:, <span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;&quot;&quot;Accuracy after finetuning :&quot;&quot;&quot;</span>, numpy.mean(correct)</span><br><span class="line">    </span><br><span class="line">executeStackedAutoencoder()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>深度学习算法</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>分层时间记忆</title>
    <url>/posts/80487953.html</url>
    <content><![CDATA[<h2 id="分层时间记忆-Hierarchical-Temporal-Memory">分层时间记忆(Hierarchical Temporal Memory)</h2>
<p>分层时间记忆算法(Hierarchical Temporal Memory)，全称HTM Cortical Learning Algorithms是由《人工智能的未来》(On Intelligence)一书作者Jeff Hawkins创建的Numenta公司发表的新一代人工智能算法。HTM算法旨在模拟新大脑皮层的工作原理，将复杂的问题转化为模式匹配与预测。正如它的名字HTM一样，该算法与普通的神经网络算法有诸多的不同之处。HTM强调对“神经元”进行分层级，强调信息模式的空间特性与时间特性。目前Numenta公司已经推出基于HTM算法的python平台和可进行视觉识别的软件工具箱。</p>
<p>传统的人工智能算法大多是针对特定的任务目标而设计的。HTM算法与之不同 ，它注重先把问题转化成模式匹配与预测的问题再解决。这使提出人工智能的“统一理论”成为可能。HTM算法是建立在大量解剖学和神经科学的基础上的。HTM算法认为人类之所以具有智能，新大脑皮层是不可缺少的必要条件，并且由其承担高级脑活动。我们的大脑的运行机制是将接受到的各种模式与记忆中模式进行匹配，并对下一刻将会接收到的信息作出预测及反应，如此循环往复。这正是其时效性(Temporal)的体现。<br>
HTM算法表面上与神经网络算法有相似之处，其实质是完全不同的。这就好比一般电路与门电路的区别。将模拟“神经元”按照新大脑皮层的结构连接之后就会产生与一般神经网路完全不同的效果。一般的神经网络注重前馈，而HTM算法更注重信息的双向交流，这也是由于神经解剖学发现反馈突触数量不亚于前馈的原因。而反馈并不能得到大多数人的重视。</p>
<p>HTM算法也是一种拥有记忆性和可学习性的算法。它相对于其他学习算法更注重对神经网络的训练而不是架构。HTM算法认为只要经过合理的训练，该算法适用于解决大多数人工智能问题。对于不同的任务目标实验者需要将数据先空间化和时间化再对HTM网络进行训练即可。</p>
<p>其实HTM算法是源于生物学理论，意味着它来自神经解剖学和神经生理学，是解释生物学的新皮质如何运作的。我们有时说HTM 理论是“约束于生物学”，和“启发于生物学”相反，后者是机器学习领域常用的说法。HTM 理论必须与新皮质的生物学细节相容，并且不能依赖生物组织中不可能实现的原理。比如，考虑锥体细胞，这是新皮质中最常见的神经元类型。锥体细胞有称作树突的树状延伸，通过数千个突触连接。神经学家知道树突是激活的处理单元，通过突触的交流是动态的、内在随机的过程。锥体细胞是新皮质的核心信息处理元件，突触是记忆的基础。所以，为了理解新皮质是如何运作的，我们需要一种适应神经元和突触的本质特征的理论。人工神经网络（ANN）一般是对没有树突并且只有很少的高度精确的突触和特征的神经元建模，真实的神经元并非如此。这种人工神经元与生物神经元不相容，因此不可能发展成与脑的运作原理相同的网络。这个评论不是说 ANN 没用，只是它们的运作原理和生物神经网络的不同。你将会看到，HTM 理论解释了为什么神经元有数千个突触和激活树突。我们认为，这些和很多其他生物学特征对智能系统来说是必不可少、无法忽视的。</p>
<p>HTM的原理：稀疏分布表征理论,运用的表征方法称作稀疏分布表征，简称 SDR。SDR 是包含数千比特的向量。在任何时候，一小部分比特置 1，其余的置 0。HTM 理论会解释为什么在 SDR 中，总是有一小部分零散的比特置 1，以及这些置 1 的比特的比重必须小，通常小于 2%。SDR 中的比特对应着新皮质中的神经元。稀疏分布表征有一些意义重大并且不可思议的特性。为了方便比较，考虑在可编程计算机中的表征方法。单词存储在计算机中的含义不是单词内在的。如果给你看计算机内存中某处的 64 比特，你并不能知道它表示什么。在程序运行的某一时刻，这些比特可能是表示一个意思，在另一时刻，可能又表示别的意思。无论是哪种情况，只能依赖物理地址，而非比特本身。对于 SDR，表征的比特编码了自身的语义特征，即表达和含义是一致的。如果两个 SDR 有相同的比特位置 1，它们就共有某种语义特征。如果两个 SDR 有越多相同的比特位置 1，它们在语义上就越相似。SDR 解释了人脑是如何做语义归纳的，它正是这种表征方法的内在特性。另一个展示稀疏表征的特有能力的例子是，一组神经元可以同时激活多种表征并且不引起混乱。这就好比在计算机内存中的某处，不仅仅只能容纳一个值，而是同时容纳二十个值，并且不引起混乱。我们称这种独一无二的特性为“联合性”。在 HTM 理论中它被用来同时做多个预测。稀疏分布表征的运用是 HTM 理论的关键所在。我们认为，所有真正的智能系统必须要运用稀疏分布表征。为了轻松理解 HTM 理论，你需要培养一种面向 SDR 的数学特性和表征特性的直觉。</p>
<p>每个 HTM 系统都需要“感知器官”，我们称之为“编码器”。每种编码器负责把某类数据（数字、事件、温度、图像或者 GPS 坐标）转化成一个稀疏分布表征，以便 HTM 学习算法进一步处理。每种编码器都是为明确的数据类型专门设计的，往往有很多途径可以把输入信息转化为 SDR，就如同哺乳动物们的视网膜构造五花八门。只要感知信息被编码成适当的 SDR，HTM 学习算法就可以处理了。</p>
<p>基于 HTM 理论的机器智能令人兴奋的一个方面是，我们可以创造一些生物学上不存在的具有类似功能的编码器。比如，我们可以创造接收 GPS 坐标的编码器并把数据转化成 SDR。这种编码器允许 HTM 系统直接通过空间位置检测运动。HTM 系统可以进一步对运动分类，预测未来的位置，侦查运动中的异常。能够运用非人类感官的能力启发了智能机器可能的发展方向。智能机器不仅仅在人类事务上表现出优越性，还将处理那些人类难以感知或者无能为力的问题。</p>
<p>每个 HTM 系统都需要“感知器官”，我们称之为“编码器”。每种编码器负责把某类数据（数字、事件、温度、图像或者 GPS 坐标）转化成一个稀疏分布表征，以便 HTM 学习算法进一步处理。每种编码器都是为明确的数据类型专门设计的，往往有很多途径可以把输入信息转化为 SDR，就如同哺乳动物们的视网膜构造五花八门。只要感知信息被编码成适当的 SDR，HTM 学习算法就可以处理了。</p>
<p>基于 HTM 理论的机器智能令人兴奋的一个方面是，我们可以创造一些生物学上不存在的具有类似功能的编码器。比如，我们可以创造接收 GPS 坐标的编码器并把数据转化成 SDR。这种编码器允许 HTM 系统直接通过空间位置检测运动。HTM 系统可以进一步对运动分类，预测未来的位置，侦查运动中的异常。能够运用非人类感官的能力启发了智能机器可能的发展方向。智能机器不仅仅在人类事务上表现出优越性，还将处理那些人类难以感知或者无能为力的问题。</p>
<p align="center">
<img width="500" align="center" src="/img/images/372.jpg" />
</p>
<p align="center">HTM 算法在图像识别中的应用</p>
<p>因而HTM算法应用与传统的算法应用是不同的。传统上每一个程序解决一个具体问题例如处理电邮或是分析数据。与此相反，HTM算法可以被训练来解决不领域不同类型的问题。一个HTM系统，相比之下，是在训练，而不是编程。 HTM通过感知的数据流以人类认知世界的方式来学习世界中的对象。通过模拟人类大脑的模式发现机制，HTM提供一种在杂乱 、大型、现实世界的数据集中进行模式识别和预测的方法。其应用领域很广，比如图像和声音识别，复杂系统的故障预测，网络点击预测，欺诈检测系统预测，文本的语义分析等 。HTM底层的学习算法并不局限于特定的应用领域。</p>
<h3 id="应用示例-7">应用示例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> carver.htm.config <span class="keyword">import</span> config</span><br><span class="line"><span class="keyword">from</span> carver.htm.synapse <span class="keyword">import</span> CONNECTED_CUTOFF</span><br><span class="line"><span class="keyword">from</span> carver.htm.segment <span class="keyword">import</span> Segment</span><br><span class="line"></span><br><span class="line"><span class="comment">#one column out of n should fire:</span></span><br><span class="line">desiredLocalActivity = config.getint(<span class="string">&#x27;constants&#x27;</span>,<span class="string">&#x27;desiredLocalActivity&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pool_spatial</span>(<span class="params">htm</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    A couple notable deviations:</span></span><br><span class="line"><span class="string">    *column overlap boost and cutoff are swapped from pseudocode, details inline</span></span><br><span class="line"><span class="string">        see _spatial_overlap</span></span><br><span class="line"><span class="string">    *time and inputData removed from code - used a data producer model, linked to htm </span></span><br><span class="line"><span class="string">    *getBestMatchingSegment now takes an argument for whether it is a nextStep segment or a sequence one</span></span><br><span class="line"><span class="string">        inspired by binarybarry on http://www.numenta.com/phpBB2/viewtopic.php?t=1403</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    _spatial_overlap(htm)</span><br><span class="line">    </span><br><span class="line">    activeColumns = _spatial_inhibition(htm)</span><br><span class="line">            </span><br><span class="line">    inhibitionRadius = _spatial_learning(htm, activeColumns)</span><br><span class="line">    </span><br><span class="line">    htm.inhibitionRadius = inhibitionRadius</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pool_temporal</span>(<span class="params">htm, updateSegments, learning=<span class="literal">True</span></span>):</span><br><span class="line">    updateSegments = _temporal_phase1(htm, learning, updateSegments)</span><br><span class="line">            </span><br><span class="line">    updateSegments = _temporal_phase2(htm, updateSegments, learning)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> learning:</span><br><span class="line">        updateSegments = _temporal_phase3(htm, updateSegments)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> updateSegments</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_spatial_overlap</span>(<span class="params">htm</span>):</span><br><span class="line">    <span class="string">&#x27;Overlap, p 35&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> htm.columns:</span><br><span class="line">        col.overlap = <span class="built_in">len</span>(col.old_firing_synapses())</span><br><span class="line">            </span><br><span class="line">        <span class="comment">#The paper has conflicting information in the following lines.</span></span><br><span class="line">        <span class="comment">#The text implies boost before cutoff, the code: cutoff then boost. I </span></span><br><span class="line">        <span class="comment">#chose boost first because I think the boost should help a column </span></span><br><span class="line">        <span class="comment">#overcome the cutoff.</span></span><br><span class="line">        col.overlap *= col.boost</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> col.overlap &lt; col.MIN_OVERLAP:</span><br><span class="line">            col.overlap = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_spatial_inhibition</span>(<span class="params">htm</span>):</span><br><span class="line">    <span class="string">&#x27;Inhibition, p 35&#x27;</span></span><br><span class="line">    activeColumns = []</span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> htm.columns:</span><br><span class="line">        kthNeighbor = col.kth_neighbor(desiredLocalActivity)</span><br><span class="line">        minLocalActivity = kthNeighbor.overlap</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> col.overlap &gt; <span class="number">0</span> <span class="keyword">and</span> col.overlap &gt;= minLocalActivity:</span><br><span class="line">            activeColumns.append(col)</span><br><span class="line">            col.active = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            col.active = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> activeColumns</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_spatial_learning</span>(<span class="params">htm, activeColumns</span>):</span><br><span class="line">    <span class="string">&#x27;Learning, p 36&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> activeColumns:</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> col.synapses:</span><br><span class="line">            <span class="keyword">if</span> s.was_firing():</span><br><span class="line">                s.permanence_increment()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s.permanence_decrement()</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> htm.columns:</span><br><span class="line">        col.dutyCycleMin = <span class="number">0.01</span> * col.neighbor_duty_cycle_max()</span><br><span class="line">        col.dutyCycleActive = col.get_duty_cycle_active()</span><br><span class="line">        col.boost = col.next_boost()</span><br><span class="line">        </span><br><span class="line">        col.dutyCycleOverlap = col.get_duty_cycle_overlap()</span><br><span class="line">        <span class="keyword">if</span> col.dutyCycleOverlap &lt; col.dutyCycleMin:</span><br><span class="line">            col.increase_permanences(<span class="number">0.1</span> * CONNECTED_CUTOFF)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> htm.average_receptive_field_size()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_temporal_phase1</span>(<span class="params">htm, learning, updateSegments</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Phase 1, p40</span></span><br><span class="line"><span class="string">    @param htm: htm network object</span></span><br><span class="line"><span class="string">    @param learning: boolean describing whether the network is learning now</span></span><br><span class="line"><span class="string">    @param updateSegments: hash from cell to a list of segments to update when cell becomes active</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> htm.columns_active():</span><br><span class="line">        buPredicted = <span class="literal">False</span></span><br><span class="line">        learningCellChosen = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> cell <span class="keyword">in</span> col.cells:</span><br><span class="line">            <span class="keyword">if</span> cell.predicted:</span><br><span class="line">                seg = cell.findSegmentWasActive(nextStep=<span class="literal">True</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment">#distal dendrite segments = sequence memory</span></span><br><span class="line">                <span class="keyword">if</span> seg <span class="keyword">and</span> seg.distal:</span><br><span class="line">                    buPredicted = <span class="literal">True</span></span><br><span class="line">                    cell.active = <span class="literal">True</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">#Learning Phase 1, p 41</span></span><br><span class="line">                    <span class="keyword">if</span> learning <span class="keyword">and</span> seg.wasActiveFromLearningCells:</span><br><span class="line">                        learningCellChosen = <span class="literal">True</span></span><br><span class="line">                        cell.learning = <span class="literal">True</span></span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> buPredicted:</span><br><span class="line">            <span class="keyword">for</span> cell <span class="keyword">in</span> col.cells:</span><br><span class="line">                cell.active = <span class="literal">True</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment">#Learning Phase 1, p41</span></span><br><span class="line">        <span class="keyword">if</span> learning <span class="keyword">and</span> <span class="keyword">not</span> learningCellChosen:</span><br><span class="line">            cell, seg = col.bestCell(nextStep=<span class="literal">True</span>)</span><br><span class="line">            cell.learning = <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> seg <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                seg = cell.create_segment(htm, nextStep=<span class="literal">True</span>)</span><br><span class="line">                </span><br><span class="line">            updateSegments.add(cell, seg, timeDelta=-<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> updateSegments</span><br><span class="line">            </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_temporal_phase2</span>(<span class="params">htm, updateSegments, learning</span>):</span><br><span class="line">    <span class="string">&#x27;Phase 2, p40&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> cell <span class="keyword">in</span> htm.cells:</span><br><span class="line">        <span class="keyword">for</span> seg <span class="keyword">in</span> cell.segments:</span><br><span class="line">            <span class="keyword">if</span> seg.active:</span><br><span class="line">                cell.predicting = <span class="literal">True</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> learning:</span><br><span class="line">                    updateSegments.add(cell, seg, timeDelta=<span class="number">0</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="comment">#for each cell, grab the best segment. right now, this does not prevent </span></span><br><span class="line">        <span class="comment">#duplication of learning on the best segment</span></span><br><span class="line">        <span class="keyword">if</span> learning <span class="keyword">and</span> cell.predicting:</span><br><span class="line">            bestSeg = cell.bestMatchingSegment(nextStep=<span class="literal">False</span>)</span><br><span class="line">            <span class="keyword">if</span> bestSeg <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                bestSeg = cell.create_segment(htm, nextStep=<span class="literal">False</span>)</span><br><span class="line">                </span><br><span class="line">            bestSeg.round_out_synapses(htm)</span><br><span class="line">            </span><br><span class="line">            updateSegments.add(cell, bestSeg, timeDelta=-<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> updateSegments</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_temporal_phase3</span>(<span class="params">htm, updateSegments</span>):</span><br><span class="line">    <span class="string">&#x27;Phase 3, p42&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> cell <span class="keyword">in</span> htm.cells:</span><br><span class="line">        <span class="keyword">if</span> cell.learning:</span><br><span class="line">            <span class="keyword">for</span> synapseStates <span class="keyword">in</span> updateSegments[cell]:</span><br><span class="line">                Segment.adapt_up(synapseStates)</span><br><span class="line">            updateSegments.reset(cell)</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> cell.predicting <span class="keyword">and</span> cell.predicted:</span><br><span class="line">            <span class="keyword">for</span> synapseStates <span class="keyword">in</span> updateSegments[cell]:</span><br><span class="line">                Segment.adapt_down(synapseStates)</span><br><span class="line">            updateSegments.reset(cell)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> updateSegments</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>深度学习算法</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>深度信念网络</title>
    <url>/posts/8e740f68.html</url>
    <content><![CDATA[<h2 id="深度信念网络-Deep-Belief-Machines">深度信念网络(Deep Belief Machines)</h2>
<p>深度信念网络 (Deep Belief Network, DBN) 由 Geoffrey Hinton 在 2006 年提出。它是一种生成模型，通过训练其神经元间的权重，我们可以让整个神经网络按照最大概率来生成训练数据。我们不仅可以使用 DBN 识别特征、分类数据，还可以用它来生成数据。深度信念网络(Deep Belief Network, DBN)由多层神经元构成，这些神经元又分为显性神经元和隐性神经元（以下简称显元和隐元）。显元用于接受输入，隐元用于提取特征。因此隐元也有个别名，叫特征检测器 (feature detectors)。最顶上的两层间的连接是无向的，组成联合内存 (associative memory)。较低的其他层之间有连接上下的有向连接。最底层代表了数据向量 (data vectors)，每一个神经元代表数据向量的一维。</p>
<p>深度信念网络(Deep Belief Network, DBN)组成元件是受限玻尔兹曼机 (Restricted Boltzmann Machines, RBM)。训练 DBN 的过程是一层一层地进行的。在每一层中，用数据向量来推断隐层，再把这一隐层当作下一层 (高一层) 的数据向量。</p>
<p align="center">
<img width="400" align="center" src="/img/images/357.jpg" />
</p>
<p>如上图所示用两个限制玻尔兹曼机堆叠起来，构成深度信念网络(Deep Belief Nets, 简称DBN)。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>利用输入，生成第一个限制玻尔兹曼机，得到输入的特征。</p>
</li>
<li class="lvl-2">
<p>利用上面得到的输入的特征，生成每二个限制玻尔兹曼机，得到特征的特征。</p>
</li>
<li class="lvl-2">
<p>依次循环，可以得到多个限制玻尔兹曼机。</p>
</li>
<li class="lvl-2">
<p>把得到次序到多个限制玻尔兹曼机堆叠起来，构成一个DBN。</p>
</li>
<li class="lvl-2">
<p>以上是一种贪婪的训练堆叠方式，对网络的预训练非常好。</p>
</li>
</ul>
<p>这样得到的效果跟autoencoder的堆叠一致。</p>
<p>wake-sleep算法：在分类问题中，DBN的最底层可以是已知的label层，如下图:</p>
<p align="center">
<img width="400" align="center" src="/img/images/358.jpg" />
</p>
<p>上图是MNIST数字识别的一个任务，输入是28*28的图片，输出是0到9的数字。</p>
<p>在经过上面提到的贪婪地堆叠训练后，再加上一层label层进行训练。然后再利用wake-sleep算法进行调优:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>wake: 认知过程，通过外界的特征和向上的权重 (认知权重) 产生每一层的抽象表示 (结点状态) ，并且使用梯度下降修改层间的下行权重 (生成权重) 。自底向上，进行训练</p>
</li>
<li class="lvl-2">
<p>sleep: 生成过程，通过顶层表示 (醒时学得的概念) 和向下权重，生成底层的状态，同时修改层间向上的权重。自项向下，进行训练</p>
</li>
</ul>
<p>在上面的训练完成后，如果对最上的两层进行随机的Gibbs采样，然后再逐渐从顶到底，生成的图像就是0到9中的一个图像。感觉这个跟人回忆、画画、做梦的过程非常像。</p>
<p align="center">
<img width="400" align="center" src="/img/images/359.jpg" />
</p>
由stuff、image、label的构成，是右边这种模式，而非左边那种。所以，一个更好的方式是直接从image，进行非监督还原成stuff，然后再学习stuff与label的关系。这也就是非监督的预训练有效的原因。
<h3 id="应用示例-8">应用示例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> rbm <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dbn</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,sizes = [],learning_rate = <span class="number">0.01</span>,numepochs = <span class="number">1</span></span>):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;dbn init ,sizes:&#x27;</span>,sizes,<span class="string">&#x27;, numepochs:&#x27;</span>,numepochs</span><br><span class="line">        self.sizes = sizes</span><br><span class="line">        self.rbms = []</span><br><span class="line">        self.learning_rate = learning_rate</span><br><span class="line">        self.numepochs = numepochs</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.sizes)-<span class="number">1</span>):</span><br><span class="line">            self.rbms.append(rbm(sizes[i:i+<span class="number">2</span>],self.learning_rate,self.numepochs))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self,X</span>):</span><br><span class="line">        <span class="comment">#for i in range(self.numepochs):</span></span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.sizes)-<span class="number">1</span>):</span><br><span class="line">            self.rbms[j].train(X)</span><br><span class="line">            X = self.rbms[j].v2h(X)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">v2h</span>(<span class="params">self,X</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.sizes)-<span class="number">1</span>):</span><br><span class="line">            X = self.rbms[j].v2h(X)</span><br><span class="line">        <span class="keyword">return</span> X</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">h2v</span>(<span class="params">self,X</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.sizes)-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> j == <span class="built_in">len</span>(self.sizes)-<span class="number">2</span>:</span><br><span class="line">                X = self.rbms[<span class="built_in">len</span>(self.sizes)-j-<span class="number">2</span>].h2v(X,<span class="literal">False</span>);</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                X = self.rbms[<span class="built_in">len</span>(self.sizes)-j-<span class="number">2</span>].h2v(X)</span><br><span class="line">        <span class="keyword">return</span> X</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="keyword">return</span> self.h2v(self.v2h(X))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>深度学习算法</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>深度卷积神经网络</title>
    <url>/posts/1b1bc4df.html</url>
    <content><![CDATA[<h2 id="深度卷积神经网络-Deep-Convolutional-Neural-Networks">深度卷积神经网络(Deep Convolutional Neural Networks)</h2>
<p>深度卷积神经网络（DCNN）在特征识别相关任务中取得的效果，远比传统方法好。因此，DCNN常用于图像识别、语音识别等。但是，因为深度卷积神经网络结构庞大，一般都会包含几十个神经层，每一层，又有数百至数千个神经元；同时，DCNN任意两层之间神经元的相互影响错综复杂。这两个主要的因素，导致DCNN难以理解、分析。为此，用户很难从失败或成功的例子中学习到如何设计一个好的卷积神经网络。因此，设计一个效果好的神经网络，往往需要依靠大量的尝试。</p>
<p>而卷积神经网络（Convolutional Neural Network,CNN）是一种前馈神经网络，它的人工神经元可以响应一部分覆盖范围内的周围单元，对于大型图像处理有出色表现。 它包括卷积层(convolutional layer)和池化层(pooling layer)。</p>
<p>卷积神经网络是近年发展起来，并引起广泛重视的一种高效识别方法。20世纪60年代，Hubel和Wiesel在研究猫脑皮层中用于局部敏感和方向选择的神经元时发现其独特的网络结构可以有效地降低反馈神经网络的复杂性，继而提出了卷积神经网络（Convolutional Neural Networks-简称CNN）。现在，CNN已经成为众多科学领域的研究热点之一，特别是在模式分类领域，由于该网络避免了对图像的复杂前期预处理，可以直接输入原始图像，因而得到了更为广泛的应用。 K.Fukushima在1980年提出的新识别机是卷积神经网络的第一个实现网络。随后，更多的科研工作者对该网络进行了改进。其中，具有代表性的研究成果是Alexander和Taylor提出的“改进认知机”，该方法综合了各种改进方法的优点并避免了耗时的误差反向传播。</p>
<p>卷积神经网络的基本结构包括两层，其一为特征提取层，每个神经元的输入与前一层的局部接受域相连，并提取该局部的特征。一旦该局部特征被提取后，它与其它特征间的位置关系也随之确定下来；其二是特征映射层，网络的每个计算层由多个特征映射组成，每个特征映射是一个平面，平面上所有神经元的权值相等。特征映射结构采用影响函数核小的sigmoid函数作为卷积网络的激活函数，使得特征映射具有位移不变性。此外，由于一个映射面上的神经元共享权值，因而减少了网络自由参数的个数。卷积神经网络中的每一个卷积层都紧跟着一个用来求局部平均与二次提取的计算层，这种特有的两次特征提取结构减小了特征分辨率。</p>
<p>卷积神经网络主要用来识别位移、缩放及其他形式扭曲不变性的二维图形。由于CNN的特征检测层通过训练数据进行学习，所以在使用CNN时，避免了显式的特征抽取，而隐式地从训练数据中进行学习；再者由于同一特征映射面上的神经元权值相同，所以网络可以并行学习，这也是卷积网络相对于神经元彼此相连网络的一大优势。卷积神经网络以其局部权值共享的特殊结构在语音识别和图像处理方面有着独特的优越性，其布局更接近于实际的生物神经网络，权值共享降低了网络的复杂性，特别是多维输入向量的图像可以直接输入网络这一特点避免了特征提取和分类过程中数据重建的复杂度。</p>
<p align="center">
<img width="300" align="center" src="/img/images/1.jpg" />
</p>
<p>一个典型的卷积神经网络包含两个卷积层（convolution layer），两个池化层（pooling layer）和一个全连接层（fully connected layer）。</p>
<p align="center">
<img width="300" align="center" src="/img/images/360.jpg" />
</p>
<p>卷积层，采用各种卷积核对输入图片进行卷积处理，基本卷积过程如图2所示。卷积操作具有平移不变性。因而，能够支持神经元学习到鲁棒性比较高的特征。</p>
<p align="center">
<img width="300" align="center" src="/img/images/361.jpg" />
</p>
池化层的操作，是一种降采样操作。该操作是在一个小区域内，采取一个特定的值作为输出值。比如图3，在每个特定的小区域内，我们选取最大值作为输出值。池化层的操作可以达到一定的空间不变性效果。
<p>卷积神经网络中的激励函数，根据一系列的输入值，神经元之间连接的权值以及激励规则，刺激神经元。</p>
<p>卷积神经网络中的损失函数，在训练阶段，用于评估网络输出结果与实际值的差异。然后用损失函数的值更新每个神经元之间的权重值。卷积神经网络的训练目的就是最小化损失函数值。</p>
<p>深度卷积神经网络在许多模式识别任务上较传统的方法而言已经展示了很大的提升，比如语音识别，图像分类和视频分类。</p>
<h3 id="应用示例-9">应用示例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">&#x27;AGG&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> cifar10</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> (Activation, Conv3D, Dense, Dropout, Flatten,</span><br><span class="line">                          MaxPooling3D)</span><br><span class="line"><span class="keyword">from</span> keras.layers.advanced_activations <span class="keyword">import</span> LeakyReLU</span><br><span class="line"><span class="keyword">from</span> keras.losses <span class="keyword">import</span> categorical_crossentropy</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> Adam</span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> np_utils</span><br><span class="line"><span class="keyword">from</span> keras.utils.vis_utils <span class="keyword">import</span> plot_model</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> videoto3d</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_history</span>(<span class="params">history, result_dir</span>):</span><br><span class="line">    plt.plot(history.history[<span class="string">&#x27;acc&#x27;</span>], marker=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    plt.plot(history.history[<span class="string">&#x27;val_acc&#x27;</span>], marker=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;model accuracy&#x27;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;epoch&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;accuracy&#x27;</span>)</span><br><span class="line">    plt.grid()</span><br><span class="line">    plt.legend([<span class="string">&#x27;acc&#x27;</span>, <span class="string">&#x27;val_acc&#x27;</span>], loc=<span class="string">&#x27;lower right&#x27;</span>)</span><br><span class="line">    plt.savefig(os.path.join(result_dir, <span class="string">&#x27;model_accuracy.png&#x27;</span>))</span><br><span class="line">    plt.close()</span><br><span class="line"></span><br><span class="line">    plt.plot(history.history[<span class="string">&#x27;loss&#x27;</span>], marker=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    plt.plot(history.history[<span class="string">&#x27;val_loss&#x27;</span>], marker=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;model loss&#x27;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;epoch&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;loss&#x27;</span>)</span><br><span class="line">    plt.grid()</span><br><span class="line">    plt.legend([<span class="string">&#x27;loss&#x27;</span>, <span class="string">&#x27;val_loss&#x27;</span>], loc=<span class="string">&#x27;upper right&#x27;</span>)</span><br><span class="line">    plt.savefig(os.path.join(result_dir, <span class="string">&#x27;model_loss.png&#x27;</span>))</span><br><span class="line">    plt.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_history</span>(<span class="params">history, result_dir</span>):</span><br><span class="line">    loss = history.history[<span class="string">&#x27;loss&#x27;</span>]</span><br><span class="line">    acc = history.history[<span class="string">&#x27;acc&#x27;</span>]</span><br><span class="line">    val_loss = history.history[<span class="string">&#x27;val_loss&#x27;</span>]</span><br><span class="line">    val_acc = history.history[<span class="string">&#x27;val_acc&#x27;</span>]</span><br><span class="line">    nb_epoch = <span class="built_in">len</span>(acc)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(result_dir, <span class="string">&#x27;result.txt&#x27;</span>), <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(<span class="string">&#x27;epoch\tloss\tacc\tval_loss\tval_acc\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nb_epoch):</span><br><span class="line">            fp.write(<span class="string">&#x27;&#123;&#125;\t&#123;&#125;\t&#123;&#125;\t&#123;&#125;\t&#123;&#125;\n&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">                i, loss[i], acc[i], val_loss[i], val_acc[i]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loaddata</span>(<span class="params">video_dir, vid3d, nclass, result_dir, color=<span class="literal">False</span>, skip=<span class="literal">True</span></span>):</span><br><span class="line">    files = os.listdir(video_dir)</span><br><span class="line">    X = []</span><br><span class="line">    labels = []</span><br><span class="line">    labellist = []</span><br><span class="line"></span><br><span class="line">    pbar = tqdm(total=<span class="built_in">len</span>(files))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> files:</span><br><span class="line">        pbar.update(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> filename == <span class="string">&#x27;.DS_Store&#x27;</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        name = os.path.join(video_dir, filename)</span><br><span class="line">        label = vid3d.get_UCF_classname(filename)</span><br><span class="line">        <span class="keyword">if</span> label <span class="keyword">not</span> <span class="keyword">in</span> labellist:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(labellist) &gt;= nclass:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            labellist.append(label)</span><br><span class="line">        labels.append(label)</span><br><span class="line">        X.append(vid3d.video3d(name, color=color, skip=skip))</span><br><span class="line"></span><br><span class="line">    pbar.close()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(result_dir, <span class="string">&#x27;classes.txt&#x27;</span>), <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(labellist)):</span><br><span class="line">            fp.write(<span class="string">&#x27;&#123;&#125;\n&#x27;</span>.<span class="built_in">format</span>(labellist[i]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> num, label <span class="keyword">in</span> <span class="built_in">enumerate</span>(labellist):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(labels)):</span><br><span class="line">            <span class="keyword">if</span> label == labels[i]:</span><br><span class="line">                labels[i] = num</span><br><span class="line">    <span class="keyword">if</span> color:</span><br><span class="line">        <span class="keyword">return</span> np.array(X).transpose((<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>)), labels</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> np.array(X).transpose((<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>)), labels</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    parser = argparse.ArgumentParser(</span><br><span class="line">        description=<span class="string">&#x27;simple 3D convolution for action recognition&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--batch&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">128</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--epoch&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">100</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--videos&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;UCF101&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;directory where videos are stored&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--nclass&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">101</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--output&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, required=<span class="literal">True</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--color&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">bool</span>, default=<span class="literal">False</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--skip&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">bool</span>, default=<span class="literal">True</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--depth&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">10</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    img_rows, img_cols, frames = <span class="number">32</span>, <span class="number">32</span>, args.depth</span><br><span class="line">    channel = <span class="number">3</span> <span class="keyword">if</span> args.color <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">    fname_npz = <span class="string">&#x27;dataset_&#123;&#125;_&#123;&#125;_&#123;&#125;.npz&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">        args.nclass, args.depth, args.skip)</span><br><span class="line"></span><br><span class="line">    vid3d = videoto3d.Videoto3D(img_rows, img_cols, frames)</span><br><span class="line">    nb_classes = args.nclass</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(fname_npz):</span><br><span class="line">        loadeddata = np.load(fname_npz)</span><br><span class="line">        X, Y = loadeddata[<span class="string">&quot;X&quot;</span>], loadeddata[<span class="string">&quot;Y&quot;</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x, y = loaddata(args.videos, vid3d, args.nclass,</span><br><span class="line">                        args.output, args.color, args.skip)</span><br><span class="line">        X = x.reshape((x.shape[<span class="number">0</span>], img_rows, img_cols, frames, channel))</span><br><span class="line">        Y = np_utils.to_categorical(y, nb_classes)</span><br><span class="line"></span><br><span class="line">        X = X.astype(<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">        np.savez(fname_npz, X=X, Y=Y)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Saved dataset to dataset.npz.&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;X_shape:&#123;&#125;\nY_shape:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(X.shape, Y.shape))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Define model</span></span><br><span class="line">    model = Sequential()</span><br><span class="line">    model.add(Conv3D(<span class="number">32</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>), input_shape=(</span><br><span class="line">        X.shape[<span class="number">1</span>:]), border_mode=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">    model.add(Activation(<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    model.add(Conv3D(<span class="number">32</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>), border_mode=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">    model.add(Activation(<span class="string">&#x27;softmax&#x27;</span>))</span><br><span class="line">    model.add(MaxPooling3D(pool_size=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>), border_mode=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">    model.add(Dropout(<span class="number">0.25</span>))</span><br><span class="line"></span><br><span class="line">    model.add(Conv3D(<span class="number">64</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>), border_mode=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">    model.add(Activation(<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    model.add(Conv3D(<span class="number">64</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>), border_mode=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">    model.add(Activation(<span class="string">&#x27;softmax&#x27;</span>))</span><br><span class="line">    model.add(MaxPooling3D(pool_size=(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>), border_mode=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">    model.add(Dropout(<span class="number">0.25</span>))</span><br><span class="line"></span><br><span class="line">    model.add(Flatten())</span><br><span class="line">    model.add(Dense(<span class="number">512</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>))</span><br><span class="line">    model.add(Dropout(<span class="number">0.5</span>))</span><br><span class="line">    model.add(Dense(nb_classes, activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    model.<span class="built_in">compile</span>(loss=categorical_crossentropy,</span><br><span class="line">                  optimizer=Adam(), metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">    model.summary()</span><br><span class="line">    plot_model(model, show_shapes=<span class="literal">True</span>,</span><br><span class="line">               to_file=os.path.join(args.output, <span class="string">&#x27;model.png&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    X_train, X_test, Y_train, Y_test = train_test_split(</span><br><span class="line">        X, Y, test_size=<span class="number">0.2</span>, random_state=<span class="number">43</span>)</span><br><span class="line"></span><br><span class="line">    history = model.fit(X_train, Y_train, validation_data=(X_test, Y_test), batch_size=args.batch,</span><br><span class="line">                        epochs=args.epoch, verbose=<span class="number">1</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line">    model.evaluate(X_test, Y_test, verbose=<span class="number">0</span>)</span><br><span class="line">    model_json = model.to_json()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(args.output):</span><br><span class="line">        os.makedirs(args.output)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(args.output, <span class="string">&#x27;ucf101_3dcnnmodel.json&#x27;</span>), <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> json_file:</span><br><span class="line">        json_file.write(model_json)</span><br><span class="line">    model.save_weights(os.path.join(args.output, <span class="string">&#x27;ucf101_3dcnnmodel.hd5&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    loss, acc = model.evaluate(X_test, Y_test, verbose=<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Test loss:&#x27;</span>, loss)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Test accuracy:&#x27;</span>, acc)</span><br><span class="line">    plot_history(history, args.output)</span><br><span class="line">    save_history(history, args.output)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>深度学习算法</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习简介</title>
    <url>/posts/ab156def.html</url>
    <content><![CDATA[<h2 id="深度学习-Deep-Learning">深度学习(Deep Learning)</h2>
<p>深度学习的概念源于人工神经网络的研究。含多隐层的多层感知器就是一种深度学习结构。深度学习通过组合低层特征形成更加抽象的高层表示属性类别或特征，以发现数据的分布式特征表示。</p>
<p>深度学习的概念由Hinton等人于2006年提出。基于深度置信网络(DBN)提出非监督贪心逐层训练算法，为解决深层结构相关的优化难题带来希望，随后提出多层自动编码器深层结构。此外Lecun等人提出的卷积神经网络是第一个真正多层结构学习算法，它利用空间相对关系减少参数数目以提高训练性能。</p>
<p>深度学习是机器学习研究中的一个新的领域，其动机在于建立、模拟人脑进行分析学习的神经网络，它模仿人脑的机制来解释数据，例如图像，声音和文本。深度学习是无监督学习的一种。</p>
<p>深度学习的概念源于人工神经网络的研究。含多隐层的多层感知器就是一种深度学习结构。深度学习通过组合低层特征形成更加抽象的高层表示属性类别或特征，以发现数据的分布式特征表示。</p>
<p>Deep learning本身算是machine learning的一个分支，简单可以理解为neural network的发展。大约二三十年前，neural network曾经是ML领域特别火热的一个方向，但是后来确慢慢淡出了，原因包括以下几个方面：</p>
<p>(1)比较容易过拟合，参数比较难tune，而且需要不少trick；</p>
<p>(2)训练速度比较慢，在层次比较少（小于等于3）的情况下效果并不比其它方法更优；</p>
<p>所以中间有大约20多年的时间，神经网络被关注很少，这段时间基本上是SVM和boosting算法的天下。但是，一个痴心的老先生Hinton，他坚持了下来，并最终（和其它人一起Bengio、Yann.lecun等）提成了一个实际可行的deep learning框架。</p>
<p>Deep learning与传统的神经网络之间有相同的地方也有很多不同。</p>
<p>二者的相同在于deep learning采用了神经网络相似的分层结构，系统由包括输入层、隐层（多层）、输出层组成的多层网络，只有相邻层节点之间有连接，同一层以及跨层节点之间相互无连接，每一层可以看作是一个logistic regression模型；这种分层结构，是比较接近人类大脑的结构的。</p>
<p>深度学习(Deep Learning)的应用算法有：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>深度信念网络(Deep Belief Machines)</p>
</li>
<li class="lvl-2">
<p>深度卷积神经网络(Deep Convolutional Neural Networks)</p>
</li>
<li class="lvl-2">
<p>深度递归神经网络(Deep Recurrent Neural Networks)</p>
</li>
<li class="lvl-2">
<p>分层时间记忆(Hierarchical Temporal Memory)</p>
</li>
<li class="lvl-2">
<p>深度玻尔兹曼机(Deep Boltzmann Machine)</p>
</li>
<li class="lvl-2">
<p>堆叠自动编码器(Stacked Boltzmann Machine)</p>
</li>
<li class="lvl-2">
<p>生成式对抗网络(Generative Adversarial Networks)</p>
</li>
</ul>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>深度学习算法</category>
      </categories>
  </entry>
  <entry>
    <title>深度递归神经网络</title>
    <url>/posts/246c629b.html</url>
    <content><![CDATA[<h2 id="深度递归神经网络-Deep-Recurrent-Neural-Networks">深度递归神经网络(Deep Recurrent Neural Networks)</h2>
<p>递归神经网络（RNN）是两种人工神经网络的总称。一种是时间递归神经网络（Recurrent Neural Networks,RNN），又名循环神经网络，另一种是结构递归神经网络（recursive neural network）。时间递归神经网络的神经元间连接构成矩阵，而结构递归神经网络利用相似的神经网络结构递归构造更为复杂的深度网络。RNN一般指代时间递归神经网络。单纯递归神经网络因为无法处理随着递归，权重指数级爆炸或消失的问题（Vanishing gradient problem），难以捕捉长期时间关联；而结合不同的LSTM可以很好解决这个问题。</p>
<p>时间递归神经网络可以描述动态时间行为，因为和前馈神经网络（feedforward neural network）接受较特定结构的输入不同，RNN将状态在自身网络中循环传递，因此可以接受更广泛的时间序列结构输入。手写识别是最早成功利用RNN的研究结果</p>
<p>循环神经网络不同于传统的FNNs(Feed-forward Neural Networks，前向反馈神经网络)，循环神经网络引入了定向循环，能够处理那些输入之间前后关联的问题。</p>
<p align="center">
<img width="500" align="center" src="/img/images/362.jpg" />
</p>
<p>循环神经网络的目的是用来处理序列数据的问题。通常在传统的神经网络模型中，是从输入层到隐含层再到输出层，层与层之间是全连接的，每层之间的节点是无连接的。但是这种普通的神经网络对于很多问题却是无法解决的。比如你需要要预测一个句子的下一个单词是什么，一般需要用到前面的单词，因为一个句子中前后单词并不是独立的。RNNs之所以称为循环神经网路，即一个序列当前的输出与前面的输出也有关。对应的表现形式为网络会对前面的信息进行记忆并应用于当前输出的计算中，即隐藏层之间的节点不再无连接而是有连接的，并且隐藏层的输入不仅包括输入层的输出还包括上一时刻隐藏层的输出。理论上，RNNs能够对任何长度的序列数据进行处理。</p>
<p align="center">
<img width="500" align="center" src="/img/images/363.jpg" />
</p>
<p align="center">
<img width="500" align="center" src="/img/images/364.jpg" />
</p>
<p align="center">循环神经网络进行展开成一个全神经网络的过程</p>
<p>时间递归神经网络包含输入单元(Input units)，输入集标记为，而输出单元(Output units)的输出集则被标记为。RNNs还包含隐藏单元(Hidden units)，我们将其输出集标记为，这些隐藏单元完成了最为主要的工作。你会发现，在图中：有一条单向流动的信息流是从输入单元到达隐藏单元的，与此同时另一条单向流动的信息流从隐藏单元到达输出单元。在某些情况下，RNNs会打破后者的限制，引导信息从输出单元返回隐藏单元，这些被称为“Back Projections”，并且隐藏层的输入还包括上一隐藏层的状态，即隐藏层内的节点可以自连也可以互连。</p>
<p>在深度递归神经网络中，它的主要作用是做什么呢？</p>
<p>时间递归神经网络已经被在实践中证明对NLP是非常成功的。如词向量表达、语句合法性检查、词性标注、机器翻译、图像描述生成等。在时间递归神经网络中，目前使用最广泛最成功的模型便是LSTMs(Long Short-Term Memory，长短时记忆模型)模型，该模型通常比vanilla RNNs能够更好地对长短时依赖进行表达，该模型相对于一般的RNNs，只是在隐藏层做了改变。</p>
<p>那么我们应该怎么训练时间递归神经网络呢？</p>
<p>对于递归神经网络的训练和对传统的人工神经网络训练一样。同样使用BP误差反向传播算法，不过这里有点区别。如果将RNNs进行网络展开，那么参数是共享的，而传统神经网络不是这样的。所以使用梯度下降算法中，每一步的输出不仅依赖当前步的网络，而且还依赖前面操作的网络的状态。该学习算法称为Backpropagation Through Time (BPTT).这里我们需要了解到的是，在vanilla RNNs训练中，BPTT无法解决长时依赖问题(即当前的输出与前面很长的一段序列有关，一般超过十步就无能为力了)，因为BPTT会带来所谓的梯度消失或梯度爆炸问题(the vanishing/exploding gradient problem)。当然，有很多方法去解决这个问题，如LSTMs便是专门应对这种问题的。</p>
<p>接下来我们需要对RNNs进行扩展和模型改进.</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>第一种:Simple RNNs(SRNs)</p>
</li>
</ul>
<p>SRNs是RNNs的一种特例，它是一个由三层网络组成的，并且在隐藏层增加了上下文单元，下图中的便是隐藏层，便是上下文单元。上下文单元节点与隐藏层中的节点的连接是固定的，并且权值也是固定的(值是多少)，其实是一个上下文节点与隐藏层节点一一对应，并且值是确定的。在每一步中，使用标准的前向反馈进行传播，然后使用学习算法进行学习。上下文每一个节点保存其连接的隐藏层节点的上一步的输出，即保存上文，并作用于当前步对应的隐藏层节点的状态，即隐藏层的输入由输入层的输出与上一步的自己的状态所决定的。因此SRNs能够解决标准的多层感知机(MLP)无法解决的对序列数据进行预测的任务。</p>
<p align="center">
<img width="300" align="center" src="/img/images/365.jpg" />
</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>第二种:Bidirectional RNNs</p>
</li>
</ul>
<p>Bidirectional RNNs双向网络改进之处，假设当前的输出(第步的输出)不仅仅与前面的序列有关，并且还与后面的序列有关。例如：预测一个语句中缺失的词语那么就需要根据上下文来进行预测。Bidirectional RNNs是一个相对较简单的RNNs，是由两个RNNs上下叠加在一起组成的。输出由这两个RNNs的隐藏层的状态决定的。</p>
<p align="center">
<img width="300" align="center" src="/img/images/366.jpg" />
</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>第三种: Deep(Bidirectional)RNNs</p>
</li>
</ul>
<p>Deep(Bidirectional)RNNs与Bidirectional RNNs相似，只是对于每一步的输入有多层网络。该网络便有更强大的表达与学习能力，但是复杂性也提高了，同时需要更多的训练数据。</p>
<p align="center">
<img width="300" align="center" src="/img/images/367.jpg" />
</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>第四种:Echo State Networks</p>
</li>
</ul>
<p>ESNs(回声状态网络)也是一种RNNs，但是它与传统的RNNs相差很大。回声状态网络具有三个特点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>它的核心结构时一个随机生成、且保持不变的储备池(Reservoir)，储备池是大规模的、随机生成的、稀疏连接(SD通常保持1%～5%，SD表示储备池中互相连接的神经元占总的神经元个数N的比例)的循环结构；</p>
</li>
<li class="lvl-2">
<p>它的储备池到输出层的权值矩阵是唯一需要调整的部分；</p>
</li>
<li class="lvl-2">
<p>通过简单的线性回归就可完成网络的训练。</p>
</li>
</ul>
<p>回声状态网络是一种特殊类型的循环神经网络，其基本思想是：使用大规模随机连接的循环网络取代经典神经网络中的中间层，从而简化网络的训练过程。因此ESNs的关键是中间的储备池。网络中的参数包括：为储备池中节点的连接权值矩阵，为输入层到储备池之间的连接权值矩阵，表明储备池中的神经元之间是连接的，为输出层到储备池之间的反馈连接权值矩阵，表明储备池会有输出层来的反馈，为输入层、储备池、输出层到输出层的连接权值矩阵，表明输出层不仅与储备池连接，还与输入层和自己连接。表示输出层的偏置项。</p>
<p>对于ESNs，关键是储备池的四个参数，如储备池内部连接权谱半径SR(，只有SR &lt;1时，ESNs才能具有回声状态属性)、储备池规模N(即储备池中神经元的个数)、储备池输入单元尺度IS(IS为储备池的输入信号连接到储备池内部神经元之前需要相乘的一个尺度因子)、储备池稀疏程度SD(即为储备池中互相连接的神经元个数占储备池神经元总个数的比例)。对于IS，如果需要处理的任务的非线性越强，那么输入单元尺度越大。该原则的本质就是通过输入单元尺度IS，将输入变换到神经元激活函数相应的范围(神经元激活函数的不同输入范围，其非线性程度不同)。</p>
<p align="center">
<img width="300" align="center" src="/img/images/368.jpg" />
</p>
<p align="center">
<img width="300" align="center" src="/img/images/369.jpg" />
</p>
<p align="center">
<img width="300" align="center" src="/img/images/370.jpg" />
</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>第五种:Gated Recurrent Unit Recurrent Neural Networks</p>
</li>
</ul>
<p>GRUs也是一般的RNNs的改良版本，主要是体现在两个方面。一是，序列中不同的位置处的单词(已单词举例)对当前的隐藏层的状态的影响不同，越前面的影响越小，即每个前面状态对当前的影响进行了距离加权，距离越远，权值越小。二是，在产生误差error时，误差可能是由某一个或者几个单词而引发的，所以应当仅仅对对应的单词weight进行更新。GRUs的结构如下图所示。GRUs首先根据当前输入单词向量word vector已经前一个隐藏层的状态hidden state计算出update gate和reset gate。再根据reset gate、当前word vector以及前一个hidden state计算新的记忆单元内容(new memory content)。当reset gate为1的时候，new memory content忽略之前的所有memory content，最终的memory是之前的hidden state与new memory content的结合。</p>
 <p align="center">
<img width="300" align="center" src="/img/images/371.jpg" />
</p>
<h3 id="应用示例-10">应用示例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> cnn_model <span class="keyword">import</span> TCNNConfig, TextCNN</span><br><span class="line"><span class="keyword">from</span> data.cnews_loader <span class="keyword">import</span> read_vocab, read_category, batch_iter, process_file, build_vocab</span><br><span class="line"></span><br><span class="line">base_dir = <span class="string">&#x27;data/cnews&#x27;</span></span><br><span class="line">train_dir = os.path.join(base_dir, <span class="string">&#x27;cnews.train.txt&#x27;</span>)</span><br><span class="line">test_dir = os.path.join(base_dir, <span class="string">&#x27;cnews.test.txt&#x27;</span>)</span><br><span class="line">val_dir = os.path.join(base_dir, <span class="string">&#x27;cnews.val.txt&#x27;</span>)</span><br><span class="line">vocab_dir = os.path.join(base_dir, <span class="string">&#x27;cnews.vocab.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">save_dir = <span class="string">&#x27;checkpoints/textcnn&#x27;</span></span><br><span class="line">save_path = os.path.join(save_dir, <span class="string">&#x27;best_validation&#x27;</span>)  <span class="comment"># 最佳验证结果保存路径</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_time_dif</span>(<span class="params">start_time</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取已使用时间&quot;&quot;&quot;</span></span><br><span class="line">    end_time = time.time()</span><br><span class="line">    time_dif = end_time - start_time</span><br><span class="line">    <span class="keyword">return</span> timedelta(seconds=<span class="built_in">int</span>(<span class="built_in">round</span>(time_dif)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">feed_data</span>(<span class="params">x_batch, y_batch, keep_prob</span>):</span><br><span class="line">    feed_dict = &#123;</span><br><span class="line">        model.input_x: x_batch,</span><br><span class="line">        model.input_y: y_batch,</span><br><span class="line">        model.keep_prob: keep_prob</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> feed_dict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate</span>(<span class="params">sess, x_, y_</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;评估在某一数据上的准确率和损失&quot;&quot;&quot;</span></span><br><span class="line">    data_len = <span class="built_in">len</span>(x_)</span><br><span class="line">    batch_eval = batch_iter(x_, y_, <span class="number">128</span>)</span><br><span class="line">    total_loss = <span class="number">0.0</span></span><br><span class="line">    total_acc = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> x_batch, y_batch <span class="keyword">in</span> batch_eval:</span><br><span class="line">        batch_len = <span class="built_in">len</span>(x_batch)</span><br><span class="line">        feed_dict = feed_data(x_batch, y_batch, <span class="number">1.0</span>)</span><br><span class="line">        loss, acc = sess.run([model.loss, model.acc], feed_dict=feed_dict)</span><br><span class="line">        total_loss += loss * batch_len</span><br><span class="line">        total_acc += acc * batch_len</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total_loss / data_len, total_acc / data_len</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Configuring TensorBoard and Saver...&quot;</span>)</span><br><span class="line">    <span class="comment"># 配置 Tensorboard，重新训练时，请将tensorboard文件夹删除，不然图会覆盖</span></span><br><span class="line">    tensorboard_dir = <span class="string">&#x27;tensorboard/textcnn&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(tensorboard_dir):</span><br><span class="line">        os.makedirs(tensorboard_dir)</span><br><span class="line"></span><br><span class="line">    tf.summary.scalar(<span class="string">&quot;loss&quot;</span>, model.loss)</span><br><span class="line">    tf.summary.scalar(<span class="string">&quot;accuracy&quot;</span>, model.acc)</span><br><span class="line">    merged_summary = tf.summary.merge_all()</span><br><span class="line">    writer = tf.summary.FileWriter(tensorboard_dir)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 配置 Saver</span></span><br><span class="line">    saver = tf.train.Saver()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(save_dir):</span><br><span class="line">        os.makedirs(save_dir)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Loading training and validation data...&quot;</span>)</span><br><span class="line">    <span class="comment"># 载入训练集与验证集</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    x_train, y_train = process_file(train_dir, word_to_id, cat_to_id, config.seq_length)</span><br><span class="line">    x_val, y_val = process_file(val_dir, word_to_id, cat_to_id, config.seq_length)</span><br><span class="line">    time_dif = get_time_dif(start_time)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Time usage:&quot;</span>, time_dif)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建session</span></span><br><span class="line">    session = tf.Session()</span><br><span class="line">    session.run(tf.global_variables_initializer())</span><br><span class="line">    writer.add_graph(session.graph)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Training and evaluating...&#x27;</span>)</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    total_batch = <span class="number">0</span>  <span class="comment"># 总批次</span></span><br><span class="line">    best_acc_val = <span class="number">0.0</span>  <span class="comment"># 最佳验证集准确率</span></span><br><span class="line">    last_improved = <span class="number">0</span>  <span class="comment"># 记录上一次提升批次</span></span><br><span class="line">    require_improvement = <span class="number">1000</span>  <span class="comment"># 如果超过1000轮未提升，提前结束训练</span></span><br><span class="line"></span><br><span class="line">    flag = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(config.num_epochs):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Epoch:&#x27;</span>, epoch + <span class="number">1</span>)</span><br><span class="line">        batch_train = batch_iter(x_train, y_train, config.batch_size)</span><br><span class="line">        <span class="keyword">for</span> x_batch, y_batch <span class="keyword">in</span> batch_train:</span><br><span class="line">            feed_dict = feed_data(x_batch, y_batch, config.dropout_keep_prob)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> total_batch % config.save_per_batch == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 每多少轮次将训练结果写入tensorboard scalar</span></span><br><span class="line">                s = session.run(merged_summary, feed_dict=feed_dict)</span><br><span class="line">                writer.add_summary(s, total_batch)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> total_batch % config.print_per_batch == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 每多少轮次输出在训练集和验证集上的性能</span></span><br><span class="line">                feed_dict[model.keep_prob] = <span class="number">1.0</span></span><br><span class="line">                loss_train, acc_train = session.run([model.loss, model.acc], feed_dict=feed_dict)</span><br><span class="line">                loss_val, acc_val = evaluate(session, x_val, y_val)  <span class="comment"># todo</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> acc_val &gt; best_acc_val:</span><br><span class="line">                    <span class="comment"># 保存最好结果</span></span><br><span class="line">                    best_acc_val = acc_val</span><br><span class="line">                    last_improved = total_batch</span><br><span class="line">                    saver.save(sess=session, save_path=save_path)</span><br><span class="line">                    improved_str = <span class="string">&#x27;*&#x27;</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    improved_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">                time_dif = get_time_dif(start_time)</span><br><span class="line">                msg = <span class="string">&#x27;Iter: &#123;0:&gt;6&#125;, Train Loss: &#123;1:&gt;6.2&#125;, Train Acc: &#123;2:&gt;7.2%&#125;,&#x27;</span> \</span><br><span class="line">                      + <span class="string">&#x27; Val Loss: &#123;3:&gt;6.2&#125;, Val Acc: &#123;4:&gt;7.2%&#125;, Time: &#123;5&#125; &#123;6&#125;&#x27;</span></span><br><span class="line">                <span class="built_in">print</span>(msg.<span class="built_in">format</span>(total_batch, loss_train, acc_train, loss_val, acc_val, time_dif, improved_str))</span><br><span class="line"></span><br><span class="line">            session.run(model.optim, feed_dict=feed_dict)  <span class="comment"># 运行优化</span></span><br><span class="line">            total_batch += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> total_batch - last_improved &gt; require_improvement:</span><br><span class="line">                <span class="comment"># 验证集正确率长期不提升，提前结束训练</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;No optimization for a long time, auto-stopping...&quot;</span>)</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span>  <span class="comment"># 跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> flag:  <span class="comment"># 同上</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Loading test data...&quot;</span>)</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    x_test, y_test = process_file(test_dir, word_to_id, cat_to_id, config.seq_length)</span><br><span class="line"></span><br><span class="line">    session = tf.Session()</span><br><span class="line">    session.run(tf.global_variables_initializer())</span><br><span class="line">    saver = tf.train.Saver()</span><br><span class="line">    saver.restore(sess=session, save_path=save_path)  <span class="comment"># 读取保存的模型</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Testing...&#x27;</span>)</span><br><span class="line">    loss_test, acc_test = evaluate(session, x_test, y_test)</span><br><span class="line">    msg = <span class="string">&#x27;Test Loss: &#123;0:&gt;6.2&#125;, Test Acc: &#123;1:&gt;7.2%&#125;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(msg.<span class="built_in">format</span>(loss_test, acc_test))</span><br><span class="line"></span><br><span class="line">    batch_size = <span class="number">128</span></span><br><span class="line">    data_len = <span class="built_in">len</span>(x_test)</span><br><span class="line">    num_batch = <span class="built_in">int</span>((data_len - <span class="number">1</span>) / batch_size) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    y_test_cls = np.argmax(y_test, <span class="number">1</span>)</span><br><span class="line">    y_pred_cls = np.zeros(shape=<span class="built_in">len</span>(x_test), dtype=np.int32)  <span class="comment"># 保存预测结果</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_batch):  <span class="comment"># 逐批次处理</span></span><br><span class="line">        start_id = i * batch_size</span><br><span class="line">        end_id = <span class="built_in">min</span>((i + <span class="number">1</span>) * batch_size, data_len)</span><br><span class="line">        feed_dict = &#123;</span><br><span class="line">            model.input_x: x_test[start_id:end_id],</span><br><span class="line">            model.keep_prob: <span class="number">1.0</span></span><br><span class="line">        &#125;</span><br><span class="line">        y_pred_cls[start_id:end_id] = session.run(model.y_pred_cls, feed_dict=feed_dict)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 评估</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Precision, Recall and F1-Score...&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(metrics.classification_report(y_test_cls, y_pred_cls, target_names=categories))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 混淆矩阵</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Confusion Matrix...&quot;</span>)</span><br><span class="line">    cm = metrics.confusion_matrix(y_test_cls, y_pred_cls)</span><br><span class="line">    <span class="built_in">print</span>(cm)</span><br><span class="line"></span><br><span class="line">    time_dif = get_time_dif(start_time)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Time usage:&quot;</span>, time_dif)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">2</span> <span class="keyword">or</span> sys.argv[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;test&#x27;</span>]:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;&quot;&quot;usage: python run_cnn.py [train / test]&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Configuring CNN model...&#x27;</span>)</span><br><span class="line">    config = TCNNConfig()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(vocab_dir):  <span class="comment"># 如果不存在词汇表，重建</span></span><br><span class="line">        build_vocab(train_dir, vocab_dir, config.vocab_size)</span><br><span class="line">    categories, cat_to_id = read_category()</span><br><span class="line">    words, word_to_id = read_vocab(vocab_dir)</span><br><span class="line">    config.vocab_size = <span class="built_in">len</span>(words)</span><br><span class="line">    model = TextCNN(config)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">        train()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        test()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>深度学习算法</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>生成式对抗网络</title>
    <url>/posts/b8a67b7c.html</url>
    <content><![CDATA[<h2 id="生成式对抗网络-Generative-Adversarial-Networks">生成式对抗网络(Generative Adversarial Networks)</h2>
<p>生成对抗网络（Generative Adversarial Network，简称GAN）是非监督式学习的一种方法，通过让两个神经网络相互博弈的方式进行学习。该方法由伊恩·古德费洛等人于2014年提出。</p>
<p>生成对抗网络由一个生成网络与一个判别网络组成。生成网络从潜在空间（latent space）中随机采样作为输入，其输出结果需要尽量模仿训练集中的真实样本。判别网络的输入则为真实样本或生成网络的输出，其目的是将生成网络的输出从真实样本中尽可能分辨出来。而生成网络则要尽可能地欺骗判别网络。两个网络相互对抗、不断调整参数，最终目的是使判别网络无法判断生成网络的输出结果是否真实。</p>
<p>生成对抗网络常用于生成以假乱真的图片。此外，该方法还被用于生成视频、三维物体模型等。</p>
<p>机器学习的模型可大体分为两类，生成模型（Generative Model）和判别模型（Discriminative Model）。判别模型需要输入变量 ，通过某种模型来预测 。生成模型是给定某种隐含信息，来随机产生观测数据。</p>
<p>举个例子:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>判别模型：给定一张图，判断这张图里的动物是猫还是狗</p>
</li>
<li class="lvl-2">
<p>生成模型：给一系列猫的图片，生成一张新的猫咪（不在数据集里）</p>
</li>
</ul>
<p align="center">
<img width="500" align="center" src="/img/images/400.jpg" />
</p>
<p>对于判别模型，损失函数是容易定义的，因为输出的目标相对简单。但对于生成模型，损失函数的定义就不是那么容易。我们对于生成结果的期望，往往是一个暧昧不清，难以数学公理化定义的范式。所以不妨把生成模型的回馈部分，交给判别模型处理。这就是Goodfellow他将机器学习中的两大类模型，Generative和Discrimitive给紧密地联合在了一起 。</p>
<p>GAN的基本原理其实非常简单，这里以生成图片为例进行说明。假设我们有两个网络，G（Generator）和D（Discriminator）。正如它的名字所暗示的那样，它们的功能分别是：</p>
<p>G是一个生成图片的网络，它接收一个随机的噪声z，通过这个噪声生成图片，记做G(z)。</p>
<p>D是一个判别网络，判别一张图片是不是“真实的”。它的输入参数是x，x代表一张图片，输出D（x）代表x为真实图片的概率，如果为1，就代表100%是真实的图片，而输出为0，就代表不可能是真实的图片。</p>
<p>在训练过程中，生成网络G的目标就是尽量生成真实的图片去欺骗判别网络D。而D的目标就是尽量把G生成的图片和真实的图片分别开来。这样，G和D构成了一个动态的“博弈过程”。</p>
<p>最后博弈的结果是什么？在最理想的状态下，G可以生成足以“以假乱真”的图片G(z)。对于D来说，它难以判定G生成的图片究竟是不是真实的，因此D(G(z)) = 0.5。这样我们的目的就达成了：我们得到了一个生成式的模型G，它可以用来生成图片。<br>
Goodfellow从理论上证明了该算法的收敛性 ，以及在模型收敛时，生成数据具有和真实数据相同的分布（保证了模型效果）。</p>
<p>应用领域:目前生成对抗网络最常使用的地方就是图像生成，如超分辨率任务，语义分割等等</p>
<h3 id="应用实例">应用实例:</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line">mpl.use(<span class="string">&#x27;Agg&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.gridspec <span class="keyword">as</span> gridspec</span><br><span class="line"><span class="keyword">import</span> os,sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&#x27;utils&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> nets <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> datas <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sample_z</span>(<span class="params">m, n</span>):</span><br><span class="line">	<span class="keyword">return</span> np.random.uniform(-<span class="number">1.</span>, <span class="number">1.</span>, size=[m, n])</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DCGAN</span>():</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, generator, discriminator, data</span>):</span><br><span class="line">		self.generator = generator</span><br><span class="line">		self.discriminator = discriminator</span><br><span class="line">		self.data = data</span><br><span class="line"></span><br><span class="line">		<span class="comment"># data</span></span><br><span class="line">		self.z_dim = self.data.z_dim</span><br><span class="line">		self.size = self.data.size</span><br><span class="line">		self.channel = self.data.channel</span><br><span class="line"></span><br><span class="line">		self.X = tf.placeholder(tf.float32, shape=[<span class="literal">None</span>, self.size, self.size, self.channel])</span><br><span class="line">		self.z = tf.placeholder(tf.float32, shape=[<span class="literal">None</span>, self.z_dim])</span><br><span class="line"></span><br><span class="line">		<span class="comment"># nets</span></span><br><span class="line">		self.G_sample = self.generator(self.z)</span><br><span class="line"></span><br><span class="line">		self.D_real, _ = self.discriminator(self.X)</span><br><span class="line">		self.D_fake, _ = self.discriminator(self.G_sample, reuse = <span class="literal">True</span>)</span><br><span class="line">		</span><br><span class="line">		<span class="comment"># loss</span></span><br><span class="line">		self.D_loss = tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(logits=self.D_real, labels=tf.ones_like(self.D_real))) + tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(logits=self.D_fake, labels=tf.zeros_like(self.D_fake)))</span><br><span class="line">		self.G_loss = tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(logits=self.D_fake, labels=tf.ones_like(self.D_fake)))</span><br><span class="line"></span><br><span class="line">		<span class="comment"># solver</span></span><br><span class="line">		self.D_solver = tf.train.AdamOptimizer(learning_rate=<span class="number">2e-4</span>).minimize(self.D_loss, var_list=self.discriminator.<span class="built_in">vars</span>)</span><br><span class="line">		self.G_solver = tf.train.AdamOptimizer(learning_rate=<span class="number">2e-4</span>).minimize(self.G_loss, var_list=self.generator.<span class="built_in">vars</span>)</span><br><span class="line">		</span><br><span class="line">		self.saver = tf.train.Saver()</span><br><span class="line">		gpu_options = tf.GPUOptions(allow_growth=<span class="literal">True</span>)</span><br><span class="line">		self.sess = tf.Session(config=tf.ConfigProto(gpu_options=gpu_options))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self, sample_dir, ckpt_dir=<span class="string">&#x27;ckpt&#x27;</span>, training_epoches = <span class="number">1000000</span>, batch_size = <span class="number">32</span></span>):</span><br><span class="line">		fig_count = <span class="number">0</span></span><br><span class="line">		self.sess.run(tf.global_variables_initializer())</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(training_epoches):</span><br><span class="line">			<span class="comment"># update D</span></span><br><span class="line">			X_b = self.data(batch_size)</span><br><span class="line">			self.sess.run(</span><br><span class="line">				self.D_solver,</span><br><span class="line">				feed_dict=&#123;self.X: X_b, self.z: sample_z(batch_size, self.z_dim)&#125;</span><br><span class="line">				)</span><br><span class="line">			<span class="comment"># update G</span></span><br><span class="line">			k = <span class="number">1</span></span><br><span class="line">			<span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">				self.sess.run(</span><br><span class="line">					self.G_solver,</span><br><span class="line">					feed_dict=&#123;self.z: sample_z(batch_size, self.z_dim)&#125;</span><br><span class="line">				)</span><br><span class="line"></span><br><span class="line">			<span class="comment"># save img, model. print loss</span></span><br><span class="line">			<span class="keyword">if</span> epoch % <span class="number">100</span> == <span class="number">0</span> <span class="keyword">or</span> epoch &lt; <span class="number">100</span>:</span><br><span class="line">				D_loss_curr = self.sess.run(</span><br><span class="line">						self.D_loss,</span><br><span class="line">            			feed_dict=&#123;self.X: X_b, self.z: sample_z(batch_size, self.z_dim)&#125;)</span><br><span class="line">				G_loss_curr = self.sess.run(</span><br><span class="line">						self.G_loss,</span><br><span class="line">						feed_dict=&#123;self.z: sample_z(batch_size, self.z_dim)&#125;)</span><br><span class="line">				<span class="built_in">print</span>(<span class="string">&#x27;Iter: &#123;&#125;; D loss: &#123;:.4&#125;; G_loss: &#123;:.4&#125;&#x27;</span>.<span class="built_in">format</span>(epoch, D_loss_curr, G_loss_curr))</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> epoch % <span class="number">1000</span> == <span class="number">0</span>:</span><br><span class="line">					samples = self.sess.run(self.G_sample, feed_dict=&#123;self.z: sample_z(<span class="number">16</span>, self.z_dim)&#125;)</span><br><span class="line"></span><br><span class="line">					fig = self.data.data2fig(samples)</span><br><span class="line">					plt.savefig(<span class="string">&#x27;&#123;&#125;/&#123;&#125;.png&#x27;</span>.<span class="built_in">format</span>(sample_dir, <span class="built_in">str</span>(fig_count).zfill(<span class="number">3</span>)), bbox_inches=<span class="string">&#x27;tight&#x27;</span>)</span><br><span class="line">					fig_count += <span class="number">1</span></span><br><span class="line">					plt.close(fig)</span><br><span class="line"></span><br><span class="line">				<span class="comment">#if epoch % 2000 == 0:</span></span><br><span class="line">					<span class="comment">#self.saver.save(self.sess, os.path.join(ckpt_dir, &quot;dcgan.ckpt&quot;))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment"># constraint GPU</span></span><br><span class="line">	os.environ[<span class="string">&#x27;CUDA_VISIBLE_DEVICES&#x27;</span>] = <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># save generated images</span></span><br><span class="line">	sample_dir = <span class="string">&#x27;Samples/celebA_dcgan&#x27;</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(sample_dir):</span><br><span class="line">		os.makedirs(sample_dir)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># param</span></span><br><span class="line">	generator = G_conv()</span><br><span class="line">	discriminator = D_conv()</span><br><span class="line"></span><br><span class="line">	data = celebA()</span><br><span class="line"></span><br><span class="line">	<span class="comment"># run</span></span><br><span class="line">	dcgan = DCGAN(generator, discriminator, data)</span><br><span class="line">	dcgan.train(sample_dir)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>深度学习算法</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>K-均值</title>
    <url>/posts/f653cb3b.html</url>
    <content><![CDATA[<h2 id="K-均值-K-Means-Algorithm">K-均值(K-Means Algorithm)</h2>
<p>k-means算法，也被称为k-平均或k-均值，是一种得到最广泛使用的聚类算法。 通常它把n个点（可以是样本的一次观察或一个实例）划分到k个聚类中，使得每个点都属于离他最近的均值（此即聚类中心）对应的聚类，以之作为聚类的标准。</p>
<p>k-means算法属于无监督学习方法。此算法以k为参数，把n 个对象分为k个簇，以使簇内具有较高的相似度，而且簇间的相似度较低。相似度的计算根据一个簇中对象的平均值（被看作簇的重心）来进行。此算法首先随机选择k个对象，每个对象代表一个聚类的质心。对于其余的每一个对象，根据该对象与各聚类质心之间的距离，把它分配到与之最相似的聚类中。然后，计算每个聚类的新质心。重复上述过程，直到准则函数收敛。k-means算法是一种较典型的逐点修改迭代的动态聚类算法，其要点是以误差平方和为准则函数。逐点修改类中心：一个象元样本按某一原则，归属于某一组类后，就要重新计算这个组类的均值，并且以新的均值作为凝聚中心点进行下一次象元素聚类；逐批修改类中心：在全部象元样本按某一组的类中心分类之后，再计算修改各类的均值，作为下一次分类的凝聚中心点</p>
<p>聚类相似度是利用各聚类中对象的均值所获得一个“中心对象”（引力中心）来进行计算的。相异度计算方法：欧几里得距离,曼哈顿距离,闵可夫斯基距离,皮尔逊相关系数.</p>
<h3 id="应用示例-11">应用示例</h3>
<p>输入：簇的数目k和包含n个对象的数据库。 输出：k个簇，使平方误差准则最小。</p>
<p>算法步骤：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>1.为每个聚类确定一个初始聚类中心，这样就有K 个初始聚类中心。</p>
</li>
<li class="lvl-2">
<p>2.将样本集中的样本按照最小距离原则分配到最邻近聚类</p>
</li>
<li class="lvl-2">
<p>3.使用每个聚类中的样本均值作为新的聚类中心。</p>
</li>
<li class="lvl-2">
<p>4.重复步骤2.3直到聚类中心不再变化。</p>
</li>
<li class="lvl-2">
<p>5.结束，得到K个聚类</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="comment"># matplotlib inline</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets.samples_generator <span class="keyword">import</span> make_blobs</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets.samples_generator <span class="keyword">import</span> make_circles</span><br><span class="line"></span><br><span class="line">N = <span class="number">200</span></span><br><span class="line">K = <span class="number">4</span></span><br><span class="line">DATA_TYPE = <span class="string">&#x27;blobs&#x27;</span></span><br><span class="line">MAX_ITERS = <span class="number">1000</span></span><br><span class="line">colourindexes = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># k-means不适用于circles数据，2个类足以demo这个问题</span></span><br><span class="line"><span class="keyword">if</span> (DATA_TYPE == <span class="string">&#x27;circle&#x27;</span>):</span><br><span class="line">    K = <span class="number">2</span></span><br><span class="line">    colourindexes = [<span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据聚类中心生成测试数据</span></span><br><span class="line">centers = [(-<span class="number">2</span>, -<span class="number">2</span>), (-<span class="number">2</span>, <span class="number">1.5</span>), (<span class="number">1.5</span>, -<span class="number">2</span>), (<span class="number">2</span>, <span class="number">1.5</span>)]</span><br><span class="line"><span class="keyword">if</span> (DATA_TYPE == <span class="string">&#x27;circle&#x27;</span>):</span><br><span class="line">    data, features = make_circles(</span><br><span class="line">        n_samples=N, shuffle=<span class="literal">True</span>, noise=<span class="number">0.01</span>, factor=<span class="number">0.4</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    data, features = make_blobs(n_samples=N, centers=centers,</span><br><span class="line">                                n_features=<span class="number">2</span>, cluster_std=<span class="number">0.8</span>,</span><br><span class="line">                                shuffle=<span class="literal">False</span>, random_state=<span class="number">42</span>)</span><br><span class="line">    <span class="comment">#fig, ax = plt.subplots()</span></span><br><span class="line">    <span class="comment">#ax.scatter(np.asarray(centers).transpose()[0], np.asarray(</span></span><br><span class="line">    <span class="comment">#    centers).transpose()[1], marker=&#x27;o&#x27;, s=250)</span></span><br><span class="line">    <span class="comment">#plt.show()</span></span><br><span class="line"></span><br><span class="line">    fig, ax = plt.subplots()</span><br><span class="line">    ax.scatter(np.asarray(centers).transpose()[<span class="number">0</span>], np.asarray(</span><br><span class="line">        centers).transpose()[<span class="number">1</span>], marker=<span class="string">&#x27;o&#x27;</span>, s=<span class="number">250</span>)</span><br><span class="line">    ax.scatter(data.transpose()[<span class="number">0</span>], data.transpose()[</span><br><span class="line">               <span class="number">1</span>], marker=<span class="string">&#x27;o&#x27;</span>, s=<span class="number">100</span>, c=features, cmap=plt.cm.coolwarm)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bucket_mean</span>(<span class="params">data, bucket_ids, num_buckets</span>):</span><br><span class="line">    total = tf.unsorted_segment_sum(data, bucket_ids, num_buckets)</span><br><span class="line">    count = tf.unsorted_segment_sum(</span><br><span class="line">        tf.ones_like(data), bucket_ids, num_buckets)</span><br><span class="line">    <span class="keyword">return</span> total / count</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">points = tf.Variable(data)</span><br><span class="line">cluster_assignments = tf.Variable(tf.zeros([N], dtype=tf.int64))</span><br><span class="line">centroids = tf.Variable(tf.<span class="built_in">slice</span>(points.initialized_value(), [<span class="number">0</span>, <span class="number">0</span>], [K, <span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line">rep_centroids = tf.reshape(tf.tile(centroids, [N, <span class="number">1</span>]), [N, K, <span class="number">2</span>])</span><br><span class="line">rep_points = tf.reshape(tf.tile(points, [<span class="number">1</span>, K]), [N, K, <span class="number">2</span>])</span><br><span class="line">sum_squares = tf.reduce_sum(tf.square(rep_points - rep_centroids),</span><br><span class="line">                            reduction_indices=<span class="number">2</span>)</span><br><span class="line">best_centroids = tf.argmin(sum_squares, <span class="number">1</span>)</span><br><span class="line">did_assignments_change = tf.reduce_any(</span><br><span class="line">    tf.not_equal(best_centroids, cluster_assignments))</span><br><span class="line">means = bucket_mean(points, best_centroids, K)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.control_dependencies([did_assignments_change]):</span><br><span class="line">    do_updates = tf.group(</span><br><span class="line">        centroids.assign(means),</span><br><span class="line">        cluster_assignments.assign(best_centroids))</span><br><span class="line"></span><br><span class="line">changed = <span class="literal">True</span></span><br><span class="line">iters = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">sess = tf.Session()</span><br><span class="line">sess.run(tf.initialize_all_variables())</span><br><span class="line"><span class="keyword">while</span> changed <span class="keyword">and</span> iters &lt; MAX_ITERS:</span><br><span class="line">    iters += <span class="number">1</span></span><br><span class="line">    [changed, _] = sess.run([did_assignments_change, do_updates])</span><br><span class="line">    [centers, assignments] = sess.run([centroids, cluster_assignments])</span><br><span class="line">    fig, ax = plt.subplots()</span><br><span class="line">    ax.scatter(sess.run(points).transpose()[<span class="number">0</span>], sess.run(points).transpose()[</span><br><span class="line">               <span class="number">1</span>], marker=<span class="string">&#x27;o&#x27;</span>, s=<span class="number">200</span>, c=assignments, cmap=plt.cm.coolwarm)</span><br><span class="line">    ax.scatter(centers[:, <span class="number">0</span>], centers[:, <span class="number">1</span>], marker=<span class="string">&#x27;^&#x27;</span>,</span><br><span class="line">               s=<span class="number">550</span>, c=colourindexes, cmap=plt.cm.plasma)</span><br><span class="line">    ax.set_title(<span class="string">&#x27;Iteration &#x27;</span> + <span class="built_in">str</span>(iters))</span><br><span class="line">    <span class="comment"># plt.savefig(&quot;kmeans&quot; + str(iters) + &quot;.png&quot;)</span></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.scatter(sess.run(points).transpose()[<span class="number">0</span>], sess.run(points).transpose()[</span><br><span class="line">           <span class="number">1</span>], marker=<span class="string">&#x27;o&#x27;</span>, s=<span class="number">200</span>, c=assignments, cmap=plt.cm.coolwarm)</span><br><span class="line">ax.scatter(np.asarray(centers).transpose()[<span class="number">0</span>], np.asarray(</span><br><span class="line">        centers).transpose()[<span class="number">1</span>], marker=<span class="string">&#x27;o&#x27;</span>, s=<span class="number">250</span>, c=colourindexes, cmap=plt.cm.plasma)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">end = time.time()</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Found in %.2f seconds&quot;</span> % (end - start)), iters, <span class="string">&quot;iterations&quot;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Centroids:&quot;</span>, centers</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Cluster assignments:&quot;</span>, assignments</span><br></pre></td></tr></table></figure>
<p align="center">
<img width="400" align="center" src="/img/images/233.jpg" />
</p>
<p align="center">
<img width="400" align="center" src="/img/images/234.jpg" />
</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Found <span class="keyword">in</span> <span class="number">2.15</span> seconds <span class="number">8</span> iterations</span><br><span class="line">Centroids: [[ <span class="number">1.65289262</span> -<span class="number">2.04643427</span>]</span><br><span class="line"> [-<span class="number">2.0763623</span>   <span class="number">1.61204964</span>]</span><br><span class="line"> [-<span class="number">2.08862822</span> -<span class="number">2.07255306</span>]</span><br><span class="line"> [ <span class="number">2.09831502</span>  <span class="number">1.55936014</span>]]</span><br><span class="line">Cluster assignments: [<span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<h3 id="优点-6">优点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>简单、快速，可并行计算</p>
</li>
<li class="lvl-2">
<p>已经获得防范的应用</p>
</li>
</ul>
<h3 id="缺点-3">缺点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>必须事先给出k（要生成的簇的数目），而且对初值敏感，对于不同的初始值，可能会导致不同结果。</p>
</li>
<li class="lvl-2">
<p>对于“躁声”和孤立点数据是敏感的，少量的该类数据能够对平均值产生极大的影响。</p>
</li>
</ul>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>聚类算法</category>
      </categories>
      <tags>
        <tag>聚类算法</tag>
      </tags>
  </entry>
  <entry>
    <title>期望最大化</title>
    <url>/posts/c3a31218.html</url>
    <content><![CDATA[<h2 id="期望最大化-Expectation-Maximization">期望最大化(Expectation-Maximization)</h2>
<p>期望最大化（Expectation-maximization）算法是由Dempster等人1977年提出的统计模型参数估计的一种算法。它采用的迭代交替搜索方式可以简单有效的求解最大似然函数估计问题。已知的概率模型内部存在隐含的变量，导致了不能直接用极大似然法来估计参数，期望最大化（Expectation-maximization）就是通过迭代逼近的方式用实际的值带入求解模型内部参数的算法。它在当代的工业、商业和科学研究领域发挥了重要的作用。</p>
<p>期望最大化算法是一种启发式的迭代算法，是一种从“不完全数据”中求极大似然的方法。在人工智能、机器学习、数理统计、模式识别等许多应用都需要进行模型的参数估计，极大似然估计和极大后验似然估计是必要进行的。然而在理想的可观察变量模型中，即变量分布式均匀的时候，做出以上两个估计是显然可以的。但是实际的情况往往不是这样，某些变量并不是可以观察的，对这类模型进行极大似然估计就比较复杂了。期望最大化算法是解决对于不可观察变量进行似然估计的一种方法。期望最大化算法的提出主要是用来计算后验分布的众数或极大似然估计。然而，近年来它引起了统计学家的极大兴趣，在统计领域得到了广泛的应用。该方法广泛的应用于缺损数据、截尾数据、成群数据、带有复杂参数的数据等不完整数据。期望最大化算法流行的原因，一是在于它的理论简单化和一般性，二是许多应用都能够纳入到期望最大化算法的范畴，期望最大化算法已经成为统计学上的一个标准工具。<br>
EM算法还是许多非监督聚类算法的基础（如Cheeseman et al. 1988），而且它是用于学习部分可观察马尔可夫模型（Partially Observable Markov Model）的广泛使用的Baum-Welch前向后向算法的基础。</p>
<p>给定的训练样本是<img width="80" align="center" src="/img/images/238.jpg" />，样例间独立，我们想找到每个样例隐含的类别z，能使得p(x,z)最大。p(x,z)的最大似然估计如下：</p>
<p align="center">
<img width="300" align="center" src="/img/images/239.jpg" />
</p>
<p>由jensen不等式可得：</p>
<p align="center">
<img width="680" align="center" src="/img/images/240.jpg" />
</p>
<p>对于每一个样例i，让<img width="20" align="center" src="/img/images/241.jpg" />表示该样例隐含变量z的某种分布，<img width="20" align="center" src="/img/images/241.jpg" />满足的条件是<img width="80" align="center" src="/img/images/242.jpg" />，<img width="80" align="center" src="/img/images/243.jpg" />。由此，可以确定式子的下界，然后不断的提高此下界达到逼近最后真实值的目的值，这个不等式变成等式为止，然后再依据jensen不等式，当不等式变为等式的时候，当且仅当，也就是说X是常量，推出就是下面的公式：</p>
<p align="center">
<img width="130" align="center" src="/img/images/244.jpg" />
</p>
<p>由于Q是随机变量z的概率密度函数，因此，可以得到：分子的和等于c（分子分母都对所有z求和：多个等式分子分母相加不变，这个认为每个样例的两个概率比值都是c）。</p>
<p align="center">
<img width="230" align="center" src="/img/images/245.jpg" />
</p>
<p>由此可得出EM算法的一般过程：循环重复E步骤和M步骤直到收敛。<br>
E步骤：对于每一个i，计算：</p>
<p align="center">
<img width="260" align="center" src="/img/images/246.jpg" />
</p>
<p>M步骤计算:</p>
<p align="center">
<img width="280" align="center" src="/img/images/247.jpg" />
</p>
<h3 id="应用示例-12">应用示例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> multivariate_normal</span><br><span class="line"></span><br><span class="line">DEBUG = <span class="literal">True</span></span><br><span class="line"><span class="comment"># 调试输出函数</span></span><br><span class="line"><span class="comment"># 由全局变量 DEBUG 控制输出</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="keyword">global</span> DEBUG</span><br><span class="line">    <span class="keyword">if</span> DEBUG:</span><br><span class="line">        <span class="built_in">print</span>(*args, **kwargs)</span><br><span class="line"><span class="comment"># 第 k 个模型的高斯分布密度函数</span></span><br><span class="line"><span class="comment"># 每 i 行表示第 i 个样本在各模型中的出现概率</span></span><br><span class="line"><span class="comment"># 返回一维列表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">phi</span>(<span class="params">Y, mu_k, cov_k</span>):</span><br><span class="line">    norm = multivariate_normal(mean=mu_k, cov=cov_k)</span><br><span class="line">    <span class="keyword">return</span> norm.pdf(Y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># E 步：计算每个模型对样本的响应度</span></span><br><span class="line"><span class="comment"># Y 为样本矩阵，每个样本一行，只有一个特征时为列向量</span></span><br><span class="line"><span class="comment"># mu 为均值多维数组，每行表示一个样本各个特征的均值</span></span><br><span class="line"><span class="comment"># cov 为协方差矩阵的数组，alpha 为模型响应度数组</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getExpectation</span>(<span class="params">Y, mu, cov, alpha</span>):</span><br><span class="line">    <span class="comment"># 样本数</span></span><br><span class="line">    N = Y.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 模型数</span></span><br><span class="line">    K = alpha.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 为避免使用单个高斯模型或样本，导致返回结果的类型不一致</span></span><br><span class="line">    <span class="comment"># 因此要求样本数和模型个数必须大于1</span></span><br><span class="line">    <span class="keyword">assert</span> N &gt; <span class="number">1</span>, <span class="string">&quot;There must be more than one sample!&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> K &gt; <span class="number">1</span>, <span class="string">&quot;There must be more than one gaussian model!&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 响应度矩阵，行对应样本，列对应响应度</span></span><br><span class="line">    gamma = np.mat(np.zeros((N, K)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算各模型中所有样本出现的概率，行对应样本，列对应模型</span></span><br><span class="line">    prob = np.zeros((N, K))</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(K):</span><br><span class="line">        prob[:, k] = phi(Y, mu[k], cov[k])</span><br><span class="line">    prob = np.mat(prob)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算每个模型对每个样本的响应度</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(K):</span><br><span class="line">        gamma[:, k] = alpha[k] * prob[:, k]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        gamma[i, :] /= np.<span class="built_in">sum</span>(gamma[i, :])</span><br><span class="line">    <span class="keyword">return</span> gamma</span><br><span class="line"></span><br><span class="line"><span class="comment"># M 步：迭代模型参数</span></span><br><span class="line"><span class="comment"># Y 为样本矩阵，gamma 为响应度矩阵</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">maximize</span>(<span class="params">Y, gamma</span>):</span><br><span class="line">    <span class="comment"># 样本数和特征数</span></span><br><span class="line">    N, D = Y.shape</span><br><span class="line">    <span class="comment"># 模型数</span></span><br><span class="line">    K = gamma.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#初始化参数值</span></span><br><span class="line">    mu = np.zeros((K, D))</span><br><span class="line">    cov = []</span><br><span class="line">    alpha = np.zeros(K)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新每个模型的参数</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(K):</span><br><span class="line">        <span class="comment"># 第 k 个模型对所有样本的响应度之和</span></span><br><span class="line">        Nk = np.<span class="built_in">sum</span>(gamma[:, k])</span><br><span class="line">        <span class="comment"># 更新 mu</span></span><br><span class="line">        <span class="comment"># 对每个特征求均值</span></span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(D):</span><br><span class="line">            mu[k, d] = np.<span class="built_in">sum</span>(np.multiply(gamma[:, k], Y[:, d])) / Nk</span><br><span class="line">        <span class="comment"># 更新 cov</span></span><br><span class="line">        cov_k = np.mat(np.zeros((D, D)))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            cov_k += gamma[i, k] * (Y[i] - mu[k]).T * (Y[i] - mu[k]) / Nk</span><br><span class="line">        cov.append(cov_k)</span><br><span class="line">        <span class="comment"># 更新 alpha</span></span><br><span class="line">        alpha[k] = Nk / N</span><br><span class="line">    cov = np.array(cov)</span><br><span class="line">    <span class="keyword">return</span> mu, cov, alpha</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 数据预处理</span></span><br><span class="line"><span class="comment"># 将所有数据都缩放到 0 和 1 之间</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scale_data</span>(<span class="params">Y</span>):</span><br><span class="line">    <span class="comment"># 对每一维特征分别进行缩放</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">1</span>]):</span><br><span class="line">        max_ = Y[:, i].<span class="built_in">max</span>()</span><br><span class="line">        min_ = Y[:, i].<span class="built_in">min</span>()</span><br><span class="line">        Y[:, i] = (Y[:, i] - min_) / (max_ - min_)</span><br><span class="line">    debug(<span class="string">&quot;Data scaled.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> Y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化模型参数</span></span><br><span class="line"><span class="comment"># shape 是表示样本规模的二元组，(样本数, 特征数)</span></span><br><span class="line"><span class="comment"># K 表示模型个数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_params</span>(<span class="params">shape, K</span>):</span><br><span class="line">    N, D = shape</span><br><span class="line">    mu = np.random.rand(K, D)</span><br><span class="line">    cov = np.array([np.eye(D)] * K)</span><br><span class="line">    alpha = np.array([<span class="number">1.0</span> / K] * K)</span><br><span class="line">    debug(<span class="string">&quot;Parameters initialized.&quot;</span>)</span><br><span class="line">    debug(<span class="string">&quot;mu:&quot;</span>, mu, <span class="string">&quot;cov:&quot;</span>, cov, <span class="string">&quot;alpha:&quot;</span>, alpha, sep=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> mu, cov, alpha</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 高斯混合模型 EM 算法</span></span><br><span class="line"><span class="comment"># 给定样本矩阵 Y，计算模型参数</span></span><br><span class="line"><span class="comment"># K 为模型个数</span></span><br><span class="line"><span class="comment"># times 为迭代次数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GMM_EM</span>(<span class="params">Y, K, times</span>):</span><br><span class="line">    Y = scale_data(Y)</span><br><span class="line">    mu, cov, alpha = init_params(Y.shape, K)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(times):</span><br><span class="line">        gamma = getExpectation(Y, mu, cov, alpha)</span><br><span class="line">        mu, cov, alpha = maximize(Y, gamma)</span><br><span class="line">    debug(<span class="string">&quot;&#123;sep&#125; Result &#123;sep&#125;&quot;</span>.<span class="built_in">format</span>(sep=<span class="string">&quot;-&quot;</span> * <span class="number">20</span>))</span><br><span class="line">    debug(<span class="string">&quot;mu:&quot;</span>, mu, <span class="string">&quot;cov:&quot;</span>, cov, <span class="string">&quot;alpha:&quot;</span>, alpha, sep=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> mu, cov, alpha</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">main.py 文件：</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> gmm <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置调试模式</span></span><br><span class="line">DEBUG = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入数据</span></span><br><span class="line">Y = np.loadtxt(<span class="string">&quot;gmm.data&quot;</span>)</span><br><span class="line">matY = np.matrix(Y, copy=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型个数，即聚类的类别个数</span></span><br><span class="line">K = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 GMM 模型参数</span></span><br><span class="line">mu, cov, alpha = GMM_EM(matY, K, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据 GMM 模型，对样本数据进行聚类，一个模型对应一个类别</span></span><br><span class="line">N = Y.shape[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 求当前模型参数下，各模型对样本的响应度矩阵</span></span><br><span class="line">gamma = getExpectation(matY, mu, cov, alpha)</span><br><span class="line"><span class="comment"># 对每个样本，求响应度最大的模型下标，作为其类别标识</span></span><br><span class="line">category = gamma.argmax(axis=<span class="number">1</span>).flatten().tolist()[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 将每个样本放入对应类别的列表中</span></span><br><span class="line">class1 = np.array([Y[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N) <span class="keyword">if</span> category[i] == <span class="number">0</span>])</span><br><span class="line">class2 = np.array([Y[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N) <span class="keyword">if</span> category[i] == <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制聚类结果</span></span><br><span class="line">plt.plot(class1[:, <span class="number">0</span>], class1[:, <span class="number">1</span>], <span class="string">&#x27;rs&#x27;</span>, label=<span class="string">&quot;class1&quot;</span>)</span><br><span class="line">plt.plot(class2[:, <span class="number">0</span>], class2[:, <span class="number">1</span>], <span class="string">&#x27;bo&#x27;</span>, label=<span class="string">&quot;class2&quot;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&quot;best&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;GMM Clustering By EM Algorithm&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h3 id="期望最大化算法的特点">期望最大化算法的特点</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>1.EM算法中，由于似然函数是有界的，并且算法的每一步迭代都使似然函数增加，根据单调有界定理可以证明EM算法具有收敛性。</p>
</li>
<li class="lvl-2">
<p>2.EM算法是一种初始值敏感的算法，选取不同初始参数会有不同的最终结果；</p>
</li>
<li class="lvl-2">
<p>3.EM算法得到的不会是全局最优，每次迭代逼近的都是当前的局部最优。</p>
</li>
</ul>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>聚类算法</category>
      </categories>
      <tags>
        <tag>聚类算法</tag>
      </tags>
  </entry>
  <entry>
    <title>模糊c-均值</title>
    <url>/posts/adc5763c.html</url>
    <content><![CDATA[<h2 id="模糊c-均值聚类算法-Fuzzy-C-means-Algorithm">模糊c-均值聚类算法(Fuzzy C-means Algorithm)</h2>
<p>模糊c-均值聚类算法,是一种基于目标函数的模糊聚类算法，主要用于数据的聚类分析。理论成熟，应用广泛，是一种优秀的聚类算法。模糊c-均值聚类算法输入就是一个待聚类的数据集，每一个数据都有p个特征。它的输出是一个c行n列的矩阵U，c刚才提到是聚类数目，n是数据集中元素的个数，用这个矩阵就可以表示分类的结果，因为你看某一列，表示的就是这个元素对各个类的隶属程度，哪一个值最大，就说这个元素属于哪一类。</p>
<p>还有一个输出是各个类的聚类中心向量集合V，一共有c个元素。每个元素也是有p维的。</p>
<p align="center">
<img width="200" align="center" src="/img/images/235.jpg" />
</p>
<p align="center">
<img width="200" align="center" src="/img/images/236.jpg" />
</p>
<p align="center">
<img width="200" align="center" src="/img/images/237.jpg" />
</p>
<h3 id="应用示例-13">应用示例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">    double x;</span><br><span class="line">    double y;</span><br><span class="line">&#125; Position;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//<span class="built_in">len</span>:节点数量</span><br><span class="line">//<span class="built_in">range</span>：节点x、y值的范围</span><br><span class="line">Position *randomPosition(<span class="built_in">int</span> <span class="built_in">len</span>, <span class="built_in">int</span> <span class="built_in">range</span>)&#123;</span><br><span class="line">    srand((unsigned)time(NULL));</span><br><span class="line">    Position *allPos = (Position *)malloc(<span class="built_in">len</span> * sizeof(Position));</span><br><span class="line"></span><br><span class="line">    short a = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a)</span><br><span class="line">        &#123;</span><br><span class="line">            allPos[i].x = (double)rand() / <span class="number">2147483647</span> * <span class="built_in">range</span>;</span><br><span class="line">            allPos[i].y = (double)rand() / <span class="number">2147483647</span> * <span class="built_in">range</span>;</span><br><span class="line">            a = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!a)</span><br><span class="line">        &#123;</span><br><span class="line">            allPos[i].x = (double)rand() / <span class="number">2147483647</span> * <span class="built_in">range</span>+<span class="number">50</span>;</span><br><span class="line">            allPos[i].y = (double)rand() / <span class="number">2147483647</span> * <span class="built_in">range</span>+<span class="number">50</span>;</span><br><span class="line">            a = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> allPos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//posNum：节点数量</span><br><span class="line">//clusterNum：聚类中心数量</span><br><span class="line">double **init(<span class="built_in">int</span> posNum, <span class="built_in">int</span> clusterNum)&#123;</span><br><span class="line">    double **u = (double **)malloc(sizeof(double *) * clusterNum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;clusterNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        u[i] = (double *)malloc(sizeof(double) * posNum);</span><br><span class="line">    &#125;</span><br><span class="line">    srand((unsigned)time(NULL));</span><br><span class="line">    double <span class="built_in">sum</span>;</span><br><span class="line">    //初始化u：sigmaU[i]=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; posNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sum</span>=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> x = <span class="number">0</span>; x &lt; clusterNum - <span class="number">1</span>; ++x)</span><br><span class="line">        &#123;</span><br><span class="line">            u[x][i] = ((double)rand() / <span class="number">2147483647</span>) * <span class="built_in">sum</span>;</span><br><span class="line">            <span class="built_in">sum</span> -= u[x][i];</span><br><span class="line">            printf(<span class="string">&quot;u[%d][%d]:%f &quot;</span>,x,i,u[x][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        u[clusterNum-<span class="number">1</span>][i]=<span class="built_in">sum</span>;</span><br><span class="line">        printf(<span class="string">&quot;u[%d][%d]:%f\n&quot;</span>,clusterNum-<span class="number">1</span>,i,u[clusterNum-<span class="number">1</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//allPos：节点数组</span><br><span class="line">//<span class="built_in">len</span>：节点数量</span><br><span class="line">void outputPos(Position *allPos, <span class="built_in">int</span> <span class="built_in">len</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>; ++i)</span><br><span class="line">        printf(<span class="string">&quot;position %d:(%f,%f)\n&quot;</span>, i, allPos[i].x, allPos[i].y);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//u：隶属度矩阵</span><br><span class="line">//posNum：节点数量</span><br><span class="line">//i:第i个聚类中心</span><br><span class="line">//m：隶属度因子</span><br><span class="line">double sumUi(double** u,<span class="built_in">int</span> posNum,<span class="built_in">int</span> i,<span class="built_in">int</span> m)&#123;</span><br><span class="line">    double res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> x=<span class="number">0</span>;x&lt;posNum;++x)</span><br><span class="line">        res+=<span class="built_in">pow</span>(u[i][x],m);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//u：隶属度矩阵</span><br><span class="line">//allPos:节点数组</span><br><span class="line">//posNum：节点数量</span><br><span class="line">//i:第i个聚类中心</span><br><span class="line">//m：隶属度因子</span><br><span class="line">double sumXi(double** u,Position* allPos,<span class="built_in">int</span> posNum,<span class="built_in">int</span> i,<span class="built_in">int</span> m)&#123;</span><br><span class="line">    double res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> x=<span class="number">0</span>;x&lt;posNum;++x)</span><br><span class="line">        res+=allPos[x].x*<span class="built_in">pow</span>(u[i][x],m);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//u：隶属度矩阵</span><br><span class="line">//posNum：节点数量</span><br><span class="line">//i:第i个聚类中心</span><br><span class="line">//m：隶属度因子</span><br><span class="line">double sumYi(double** u,Position* allPos,<span class="built_in">int</span> posNum,<span class="built_in">int</span> i,<span class="built_in">int</span> m)&#123;</span><br><span class="line">    double res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> x=<span class="number">0</span>;x&lt;posNum;++x)</span><br><span class="line">        res+=allPos[x].y*<span class="built_in">pow</span>(u[i][x],m);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//pos:第j个节点</span><br><span class="line">//cluster:聚类中心数组</span><br><span class="line">//clusterNum：聚类中心数量</span><br><span class="line">//m：隶属度因子</span><br><span class="line">double sumDis(Position pos,Position* cluster,<span class="built_in">int</span> clusterNum,<span class="built_in">int</span> m)&#123;</span><br><span class="line">    double res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;clusterNum;++i)</span><br><span class="line">        res+=(double)<span class="number">1</span>/<span class="built_in">pow</span>(<span class="built_in">pow</span>(pos.x-cluster[i].x,<span class="number">2</span>)+<span class="built_in">pow</span>(pos.y-cluster[i].y,<span class="number">2</span>),(double)<span class="number">1</span>/(m-<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//allPos:节点数组</span><br><span class="line">//cluster:聚类中心数组</span><br><span class="line">//u：隶属度矩阵</span><br><span class="line">//posNum：节点数量</span><br><span class="line">//clusterNum：聚类中心数量</span><br><span class="line">//m：隶属度因子</span><br><span class="line">void updateCluster(Position* allPos,Position* cluster,double** u,<span class="built_in">int</span> posNum,<span class="built_in">int</span> clusterNum,<span class="built_in">int</span> m)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;clusterNum;++i)&#123;</span><br><span class="line">        cluster[i].x=sumXi(u,allPos,posNum,i,m)/sumUi(u,posNum,i,m);</span><br><span class="line">        cluster[i].y=sumYi(u,allPos,posNum,i,m)/sumUi(u,posNum,i,m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//allPos:节点数组</span><br><span class="line">//cluster:聚类中心数组</span><br><span class="line">//u：隶属度矩阵</span><br><span class="line">//posNum：节点数量</span><br><span class="line">//clusterNum：聚类中心数量</span><br><span class="line">//m：隶属度因子</span><br><span class="line">void updateU(Position* allPos,Position* cluster,double** u,<span class="built_in">int</span> posNum,<span class="built_in">int</span> clusterNum,<span class="built_in">int</span> m)&#123;</span><br><span class="line">    double disXI;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;clusterNum;++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> x=<span class="number">0</span>;x&lt;posNum;++x)&#123;</span><br><span class="line">        disXI=<span class="built_in">pow</span>(<span class="built_in">pow</span>(allPos[x].x-cluster[i].x,<span class="number">2</span>)+<span class="built_in">pow</span>(allPos[x].y-cluster[i].y,<span class="number">2</span>),(double)<span class="number">1</span>/(m-<span class="number">1</span>));</span><br><span class="line">        u[i][x]=(double)<span class="number">1</span>/(disXI*sumDis(allPos[x],cluster,clusterNum,m));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//allPos:节点数组</span><br><span class="line">//cluster:聚类中心数组</span><br><span class="line">//u：隶属度矩阵</span><br><span class="line">//posNum：节点数量</span><br><span class="line">//clusterNum：聚类中心数量</span><br><span class="line">//m：隶属度因子</span><br><span class="line">void outpuCost_fun(Position* allPos,Position* cluster,double** u,<span class="built_in">int</span> posNum,<span class="built_in">int</span> clusterNum,<span class="built_in">int</span> m)&#123;</span><br><span class="line">    double res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;clusterNum;++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> x=<span class="number">0</span>;x&lt;posNum;++x)</span><br><span class="line">        res+=(<span class="built_in">pow</span>(u[i][x],m)*(<span class="built_in">pow</span>(allPos[x].x-cluster[i].x,<span class="number">2</span>)+<span class="built_in">pow</span>(allPos[x].y-cluster[i].y,<span class="number">2</span>)));</span><br><span class="line">    printf(<span class="string">&quot;costFun:%f\n&quot;</span>,res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void outputU(double** u,<span class="built_in">int</span> posNum,<span class="built_in">int</span> clusterNum)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;posNum;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> x=<span class="number">0</span>;x&lt;clusterNum;++x)</span><br><span class="line">            printf(<span class="string">&quot;u[%d][%d]:%f &quot;</span>,x,i,u[x][i]);</span><br><span class="line">        printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void fuzzy_Cmeans(<span class="built_in">int</span> posNum,<span class="built_in">int</span> clusterNum, <span class="built_in">int</span> m, <span class="built_in">int</span> iterTime,<span class="built_in">int</span> <span class="built_in">range</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Position* allPos=randomPosition(posNum,<span class="built_in">range</span>);</span><br><span class="line">    Position* cluster=(Position*)malloc(sizeof(Position)*clusterNum);</span><br><span class="line">    double** u=init(posNum,clusterNum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iterTime; ++i)</span><br><span class="line">    &#123;   </span><br><span class="line">        updateCluster(allPos,cluster,u,posNum,clusterNum,m);</span><br><span class="line">        updateU(allPos,cluster,u,posNum,clusterNum,m);</span><br><span class="line">        outpuCost_fun(allPos,cluster,u,posNum,clusterNum,m);</span><br><span class="line">        //outputU(u,posNum,clusterNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">    fuzzy_Cmeans(<span class="number">100</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">500</span>,<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>聚类算法</category>
      </categories>
      <tags>
        <tag>聚类算法</tag>
      </tags>
  </entry>
  <entry>
    <title>聚类分析</title>
    <url>/posts/8e5c6000.html</url>
    <content><![CDATA[<h2 id="聚类分析-Cluster-Analysis">聚类分析(Cluster Analysis)</h2>
<p>聚类分析指将物理或抽象对象的集合分组为由类似的对象组成的多个类的分析过程。它是一种重要的人类行为。聚类分析的目标就是在相似的基础上收集数据来分类。聚类源于很多领域，包括数学，计算机科学，统计学，生物学和经济学。在不同的应用领域，很多聚类技术都得到了发展，这些技术方法被用作描述数据，衡量不同数据源间的相似性，以及把数据源分类到不同的簇中。</p>
<p>聚类与分类的不同在于，聚类所要求划分的类是未知的。聚类是将数据分类到不同的类或者簇这样的一个过程，所以同一个簇中的对象有很大的相似性，而不同簇间的对象有很大的相异性。从统计学的观点看，聚类分析是通过数据建模简化数据的一种方法。传统的统计聚类分析方法包括系统聚类法、分解法、加入法、动态聚类法、有序样品聚类、有重叠聚类和模糊聚类等。采用k-均值、k-中心点等算法的聚类分析工具已被加入到许多著名的统计分析软件包中，如SPSS、SAS等。</p>
<p>从机器学习的角度讲，簇相当于隐藏模式。聚类是搜索簇的无监督学习过程。与分类不同，无监督学习不依赖预先定义的类或带类标记的训练实例，需要由聚类学习算法自动确定标记，而分类学习的实例或数据对象有类别标记。聚类是观察式学习，而不是示例式的学习。聚类分析是一种探索性的分析，在分类的过程中，人们不必事先给出一个分类的标准，聚类分析能够从样本数据出发，自动进行分类。聚类分析所使用方法的不同，常常会得到不同的结论。不同研究者对于同一组数据进行聚类分析，所得到的聚类数未必一致。从实际应用的角度看，聚类分析是数据挖掘的主要任务之一。而且聚类能够作为一个独立的工具获得数据的分布状况，观察每一簇数据的特征，集中对特定的聚簇集合作进一步地分析。聚类分析还可以作为其他算法（如分类和定性归纳算法）的预处理步骤。</p>
<p>聚类分析是一个富有挑战性的研究领域，对数据挖掘中聚类分析的一些要求:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>可伸缩性(scalability)。实际应用要求聚类算法能够处理大数据集，且时间复杂度不能太高(最好是多项式时间)，消耗的内存空间也有限。目前，为了将算法拓展到超大数据库(VLDB)领域，研究人员已经进行了许多有益的尝试，包括：增量式挖掘、可靠的采样、数据挤压(data squashing)等。其中，数据挤压技术首先通过扫描数据来获得数据的统计信息，然后在这些统计信息的基础上进行聚类分析。比如BIRCH 算法中使用CF树就是属于数据挤压技术。</p>
</li>
<li class="lvl-2">
<p>能够处理不同类型的属性。现实中的数据对象己远远超出关系型数据的范畴，比如空间数据、多媒体数据、遗传学数据、时间序列数据、文本数据、万维网上的数据、以及目前逐渐兴起的数据流。这些数据对象的属性类型往往是由多种数据类型综合而成的。</p>
</li>
<li class="lvl-2">
<p>能够发现任意形状的簇。</p>
</li>
<li class="lvl-2">
<p>尽量减少用于决定输入参数的领域知识。</p>
</li>
<li class="lvl-2">
<p>能够处理噪声数据及孤立点。</p>
</li>
<li class="lvl-2">
<p>对输入数据记录的顺序不敏感。</p>
</li>
<li class="lvl-2">
<p>高维性(high-dimensional)。一个数据集可能包含若干维。较高的维数给聚类分析带来两个问题：首先，不相关的属性削弱了数据汇聚的趋势，使得数据分布非常稀疏。尽管这种情况在低维空间中并不多见，但是随着维数的增加，不相关属性的出现概率及数量也会增加，最后导致数据空间中几乎不存在簇。其次，高维使得在低维中很有效的区分数据的标准在高维空间中失效了。如在高维空间中，数据点到最近邻点的距离与到其他点的距离没有多少分别，从而导致最近邻查询在高维空间中不稳定，此时若根据接近度来划分簇，结果是不可信的。</p>
</li>
<li class="lvl-2">
<p>能够根据用户指定的约束条件进行聚类。</p>
</li>
<li class="lvl-3">
<p>聚类结果具有可解释性和可用性。</p>
</li>
</ul>
<p>聚类分析是一种分类技术。与多元分析的其他方法相比，该方法较为粗糙，理论上还不完善，但应用方面取得了很大成功。与回归分析、判别分析一起被称为多元分析的三大方法。</p>
<p>聚类的目的——根据已知数据（ 一批观察个体的许多观测指标） ， 按照一定的数学公式计算各观察个体或变量（指标）之间亲疏关系的统计量（距离或相关系数等）。 根据某种准则（ 最短距离法、最长距离法、中间距离法、重心法等），使同一类内的差别较小，而类与类之间的差别较大，最终将观察个体或变量分为若干类。</p>
<p>根据分类的方法可将聚类分析分为：系统聚类、快速聚类、有序聚类。根据分类的对象可将聚类分析分为：Q型——样品聚类clustering for individuals；R型——指标聚类clustering for variables。</p>
<h3 id="应用示例-14">应用示例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> vstack </span><br><span class="line"><span class="keyword">from</span> scipy.cluster.vq <span class="keyword">import</span> kmeans,vq </span><br><span class="line"><span class="keyword">from</span> matplotlib.finance <span class="keyword">import</span> quotes_historical_yahoo_ochl </span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime </span><br><span class="line"></span><br><span class="line">start = datetime(<span class="number">2014</span>,<span class="number">7</span>,<span class="number">1</span>) </span><br><span class="line">end = datetime(<span class="number">2014</span>,<span class="number">9</span>,<span class="number">30</span>) </span><br><span class="line">listDji = [<span class="string">&#x27;AXP&#x27;</span>,<span class="string">&#x27;BA&#x27;</span>,<span class="string">&#x27;CAT&#x27;</span>,<span class="string">&#x27;CSCO&#x27;</span>,<span class="string">&#x27;CVX&#x27;</span>,<span class="string">&#x27;DD&#x27;</span>,<span class="string">&#x27;DIS&#x27;</span>,<span class="string">&#x27;GE&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;GS&#x27;</span>,<span class="string">&#x27;HD&#x27;</span>,<span class="string">&#x27;IBM&#x27;</span>, <span class="string">&#x27;INTC&#x27;</span>,<span class="string">&#x27;JNJ&#x27;</span>,<span class="string">&#x27;JPM&#x27;</span>,<span class="string">&#x27;KO&#x27;</span>,<span class="string">&#x27;MCD&#x27;</span>,<span class="string">&#x27;MMM&#x27;</span>,<span class="string">&#x27;MRK&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;MSFT&#x27;</span>,<span class="string">&#x27;NKE&#x27;</span>,<span class="string">&#x27;PFE&#x27;</span>,<span class="string">&#x27;PG&#x27;</span>,<span class="string">&#x27;T&#x27;</span>,<span class="string">&#x27;TRV&#x27;</span>, <span class="string">&#x27;UNH&#x27;</span>,<span class="string">&#x27;UTX&#x27;</span>,<span class="string">&#x27;V&#x27;</span>,<span class="string">&#x27;VZ&#x27;</span>,<span class="string">&#x27;WMT&#x27;</span>,<span class="string">&#x27;XOM&#x27;</span>]    <span class="comment">#30家公司代号</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;初始化两个二维数组&#x27;&#x27;&#x27;</span></span><br><span class="line">quotes = [ [<span class="number">0</span> <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">90</span>)] <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>)] </span><br><span class="line">listTemp = [ [<span class="number">0</span> <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">90</span>)] <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>)]      </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>):</span><br><span class="line">    quotes[i] = quotes_historical_yahoo_ochl(listDji[i], start, end)       <span class="comment">#摘录数据，放入quotes</span></span><br><span class="line"></span><br><span class="line">days = <span class="built_in">len</span>(quotes[<span class="number">0</span>])                                           </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(days-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> (quotes[i][j][<span class="number">2</span>] <span class="keyword">and</span> quotes[i][j+<span class="number">1</span>][<span class="number">2</span>] <span class="keyword">and</span> (quotes[i][j+<span class="number">1</span>][<span class="number">2</span>]&gt;=quotes[i][j][<span class="number">2</span>])):    <span class="comment">#比较前后两天的收盘价</span></span><br><span class="line">            listTemp[i][j] = <span class="number">1.0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            listTemp[i][j] = -<span class="number">1.0</span> </span><br><span class="line"></span><br><span class="line">data = vstack(listTemp) </span><br><span class="line">centroids,_ = kmeans(data,<span class="number">4</span>) <span class="comment">#float or double is supported  </span></span><br><span class="line">result,_= vq(data,centroids) </span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>聚类算法</category>
      </categories>
      <tags>
        <tag>聚类算法</tag>
      </tags>
  </entry>
  <entry>
    <title>聚类算法简介</title>
    <url>/posts/c20ad0d2.html</url>
    <content><![CDATA[<h2 id="聚类算法">聚类算法</h2>
<p>聚类分析又称群分析，它是研究（样品或指标）分类问题的一种统计分析方法，同时也是数据挖掘的一个重要算法。聚类（Cluster）分析是由若干模式（Pattern）组成的，通常，模式是一个度量（Measurement）的向量，或者是多维空间中的一个点。聚类分析以相似性为基础，在一个聚类中的模式之间比不在同一聚类中的模式之间具有更多的相似性。</p>
<p>聚类算法是一种非监督学习。聚类分析起源于分类学，在古老的分类学中，人们主要依靠经验和专业知识来实现分类，很少利用数学工具进行定量的分类。随着人类科学技术的发展，对分类的要求越来越高，以致有时仅凭经验和专业知识难以确切地进行分类，于是人们逐渐地把数学工具引用到了分类学中，形成了数值分类学，之后又将多元分析的技术引入到数值分类学形成了聚类分析。聚类分析内容非常丰富，有系统聚类法、有序样品聚类法、动态聚类法、模糊聚类法、图论聚类法、聚类预报法等。</p>
<p>许多聚类算法在执行之前，需要指定从输入数据集中产生的分类个数。除非事先准备好一个合适的值，否则必须决定一个大概值，关于这个问题已经有一些现成的技术。</p>
<p>聚类算法主要可分为：划分方法（partitioning method），层次方法(hierarchical method)，基于密度的方法(density-basedmethod)，基于网格的方法(grid-based method)，和基于模型的方法(model-based method)。</p>
<p>聚类算法(Cluster analysis)的应用算法有：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>K-均值(K-Means Algorithm)</p>
</li>
<li class="lvl-2">
<p>模糊聚类Fuzzy Clustering</p>
</li>
<li class="lvl-2">
<p>期望最大化(Expectation-Maximization)</p>
</li>
<li class="lvl-2">
<p>聚类分析(Cluster Analysis)</p>
</li>
</ul>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>聚类算法</category>
      </categories>
      <tags>
        <tag>聚类算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Hopfield网络</title>
    <url>/posts/61877bd0.html</url>
    <content><![CDATA[<h2 id="Hopfield网络-Hopfield-Network">Hopfield网络(Hopfield Network)</h2>
<p>Hopfield神经网络是一种递归神经网络，由约翰·霍普菲尔德在1982年发明。Hopfield网络是一种结合存储系统和二元系统的神经网络。它保证了向局部极小的收敛，但收敛到错误的局部极小值（local minimum），而非全局极小（global minimum）的情况也可能发生。Hopfield网络也提供了模拟人类记忆的模型。</p>
<p>Hopfield提出了连续和离散的Hopfield神经网络模型，并采用全互联型神经网络尝试对非多项式复杂度的旅行商问题（Travelling Salesman Problem，TSP）进行了求解，促进神经网络的研究再次进入了蓬勃发展的时期。</p>
<p>Hopfield强调工程实践的重要性，他利用电阻、电容和运算放大器等元件组成的模拟电路实现了对网络神经元的描述，把最优化问题的目标函数转换成Hopfield神经网络的能量函数，通过网络能量函数最小化来寻找对应问题的最优解．Hopfield网络是一种循环神经网络，从输出到输入有反馈连接，典型的Hopfield神经网络模型如图所示．</p>
<p align="center">
<img width="300" align="center" src="/img/images/92.jpg" />
</p>
在图中每组运算放大器及其相关的电阻、电容组成的网络代表一个神经元。每个神经元有两组输入，一组是恒定的外部电流，另一组是来自其他运算放大器输出的正向或反向的反馈连接。假设第i个神经元的内部膜电位为Ui(i=1,2,…,n)，细胞膜的输入电容和传递电阻分别为Ci和Ri，神经元的输出电位为Vi，外部输入电流为Ii，并用电阻Rij(i，j=1,2,…,n)来模拟第i个和第j个神经元之间的突触特性。由基尔霍夫电流定律(Kirchhoff’s Cureent Law ,KCL)可知，放大器输入节点处的流入电流和流出电流保持平衡，亦即有下式成立：
<p align="center">
<img width="300" align="center" src="/img/images/93.jpg" />
</p>
同时，每一个运算放大器模拟了神经元输入和输出之间的非线性特性，即有
<p align="center">
<img width="300" align="center" src="/img/images/94.jpg" />
</p>
<p>其中，fi代表了第i个神经元的传递函数，并定义W=Rij-1 （i,j＝1,2,…,n）为网络的权系数矩阵．为证明连续型网络的稳定性，Hopfield定义了如下的能量函数：</p>
<p align="center">
<img width="300" align="center" src="/img/images/95.jpg" />
</p>
<p>其中，f-1为神经元传递函数的反函数．经过推导后得出以下两点结论：一是对于具有单调递增传递函数且对称权系数矩阵的网络来说，其能量会随着时间的变化而趋于稳定；二是当且仅当网络中所有神经元的输出不再随时间变化时，则可以认为网络的能量保持不变。在将网络用于求解诸如旅行商的组合优化问题时，Hopfield将优化的目标函数转化为网络的能量函数，对应地将待求解问题的变量用网络中神经元的状态来表示。由这样的表示方式可知当网络的能量衰减到稳定值时，问题的最优解也随之求出。</p>
<p>Hopfield网络按网络输入和输出的数字形式不同可分为离散型和连续型两种网络,即：离散型Hopfield神经网络----DHNN(Discrete Hopfield Neural Network)；连续型Hopfield神经网络----CHNN(ContinuesHopfield Neural Network)。</p>
<p>DHNN结构：它是一种单层全反馈网络,共有n个神经元。每个神经元都通过连接权接收所有其它神经元输出反馈来的信息，其目的是为了让任一神经元的输出能接受所有神经元输出的控制,从而使各神经元能相互制约。</p>
<p>DHNN的设计原则：吸引子的分布是由网络的权值（包括阀值）决定的，设计吸引子的核心就是如何设计一组合适的权值。为了使所设计的权值满足要求，权值矩阵应符合以下要求：(1)为保证异步方式工作时网络收敛，W应为对称阵；(2)为保证同步方式工作时网络收敛，W应为非负定对称阵；(3)保证给定的样本是网络的吸引子，并且要有一定的吸引域。</p>
<p>具体设计时，可以采用不同的方法：(1)联立方程法；(2)外积和法。</p>
<p>CHNN：在连续型Hopfield神经网络中，所有神经元都随时间t并行更新，网络状态随时间连续改变。</p>
<h3 id="优缺点-9">优缺点</h3>
<p>Hopfield网络是一种非线性的动力网络，可通过反复的网络动态迭代来求解问题，这是符号逻辑方法所不具有的特性。在求解某些问题时，其求解问题的方法与人类求解问题的方法很相似，虽然所求得的解不是最佳解，但其求解速度快，更符合人们日常解决问题的策略。</p>
<p>Hopfield神经网络的提出就是与其实际应用密切相关。具有联系记忆的功能，具体为：</p>
<p>联想记忆：输入–输出模式的各元素之间，并不存在一对一的映射关系，输入–输出模式的维数也不要求相同；联想记忆时，只给出输入模式部分信息，就能联想出完整的输出模式。即具有容错性。</p>
<h3 id="应用领域-3">应用领域</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint, shuffle</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InvalidWeightsException</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InvalidNetworkInputException</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HopfieldNetwork</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_inputs</span>):</span><br><span class="line">        self._num_inputs = num_inputs</span><br><span class="line">        self._weights = np.random.uniform(-<span class="number">1.0</span>, <span class="number">1.0</span>, (num_inputs, num_inputs))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_weights</span>(<span class="params">self, weights</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Update the weights array&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> weights.shape != (self._num_inputs, self._num_inputs):</span><br><span class="line">            <span class="keyword">raise</span> InvalidWeightsException()</span><br><span class="line"></span><br><span class="line">        self._weights = weights</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_weights</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return the weights array&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._weights</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate_neuron_output</span>(<span class="params">self, neuron, input_pattern</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Calculate the output of the given neuron&quot;&quot;&quot;</span></span><br><span class="line">        num_neurons = <span class="built_in">len</span>(input_pattern)</span><br><span class="line"></span><br><span class="line">        s = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_neurons):</span><br><span class="line">            s += self._weights[neuron][j] * input_pattern[j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span> <span class="keyword">if</span> s &gt; <span class="number">0.0</span> <span class="keyword">else</span> -<span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run_once</span>(<span class="params">self, update_list, input_pattern</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Iterate over every neuron and update it&#x27;s output&quot;&quot;&quot;</span></span><br><span class="line">        result = input_pattern.copy()</span><br><span class="line"></span><br><span class="line">        changed = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> neuron <span class="keyword">in</span> update_list:</span><br><span class="line">            neuron_output = self.calculate_neuron_output(neuron, result)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> neuron_output != result[neuron]:</span><br><span class="line">                result[neuron] = neuron_output</span><br><span class="line">                changed = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> changed, result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, input_pattern, max_iterations=<span class="number">10</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Run the network using the input data until the output state doesn&#x27;t change</span></span><br><span class="line"><span class="string">        or a maximum number of iteration has been reached.&quot;&quot;&quot;</span></span><br><span class="line">        iteration_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        result = input_pattern.copy()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            update_list = <span class="built_in">range</span>(self._num_inputs)</span><br><span class="line">            shuffle(update_list)</span><br><span class="line"></span><br><span class="line">            changed, result = self.run_once(update_list, result)</span><br><span class="line"></span><br><span class="line">            iteration_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> changed <span class="keyword">or</span> iteration_count == max_iterations:</span><br><span class="line">                <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>神经网络算法</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>卷积神经网络</title>
    <url>/posts/c6767314.html</url>
    <content><![CDATA[<h2 id="卷积神经网络-Convolutional-Neural-Network">卷积神经网络(Convolutional Neural Network)</h2>
<p>卷积神经网络（Convolutional Neural Network,CNN）是一种前馈神经网络，它的人工神经元可以响应一部分覆盖范围内的周围单元，对于大型图像处理有出色表现。 它包括卷积层(convolutional layer)和池化层(pooling layer)。</p>
<p>卷积神经网络是近年发展起来，并引起广泛重视的一种高效识别方法。20世纪60年代，Hubel和Wiesel在研究猫脑皮层中用于局部敏感和方向选择的神经元时发现其独特的网络结构可以有效地降低反馈神经网络的复杂性，继而提出了卷积神经网络（Convolutional Neural Networks-简称CNN）。现在，CNN已经成为众多科学领域的研究热点之一，特别是在模式分类领域，由于该网络避免了对图像的复杂前期预处理，可以直接输入原始图像，因而得到了更为广泛的应用。 K.Fukushima在1980年提出的新识别机是卷积神经网络的第一个实现网络。随后，更多的科研工作者对该网络进行了改进。其中，具有代表性的研究成果是Alexander和Taylor提出的“改进认知机”，该方法综合了各种改进方法的优点并避免了耗时的误差反向传播。</p>
<p>CNN的基本结构包括两层，其一为特征提取层，每个神经元的输入与前一层的局部接受域相连，并提取该局部的特征。一旦该局部特征被提取后，它与其它特征间的位置关系也随之确定下来；其二是特征映射层，网络的每个计算层由多个特征映射组成，每个特征映射是一个平面，平面上所有神经元的权值相等。特征映射结构采用影响函数核小的sigmoid函数作为卷积网络的激活函数，使得特征映射具有位移不变性。此外，由于一个映射面上的神经元共享权值，因而减少了网络自由参数的个数。卷积神经网络中的每一个卷积层都紧跟着一个用来求局部平均与二次提取的计算层，这种特有的两次特征提取结构减小了特征分辨率。</p>
<p>CNN主要用来识别位移、缩放及其他形式扭曲不变性的二维图形。由于CNN的特征检测层通过训练数据进行学习，所以在使用CNN时，避免了显式的特征抽取，而隐式地从训练数据中进行学习；再者由于同一特征映射面上的神经元权值相同，所以网络可以并行学习，这也是卷积网络相对于神经元彼此相连网络的一大优势。卷积神经网络以其局部权值共享的特殊结构在语音识别和图像处理方面有着独特的优越性，其布局更接近于实际的生物神经网络，权值共享降低了网络的复杂性，特别是多维输入向量的图像可以直接输入网络这一特点避免了特征提取和分类过程中数据重建的复杂度。</p>
<p align="center">
<img width="330" align="center" src="/img/images/1.jpg" />
</p>
#### 应用示例
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.signal <span class="keyword">as</span> signal</span><br><span class="line"><span class="keyword">import</span> cPickle</span><br><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"><span class="keyword">import</span> scipy</span><br><span class="line"><span class="comment">#import objgraph  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line">    <span class="string">&#x27;激励函数&#x27;</span></span><br><span class="line">    out=<span class="number">1.7159</span>*scipy.tanh(<span class="number">2.0</span>/<span class="number">3.0</span>*<span class="built_in">input</span>)</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dsigmoid</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line">    <span class="string">&#x27;sigmoid的导函数已知input=sigmod(out)&#x27;</span></span><br><span class="line">    out=<span class="number">2.0</span>/<span class="number">3.0</span>/<span class="number">1.7159</span>*(<span class="number">1.7159</span>+<span class="built_in">input</span>)*(<span class="number">1.7159</span>-<span class="built_in">input</span>)</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convolutional</span>(<span class="params">fm,ct,kernel,bias</span>):</span><br><span class="line">    <span class="string">&#x27;卷积函数&#x27;</span></span><br><span class="line">    <span class="string">&quot;fm 特征图 三维&quot;</span></span><br><span class="line">    <span class="string">&quot;ct 连接权矩阵&quot;</span></span><br><span class="line">    <span class="string">&quot;kernel 卷积核 三维&quot;</span></span><br><span class="line">    <span class="string">&quot;bias 偏置 向量&quot;</span></span><br><span class="line">    map_width=fm.shape[<span class="number">2</span>]</span><br><span class="line">    map_height=fm.shape[<span class="number">1</span>]</span><br><span class="line">    kernel_width=kernel.shape[<span class="number">2</span>]</span><br><span class="line">    kernel_height=kernel.shape[<span class="number">1</span>]</span><br><span class="line">    <span class="string">&#x27;计算特征图的尺寸&#x27;</span></span><br><span class="line">    dst_height=map_height-kernel_height+<span class="number">1</span></span><br><span class="line">    dst_width=map_width-kernel_width+<span class="number">1</span></span><br><span class="line">    <span class="string">&#x27;计算输出特征图的数量&#x27;</span></span><br><span class="line">    cfmDims=np.<span class="built_in">max</span>(ct[<span class="number">1</span>])+<span class="number">1</span></span><br><span class="line">    n_kernels=kernel.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">#print(&quot;ct&#x27;s shape%d:%d&quot;%(ct.shape[0],ct.shape[1]))</span></span><br><span class="line">    <span class="string">&#x27; 初始化结果特征图&#x27;</span> </span><br><span class="line">    cfm=np.zeros((cfmDims,dst_height,dst_width))</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> xrange(<span class="number">0</span>,cfmDims):</span><br><span class="line">        <span class="string">&quot;首先加上偏置值&quot;</span></span><br><span class="line">        cfm[index]+=bias[index]</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> xrange(<span class="number">0</span>,n_kernels):</span><br><span class="line">        <span class="comment">#print(index)</span></span><br><span class="line">        this_fm=fm[ct[<span class="number">0</span>,index]]</span><br><span class="line">        this_kernel=kernel[index]</span><br><span class="line">        <span class="string">&quot;计算卷积&quot;</span></span><br><span class="line">        this_conv=signal.convolve2d(this_fm, this_kernel, mode=<span class="string">&#x27;valid&#x27;</span>)</span><br><span class="line">        cfm_index=ct[<span class="number">1</span>,index]</span><br><span class="line">        cfm[cfm_index]+=this_conv</span><br><span class="line">    <span class="string">&quot;使用sigmoid压制&quot;</span></span><br><span class="line">    <span class="keyword">return</span> sigmoid(cfm)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">subsampling</span>(<span class="params">fm,sW,sb,pool_size,pool_stride</span>):</span><br><span class="line">    <span class="string">&quot;重采样函数&quot;</span></span><br><span class="line">    <span class="string">&quot;fm 特征图&quot;</span></span><br><span class="line">    <span class="string">&quot;sW 重采样权值 向量&quot;</span></span><br><span class="line">    <span class="string">&quot;sb 重采样偏置 向量&quot;</span></span><br><span class="line">    <span class="string">&quot;pool_size 重采样窗口大小 二维矩阵&quot;</span></span><br><span class="line">    <span class="string">&quot;pool_stride 步长 int&quot;</span></span><br><span class="line">    sfm_width=<span class="built_in">int</span>((fm.shape[<span class="number">2</span>]-pool_size[<span class="number">1</span>])/pool_stride)+<span class="number">1</span></span><br><span class="line">    sfm_height=<span class="built_in">int</span>((fm.shape[<span class="number">1</span>]-pool_size[<span class="number">0</span>])/pool_stride)+<span class="number">1</span></span><br><span class="line">    sfmDims=fm.shape[<span class="number">0</span>]</span><br><span class="line">    sfm=np.zeros((sfmDims,sfm_width,sfm_height))</span><br><span class="line">    <span class="comment">#sfm=[]</span></span><br><span class="line">    <span class="string">&quot;使用权值为1的核进行采样&quot;</span></span><br><span class="line">    kernel=np.ones(pool_size)</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> xrange(<span class="number">0</span>,sfmDims):</span><br><span class="line">        this_fm=fm[index]</span><br><span class="line">        this_kernel=kernel*sW[index]</span><br><span class="line">        <span class="string">&quot;采样实际就是一次卷积过程&quot;</span></span><br><span class="line">        this_sfm=signal.convolve2d(this_fm, this_kernel, mode=<span class="string">&#x27;valid&#x27;</span>)</span><br><span class="line">        sfm[index]=copy_fm(this_sfm,pool_stride)</span><br><span class="line">        sfm[index]=sfm[index]+sb[index]</span><br><span class="line">    sfm=sigmoid(sfm)</span><br><span class="line">    <span class="keyword">return</span> sfm</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">copy_fm</span>(<span class="params">fm,stride</span>):</span><br><span class="line">    height=fm.shape[<span class="number">0</span>]</span><br><span class="line">    width=fm.shape[<span class="number">1</span>]</span><br><span class="line">    result=[]</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> xrange(<span class="number">0</span>,height,stride):</span><br><span class="line">        y_result=[]</span><br><span class="line">        y_data=fm[y]</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">0</span>,width,stride):</span><br><span class="line">            y_result.append(y_data[x])</span><br><span class="line">        result.append(y_result)</span><br><span class="line">    <span class="keyword">return</span> np.array(result)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">max_with_index</span>(<span class="params">value</span>):</span><br><span class="line">    <span class="string">&quot;返回最大值，及最大值的下标&quot;</span></span><br><span class="line">    <span class="string">&quot;结果 [下标,最大值]&quot;</span></span><br><span class="line">    d=np.<span class="built_in">max</span>(value)</span><br><span class="line">    i=np.argmax(value)</span><br><span class="line">    <span class="keyword">return</span> [i,d]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">grade</span>(<span class="params">dout,out,<span class="built_in">input</span>,w</span>):</span><br><span class="line">    dout=dout*dsigmoid(out)</span><br><span class="line">    db=dout</span><br><span class="line">    dw=np.zeros(w.shape)</span><br><span class="line">    out=out*dsigmoid(out)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(w.shape[<span class="number">1</span>]):</span><br><span class="line">        dw[:,i]=dout[i]*<span class="built_in">input</span></span><br><span class="line">    din=np.zeros(<span class="built_in">input</span>.shape)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(db.shape[<span class="number">0</span>]):</span><br><span class="line">        this_kernel=w[:,i]</span><br><span class="line">        <span class="comment">#print(&quot;this kernrl:%s\n&quot;%(this_kernel))</span></span><br><span class="line">        this_dout=dout[i]*this_kernel</span><br><span class="line">        <span class="comment">#print(&quot;this dout: %s&quot;%(this_dout))</span></span><br><span class="line">        din+=this_dout</span><br><span class="line">    <span class="keyword">return</span> [din,dw,db]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dconv2_in</span>(<span class="params">dout,<span class="built_in">input</span>,kernel</span>):</span><br><span class="line">    <span class="keyword">return</span> signal.convolve2d(dout,kernel,mode=<span class="string">&#x27;full&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dconv2_kernel</span>(<span class="params">dout,<span class="built_in">input</span>,kernel</span>):</span><br><span class="line">    <span class="keyword">return</span> signal.convolve2d(<span class="built_in">input</span>,dout,mode=<span class="string">&#x27;valid&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initWeight</span>(<span class="params">ct,kernel_shape</span>):</span><br><span class="line">    kernel_num=ct[<span class="number">0</span>].shape[<span class="number">0</span>]</span><br><span class="line">    kernel_height=kernel_shape[<span class="number">0</span>]</span><br><span class="line">    kernel_width=kernel_shape[<span class="number">1</span>]</span><br><span class="line">    weights=np.zeros((kernel_num,kernel_height,kernel_width))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(kernel_num):</span><br><span class="line">        connected=np.array((ct[<span class="number">1</span>]==ct[<span class="number">0</span>,i]),dtype=<span class="string">&#x27;int&#x27;</span>)</span><br><span class="line">        connected=np.array(np.nonzero(connected))</span><br><span class="line">        connected=connected.shape[<span class="number">0</span>]</span><br><span class="line">        fanin=connected*kernel_height*kernel_width</span><br><span class="line">        sd=<span class="number">1.0</span>/np.sqrt(fanin)</span><br><span class="line">        weights[i]=-<span class="number">1.0</span>*sd+<span class="number">2</span>*sd*np.random.random_sample((kernel_height,kernel_width))</span><br><span class="line">    <span class="keyword">return</span> weights    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">convlayer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,cw,cb,sw,sb,ct,stride</span>):</span><br><span class="line">        self.sw=sw</span><br><span class="line">        self.sb=sb</span><br><span class="line">        self.cw=cw</span><br><span class="line">        self.cb=cb</span><br><span class="line">        self.ct=ct</span><br><span class="line">        self.stride=stride</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bplayer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n_in,n_out</span>):</span><br><span class="line">        sd=<span class="number">1.0</span>/np.sqrt(n_in)</span><br><span class="line">        self.w=-sd+<span class="number">2</span>*sd*np.random.random_sample((n_in,n_out))</span><br><span class="line">        self.b=np.zeros(n_out)</span><br><span class="line">        self.n_in=n_in</span><br><span class="line">        self.n_out=n_out</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">convnet</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,image_shape</span>):</span><br><span class="line">        self.eta=<span class="number">0.01</span></span><br><span class="line">        self.decay=<span class="number">0.8</span></span><br><span class="line">        self.step=<span class="number">2</span></span><br><span class="line">        ct1=np.array([[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]])</span><br><span class="line">        ct2=np.array([[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                      [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                      [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                      [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]])</span><br><span class="line">        ct1=np.transpose(ct1)</span><br><span class="line">        ct2=np.transpose(ct2)</span><br><span class="line">        conv_ct1=np.nonzero(ct1)</span><br><span class="line">        conv_ct1=np.array((conv_ct1[<span class="number">1</span>],conv_ct1[<span class="number">0</span>]))</span><br><span class="line">        conv_ct2=np.nonzero(ct2)</span><br><span class="line">        conv_ct2=np.array((conv_ct2[<span class="number">1</span>],conv_ct2[<span class="number">0</span>]))</span><br><span class="line">        image_height=image_shape[<span class="number">0</span>]</span><br><span class="line">        image_width=image_shape[<span class="number">1</span>]</span><br><span class="line">        self.image_shape=image_shape</span><br><span class="line">        self.kernel_shape=[<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line">        self.pool_shape=[<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">        self.stride=<span class="number">2</span></span><br><span class="line">        stride=self.stride</span><br><span class="line">        kernel_height=self.kernel_shape[<span class="number">0</span>]</span><br><span class="line">        kernel_width=self.kernel_shape[<span class="number">1</span>]</span><br><span class="line">        pool_height=self.pool_shape[<span class="number">0</span>]</span><br><span class="line">        pool_width=self.pool_shape[<span class="number">1</span>]</span><br><span class="line">        nofms1=ct1.shape[<span class="number">0</span>]</span><br><span class="line">        <span class="string">&quot;初始化卷积层1&quot;</span></span><br><span class="line">        cmfHeight1=image_height-kernel_height+<span class="number">1</span></span><br><span class="line">        cfmWidth1=image_width-kernel_width+<span class="number">1</span></span><br><span class="line">        conv_layer1_cw=initWeight(conv_ct1, self.kernel_shape)</span><br><span class="line">        conv_layer2_cb=np.zeros(nofms1)</span><br><span class="line">        sfmHeight1=((cmfHeight1-pool_height)/stride)+<span class="number">1</span></span><br><span class="line">        sfmWidth1=((cfmWidth1-pool_width)/stride)+<span class="number">1</span></span><br><span class="line">        fanin=pool_height*pool_width</span><br><span class="line">        sd=<span class="number">1.0</span>/np.sqrt(fanin)</span><br><span class="line">        conv_layer1_sw=-sd+<span class="number">2</span>*sd*np.random.random_sample(nofms1)</span><br><span class="line">        conv_layer1_sb=np.zeros(nofms1)</span><br><span class="line">        self.conv1=convlayer(conv_layer1_cw,conv_layer2_cb,conv_layer1_sw,conv_layer1_sb,conv_ct1,stride)</span><br><span class="line">        <span class="string">&quot;初始化卷基层2&quot;</span></span><br><span class="line">        nofms2=ct2.shape[<span class="number">0</span>]</span><br><span class="line">        conv_layer2_cw=initWeight(conv_ct2, self.kernel_shape)</span><br><span class="line">        conv_layer2_cb=np.zeros(nofms2)</span><br><span class="line">        cfmHeight2=sfmHeight1-kernel_height+<span class="number">1</span></span><br><span class="line">        cfmWidth2=sfmWidth1-kernel_width+<span class="number">1</span></span><br><span class="line">        sfmHeight2=((cfmHeight2-pool_height)/stride)+<span class="number">1</span></span><br><span class="line">        sfmWidth2=((cfmWidth2-pool_width)/stride)+<span class="number">1</span></span><br><span class="line">        fanin=pool_width*pool_height</span><br><span class="line">        sd=<span class="number">1.0</span>/np.sqrt(fanin)</span><br><span class="line">        conv_layer2_sw=-sd+<span class="number">2</span>*sd*np.random.random_sample(nofms2)</span><br><span class="line">        conv_layer2_sb=np.zeros(nofms2)</span><br><span class="line">        self.conv2=convlayer(conv_layer2_cw,conv_layer2_cb,conv_layer2_sw,conv_layer2_sb,conv_ct2,stride)</span><br><span class="line">        <span class="string">&quot;BP分类器第一层&quot;</span></span><br><span class="line">        self.bp1=bplayer(nofms2*sfmHeight2*sfmWidth2,<span class="number">20</span>)</span><br><span class="line">        self.bp2=bplayer(<span class="number">20</span>,<span class="number">10</span>)</span><br><span class="line">        self.noErrors=<span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forwardPropConv</span>(<span class="params">self,<span class="built_in">input</span></span>):</span><br><span class="line">        <span class="string">&quot;开始第一层的卷积操作&quot;</span></span><br><span class="line">        ct=self.conv1.ct</span><br><span class="line">        cw=self.conv1.cw</span><br><span class="line">        cb=self.conv1.cb</span><br><span class="line">        cfm1=convolutional(<span class="built_in">input</span>, ct, cw, cb)</span><br><span class="line">        sw=self.conv1.sw</span><br><span class="line">        sb=self.conv1.sb</span><br><span class="line">        sfm1=subsampling(cfm1, sw, sb, self.pool_shape, self.stride)</span><br><span class="line">        <span class="string">&quot;开始第二层的卷积操作&quot;</span></span><br><span class="line">        ct=self.conv2.ct</span><br><span class="line">        cw=self.conv2.cw</span><br><span class="line">        cb=self.conv2.cb</span><br><span class="line">        cfm2=convolutional(sfm1, ct, cw, cb)</span><br><span class="line">        sw=self.conv2.sw</span><br><span class="line">        sb=self.conv2.sb</span><br><span class="line">        sfm2=subsampling(cfm2, sw, sb, self.pool_shape, self.stride)</span><br><span class="line">        <span class="keyword">return</span> [cfm1,sfm1,cfm2,sfm2]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forwradPropBp</span>(<span class="params">self,<span class="built_in">input</span></span>):</span><br><span class="line">        <span class="string">&quot;开始第一层分类器的操作&quot;</span></span><br><span class="line">        w=self.bp1.w</span><br><span class="line">        b=self.bp1.b</span><br><span class="line">        out1=np.dot(<span class="built_in">input</span>,w)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(b.shape[<span class="number">0</span>]):</span><br><span class="line">            out1[i]+=b[i]</span><br><span class="line">        out1=sigmoid(out1)</span><br><span class="line">        <span class="string">&quot;开始第二层的操作&quot;</span></span><br><span class="line">        w=self.bp2.w</span><br><span class="line">        b=self.bp2.b</span><br><span class="line">        out2=np.dot(out1,w)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(b.shape[<span class="number">0</span>]):</span><br><span class="line">            out2[i]+=b[i]</span><br><span class="line">        out2=sigmoid(out2)</span><br><span class="line">        <span class="keyword">return</span> [out1,out2]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backPropBp</span>(<span class="params">self,sfm,tartget,fm1,fm2,w1,w2,b1,b2</span>):</span><br><span class="line">        <span class="string">&quot;对BP层进行反向传播&quot;</span></span><br><span class="line">        <span class="string">&quot;sfm 卷积层的S神经元的输出&quot;</span></span><br><span class="line">        <span class="string">&quot;target 目标值&quot;</span></span><br><span class="line">        <span class="string">&quot;fm1 BP层第一层输出&quot;</span></span><br><span class="line">        <span class="string">&quot;fm2 BP层第二层输出&quot;</span></span><br><span class="line">        <span class="string">&quot;w1 b1 第一层参数&quot;</span></span><br><span class="line">        <span class="string">&quot;w2 b2 第二层参数&quot;</span></span><br><span class="line">        dtarget=-np.ones(self.bp2.n_out)*<span class="number">0.8</span></span><br><span class="line">        dtarget[target]=<span class="number">0.8</span></span><br><span class="line">        dfm2=np.zeros(self.bp2.n_out)</span><br><span class="line">        dfm2=dfm2-dtarget</span><br><span class="line">        dmf2=dfm2*dsigmoid(dfm2)</span><br><span class="line">        dfm1,dw2,db2=grade(dfm2,fm2,fm1,w2)</span><br><span class="line">        dsfm,dw1,db1=grade(dfm1,fm1,sfm,w1)</span><br><span class="line">        <span class="keyword">return</span> [dsfm,dw1,db1,dw2,db2]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backPropSubsampling</span>(<span class="params">self,dsfm,sfm,cfm,sw,sb,pool_shape,stride</span>):</span><br><span class="line">        <span class="string">&quot;对S神经元进行反向传播&quot;</span></span><br><span class="line">        <span class="string">&quot;dsfm s神经元的输出的偏导数&quot;</span></span><br><span class="line">        <span class="string">&quot;sfm s神经元的输出&quot;</span></span><br><span class="line">        <span class="string">&quot;cfm 上层c神经元的输出&quot;</span></span><br><span class="line">        <span class="string">&quot;sw sb 神经元参数&quot;</span></span><br><span class="line">        <span class="string">&quot;pool_shape 采样窗口&quot;</span></span><br><span class="line">        <span class="string">&quot;stride 采样步长&quot;</span></span><br><span class="line">        dims,height,width=cfm.shape</span><br><span class="line">        dfm=np.zeros(cfm.shape)</span><br><span class="line">        dsw=np.zeros(sw.shape)</span><br><span class="line">        dsb=np.zeros(sb.shape)</span><br><span class="line">        dsfm=dsfm*dsigmoid(sfm)</span><br><span class="line">        kernel=np.ones(pool_shape)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(dims):</span><br><span class="line">            this_dsfm=dsfm[i]</span><br><span class="line">            dthis_kernel=kernel*sw[i]</span><br><span class="line">            dsb[i]=np.<span class="built_in">sum</span>(this_dsfm)</span><br><span class="line">            cfm_height=height-pool_shape[<span class="number">0</span>]+<span class="number">1</span></span><br><span class="line">            cfm_width=width-pool_shape[<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">            <span class="comment">#print(&quot;height:%d,width:%d\n&quot;%(cfm_height,cfm_width))</span></span><br><span class="line">            dsfm_beforeSubsampling=np.zeros((cfm_height, cfm_width))</span><br><span class="line">            y=<span class="number">0</span></span><br><span class="line">            x=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> dy <span class="keyword">in</span> xrange(<span class="number">0</span>,dsfm_beforeSubsampling.shape[<span class="number">0</span>],stride):</span><br><span class="line">                x=<span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> dx <span class="keyword">in</span> xrange(<span class="number">0</span>,dsfm_beforeSubsampling.shape[<span class="number">1</span>],stride):</span><br><span class="line">                    dsfm_beforeSubsampling[dy,dx]=this_dsfm[y,x]</span><br><span class="line">                    x+=<span class="number">1</span></span><br><span class="line">                y+=<span class="number">1</span></span><br><span class="line">            dfm[i]=dconv2_in(dsfm_beforeSubsampling,cfm[i],dthis_kernel)</span><br><span class="line">            dsw[i]=np.<span class="built_in">sum</span>(dthis_kernel)</span><br><span class="line">        <span class="keyword">return</span> [dfm,dsw,dsb]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backPropConvulution</span>(<span class="params">self,dcfm,cfm,fm,ct,w,b</span>):</span><br><span class="line">        dfm=np.zeros(fm.shape)</span><br><span class="line">        dw=np.zeros(w.shape)</span><br><span class="line">        db=np.zeros(b.shape)</span><br><span class="line">        dcfm=dcfm*dsigmoid(cfm)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(b.shape[<span class="number">0</span>]):</span><br><span class="line">            this_dcfm=dcfm[i]</span><br><span class="line">            db[i]=np.<span class="built_in">sum</span>(this_dcfm)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(w.shape[<span class="number">0</span>]):</span><br><span class="line">            this_fm=fm[ct[<span class="number">0</span>,i]]</span><br><span class="line">            this_w=w[i]</span><br><span class="line">            this_dcfm=dcfm[ct[<span class="number">1</span>,i]]</span><br><span class="line">            this_dfm=dconv2_in(this_dcfm,this_fm,this_w)</span><br><span class="line">            dfm[ct[<span class="number">0</span>,i]]=dfm[ct[<span class="number">0</span>,i]]+this_dfm</span><br><span class="line">            dw[i]=dconv2_kernel(this_dcfm,this_fm,this_w)</span><br><span class="line">        <span class="keyword">return</span> [dfm,dw,db]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trian</span>(<span class="params">self,<span class="built_in">input</span>,target</span>): </span><br><span class="line">        cfm1,sfm1,cfm2,sfm2=self.forwardPropConv(<span class="built_in">input</span>)</span><br><span class="line">        bp_input=sfm2.reshape(self.bp1.n_in)</span><br><span class="line">        bp1_out,bp2_out=self.forwradPropBp(bp_input)</span><br><span class="line">        out=max_with_index(bp2_out)</span><br><span class="line">        <span class="keyword">if</span> out[<span class="number">0</span>]==target:</span><br><span class="line">            self.noErrors+=<span class="number">1</span></span><br><span class="line">        eta=self.eta</span><br><span class="line">        w1=self.bp1.w</span><br><span class="line">        b1=self.bp1.b</span><br><span class="line">        w2=self.bp2.w</span><br><span class="line">        b2=self.bp2.b</span><br><span class="line">        dsfm,dw1,db1,dw2,db2=self.backPropBp(bp_input, target, bp1_out, bp2_out, w1, w2, b1, b2)</span><br><span class="line">        self.bp1.w=self.bp1.w-dw1*eta</span><br><span class="line">        self.bp1.b=self.bp1.b-db1*eta</span><br><span class="line">        self.bp2.w=self.bp2.w-dw2*eta</span><br><span class="line">        self.bp2.b=self.bp2.b-db2*eta</span><br><span class="line">        dsfm=dsfm.reshape(sfm2.shape)</span><br><span class="line">        sw2=self.conv2.sw</span><br><span class="line">        sb2=self.conv2.sb</span><br><span class="line">        ct2=self.conv2.ct</span><br><span class="line">        cw2=self.conv2.cw</span><br><span class="line">        cb2=self.conv2.cb</span><br><span class="line">        pool_shape=self.pool_shape</span><br><span class="line">        stride=self.stride</span><br><span class="line">        dcfm2,dsw2,dsb2=self.backPropSubsampling(dsfm, sfm2,cfm2, sw2, sb2, pool_shape, stride)</span><br><span class="line">        dsfm1,dcw2,dcb2=self.backPropConvulution(dcfm2, cfm2, sfm1, ct2, cw2, cb2)</span><br><span class="line">        self.conv2.sw=self.conv2.sw-dsw2*eta</span><br><span class="line">        self.conv2.sb=self.conv2.sb-dsb2*eta</span><br><span class="line">        self.conv2.cw=self.conv2.cw-dcw2*eta</span><br><span class="line">        self.conv2.cb=self.conv2.cb-dcb2*eta</span><br><span class="line">        sw1=self.conv1.sw</span><br><span class="line">        sb1=self.conv1.sb</span><br><span class="line">        ct1=self.conv1.ct</span><br><span class="line">        cw1=self.conv1.cw</span><br><span class="line">        cb1=self.conv1.cb</span><br><span class="line">        dcfm1,dsw1,dsb1=self.backPropSubsampling(dsfm1, sfm1,cfm1, sw1, sb1, pool_shape, stride)</span><br><span class="line">        dfm,dcw1,dcb1=self.backPropConvulution(dcfm1, cfm1, <span class="built_in">input</span>, ct1, cw1, cb1)</span><br><span class="line">        self.conv1.sw=sw1-dsw1*eta</span><br><span class="line">        self.conv1.sb=sb1-dsb1*eta</span><br><span class="line">        self.conv1.cw=cw1-dcw1*eta</span><br><span class="line">        self.conv1.cb=cb1-dcb1*eta</span><br><span class="line">        <span class="comment">#print(out)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_data</span>(<span class="params">path</span>):</span><br><span class="line">    f=gzip.<span class="built_in">open</span>(path,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">    train_set,valid_set,test_set=cPickle.load(f)</span><br><span class="line">    <span class="keyword">del</span> f.f</span><br><span class="line">    <span class="keyword">return</span> [train_set,valid_set,test_set]</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    gc.enable()</span><br><span class="line">    gc.set_debug(gc.DEBUG_COLLECTABLE | gc.DEBUG_UNCOLLECTABLE | gc.DEBUG_INSTANCES | gc.DEBUG_OBJECTS)</span><br><span class="line">    train_set,valid_set,test_set=load_data(<span class="string">&#x27;d:/data/mnist.pkl.gz&#x27;</span>)</span><br><span class="line">    num=train_set[<span class="number">0</span>].shape[<span class="number">0</span>]</span><br><span class="line">    cnn=convnet([<span class="number">28</span>,<span class="number">28</span>])</span><br><span class="line">    <span class="keyword">for</span> train <span class="keyword">in</span> xrange(<span class="number">1</span>,<span class="number">21</span>):</span><br><span class="line">        cnn.noErrors=<span class="number">0</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;第%d次训练&quot;</span>%(train))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>,num+<span class="number">1</span>):</span><br><span class="line">            image=train_set[<span class="number">0</span>][i-<span class="number">1</span>]</span><br><span class="line">            data=image.reshape([<span class="number">1</span>,<span class="number">28</span>,<span class="number">28</span>])</span><br><span class="line">            target=train_set[<span class="number">1</span>][i-<span class="number">1</span>]</span><br><span class="line">            cnn.trian(data, target)</span><br><span class="line">            <span class="keyword">if</span> i%<span class="number">1000</span>==<span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;train %d,noErrors %d\n&quot;</span>%(i,cnn.noErrors)) </span><br><span class="line">                _unreachable = gc.collect()</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;unreachable %d\n&quot;</span>%(_unreachable))</span><br><span class="line">        <span class="keyword">if</span> train%cnn.step==<span class="number">0</span>:</span><br><span class="line">            cnn.eta=cnn.eta*cnn.decay</span><br><span class="line">            <span class="keyword">del</span> data</span><br><span class="line">            <span class="keyword">del</span> image</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>神经网络算法</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>受限玻尔兹曼机</title>
    <url>/posts/e20ce036.html</url>
    <content><![CDATA[<h2 id="受限玻尔兹曼机-Restricted-Boltzmann-Machine">受限玻尔兹曼机(Restricted Boltzmann Machine)</h2>
<p>受限玻尔兹曼机（Restricted Boltzmann Machine，RBM）是一种可用随机神经网络（stochastic neural network）来解释的概率图模型（probabilistic graphical model）。RBM是Smolensky于1986年在波尔兹曼机（Boltzmann Machine，BM）基础上提出的，所谓“随机”是指网络中的神经元是随机神经元，输出状态只有两种（未激活和激活），状态的具体取值根据概率统计法则来决定。RBM理论是Hinton在2006年提出基于RBM的（Deep Belief Network）模型，大量学者开始研究RBM的理论及其应用。</p>
<p>受限玻尔兹曼机(Restricted Boltzmann Machine)是玻尔兹曼机(Boltzmann machine，BM)的一种特殊拓扑结构。BM的原理起源于统计物理学，是一种基于能量函数的建模方法，能够描述变量之间的高阶相互作用，BM的学习算法较复杂，但所建模型和学习算法有比较完备的物理解释和严格的数理统计理论作基础。<br>
BM是一种对称耦合的随机反馈型二值单元神经网络，由可见层和多个隐层组成，网络节点分为可见单元(visible unit)和隐单元(hidden unit)，用可见单元和隐单元来表达随机网络与随机环境的学习模型，通过权值表达单元之间的相关性。</p>
<p align="center">
<img width="500" align="center" src="/img/images/329.jpg" />
</p>
<p>Smolensky提出的RBM由一个可见神经元层和一个隐神经元层组成，由于隐层神经元之间没有相互连接并且隐层神经元独立于给定的训练样本，这使直接计算依赖数据的期望值变得容易，可见层神经元之间也没有相互连接，通过从训练样本得到的隐层神经元状态上执行马尔可夫链抽样过程，来估计独立于数据的期望值，并行交替更新所有可见层神经元和隐层神经元的值。</p>
<p>受限玻兹曼机是一种玻兹曼机的变体，但限定模型必须为二分图。模型中包含对应输入参数的输入（可见）单元和对应训练结果的隐单元，图中的每条边必须连接一个可见单元和一个隐单元。（与此相对，“无限制”玻兹曼机包含隐单元间的边，使之成为递归神经网络。）这一限定使得相比一般玻兹曼机更高效的训练算法成为可能，特别是基于梯度的对比分歧（contrastive divergence）算法。</p>
<p>受限玻兹曼机也可被用于深度学习网络。具体地，深度信念网络可使用多个RBM堆叠而成，并可使用梯度下降法和反向传播算法进行调优</p>
<p>RBM是有两个层的浅层神经网络，它是组成深度置信网络的基础部件。RBM的第一个层称为可见层，又称输入层，而第二个层是隐藏层。</p>
<p align="center">
<img width="200" align="center" src="/img/images/344.jpg" />
</p>
<p>图中每个圆圈都是一个与神经元相似的单元，称为节点，运算在节点中进行。一个层中的节点与另一层中的所有节点分别连接，但与同一层中的其他节点并不相连。</p>
<p>也就是说，层的内部不存在通信－这就是受限玻尔兹曼机被称为受限的原因。每个节点对输入进行处理和运算，判定是否继续传输输入的数据，而这种判定一开始是随机的。(“随机”（stochastic）一词在此处指与输入相乘的初始系数是随机生成的。)</p>
<p>每个可见节点负责处理网络需要学习的数据集中一个项目的一种低层次特征。举例来说，如果处理的是一个灰度图像的数据集，则每个可见节点将接收一张图像中每个像素的像素值。（MNIST图像有784个像素，所以处理这类图像的神经网络的一个可见层必须有784个输入节点。）</p>
<p>接着来看单个像素值x如何通过这一双层网络。在隐藏层的节点1中x与一个权重相乘，再与所谓的偏差相加。这两步运算的结果输入激活函数，得到节点的输出，即输入为x时通过节点的信号强度。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">激活函数f((权重w <span class="emphasis">* 输入x) + 偏差b ) = 输出a</span></span><br></pre></td></tr></table></figure>
<p align="center">
<img width="360" align="center" src="/img/images/345.jpg" />
</p>
<p>一个隐藏节点如何整合多项输入。每个x分别与各自的权重相乘，乘积之和再与偏差相加，其结果同样经过激活函数运算得到节点的输出值。</p>
<p align="center">
<img width="360" align="center" src="/img/images/346.jpg" />
</p>
<p>由于每个可见节点的输入都被传递至所有的隐藏节点，所以也可将RBM定义为一种对称二分图。</p>
<p>对称指每个可见节点都与所有的隐藏节点相连接（见下图）。二分指有两个部分或层，而这里的图是指代节点网络的数学名词。</p>
<p>在每个隐藏节点中，每一个输入x都会与其相对应的权重w相乘。也就是说，每个输入x会对应三个权重，因此总共有12个权重（4个输入节点 x 3个隐藏节点）。两层之间的权重始终都是一个行数等于输入节点数、列数等于输出节点数的矩阵。</p>
<p>每个隐藏节点会接收四个与对应权重相乘后的输入值。这些乘积之和与一个偏差值相加（至少能强制让一部分节点激活），其结果再经过激活运算得到每个隐藏节点的输出a。</p>
<p align="center">
<img width="360" align="center" src="/img/images/347.jpg" />
</p>
<p>如果这两个层属于一个深度神经网络，那么第一隐藏层的输出会成为第二隐藏层的输入，随后再通过任意数量的隐藏层，直至到达最终的分类层。（简单的前馈动作仅能让RBM节点实现自动编码器的功能。）</p>
<p align="center">
<img width="360" align="center" src="/img/images/348.jpg" />
</p>
<p>在重构阶段，第一隐藏层的激活值成为反向传递中的输入。这些输入值与同样的权重相乘，每两个相连的节点之间各有一个权重，就像正向传递中输入x的加权运算一样。这些乘积的和再与每个可见层的偏差相加，所得结果就是重构值，亦即原始输入的近似值。这一过程表示如下：</p>
<p align="center">
<img width="360" align="center" src="/img/images/349.jpg" />
</p>
<p>由于RBM权重初始值是随机决定的，重构值与原始输入之间的差别通常很大。可以将r值与输入值之差视为重构误差，此误差值随后经由反向传播来修正RBM的权重，如此不断反复，直至误差达到最小。</p>
<p>由此可见，RBM在正向传递中使用输入值来预测节点的激活值，亦即输入为加权的x时输出的概率：p(a|x; w)。</p>
<p>但在反向传递时，激活值成为输入，而输出的是对于原始数据的重构值，或者说猜测值。此时RBM则是在尝试估计激活值为a时输入为x的概率，激活值的加权系数与正向传递中的权重相同。 第二个阶段可以表示为p(x|a; w)。</p>
<p>上述两种预测值相结合，可以得到输入 x 和激活值 a 的联合概率分布，即p(x, a)。</p>
<p>重构与回归、分类运算不同。回归运算根据许多输入值估测一个连续值，分类运算是猜测应当为一个特定的输入样例添加哪种具体的标签。</p>
<p>而重构则是在猜测原始输入的概率分布，亦即同时预测许多不同的点的值。这被称为生成学习，必须和分类器所进行的判别学习区分开来，后者是将输入值映射至标签，用直线将数据点划分为不同的组。</p>
<p>试想输入数据和重构数据是形状不同的常态曲线，两者仅有部分重叠。</p>
<p>KL散度衡量两条曲线下方不重叠（即离散）的面积，而RBM的优化算法会尝试将这些离散部分的面积最小化，使共用权重在与第一隐藏层的激活值相乘后，可以得到与原始输入高度近似的结果。下图左半边是一组原始输入的概率分布曲线p，与之并列的是重构值的概率分布曲线q；右半边的图则显示了两条曲线之间的差异。</p>
<p align="center">
<img width="360" align="center" src="/img/images/350.jpg" />
</p>
<p>RBM根据权重产生的误差反复调整权重，以此学习估计原始数据的近似值。可以说权重会慢慢开始反映出输入的结构，而这种结构被编码为第一个隐藏层的激活值。整个学习过程看上去像是两条概率分布曲线在逐步重合。</p>
<p align="center">
<img width="360" align="center" src="/img/images/351.jpg" />
</p>
<p>RBM根据第一个隐藏层的激活值学习了输入数据的结构之后，数据即在网络中继续向下传递一层。第一个隐藏层的作用现在相当于可见层。激活值实际上相当于输入，在第二个隐藏层的节点中与权重相乘，得到另一组激活值。</p>
<p>将特征分组，再将特征组分组，由此连续生成多组激活值的过程是特征层次分析的基础，神经网络用这种方法来学习更为复杂且抽象的数据表达形式。</p>
<p>每增加一个隐藏层，其权重都会反复进行调整，直到该层能较为准确地模拟出来自前一层的输入。这是无监督的逐层贪婪预训练方法，不需要标签就可以改进网络的权重，也就是说可以采用未标记、未经人工处理的数据来训练，而现实中大部分的数据都属于这一类别。一般的规律是，算法接触的数据越多，产生的结果越准确，这正是深度学习算法十分厉害的原因之一。</p>
<p>权重能够近似模拟出数据的特征后，也就为下一步的学习奠定了良好基础，比如可以在随后的有监督学习阶段使用深度置信网络来对图像进行分类。</p>
<p>RBM有许多用途，其中最强的功能之一就是对权重进行合理的初始化，为之后的学习和分类做好准备。从某种意义上来说，RBM的作用与反向传播相似：让权重能够有效地模拟数据。可以认为预训练和反向传播是实现同一个目的的不同方法，二者可以相互替代。</p>
<p align="center">
<img width="360" align="center" src="/img/images/352.jpg" />
</p>
<p>这幅对称二分二向图综合显示了玻尔兹曼机的运作方式。</p>
<h3 id="应用示例-15">应用示例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> .util <span class="keyword">import</span> tf_xavier_init</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RBM</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,</span></span><br><span class="line"><span class="params">                 n_visible,</span></span><br><span class="line"><span class="params">                 n_hidden,</span></span><br><span class="line"><span class="params">                 learning_rate=<span class="number">0.01</span>,</span></span><br><span class="line"><span class="params">                 momentum=<span class="number">0.95</span>,</span></span><br><span class="line"><span class="params">                 xavier_const=<span class="number">1.0</span>,</span></span><br><span class="line"><span class="params">                 err_function=<span class="string">&#x27;mse&#x27;</span>,</span></span><br><span class="line"><span class="params">                 use_tqdm=<span class="literal">False</span>,</span></span><br><span class="line"><span class="params">                 <span class="comment"># DEPRECATED:</span></span></span><br><span class="line"><span class="params">                 tqdm=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0.0</span> &lt;= momentum &lt;= <span class="number">1.0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;momentum should be in range [0, 1]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err_function <span class="keyword">not</span> <span class="keyword">in</span> &#123;<span class="string">&#x27;mse&#x27;</span>, <span class="string">&#x27;cosine&#x27;</span>&#125;:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;err_function should be either \&#x27;mse\&#x27; or \&#x27;cosine\&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self._use_tqdm = use_tqdm</span><br><span class="line">        self._tqdm = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> use_tqdm <span class="keyword">or</span> tqdm <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line">            self._tqdm = tqdm</span><br><span class="line"></span><br><span class="line">        self.n_visible = n_visible</span><br><span class="line">        self.n_hidden = n_hidden</span><br><span class="line">        self.learning_rate = learning_rate</span><br><span class="line">        self.momentum = momentum</span><br><span class="line"></span><br><span class="line">        self.x = tf.placeholder(tf.float32, [<span class="literal">None</span>, self.n_visible])</span><br><span class="line">        self.y = tf.placeholder(tf.float32, [<span class="literal">None</span>, self.n_hidden])</span><br><span class="line"></span><br><span class="line">        self.w = tf.Variable(tf_xavier_init(self.n_visible, self.n_hidden, const=xavier_const), dtype=tf.float32)</span><br><span class="line">        self.visible_bias = tf.Variable(tf.zeros([self.n_visible]), dtype=tf.float32)</span><br><span class="line">        self.hidden_bias = tf.Variable(tf.zeros([self.n_hidden]), dtype=tf.float32)</span><br><span class="line"></span><br><span class="line">        self.delta_w = tf.Variable(tf.zeros([self.n_visible, self.n_hidden]), dtype=tf.float32)</span><br><span class="line">        self.delta_visible_bias = tf.Variable(tf.zeros([self.n_visible]), dtype=tf.float32)</span><br><span class="line">        self.delta_hidden_bias = tf.Variable(tf.zeros([self.n_hidden]), dtype=tf.float32)</span><br><span class="line"></span><br><span class="line">        self.update_weights = <span class="literal">None</span></span><br><span class="line">        self.update_deltas = <span class="literal">None</span></span><br><span class="line">        self.compute_hidden = <span class="literal">None</span></span><br><span class="line">        self.compute_visible = <span class="literal">None</span></span><br><span class="line">        self.compute_visible_from_hidden = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        self._initialize_vars()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> self.update_weights <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">assert</span> self.update_deltas <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">assert</span> self.compute_hidden <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">assert</span> self.compute_visible <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">assert</span> self.compute_visible_from_hidden <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err_function == <span class="string">&#x27;cosine&#x27;</span>:</span><br><span class="line">            x1_norm = tf.nn.l2_normalize(self.x, <span class="number">1</span>)</span><br><span class="line">            x2_norm = tf.nn.l2_normalize(self.compute_visible, <span class="number">1</span>)</span><br><span class="line">            cos_val = tf.reduce_mean(tf.reduce_sum(tf.mul(x1_norm, x2_norm), <span class="number">1</span>))</span><br><span class="line">            self.compute_err = tf.acos(cos_val) / tf.constant(np.pi)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.compute_err = tf.reduce_mean(tf.square(self.x - self.compute_visible))</span><br><span class="line"></span><br><span class="line">        init = tf.global_variables_initializer()</span><br><span class="line">        self.sess = tf.Session()</span><br><span class="line">        self.sess.run(init)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_initialize_vars</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_err</span>(<span class="params">self, batch_x</span>):</span><br><span class="line">        <span class="keyword">return</span> self.sess.run(self.compute_err, feed_dict=&#123;self.x: batch_x&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_free_energy</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">transform</span>(<span class="params">self, batch_x</span>):</span><br><span class="line">        <span class="keyword">return</span> self.sess.run(self.compute_hidden, feed_dict=&#123;self.x: batch_x&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">transform_inv</span>(<span class="params">self, batch_y</span>):</span><br><span class="line">        <span class="keyword">return</span> self.sess.run(self.compute_visible_from_hidden, feed_dict=&#123;self.y: batch_y&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reconstruct</span>(<span class="params">self, batch_x</span>):</span><br><span class="line">        <span class="keyword">return</span> self.sess.run(self.compute_visible, feed_dict=&#123;self.x: batch_x&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partial_fit</span>(<span class="params">self, batch_x</span>):</span><br><span class="line">        self.sess.run(self.update_weights + self.update_deltas, feed_dict=&#123;self.x: batch_x&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self,</span></span><br><span class="line"><span class="params">            data_x,</span></span><br><span class="line"><span class="params">            n_epoches=<span class="number">10</span>,</span></span><br><span class="line"><span class="params">            batch_size=<span class="number">10</span>,</span></span><br><span class="line"><span class="params">            shuffle=<span class="literal">True</span>,</span></span><br><span class="line"><span class="params">            verbose=<span class="literal">True</span></span>):</span><br><span class="line">        <span class="keyword">assert</span> n_epoches &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        n_data = data_x.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> batch_size &gt; <span class="number">0</span>:</span><br><span class="line">            n_batches = n_data // batch_size + (<span class="number">0</span> <span class="keyword">if</span> n_data % batch_size == <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            n_batches = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> shuffle:</span><br><span class="line">            data_x_cpy = data_x.copy()</span><br><span class="line">            inds = np.arange(n_data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data_x_cpy = data_x</span><br><span class="line"></span><br><span class="line">        errs = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(n_epoches):</span><br><span class="line">            <span class="keyword">if</span> verbose <span class="keyword">and</span> <span class="keyword">not</span> self._use_tqdm:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Epoch: &#123;:d&#125;&#x27;</span>.<span class="built_in">format</span>(e))</span><br><span class="line"></span><br><span class="line">            epoch_errs = np.zeros((n_batches,))</span><br><span class="line">            epoch_errs_ptr = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> shuffle:</span><br><span class="line">                np.random.shuffle(inds)</span><br><span class="line">                data_x_cpy = data_x_cpy[inds]</span><br><span class="line"></span><br><span class="line">            r_batches = <span class="built_in">range</span>(n_batches)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> verbose <span class="keyword">and</span> self._use_tqdm:</span><br><span class="line">                r_batches = self._tqdm(r_batches, desc=<span class="string">&#x27;Epoch: &#123;:d&#125;&#x27;</span>.<span class="built_in">format</span>(e), <span class="built_in">ascii</span>=<span class="literal">True</span>, file=sys.stdout)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> b <span class="keyword">in</span> r_batches:</span><br><span class="line">                batch_x = data_x_cpy[b * batch_size:(b + <span class="number">1</span>) * batch_size]</span><br><span class="line">                self.partial_fit(batch_x)</span><br><span class="line">                batch_err = self.get_err(batch_x)</span><br><span class="line">                epoch_errs[epoch_errs_ptr] = batch_err</span><br><span class="line">                epoch_errs_ptr += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> verbose:</span><br><span class="line">                err_mean = epoch_errs.mean()</span><br><span class="line">                <span class="keyword">if</span> self._use_tqdm:</span><br><span class="line">                    self._tqdm.write(<span class="string">&#x27;Train error: &#123;:.4f&#125;&#x27;</span>.<span class="built_in">format</span>(err_mean))</span><br><span class="line">                    self._tqdm.write(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;Train error: &#123;:.4f&#125;&#x27;</span>.<span class="built_in">format</span>(err_mean))</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                sys.stdout.flush()</span><br><span class="line"></span><br><span class="line">            errs = np.hstack([errs, epoch_errs])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> errs</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_weights</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.sess.run(self.w),\</span><br><span class="line">            self.sess.run(self.visible_bias),\</span><br><span class="line">            self.sess.run(self.hidden_bias)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save_weights</span>(<span class="params">self, filename, name</span>):</span><br><span class="line">        saver = tf.train.Saver(&#123;name + <span class="string">&#x27;_w&#x27;</span>: self.w,</span><br><span class="line">                                name + <span class="string">&#x27;_v&#x27;</span>: self.visible_bias,</span><br><span class="line">                                name + <span class="string">&#x27;_h&#x27;</span>: self.hidden_bias&#125;)</span><br><span class="line">        <span class="keyword">return</span> saver.save(self.sess, filename)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_weights</span>(<span class="params">self, w, visible_bias, hidden_bias</span>):</span><br><span class="line">        self.sess.run(self.w.assign(w))</span><br><span class="line">        self.sess.run(self.visible_bias.assign(visible_bias))</span><br><span class="line">        self.sess.run(self.hidden_bias.assign(hidden_bias))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load_weights</span>(<span class="params">self, filename, name</span>):</span><br><span class="line">        saver = tf.train.Saver(&#123;name + <span class="string">&#x27;_w&#x27;</span>: self.w,</span><br><span class="line">                                name + <span class="string">&#x27;_v&#x27;</span>: self.visible_bias,</span><br><span class="line">                                name + <span class="string">&#x27;_h&#x27;</span>: self.hidden_bias&#125;)</span><br><span class="line">        saver.restore(self.sess, filename)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>神经网络算法</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>多层感知器</title>
    <url>/posts/4f7ff6e3.html</url>
    <content><![CDATA[<h2 id="多层感知器-Multilayer-Perceptron">多层感知器(Multilayer Perceptron)</h2>
<p>多层感知器（Multilayer Perceptron,缩写MLP）是一种前向结构的人工神经网络，映射一组输入向量到一组输出向量。MLP可以被看作是一个有向图，由多个的节点层所组成，每一层都全连接到下一层。除了输入节点，每个节点都是一个带有非线性激活函数的神经元（或称处理单元）。一种被称为反向传播算法的监督学习方法常被用来训练MLP。MLP是感知器的推广，克服了感知器不能对线性不可分数据进行识别的弱点</p>
<p>若每个神经元的激活函数都是线性函数，那么，任意层数的MLP都可被约简成一个等价的单层感知器。</p>
<p>实际上，MLP本身可以使用任何形式的激活函数，譬如阶梯函数或逻辑乙形函数（logistic sigmoid function），但为了使用反向传播算法进行有效学习，激活函数必须限制为可微函数。由于具有良好可微性，很多S函数，尤其是双曲正切函数（Hyperbolic tangent）及逻辑函数，被采用为激活函数。</p>
<p>通常MLP用来进行学习的反向传播算法，在模式识别的领域中算是标准监督学习算法，并在计算神经学及并行分布式处理领域中，持续成为被研究的课题。MLP已被证明是一种通用的函数近似方法，可以被用来拟合复杂的函数，或解决分类问题。</p>
<p>MLP在80年代的时候曾是相当流行的机器学习方法，拥有广泛的应用场景，譬如语音识别、图像识别、机器翻译等等，但自90年代以来，MLP遇到来自更为简单的支持向量机的强劲竞争。近来，由于深度学习的成功，MLP又重新得到了关注。</p>
<p>通常一个单一隐藏层的多层感知机（或人工神经网络—ANN）可以用图表现为：</p>
<p align="center">
<img width="300" align="center" src="/img/images/317.jpg" />
</p>
<p>正式的单一隐藏层的MLP可以表现为：<img width="100" align="center" src="/img/images/318.jpg" />，其中D是输入向量x的大小，L是输出向量f(x)的大小，矩阵表现为：<img width="300" align="center" src="/img/images/319.jpg" />, b是偏差向量，W是权重矩阵，G和s是激活函数。</p>
<p>向量<img width="260" align="center" src="/img/images/320.jpg" />构成隐藏层。<img width="160" align="center" src="/img/images/321.jpg" />是连接输入向量和隐藏层的权重矩阵。Wi代表输入单元到第i个隐藏单元的权重。一般选择tanh作为s的激活函数，使用<img width="260" align="center" src="/img/images/322.jpg" />或者使用逻辑sigmoid函数，<img width="300" align="center" src="/img/images/323.jpg" />。</p>
<p>这里我们使用Tanh因为一般它训练速度更快（有时也有利于解决局部最优）。tanh和sigmoid都是标量到标量函数，但通过点积运算向量和张量自然延伸（将向量分解成元素，生成同样大小的向量）。</p>
<p>输出向量通过以下公式得到<img width="200" align="center" src="/img/images/324.jpg" />。</p>
<p>我们此前在使用逻辑回归区分MNIST数字时提到过这一公式。如前，在多类区分中，通过使用softmax作为G的函数，可以获得类成员的概率。</p>
<p>训练一个MLP，我们学习模型所有的参数，这里我们使用随机梯度下降和批处理。要学习的参数为：<img width="200" align="center" src="/img/images/325.jpg" />。</p>
<p>梯度<img width="70" align="center" src="/img/images/326.jpg" />可以使用反向传播算法获得（连续微分的特殊形式），Theano可以自动计算这一微分过程。</p>
<p>从逻辑回归到多层感知机我们将聚焦单隐藏层的多层感知机。 我们从构建一个单隐藏层的类开始。之后只要在此基础之上加一个逻辑回归层就构建了MLP。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HiddenLayer</span>(<span class="title class_ inherited__">object</span>):  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, rng, <span class="built_in">input</span>, n_in, n_out, W=<span class="literal">None</span>, b=<span class="literal">None</span>,  </span></span><br><span class="line"><span class="params">                 activation=T.tanh</span>):  </span><br><span class="line">        <span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">        Typical hidden layer of a MLP: units are fully-connected and have </span></span><br><span class="line"><span class="string">        sigmoidal activation function. Weight matrix W is of shape (n_in,n_out) </span></span><br><span class="line"><span class="string">        and the bias vector b is of shape (n_out,). </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        NOTE : The nonlinearity used here is tanh </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        Hidden unit activation is given by: tanh(dot(input,W) + b) </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        :type rng: numpy.random.RandomState </span></span><br><span class="line"><span class="string">        :param rng: a random number generator used to initialize weights </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        :type input: theano.tensor.dmatrix </span></span><br><span class="line"><span class="string">        :param input: a symbolic tensor of shape (n_examples, n_in) </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        :type n_in: int </span></span><br><span class="line"><span class="string">        :param n_in: dimensionality of input </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        :type n_out: int </span></span><br><span class="line"><span class="string">        :param n_out: number of hidden units </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        :type activation: theano.Op or function </span></span><br><span class="line"><span class="string">        :param activation: Non linearity to be applied in the hidden </span></span><br><span class="line"><span class="string">                           layer </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>  </span><br><span class="line">        self.<span class="built_in">input</span> = <span class="built_in">input</span>  </span><br></pre></td></tr></table></figure>
<p>隐藏层i权重的初始值应当根据激活函数以对称间断的方式取得样本。</p>
<p>对于tanh函数，区间在<img width="270" align="center" src="/img/images/327.jpg" /></p>
<p>对于sigmoid函数，区间在<img width="270" align="center" src="/img/images/328.jpg" /></p>
<p>这种初始化方式保证了在训练早期，每一个神经元在它的激活函数内操作，信息可以便利的向上（输入到输出）或反向（输出到输入）传播。</p>
<h3 id="应用示例-16">应用示例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">This tutorial introduces the multilayer perceptron using Theano. </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> A multilayer perceptron is a logistic regressor where </span></span><br><span class="line"><span class="string">instead of feeding the input to the logistic regression you insert a </span></span><br><span class="line"><span class="string">intermediate layer, called the hidden layer, that has a nonlinear </span></span><br><span class="line"><span class="string">activation function (usually tanh or sigmoid) . One can use many such </span></span><br><span class="line"><span class="string">hidden layers making the architecture deep. The tutorial will also tackle </span></span><br><span class="line"><span class="string">the problem of MNIST digit classification. </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">.. math:: </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    f(x) = G( b^&#123;(2)&#125; + W^&#123;(2)&#125;( s( b^&#123;(1)&#125; + W^&#123;(1)&#125; x))), </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">References: </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    - textbooks: &quot;Pattern Recognition and Machine Learning&quot; - </span></span><br><span class="line"><span class="string">                 Christopher M. Bishop, section 5 </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function  </span><br><span class="line">  </span><br><span class="line">__docformat__ = <span class="string">&#x27;restructedtext en&#x27;</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> os  </span><br><span class="line"><span class="keyword">import</span> sys  </span><br><span class="line"><span class="keyword">import</span> timeit  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> numpy  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> theano  </span><br><span class="line"><span class="keyword">import</span> theano.tensor <span class="keyword">as</span> T  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> logistic_sgd <span class="keyword">import</span> LogisticRegression, load_data  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># start-snippet-1  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HiddenLayer</span>(<span class="title class_ inherited__">object</span>):  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, rng, <span class="built_in">input</span>, n_in, n_out, W=<span class="literal">None</span>, b=<span class="literal">None</span>,  </span></span><br><span class="line"><span class="params">                 activation=T.tanh</span>):  </span><br><span class="line">        <span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">        Typical hidden layer of a MLP: units are fully-connected and have </span></span><br><span class="line"><span class="string">        sigmoidal activation function. Weight matrix W is of shape (n_in,n_out) </span></span><br><span class="line"><span class="string">        and the bias vector b is of shape (n_out,). </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        NOTE : The nonlinearity used here is tanh </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        Hidden unit activation is given by: tanh(dot(input,W) + b) </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        :type rng: numpy.random.RandomState </span></span><br><span class="line"><span class="string">        :param rng: a random number generator used to initialize weights </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        :type input: theano.tensor.dmatrix </span></span><br><span class="line"><span class="string">        :param input: a symbolic tensor of shape (n_examples, n_in) </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        :type n_in: int </span></span><br><span class="line"><span class="string">        :param n_in: dimensionality of input </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        :type n_out: int </span></span><br><span class="line"><span class="string">        :param n_out: number of hidden units </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        :type activation: theano.Op or function </span></span><br><span class="line"><span class="string">        :param activation: Non linearity to be applied in the hidden </span></span><br><span class="line"><span class="string">                           layer </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>  </span><br><span class="line">        self.<span class="built_in">input</span> = <span class="built_in">input</span>  </span><br><span class="line">        <span class="comment"># end-snippet-1  </span></span><br><span class="line">  </span><br><span class="line">        <span class="comment"># `W` is initialized with `W_values` which is uniformely sampled  </span></span><br><span class="line">        <span class="comment"># from sqrt(-6./(n_in+n_hidden)) and sqrt(6./(n_in+n_hidden))  </span></span><br><span class="line">        <span class="comment"># for tanh activation function  </span></span><br><span class="line">        <span class="comment"># the output of uniform if converted using asarray to dtype  </span></span><br><span class="line">        <span class="comment"># theano.config.floatX so that the code is runable on GPU  </span></span><br><span class="line">        <span class="comment"># Note : optimal initialization of weights is dependent on the  </span></span><br><span class="line">        <span class="comment">#        activation function used (among other things).  </span></span><br><span class="line">        <span class="comment">#        For example, results presented in [Xavier10] suggest that you  </span></span><br><span class="line">        <span class="comment">#        should use 4 times larger initial weights for sigmoid  </span></span><br><span class="line">        <span class="comment">#        compared to tanh  </span></span><br><span class="line">        <span class="comment">#        We have no info for other function, so we use the same as  </span></span><br><span class="line">        <span class="comment">#        tanh.  </span></span><br><span class="line">        <span class="keyword">if</span> W <span class="keyword">is</span> <span class="literal">None</span>:  </span><br><span class="line">            W_values = numpy.asarray(  </span><br><span class="line">                rng.uniform(  </span><br><span class="line">                    low=-numpy.sqrt(<span class="number">6.</span> / (n_in + n_out)),  </span><br><span class="line">                    high=numpy.sqrt(<span class="number">6.</span> / (n_in + n_out)),  </span><br><span class="line">                    size=(n_in, n_out)  </span><br><span class="line">                ),  </span><br><span class="line">                dtype=theano.config.floatX  </span><br><span class="line">            )  </span><br><span class="line">            <span class="keyword">if</span> activation == theano.tensor.nnet.sigmoid:  </span><br><span class="line">                W_values *= <span class="number">4</span>  </span><br><span class="line">  </span><br><span class="line">            W = theano.shared(value=W_values, name=<span class="string">&#x27;W&#x27;</span>, borrow=<span class="literal">True</span>)  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> b <span class="keyword">is</span> <span class="literal">None</span>:  </span><br><span class="line">            b_values = numpy.zeros((n_out,), dtype=theano.config.floatX)  </span><br><span class="line">            b = theano.shared(value=b_values, name=<span class="string">&#x27;b&#x27;</span>, borrow=<span class="literal">True</span>)  </span><br><span class="line">  </span><br><span class="line">        self.W = W  </span><br><span class="line">        self.b = b  </span><br><span class="line">  </span><br><span class="line">        lin_output = T.dot(<span class="built_in">input</span>, self.W) + self.b  </span><br><span class="line">        self.output = (  </span><br><span class="line">            lin_output <span class="keyword">if</span> activation <span class="keyword">is</span> <span class="literal">None</span>  </span><br><span class="line">            <span class="keyword">else</span> activation(lin_output)  </span><br><span class="line">        )  </span><br><span class="line">        <span class="comment"># parameters of the model  </span></span><br><span class="line">        self.params = [self.W, self.b]  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># start-snippet-2  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MLP</span>(<span class="title class_ inherited__">object</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;Multi-Layer Perceptron Class </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    A multilayer perceptron is a feedforward artificial neural network model </span></span><br><span class="line"><span class="string">    that has one layer or more of hidden units and nonlinear activations. </span></span><br><span class="line"><span class="string">    Intermediate layers usually have as activation function tanh or the </span></span><br><span class="line"><span class="string">    sigmoid function (defined here by a ``HiddenLayer`` class)  while the </span></span><br><span class="line"><span class="string">    top layer is a softmax layer (defined here by a ``LogisticRegression`` </span></span><br><span class="line"><span class="string">    class). </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, rng, <span class="built_in">input</span>, n_in, n_hidden, n_out</span>):  </span><br><span class="line">        <span class="string">&quot;&quot;&quot;Initialize the parameters for the multilayer perceptron </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        :type rng: numpy.random.RandomState </span></span><br><span class="line"><span class="string">        :param rng: a random number generator used to initialize weights </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        :type input: theano.tensor.TensorType </span></span><br><span class="line"><span class="string">        :param input: symbolic variable that describes the input of the </span></span><br><span class="line"><span class="string">        architecture (one minibatch) </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        :type n_in: int </span></span><br><span class="line"><span class="string">        :param n_in: number of input units, the dimension of the space in </span></span><br><span class="line"><span class="string">        which the datapoints lie </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        :type n_hidden: int </span></span><br><span class="line"><span class="string">        :param n_hidden: number of hidden units </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        :type n_out: int </span></span><br><span class="line"><span class="string">        :param n_out: number of output units, the dimension of the space in </span></span><br><span class="line"><span class="string">        which the labels lie </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># Since we are dealing with a one hidden layer MLP, this will translate  </span></span><br><span class="line">        <span class="comment"># into a HiddenLayer with a tanh activation function connected to the  </span></span><br><span class="line">        <span class="comment"># LogisticRegression layer; the activation function can be replaced by  </span></span><br><span class="line">        <span class="comment"># sigmoid or any other nonlinear function  </span></span><br><span class="line">        self.hiddenLayer = HiddenLayer(  </span><br><span class="line">            rng=rng,  </span><br><span class="line">            <span class="built_in">input</span>=<span class="built_in">input</span>,  </span><br><span class="line">            n_in=n_in,  </span><br><span class="line">            n_out=n_hidden,  </span><br><span class="line">            activation=T.tanh  </span><br><span class="line">        )  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># The logistic regression layer gets as input the hidden units  </span></span><br><span class="line">        <span class="comment"># of the hidden layer  </span></span><br><span class="line">        self.logRegressionLayer = LogisticRegression(  </span><br><span class="line">            <span class="built_in">input</span>=self.hiddenLayer.output,  </span><br><span class="line">            n_in=n_hidden,  </span><br><span class="line">            n_out=n_out  </span><br><span class="line">        )  </span><br><span class="line">        <span class="comment"># end-snippet-2 start-snippet-3  </span></span><br><span class="line">        <span class="comment"># L1 norm ; one regularization option is to enforce L1 norm to  </span></span><br><span class="line">        <span class="comment"># be small  </span></span><br><span class="line">        self.L1 = (  </span><br><span class="line">            <span class="built_in">abs</span>(self.hiddenLayer.W).<span class="built_in">sum</span>()  </span><br><span class="line">            + <span class="built_in">abs</span>(self.logRegressionLayer.W).<span class="built_in">sum</span>()  </span><br><span class="line">        )  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># square of L2 norm ; one regularization option is to enforce  </span></span><br><span class="line">        <span class="comment"># square of L2 norm to be small  </span></span><br><span class="line">        self.L2_sqr = (  </span><br><span class="line">            (self.hiddenLayer.W ** <span class="number">2</span>).<span class="built_in">sum</span>()  </span><br><span class="line">            + (self.logRegressionLayer.W ** <span class="number">2</span>).<span class="built_in">sum</span>()  </span><br><span class="line">        )  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># negative log likelihood of the MLP is given by the negative  </span></span><br><span class="line">        <span class="comment"># log likelihood of the output of the model, computed in the  </span></span><br><span class="line">        <span class="comment"># logistic regression layer  </span></span><br><span class="line">        self.negative_log_likelihood = (  </span><br><span class="line">            self.logRegressionLayer.negative_log_likelihood  </span><br><span class="line">        )  </span><br><span class="line">        <span class="comment"># same holds for the function computing the number of errors  </span></span><br><span class="line">        self.errors = self.logRegressionLayer.errors  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># the parameters of the model are the parameters of the two layer it is  </span></span><br><span class="line">        <span class="comment"># made out of  </span></span><br><span class="line">        self.params = self.hiddenLayer.params + self.logRegressionLayer.params  </span><br><span class="line">        <span class="comment"># end-snippet-3  </span></span><br><span class="line">  </span><br><span class="line">        <span class="comment"># keep track of model input  </span></span><br><span class="line">        self.<span class="built_in">input</span> = <span class="built_in">input</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_mlp</span>(<span class="params">learning_rate=<span class="number">0.01</span>, L1_reg=<span class="number">0.00</span>, L2_reg=<span class="number">0.0001</span>, n_epochs=<span class="number">1000</span>,  </span></span><br><span class="line"><span class="params">             dataset=<span class="string">&#x27;mnist.pkl.gz&#x27;</span>, batch_size=<span class="number">20</span>, n_hidden=<span class="number">500</span></span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">    Demonstrate stochastic gradient descent optimization for a multilayer </span></span><br><span class="line"><span class="string">    perceptron </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    This is demonstrated on MNIST. </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    :type learning_rate: float </span></span><br><span class="line"><span class="string">    :param learning_rate: learning rate used (factor for the stochastic </span></span><br><span class="line"><span class="string">    gradient </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    :type L1_reg: float </span></span><br><span class="line"><span class="string">    :param L1_reg: L1-norm&#x27;s weight when added to the cost (see </span></span><br><span class="line"><span class="string">    regularization) </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    :type L2_reg: float </span></span><br><span class="line"><span class="string">    :param L2_reg: L2-norm&#x27;s weight when added to the cost (see </span></span><br><span class="line"><span class="string">    regularization) </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    :type n_epochs: int </span></span><br><span class="line"><span class="string">    :param n_epochs: maximal number of epochs to run the optimizer </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    :type dataset: string </span></span><br><span class="line"><span class="string">    :param dataset: the path of the MNIST dataset file from </span></span><br><span class="line"><span class="string">                 http://www.iro.umontreal.ca/~lisa/deep/data/mnist/mnist.pkl.gz </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">   &quot;&quot;&quot;</span>  </span><br><span class="line">    datasets = load_data(dataset)  </span><br><span class="line">  </span><br><span class="line">    train_set_x, train_set_y = datasets[<span class="number">0</span>]  </span><br><span class="line">    valid_set_x, valid_set_y = datasets[<span class="number">1</span>]  </span><br><span class="line">    test_set_x, test_set_y = datasets[<span class="number">2</span>]  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># compute number of minibatches for training, validation and testing  </span></span><br><span class="line">    n_train_batches = train_set_x.get_value(borrow=<span class="literal">True</span>).shape[<span class="number">0</span>] // batch_size  </span><br><span class="line">    n_valid_batches = valid_set_x.get_value(borrow=<span class="literal">True</span>).shape[<span class="number">0</span>] // batch_size  </span><br><span class="line">    n_test_batches = test_set_x.get_value(borrow=<span class="literal">True</span>).shape[<span class="number">0</span>] // batch_size  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">######################  </span></span><br><span class="line">    <span class="comment"># BUILD ACTUAL MODEL #  </span></span><br><span class="line">    <span class="comment">######################  </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;... building the model&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># allocate symbolic variables for the data  </span></span><br><span class="line">    index = T.lscalar()  <span class="comment"># index to a [mini]batch  </span></span><br><span class="line">    x = T.matrix(<span class="string">&#x27;x&#x27;</span>)  <span class="comment"># the data is presented as rasterized images  </span></span><br><span class="line">    y = T.ivector(<span class="string">&#x27;y&#x27;</span>)  <span class="comment"># the labels are presented as 1D vector of  </span></span><br><span class="line">                        <span class="comment"># [int] labels  </span></span><br><span class="line">  </span><br><span class="line">    rng = numpy.random.RandomState(<span class="number">1234</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># construct the MLP class  </span></span><br><span class="line">    classifier = MLP(  </span><br><span class="line">        rng=rng,  </span><br><span class="line">        <span class="built_in">input</span>=x,  </span><br><span class="line">        n_in=<span class="number">28</span> * <span class="number">28</span>,  </span><br><span class="line">        n_hidden=n_hidden,  </span><br><span class="line">        n_out=<span class="number">10</span>  </span><br><span class="line">    )  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># start-snippet-4  </span></span><br><span class="line">    <span class="comment"># the cost we minimize during training is the negative log likelihood of  </span></span><br><span class="line">    <span class="comment"># the model plus the regularization terms (L1 and L2); cost is expressed  </span></span><br><span class="line">    <span class="comment"># here symbolically  </span></span><br><span class="line">    cost = (  </span><br><span class="line">        classifier.negative_log_likelihood(y)  </span><br><span class="line">        + L1_reg * classifier.L1  </span><br><span class="line">        + L2_reg * classifier.L2_sqr  </span><br><span class="line">    )  </span><br><span class="line">    <span class="comment"># end-snippet-4  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># compiling a Theano function that computes the mistakes that are made  </span></span><br><span class="line">    <span class="comment"># by the model on a minibatch  </span></span><br><span class="line">    test_model = theano.function(  </span><br><span class="line">        inputs=[index],  </span><br><span class="line">        outputs=classifier.errors(y),  </span><br><span class="line">        givens=&#123;  </span><br><span class="line">            x: test_set_x[index * batch_size:(index + <span class="number">1</span>) * batch_size],  </span><br><span class="line">            y: test_set_y[index * batch_size:(index + <span class="number">1</span>) * batch_size]  </span><br><span class="line">        &#125;  </span><br><span class="line">    )  </span><br><span class="line">  </span><br><span class="line">    validate_model = theano.function(  </span><br><span class="line">        inputs=[index],  </span><br><span class="line">        outputs=classifier.errors(y),  </span><br><span class="line">        givens=&#123;  </span><br><span class="line">            x: valid_set_x[index * batch_size:(index + <span class="number">1</span>) * batch_size],  </span><br><span class="line">            y: valid_set_y[index * batch_size:(index + <span class="number">1</span>) * batch_size]  </span><br><span class="line">        &#125;  </span><br><span class="line">    )  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># start-snippet-5  </span></span><br><span class="line">    <span class="comment"># compute the gradient of cost with respect to theta (sorted in params)  </span></span><br><span class="line">    <span class="comment"># the resulting gradients will be stored in a list gparams  </span></span><br><span class="line">    gparams = [T.grad(cost, param) <span class="keyword">for</span> param <span class="keyword">in</span> classifier.params]  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># specify how to update the parameters of the model as a list of  </span></span><br><span class="line">    <span class="comment"># (variable, update expression) pairs  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># given two lists of the same length, A = [a1, a2, a3, a4] and  </span></span><br><span class="line">    <span class="comment"># B = [b1, b2, b3, b4], zip generates a list C of same size, where each  </span></span><br><span class="line">    <span class="comment"># element is a pair formed from the two lists :  </span></span><br><span class="line">    <span class="comment">#    C = [(a1, b1), (a2, b2), (a3, b3), (a4, b4)]  </span></span><br><span class="line">    updates = [  </span><br><span class="line">        (param, param - learning_rate * gparam)  </span><br><span class="line">        <span class="keyword">for</span> param, gparam <span class="keyword">in</span> <span class="built_in">zip</span>(classifier.params, gparams)  </span><br><span class="line">    ]  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># compiling a Theano function `train_model` that returns the cost, but  </span></span><br><span class="line">    <span class="comment"># in the same time updates the parameter of the model based on the rules  </span></span><br><span class="line">    <span class="comment"># defined in `updates`  </span></span><br><span class="line">    train_model = theano.function(  </span><br><span class="line">        inputs=[index],  </span><br><span class="line">        outputs=cost,  </span><br><span class="line">        updates=updates,  </span><br><span class="line">        givens=&#123;  </span><br><span class="line">            x: train_set_x[index * batch_size: (index + <span class="number">1</span>) * batch_size],  </span><br><span class="line">            y: train_set_y[index * batch_size: (index + <span class="number">1</span>) * batch_size]  </span><br><span class="line">        &#125;  </span><br><span class="line">    )  </span><br><span class="line">    <span class="comment"># end-snippet-5  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">###############  </span></span><br><span class="line">    <span class="comment"># TRAIN MODEL #  </span></span><br><span class="line">    <span class="comment">###############  </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;... training&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># early-stopping parameters  </span></span><br><span class="line">    patience = <span class="number">10000</span>  <span class="comment"># look as this many examples regardless  </span></span><br><span class="line">    patience_increase = <span class="number">2</span>  <span class="comment"># wait this much longer when a new best is  </span></span><br><span class="line">                           <span class="comment"># found  </span></span><br><span class="line">    improvement_threshold = <span class="number">0.995</span>  <span class="comment"># a relative improvement of this much is  </span></span><br><span class="line">                                   <span class="comment"># considered significant  </span></span><br><span class="line">    validation_frequency = <span class="built_in">min</span>(n_train_batches, patience // <span class="number">2</span>)  </span><br><span class="line">                                  <span class="comment"># go through this many  </span></span><br><span class="line">                                  <span class="comment"># minibatche before checking the network  </span></span><br><span class="line">                                  <span class="comment"># on the validation set; in this case we  </span></span><br><span class="line">                                  <span class="comment"># check every epoch  </span></span><br><span class="line">  </span><br><span class="line">    best_validation_loss = numpy.inf  </span><br><span class="line">    best_iter = <span class="number">0</span>  </span><br><span class="line">    test_score = <span class="number">0.</span>  </span><br><span class="line">    start_time = timeit.default_timer()  </span><br><span class="line">  </span><br><span class="line">    epoch = <span class="number">0</span>  </span><br><span class="line">    done_looping = <span class="literal">False</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (epoch &lt; n_epochs) <span class="keyword">and</span> (<span class="keyword">not</span> done_looping):  </span><br><span class="line">        epoch = epoch + <span class="number">1</span>  </span><br><span class="line">        <span class="keyword">for</span> minibatch_index <span class="keyword">in</span> <span class="built_in">range</span>(n_train_batches):  </span><br><span class="line">  </span><br><span class="line">            minibatch_avg_cost = train_model(minibatch_index)  </span><br><span class="line">            <span class="comment"># iteration number  </span></span><br><span class="line">            <span class="built_in">iter</span> = (epoch - <span class="number">1</span>) * n_train_batches + minibatch_index  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">iter</span> + <span class="number">1</span>) % validation_frequency == <span class="number">0</span>:  </span><br><span class="line">                <span class="comment"># compute zero-one loss on validation set  </span></span><br><span class="line">                validation_losses = [validate_model(i) <span class="keyword">for</span> i  </span><br><span class="line">                                     <span class="keyword">in</span> <span class="built_in">range</span>(n_valid_batches)]  </span><br><span class="line">                this_validation_loss = numpy.mean(validation_losses)  </span><br><span class="line">  </span><br><span class="line">                <span class="built_in">print</span>(  </span><br><span class="line">                    <span class="string">&#x27;epoch %i, minibatch %i/%i, validation error %f %%&#x27;</span> %  </span><br><span class="line">                    (  </span><br><span class="line">                        epoch,  </span><br><span class="line">                        minibatch_index + <span class="number">1</span>,  </span><br><span class="line">                        n_train_batches,  </span><br><span class="line">                        this_validation_loss * <span class="number">100.</span>  </span><br><span class="line">                    )  </span><br><span class="line">                )  </span><br><span class="line">  </span><br><span class="line">                <span class="comment"># if we got the best validation score until now  </span></span><br><span class="line">                <span class="keyword">if</span> this_validation_loss &lt; best_validation_loss:  </span><br><span class="line">                    <span class="comment">#improve patience if loss improvement is good enough  </span></span><br><span class="line">                    <span class="keyword">if</span> (  </span><br><span class="line">                        this_validation_loss &lt; best_validation_loss *  </span><br><span class="line">                        improvement_threshold  </span><br><span class="line">                    ):  </span><br><span class="line">                        patience = <span class="built_in">max</span>(patience, <span class="built_in">iter</span> * patience_increase)  </span><br><span class="line">  </span><br><span class="line">                    best_validation_loss = this_validation_loss  </span><br><span class="line">                    best_iter = <span class="built_in">iter</span>  </span><br><span class="line">  </span><br><span class="line">                    <span class="comment"># test it on the test set  </span></span><br><span class="line">                    test_losses = [test_model(i) <span class="keyword">for</span> i  </span><br><span class="line">                                   <span class="keyword">in</span> <span class="built_in">range</span>(n_test_batches)]  </span><br><span class="line">                    test_score = numpy.mean(test_losses)  </span><br><span class="line">  </span><br><span class="line">                    <span class="built_in">print</span>((<span class="string">&#x27;     epoch %i, minibatch %i/%i, test error of &#x27;</span>  </span><br><span class="line">                           <span class="string">&#x27;best model %f %%&#x27;</span>) %  </span><br><span class="line">                          (epoch, minibatch_index + <span class="number">1</span>, n_train_batches,  </span><br><span class="line">                           test_score * <span class="number">100.</span>))  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> patience &lt;= <span class="built_in">iter</span>:  </span><br><span class="line">                done_looping = <span class="literal">True</span>  </span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">  </span><br><span class="line">    end_time = timeit.default_timer()  </span><br><span class="line">    <span class="built_in">print</span>((<span class="string">&#x27;Optimization complete. Best validation score of %f %% &#x27;</span>  </span><br><span class="line">           <span class="string">&#x27;obtained at iteration %i, with test performance %f %%&#x27;</span>) %  </span><br><span class="line">          (best_validation_loss * <span class="number">100.</span>, best_iter + <span class="number">1</span>, test_score * <span class="number">100.</span>))  </span><br><span class="line">    <span class="built_in">print</span>((<span class="string">&#x27;The code for file &#x27;</span> +  </span><br><span class="line">           os.path.split(__file__)[<span class="number">1</span>] +  </span><br><span class="line">           <span class="string">&#x27; ran for %.2fm&#x27;</span> % ((end_time - start_time) / <span class="number">60.</span>)), file=sys.stderr)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    test_mlp()  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>神经网络算法</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>径向基函数网络</title>
    <url>/posts/2cf75940.html</url>
    <content><![CDATA[<h2 id="径向基函数网络-Radial-Basis-Function-Network">径向基函数网络(Radial Basis Function Network)</h2>
<p>在数学建模领域，径向基函数网络（Radial basis function network，缩写 RBF network）是一种使用径向基函数作为激活函数的人工神经网络。<br>
RBF神经网络是基于人脑的神经元细胞对外界反应的局部性而提出的新颖的、有效的前馈式神经网络，具有良好的局部逼近特性。它的数学理论基础成形于1985年由Powell首先提出的多变量插值的径向基函数，1988年被Broomhead和Lowe应用到神经网络设计领域，最终形成了RBF神经网络。径向基函数网络的输出是输入的径向基函数和神经元参数的线性组合。径向基函数网络具有多种用途，包括包括函数近似法、时间序列预测、分类和系统控制。他们最早由布鲁姆赫德（Broomhead）和洛维（Lowe）在1988年建立。</p>
<p>RBF神经网络是一种三层前馈神经网络。第一层为输入层，由信号源节点构成，将网络与外界环境连结起来，节点数由输入信号的维数确定；第二层为隐含层（径向基层），其节点由径向基函数构成，实现输入空间到隐层空间的非线性变换；第三层为输出层（线性层），对输入模式做出响应，其节点由隐含层节点给出的基函数的线性组合来计算。</p>
<p align="center">
<img width="500" align="center" src="/img/images/331.jpg" />
</p>
<p>径向基神经网络的激活函数采用径向基函数，通常定义为空间任一点到某一中心之间欧氏距离的单调函数。径向基神经网络的激活函数是以输入向量和权值向量之间的距离<img width="60" align="center" src="/img/images/332.jpg" /> 为自变量的。径向神经网络的激活函数一般表达式为</p>
<p align="center">
<img width="300" align="center" src="/img/images/333.jpg" />
</p>
<p>随着权值和输入向量之间距离的减少，网络输出是递增的，当输入向量和权值向量一致时，神经元输出1。b为阈值，用于调整神经元的灵敏度。利用径向基神经元和线性神经元可以建立广义回归神经网络，该种神经网络适用于函数逼近方面的应用；径向基神经元和竞争神经元可以组件概率神经网络，此种神经网络适用于解决分类问题。输出层和隐含层所完成的任务是不同的，因而它们的学习策略也不相同。输出层是对线性权进行调整，采用的是线性优化策略，因而学习速度较快。而隐函数是对激活函数（格林函数或高斯函数，一般为高斯函数）的参数进行调整，采用的是非线性优化策略，因而学习速度较慢。</p>
<p>尽管RBF网络的输出是隐单元输出的线性加权和，学习速度加快，但并不等于径向基神经网络就可以取代其他前馈网络。这是因为径向神经网络很可能需要比BP网络多得多的隐含层神经元来完成工作。</p>
<p>径向基神经网络中需要求解的参数有三个基函数的中心、方差以及隐含层到输出层的权值。根据径向基函数中心选取方法的不同，RBF网络有多种学习方法。下面介绍自组织选取中心的RBF神经网络学习法。此方法由两个阶段组成：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>自组织学习阶段，此阶段为无监督学习过程，求解隐含层基函数的中心与方差。</p>
</li>
<li class="lvl-2">
<p>监督学习阶段，此阶段求解隐含层到输出层之间的权值。</p>
</li>
</ul>
<p>径向基神经网络中常用的径向基函数是高斯函数，因此径向基神经网络的激活函数可表示为：</p>
<p align="center">
<img width="360" align="center" src="/img/images/334.jpg" />
</p>
<p>由此可得，径向基神经网络的结构可得到网络的输出为：</p>
<p align="center">
<img width="360" align="center" src="/img/images/335.jpg" />
</p>
<p>其中<img width="30" align="center" src="/img/images/336.jpg" />为第p个输入样本。h为隐含层的结点数。</p>
<p>如果d是样本的期望输出值，那么基函数的方差可表示为：</p>
<p align="center">
<img width="300" align="center" src="/img/images/337.jpg" />
</p>
<p>基于K-均值聚类方法求取基函数中心c:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>网络初始化 随机选取h个训练样本作为聚类中心<img width="30" align="center" src="/img/images/338.jpg" /></p>
</li>
<li class="lvl-2">
<p>将输入的训练样本集合按最近邻规则分组，按照<img width="30" align="center" src="/img/images/336.jpg" /> 与中心为<img width="30" align="center" src="/img/images/338.jpg" />之间的欧式距离将<img width="30" align="center" src="/img/images/336.jpg" />分配到输入样本的各个聚类集合<img width="30" align="center" src="/img/images/339.jpg" />之中。</p>
</li>
<li class="lvl-2">
<p>重新调整聚类中心 计算各个聚类集合<img width="30" align="center" src="/img/images/339.jpg" /> 中训练样本的平均值，即新的聚类中心<img width="30" align="center" src="/img/images/338.jpg" />， 如果新的聚类中心不再发生变化，所得到的<img width="30" align="center" src="/img/images/338.jpg" />就是RBF神经网络最终的基函数中心，否则返回上一步进行下一轮求解.</p>
</li>
</ul>
<p>求解方差<img width="30" align="center" src="/img/images/340.jpg" />:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>该RBF神经网络的基函数为高斯函数，因此方差<img width="30" align="center" src="/img/images/340.jpg" />可由下式求解得出:</p>
</li>
</ul>
<p align="center">
<img width="300" align="center" src="/img/images/341.jpg" />
</p>
<p>其中<img width="60" align="center" src="/img/images/342.jpg" />是所选取中心之间的最大距离.</p>
<p>计算隐含层和输出层之间的权值：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>用最小二乘法直接计算得到：</p>
</li>
</ul>
<p align="center">
<img width="500" align="center" src="/img/images/343.jpg" />
</p>
<h3 id="应用示例-17">应用示例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> pylab</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SAMPLES = <span class="number">75</span></span><br><span class="line">EPOCHS = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">TESTS = <span class="number">12</span></span><br><span class="line">RUNS = <span class="number">3</span></span><br><span class="line">MOD = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">x</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;Function to approximate: y = 0.5 + 0.4sin(2πx).&quot;&quot;&quot;</span></span><br><span class="line">  <span class="comment"># note: pylab.sin can accept a numpy.ndarray, but math.sin cannot</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0.5</span> + <span class="number">0.4</span>*pylab.sin(pylab.pi*<span class="number">2</span>*x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">noise</span>(<span class="params">x</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;Add uniform noise in intervale [-0.1, 0.1].&quot;&quot;&quot;</span></span><br><span class="line">  <span class="keyword">return</span> x + random.uniform(-<span class="number">0.1</span>, <span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sample</span>(<span class="params">n</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;Return sample of n random points uniformly distributed in [0, 1].&quot;&quot;&quot;</span></span><br><span class="line">  a = [random.random() <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">  a.sort()</span><br><span class="line">  <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gaussian</span>(<span class="params">radial, x</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;Return gaussian radial function.</span></span><br><span class="line"><span class="string">  Args:</span></span><br><span class="line"><span class="string">    radial: (num, num) of gaussian (base, width^2) pair</span></span><br><span class="line"><span class="string">    x: num of input</span></span><br><span class="line"><span class="string">  Returns:</span></span><br><span class="line"><span class="string">    num of gaussian output</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  base, width2 = radial</span><br><span class="line">  power = -<span class="number">1</span> / width2 / <span class="number">2</span> * (x-base)**<span class="number">2</span></span><br><span class="line">  y = pylab.exp(power)</span><br><span class="line">  <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">output</span>(<span class="params">radials, weights, x</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;Return set of linearly combined gaussian functions.</span></span><br><span class="line"><span class="string">  Args:</span></span><br><span class="line"><span class="string">    radials: [(num, num) of (base, width^2) pairs</span></span><br><span class="line"><span class="string">    weights: [num] of radial weights, |weights| -1 = |radials|</span></span><br><span class="line"><span class="string">    x: num of input</span></span><br><span class="line"><span class="string">  Returns:</span></span><br><span class="line"><span class="string">    num of linear combination of radial functions.</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  y = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> radial, weight <span class="keyword">in</span> <span class="built_in">zip</span>(radials, weights[:-<span class="number">1</span>]):</span><br><span class="line">    y += gaussian(radial, x) * weight</span><br><span class="line">  <span class="comment"># add bias</span></span><br><span class="line">  y += weights[-<span class="number">1</span>]</span><br><span class="line">  <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_weights</span>(<span class="params">eta, weights, radials, x, y, d</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;Update weight vector.</span></span><br><span class="line"><span class="string">  Returns:</span></span><br><span class="line"><span class="string">    [num] of updated weight vector, len = |weights|</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  new_weights = []</span><br><span class="line">  err = d-y</span><br><span class="line">  <span class="keyword">for</span> radial, weight <span class="keyword">in</span> <span class="built_in">zip</span>(radials, weights[:-<span class="number">1</span>]):</span><br><span class="line">    w = weight + (eta * err * gaussian(radial, x))</span><br><span class="line">    new_weights.append(w)</span><br><span class="line">  <span class="comment"># update bias</span></span><br><span class="line">  w = weights[-<span class="number">1</span>] + (eta * err)</span><br><span class="line">  new_weights.append(w)</span><br><span class="line">  <span class="keyword">return</span> new_weights</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">k_means</span>(<span class="params"><span class="built_in">input</span>, k</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;Return n Gaussian centers computed by K-means algorithm from sample x.</span></span><br><span class="line"><span class="string">  Args:</span></span><br><span class="line"><span class="string">    input: [num] of input vector</span></span><br><span class="line"><span class="string">    k: int number of bases, &lt;= |set(input)|</span></span><br><span class="line"><span class="string">  Returns:</span></span><br><span class="line"><span class="string">    [(num, [num])] k-size list of (center, input cluster) pairs.</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  <span class="comment"># initialize k bases as randomly selected unique elements from input</span></span><br><span class="line">  bases = random.sample(<span class="built_in">set</span>(<span class="built_in">input</span>), k)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># place all inputs in the first cluster to initialize</span></span><br><span class="line">  clusters = [ (x, <span class="number">0</span>) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">input</span> ]</span><br><span class="line">  updated = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(updated):</span><br><span class="line">    updated=<span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(clusters)):</span><br><span class="line">      x, m = clusters[i]</span><br><span class="line">      distances = [(<span class="built_in">abs</span>(b-x), j) <span class="keyword">for</span> j, b <span class="keyword">in</span> <span class="built_in">enumerate</span>(bases)]</span><br><span class="line">      d, j = <span class="built_in">min</span>(distances)</span><br><span class="line">      <span class="comment"># update to move x to a new base cluster</span></span><br><span class="line">      <span class="keyword">if</span> m != j:</span><br><span class="line">        updated = <span class="literal">True</span></span><br><span class="line">        clusters[i] = (x, j)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># update bases</span></span><br><span class="line">    <span class="keyword">if</span> updated:</span><br><span class="line">      base_sums = [ [<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(k)]</span><br><span class="line">      <span class="keyword">for</span> x, m <span class="keyword">in</span> clusters:</span><br><span class="line">        base_sums[m][<span class="number">0</span>] += x</span><br><span class="line">        base_sums[m][<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">      <span class="comment"># check for divide by zero errors</span></span><br><span class="line">      new_bases = []</span><br><span class="line">      <span class="keyword">for</span> s, n <span class="keyword">in</span> base_sums:</span><br><span class="line">        <span class="comment"># avoid rare edge case, &lt;1% @ n=25</span></span><br><span class="line">        <span class="comment"># division by zero: select a new base from input</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">          base = random.sample(<span class="built_in">set</span>(<span class="built_in">input</span>), <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          base = s / n</span><br><span class="line">        new_bases.append(base)</span><br><span class="line">      bases = new_bases</span><br><span class="line"></span><br><span class="line">  <span class="comment"># generate returned value</span></span><br><span class="line">  response = [ (b, []) <span class="keyword">for</span> b <span class="keyword">in</span> bases ]</span><br><span class="line">  <span class="keyword">for</span> x, m <span class="keyword">in</span> clusters:</span><br><span class="line">    response[m][<span class="number">1</span>].append(x)</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> response</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">variance_width</span>(<span class="params">k_meaned_x</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;Return mean, variance pairs computed from k_means(x, k).</span></span><br><span class="line"><span class="string">  Args:</span></span><br><span class="line"><span class="string">    k_meaned_x: [(num, [num])] of (base, input cluster) pairs</span></span><br><span class="line"><span class="string">  Returns:</span></span><br><span class="line"><span class="string">    [(num, num)] of (center, width^2) pairs.</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  response = []</span><br><span class="line">  <span class="keyword">for</span> base, cluster <span class="keyword">in</span> k_meaned_x:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(cluster) &gt; <span class="number">1</span>:</span><br><span class="line">      var = <span class="built_in">sum</span>([(base-x)**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> cluster]) / <span class="built_in">len</span>(cluster)</span><br><span class="line">      <span class="comment"># this actually produces excellent approximations</span></span><br><span class="line">      <span class="comment"># var = sum([(base-x)**2 for x in cluster])</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      var = <span class="literal">None</span></span><br><span class="line">    response.append((base, var))</span><br><span class="line"></span><br><span class="line">  <span class="comment"># set |cluster| widths to mean variance of other clusters</span></span><br><span class="line">  <span class="built_in">vars</span> = [v <span class="keyword">for</span> b, v <span class="keyword">in</span> response <span class="keyword">if</span> v]</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">vars</span>) == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&quot;No variance: cannot compute mean variance&quot;</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    var_mean = <span class="built_in">sum</span>(<span class="built_in">vars</span>) / <span class="built_in">len</span>(<span class="built_in">vars</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(response)):</span><br><span class="line">    base, var = response[i]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> var:</span><br><span class="line">      response[i] = (base, var_mean)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shared_width</span>(<span class="params">k_meaned_x</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;Return shared gaussian widths computed from k_means(x, k).</span></span><br><span class="line"><span class="string">  Args:</span></span><br><span class="line"><span class="string">    k_meaned_x: [(num, [num])] of (base, input cluster) pairs</span></span><br><span class="line"><span class="string">  Returns:</span></span><br><span class="line"><span class="string">    [(num, num)] of (center, width^2) pairs.</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  <span class="keyword">assert</span>(<span class="built_in">len</span>(k_meaned_x) &gt; <span class="number">1</span>)</span><br><span class="line">  <span class="comment"># ignore clusters</span></span><br><span class="line">  bases = [b <span class="keyword">for</span> b, cluster <span class="keyword">in</span> k_meaned_x]</span><br><span class="line">  <span class="comment"># compute distances between adjancent bases</span></span><br><span class="line">  s_bases = bases[:]</span><br><span class="line">  s_bases.sort()</span><br><span class="line">  distances = <span class="built_in">map</span>(<span class="keyword">lambda</span> p: <span class="built_in">abs</span>(p[<span class="number">0</span>]-p[<span class="number">1</span>]), <span class="built_in">zip</span>(s_bases, s_bases[<span class="number">1</span>:]))</span><br><span class="line">  max_d = <span class="built_in">max</span>(distances)</span><br><span class="line">  sigma_sq = (max_d / <span class="number">2</span>**<span class="number">0.5</span>)**<span class="number">2</span></span><br><span class="line">  <span class="comment"># map to outputs </span></span><br><span class="line">  response = [(b, sigma_sq) <span class="keyword">for</span> b <span class="keyword">in</span> bases]</span><br><span class="line">  <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_instance</span>(<span class="params">name, x, ideal_y, measured_y, trained_y, new_x, estimated_y</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;Plot function graph, save to file.</span></span><br><span class="line"><span class="string">  Effect: saves png file of plot to currect directory.</span></span><br><span class="line"><span class="string">  NOTE: use local graph variable</span></span><br><span class="line"><span class="string">  Args:</span></span><br><span class="line"><span class="string">    name: str of plot name, used in file name like &quot;name.png&quot;</span></span><br><span class="line"><span class="string">    x: [num] input vector</span></span><br><span class="line"><span class="string">    ideal_y: [num] ideal output vector</span></span><br><span class="line"><span class="string">    measured_y: [num] noisy output vector</span></span><br><span class="line"><span class="string">    trained_y: [num] trained output vector</span></span><br><span class="line"><span class="string">    new_x: [num] new input sample not used in training</span></span><br><span class="line"><span class="string">    estimated_y: [num] estimated output from trained RBN</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  <span class="comment"># plot graph</span></span><br><span class="line">  pylab.rc(<span class="string">&#x27;text&#x27;</span>, usetex=<span class="literal">True</span>)</span><br><span class="line">  pylab.rc(<span class="string">&#x27;font&#x27;</span>, family=<span class="string">&#x27;serif&#x27;</span>)</span><br><span class="line">  pylab.xlabel(<span class="string">&#x27;$x$&#x27;</span>)</span><br><span class="line">  pylab.ylabel(<span class="string">&#x27;$y = 0.5 + 0.4\sin(2 \pi x)$&#x27;</span>)</span><br><span class="line">  pylab.title(<span class="string">&#x27;RBF Network: %s&#x27;</span> % name)</span><br><span class="line">  pylab.plot(x, ideal_y, <span class="string">&#x27;g&#x27;</span>, label=<span class="string">&quot;Ideal&quot;</span>)</span><br><span class="line">  pylab.plot(x, measured_y, <span class="string">&#x27;bo&#x27;</span>, label=<span class="string">&quot;Measured&quot;</span>)</span><br><span class="line">  pylab.plot(x, trained_y, <span class="string">&#x27;y&#x27;</span>, label=<span class="string">&quot;Trained&quot;</span>)</span><br><span class="line">  pylab.plot(new_x, estimated_y, <span class="string">&#x27;r&#x27;</span>, label=<span class="string">&quot;Generalized&quot;</span>)</span><br><span class="line">  pylab.legend()</span><br><span class="line">  <span class="comment">#  pylab.grid(True)</span></span><br><span class="line">  filename = name</span><br><span class="line">  filename = filename.replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;_&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;$&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  filename = filename.replace(<span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="comment"># save figure</span></span><br><span class="line">  pylab.savefig(<span class="string">&quot;%s.png&quot;</span> % filename)</span><br><span class="line">  <span class="comment"># clear this figure</span></span><br><span class="line">  <span class="comment"># note: use http://matplotlib.sourceforge.net/users/artists.html#artist-tutorial</span></span><br><span class="line">  <span class="comment">#  in the future</span></span><br><span class="line">  pylab.clf()</span><br><span class="line">  pylab.cla()</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">error</span>(<span class="params">actual, expected</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;Return error from actual to expected.</span></span><br><span class="line"><span class="string">  Args</span></span><br><span class="line"><span class="string">    actual: [num] of sampled output</span></span><br><span class="line"><span class="string">    expected: [num] of expected ouput, ||expected|| = ||actual||</span></span><br><span class="line"><span class="string">  Returns:</span></span><br><span class="line"><span class="string">    num of average distance between actual and expected</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  sum_d = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> a, e <span class="keyword">in</span> <span class="built_in">zip</span>(actual, expected):</span><br><span class="line">    sum_d += <span class="built_in">abs</span>(a-e)</span><br><span class="line">  err = sum_d / <span class="built_in">len</span>(expected)</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_test</span>(<span class="params">eta, k, tests=TESTS, runs=RUNS, f_width=variance_width, graph_mod=MOD</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;Run an RBF training test set; plot, return errors from results.</span></span><br><span class="line"><span class="string">  Args:</span></span><br><span class="line"><span class="string">    eta: num of training rate</span></span><br><span class="line"><span class="string">    k: num of bases</span></span><br><span class="line"><span class="string">    tests: num of sample set iterations</span></span><br><span class="line"><span class="string">    runs: num of network generation iterations</span></span><br><span class="line"><span class="string">    f_width: function to generate radial widths</span></span><br><span class="line"><span class="string">    graph_mod: num of after how many iterations to plot a graph</span></span><br><span class="line"><span class="string">  Returns:</span></span><br><span class="line"><span class="string">    &#123;str: [num]&#125; such that n = (tests*runs) and:</span></span><br><span class="line"><span class="string">      &quot;sample_err&quot;: [num] of n sampling errors</span></span><br><span class="line"><span class="string">      &quot;train_err&quot;: [num] of n training errors</span></span><br><span class="line"><span class="string">      &quot;gen_err&quot;: [num] of n estimation errors</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  </span><br><span class="line">  results = &#123;</span><br><span class="line">    <span class="string">&quot;sample_err&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;train_err&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;gen_err&quot;</span>: [],</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  f_name = f_width.__name__.capitalize().split(<span class="string">&#x27;_&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">for</span> test <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,tests+<span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;## K=%d, eta=%.2f, Test=%d&quot;</span> % (k, eta, test)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># compute input samples</span></span><br><span class="line">    <span class="built_in">input</span> = sample(SAMPLES)</span><br><span class="line">    test_input = sample(SAMPLES)</span><br><span class="line">    <span class="comment"># compute desired and ideal outputs</span></span><br><span class="line">    ideal_y = <span class="built_in">map</span>(h, <span class="built_in">input</span>)</span><br><span class="line">    test_ideal_y = <span class="built_in">map</span>(h, test_input)</span><br><span class="line">    measured_y = <span class="built_in">map</span>(noise, ideal_y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># estimate each sample three times</span></span><br><span class="line">    <span class="keyword">for</span> run <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,runs+<span class="number">1</span>):</span><br><span class="line">      <span class="comment"># initialize K radials</span></span><br><span class="line">      radials = f_width(k_means(<span class="built_in">input</span>, k))</span><br><span class="line">      <span class="comment"># k+1 weights, last weight is bias</span></span><br><span class="line">      weights = [random.uniform(-<span class="number">0.5</span>, <span class="number">0.5</span>) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>)]</span><br><span class="line">      <span class="comment"># train all epochs</span></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(EPOCHS):</span><br><span class="line">        <span class="comment"># train one epoch</span></span><br><span class="line">        <span class="keyword">for</span> x, d <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">input</span>, measured_y):</span><br><span class="line">          y = output(radials, weights, x)</span><br><span class="line">          weights = update_weights(eta, weights, radials, x, y, d)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># examine results</span></span><br><span class="line">      trained_y = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: output(radials, weights, x), <span class="built_in">input</span>)</span><br><span class="line">      estimated_y = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: output(radials, weights, x), test_input)</span><br><span class="line">      sample_err = error(measured_y, ideal_y)</span><br><span class="line">      train_err = error(trained_y, measured_y)</span><br><span class="line">      gen_err = error(estimated_y, test_ideal_y)</span><br><span class="line">      </span><br><span class="line">      <span class="comment"># save results</span></span><br><span class="line">      results[<span class="string">&quot;sample_err&quot;</span>].append(sample_err)</span><br><span class="line">      results[<span class="string">&quot;train_err&quot;</span>].append(train_err)</span><br><span class="line">      results[<span class="string">&quot;gen_err&quot;</span>].append(gen_err)</span><br><span class="line"></span><br><span class="line"><span class="comment">#      print &quot;Run: %d, Sample: %.4f, Train: %.4f, General: %.4f&quot; \</span></span><br><span class="line"><span class="comment">#        % (run, sample_err, train_err, gen_err)</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># graph some set of results</span></span><br><span class="line">      iteration = (test-<span class="number">1</span>)*runs + run</span><br><span class="line">      <span class="keyword">if</span> (iteration % graph_mod) == <span class="number">0</span>:</span><br><span class="line"><span class="comment">#        print &quot;Graphing Test=%d, Run=%d&quot; % (test, run)</span></span><br><span class="line">        name = <span class="string">&quot;%s $K=%d, \eta =%.2f, E=%.3f$ (%d-%d)&quot;</span> % \</span><br><span class="line">          (f_name, k, eta, gen_err, test, run)</span><br><span class="line">        plot_instance( \</span><br><span class="line">          name, <span class="built_in">input</span>, ideal_y, measured_y, trained_y, test_input, estimated_y)</span><br><span class="line">  <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stats</span>(<span class="params">values</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;Return tuple of common statistical measures.</span></span><br><span class="line"><span class="string">  Returns:</span></span><br><span class="line"><span class="string">    (num, num, num, num) as (mean, std, min, max)</span></span><br><span class="line"><span class="string">   &quot;&quot;&quot;</span></span><br><span class="line">  mean = <span class="built_in">sum</span>(values) / <span class="built_in">len</span>(values)</span><br><span class="line">  sum_sqs = reduce(<span class="keyword">lambda</span> x, y: x + y*y, values)</span><br><span class="line">  var = <span class="built_in">sum</span>([(mean-x)**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> values]) / <span class="built_in">len</span>(values)</span><br><span class="line">  var = (sum_sqs - <span class="built_in">len</span>(values)*mean**<span class="number">2</span>) / <span class="built_in">len</span>(values)</span><br><span class="line">  std = var**<span class="number">0.5</span></span><br><span class="line">  min_var, max_var = <span class="built_in">min</span>(values), <span class="built_in">max</span>(values)</span><br><span class="line">  <span class="keyword">return</span> (mean, std, min_var, max_var)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">  random.seed()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># need final report</span></span><br><span class="line">  <span class="keyword">for</span> f_width <span class="keyword">in</span> (variance_width, shared_width):</span><br><span class="line">    <span class="keyword">for</span> eta <span class="keyword">in</span> (<span class="number">0.01</span>, <span class="number">0.02</span>):</span><br><span class="line">      <span class="keyword">for</span> k <span class="keyword">in</span> (<span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>):</span><br><span class="line">      </span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;BEGIN PARAMETER TEST SUITE&quot;</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;K=%d, eta=%.2f, f_width=%s, Tests=%d, Runs=%d&quot;</span> % \</span><br><span class="line">          (k, eta, f_width.__name__, TESTS, RUNS)</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;+++++++++++++++++++++++++++++++++++&quot;</span></span><br><span class="line">        r = run_test(k=k, eta=eta, f_width=f_width)</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;+++++++++++++++++++++++++++++++++++&quot;</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;RESULTS&quot;</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;K=%d, eta=%.2f, f_width=%s, Tests=%d, Runs=%d&quot;</span> % \</span><br><span class="line">          (k, eta, f_width.__name__, TESTS, RUNS)</span><br><span class="line">        <span class="keyword">for</span> name, values <span class="keyword">in</span> r.items():</span><br><span class="line">          <span class="built_in">print</span> name</span><br><span class="line">          <span class="built_in">print</span> <span class="string">&quot;mean=%.4f, std=%.4f, min=%.4f, max=%.4f&quot;</span> % \</span><br><span class="line">            stats(values)</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;+++++++++++++++++++++++++++++++++++&quot;</span></span><br><span class="line">               </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">  main()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>神经网络算法</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>玻尔兹曼机</title>
    <url>/posts/bb733ff7.html</url>
    <content><![CDATA[<h2 id="玻尔兹曼机-Boltzmann-Machine">玻尔兹曼机(Boltzmann Machine)</h2>
<p>玻尔兹曼机（Boltzmann machine）是随机神经网络和递归神经网络的一种，由杰弗里·辛顿(Geoffrey Hinton)和特里·谢泽诺斯基(Terry Sejnowski)在1985年发明。</p>
<p>玻尔兹曼机是一种特殊形式的对数线性的马尔科夫随机场（Markov Random Field，MRF），即能量函数是自由变量的线性函数。 通过引入隐含单元，我们可以提升模型的表达能力，表示非常复杂的概率分布。</p>
<p>玻尔兹曼机可被视作随机过程的，可生成的相应的Hopfield神经网络。它是最早能够学习内部表达，并能表达和（给定充足的时间）解决复杂的组合优化问题的神经网络。但是，没有特定限制连接方式的玻尔兹曼机目前为止并未被证明对机器学习的实际问题有什么用。所以它目前只在理论上显得有趣。然而，由于局部性和训练算法的赫布性质(Hebbian nature)，以及它们和简单物理过程相似的并行性，如果连接方式是受约束的（即受限玻尔兹曼机），学习方式在解决实际问题上将会足够高效。</p>
<p>它由玻尔兹曼分布得名。该分布用于玻尔兹曼机的抽样函数。</p>
<p align="center">
<img width="300" align="center" src="/img/images/330.jpg" />
</p>
<p>玻尔兹曼机的图像表示. 每条无向边都表示一对依赖关系. 在这个例子中有三个隐藏节点和四个可见节点，它并不是一个约束玻尔兹曼机（restricted Boltzmann machine）</p>
<h3 id="应用示例-18">应用示例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> unittest <span class="keyword">import</span> TestCase</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot</span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">&#x27;riri&#x27;</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">epsilon = <span class="number">0.000001</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">v</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-v))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hidden_activation_probability</span>(<span class="params">v,W,c</span>):</span><br><span class="line">    <span class="comment"># x is size k*v</span></span><br><span class="line">    <span class="comment"># W is size h*v</span></span><br><span class="line">    <span class="comment">#  W.T is size v*h</span></span><br><span class="line">    <span class="comment"># c is length h</span></span><br><span class="line">    <span class="comment"># result is size k*h</span></span><br><span class="line">    <span class="keyword">return</span> sigmoid(c + np.dot(v, W.T))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hidden_activation_probability_naive</span>(<span class="params">v,W,c</span>):</span><br><span class="line">    activations = np.zeros(W.shape[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> v.size != W.shape[<span class="number">1</span>]:</span><br><span class="line">        <span class="comment">#print v.size</span></span><br><span class="line">        <span class="comment">#print v.shape</span></span><br><span class="line">        <span class="comment">#print W.shape</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">assert</span>(v.size == W.shape[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(W.shape[<span class="number">0</span>]):</span><br><span class="line">        activations[i] = sigmoid(c[i] + <span class="built_in">sum</span>([W[i,j]*v[j] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(W.shape[<span class="number">1</span>])]))</span><br><span class="line">    <span class="keyword">return</span> activations</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">visible_activation_probability</span>(<span class="params">h,W,b</span>):</span><br><span class="line">    <span class="comment"># h is length k*h</span></span><br><span class="line">    <span class="comment"># W is size h*v</span></span><br><span class="line">    <span class="comment"># b is length v</span></span><br><span class="line">    <span class="comment"># result is size k*v</span></span><br><span class="line">    <span class="keyword">return</span> sigmoid(b + np.dot(h,W))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">visible_activation_probability_naive</span>(<span class="params">h,W,b</span>):</span><br><span class="line">    activations = np.zeros(W.shape[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">assert</span>(h.size == W.shape[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(W.shape[<span class="number">1</span>]):</span><br><span class="line">        activations[j] = sigmoid(b[j] + <span class="built_in">sum</span>([W[i,j]*h[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(W.shape[<span class="number">0</span>])]))</span><br><span class="line">    <span class="keyword">return</span> activations</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sample_hidden_units</span>(<span class="params">v,W,c</span>):</span><br><span class="line">    hidden_probabilities = hidden_activation_probability(v,W,c)</span><br><span class="line">    <span class="keyword">return</span> np.random.uniform(size=hidden_probabilities.shape) &lt; hidden_probabilities</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sample_hidden_units_naive</span>(<span class="params">v,W,c</span>):</span><br><span class="line">    hidden_probabilities = hidden_activation_probability_naive(v,W,c)</span><br><span class="line">    <span class="keyword">return</span> np.random.uniform(size=hidden_probabilities.shape) &lt; hidden_probabilities</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sample_visible_units</span>(<span class="params">h,W,b</span>):</span><br><span class="line">    visible_probabilities = visible_activation_probability(h,W,b)</span><br><span class="line">    <span class="keyword">return</span> np.random.uniform(size=visible_probabilities.shape) &lt; visible_activation_probability(h,W,b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sample_visible_units_naive</span>(<span class="params">h,W,b</span>):</span><br><span class="line">    visible_probabilities = visible_activation_probability_naive(h,W,b)</span><br><span class="line">    <span class="keyword">return</span> np.random.uniform(size=visible_probabilities.shape) &lt; visible_activation_probability(h,W,b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rbmUpdate_naive</span>(<span class="params">x, W, b, c, lr=<span class="number">0.1</span></span>):</span><br><span class="line">    h1 = sample_hidden_units_naive(x,W,c)</span><br><span class="line">    v2 = sample_visible_units_naive(h1,W,b)</span><br><span class="line">    q_v2 = visible_activation_probability_naive(h1,W,b)</span><br><span class="line">    q_h2 = hidden_activation_probability_naive(v2,W,c)</span><br><span class="line">    new_b = b + lr*(x-v2)</span><br><span class="line">    new_c = c + lr*(h1-q_h2)</span><br><span class="line">    a = np.outer(h1,x)</span><br><span class="line">    b = np.outer(q_h2,v2.T)</span><br><span class="line">    new_W = W + lr*(a-b)</span><br><span class="line">    error = np.<span class="built_in">sum</span>((x-q_v2)**<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> new_W,new_b,new_c,error</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rbmUpdate</span>(<span class="params">x,W,b,c,lr=<span class="number">0.1</span></span>):</span><br><span class="line">    h1 = sample_hidden_units(x,W,c)</span><br><span class="line">    v2 = sample_visible_units(h1,W,b)</span><br><span class="line">    q_v2 = visible_activation_probability(h1,W,b)</span><br><span class="line">    q_h2 = hidden_activation_probability(v2,W,c)</span><br><span class="line">    new_b = b + lr*(x-v2)</span><br><span class="line">    new_c = c + lr*(h1-q_h2)</span><br><span class="line">    a = np.outer(h1,x)</span><br><span class="line">    b = np.outer(q_h2,v2.T)</span><br><span class="line">    new_W = W + lr*(a-b)</span><br><span class="line">    error = np.<span class="built_in">sum</span>(np.<span class="built_in">sum</span>((x-q_v2)**<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> new_W,new_b,new_c,error</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RBM</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, visible_units, hidden_units</span>):</span><br><span class="line">        self.v = visible_units</span><br><span class="line">        self.h = hidden_units</span><br><span class="line">        self.W = np.random.random(size=(hidden_units, visible_units))</span><br><span class="line">        self.b = np.random.random(visible_units)</span><br><span class="line">        self.c = np.random.random(hidden_units)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self, data, lr=<span class="number">0.05</span>, max_iterations=<span class="number">1000</span>, eps=<span class="number">0.1</span></span>):</span><br><span class="line">        iteration = <span class="number">0</span></span><br><span class="line">        last_error = eps+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> iteration &lt; max_iterations <span class="keyword">and</span> last_error &gt; eps:</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> data:</span><br><span class="line">                self.W,self.b,self.c,last_error = rbmUpdate(item, self.W,self.b,self.c,lr)</span><br><span class="line">            iteration += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> iteration % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span> last_error</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">train_naive</span>(<span class="params">self,data,lr=<span class="number">0.05</span>,max_iterations=<span class="number">1000</span>,eps=<span class="number">0.1</span></span>):</span><br><span class="line">        iteration = <span class="number">0</span></span><br><span class="line">        last_error = eps+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> iteration &lt; max_iterations <span class="keyword">and</span> last_error &gt; eps:</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> data:</span><br><span class="line">                self.W,self.b,self.c,last_error = rbmUpdate_naive(item, self.W,self.b,self.c,lr)</span><br><span class="line">            iteration += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> iteration % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span> last_error</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestAgainstNaive</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, h_size, v_size</span>):</span><br><span class="line">        self.h_size = h_size</span><br><span class="line">        self.v_size = v_size</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_hidden</span>(<span class="params">self</span>):</span><br><span class="line">        h_size = self.h_size</span><br><span class="line">        v_size = self.v_size</span><br><span class="line">        ww = np.random.uniform(size=(h_size,v_size))</span><br><span class="line">        bb = np.random.uniform(size=v_size)</span><br><span class="line">        cc = np.random.uniform(size=h_size)</span><br><span class="line">        vv = np.random.uniform(size=v_size)</span><br><span class="line">        h1 = hidden_activation_probability_naive(vv,ww,cc)</span><br><span class="line">        h2 = hidden_activation_probability(vv,ww,cc)</span><br><span class="line">        <span class="keyword">assert</span>(h1.shape == h2.shape)</span><br><span class="line">        <span class="keyword">assert</span>(h1.size == h_size)</span><br><span class="line">        <span class="keyword">assert</span>(<span class="built_in">all</span>(np.<span class="built_in">abs</span>(h1 - h2) &lt; epsilon))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_visible</span>(<span class="params">self</span>):</span><br><span class="line">        h_size = self.h_size</span><br><span class="line">        v_size = self.v_size</span><br><span class="line">        ww = np.random.uniform(size=(h_size,v_size))</span><br><span class="line">        bb = np.random.uniform(size=v_size)</span><br><span class="line">        hh = np.random.uniform(size=h_size)</span><br><span class="line">        v1 = visible_activation_probability_naive(hh,ww,bb)</span><br><span class="line">        v2 = visible_activation_probability(hh,ww,bb)</span><br><span class="line">        <span class="keyword">assert</span>(v1.shape == v2.shape)</span><br><span class="line">        <span class="keyword">assert</span>(v1.size == v_size)</span><br><span class="line">        <span class="keyword">assert</span>(<span class="built_in">all</span>(np.<span class="built_in">abs</span>(v1 - v2) &lt; epsilon))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_update</span>(<span class="params">self</span>):</span><br><span class="line">        h_size = self.h_size</span><br><span class="line">        v_size = self.v_size</span><br><span class="line">        ww = np.random.uniform(size=(h_size,v_size))</span><br><span class="line">        bb = np.random.uniform(size=v_size)</span><br><span class="line">        cc = np.random.uniform(size=h_size)</span><br><span class="line">        vv = np.random.uniform(size=v_size)</span><br><span class="line">        (nw1,nb1,nc1,e1) = rbmUpdate(vv,ww,bb,cc)</span><br><span class="line">        (nw2,nb2,nc2,e2) = rbmUpdate_naive(vv,ww,bb,cc)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># The bounds for this are a bit larger, because</span></span><br><span class="line">        <span class="comment"># more goes one, so there are more chances for</span></span><br><span class="line">        <span class="comment"># divergence.</span></span><br><span class="line">        <span class="keyword">assert</span>(np.<span class="built_in">all</span>(np.<span class="built_in">abs</span>(nw1-nw2) &lt; epsilon*<span class="number">5</span>))</span><br><span class="line">        <span class="keyword">assert</span>(np.<span class="built_in">all</span>(np.<span class="built_in">abs</span>(nb1-nb2) &lt; epsilon*<span class="number">5</span>))</span><br><span class="line">        <span class="keyword">assert</span>(np.<span class="built_in">all</span>(np.<span class="built_in">abs</span>(nc1-nc2) &lt; epsilon*<span class="number">5</span>))</span><br><span class="line">        <span class="keyword">assert</span>(np.<span class="built_in">all</span>(np.<span class="built_in">abs</span>(e1-e2) &lt; epsilon*<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chunkfiles</span>(<span class="params">files</span>):</span><br><span class="line">    splitwords = []</span><br><span class="line">    vocab = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> files:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">            splitwords.append(<span class="built_in">set</span>(line.split()))</span><br><span class="line">            vocab = vocab.union(line.split())</span><br><span class="line">    entries = []</span><br><span class="line">    vocablist = <span class="built_in">list</span>(vocab)</span><br><span class="line">    <span class="keyword">for</span> entry <span class="keyword">in</span> splitwords:</span><br><span class="line">        entries.append([<span class="number">1</span> <span class="keyword">if</span> word <span class="keyword">in</span> entry <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> word <span class="keyword">in</span> vocablist])</span><br><span class="line">    <span class="keyword">return</span> entries</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">splitfiles</span>(<span class="params">files</span>):</span><br><span class="line">    splitwords = []</span><br><span class="line">    vocab = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> files:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">            splitwords.append(<span class="built_in">set</span>(line.split()))</span><br><span class="line">            vocab = vocab.union(line.split())</span><br><span class="line">    <span class="keyword">return</span> splitwords</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">go</span>():</span><br><span class="line">    tests = <span class="number">1</span></span><br><span class="line">    magnitude_mat = np.zeros((<span class="number">7</span>,<span class="number">4</span>*tests))</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./movies.txt&#x27;</span>) <span class="keyword">as</span> movies:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./matrices.txt&#x27;</span>) <span class="keyword">as</span> matrices:</span><br><span class="line">            terms = chunkfiles([movies, matrices])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(tests):</span><br><span class="line">        training_data = np.array(terms[<span class="number">1</span>:-<span class="number">1</span>])</span><br><span class="line">        <span class="built_in">print</span> training_data.shape</span><br><span class="line">        r = RBM(<span class="number">399</span>, <span class="number">2</span>)</span><br><span class="line">        r.train(training_data ,max_iterations=<span class="number">500</span>,lr=<span class="number">0.1</span>)</span><br><span class="line">        movterm = np.array([terms[<span class="number">1</span>]])</span><br><span class="line">        matterm = np.array([terms[-<span class="number">1</span>]])</span><br><span class="line">        <span class="built_in">print</span> hidden_activation_probability(movterm,r.W,r.c)</span><br><span class="line">        <span class="built_in">print</span> hidden_activation_probability(matterm,r.W,r.c)</span><br><span class="line">    pyplot.imshow(magnitude_mat, interpolation=<span class="string">&#x27;nearest&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    h_size = np.floor(np.random.rand()*<span class="number">100</span>)</span><br><span class="line">    v_size = np.floor(np.random.rand()*<span class="number">100</span>)</span><br><span class="line">    test = TestAgainstNaive(h_size,v_size)</span><br><span class="line">    test.test_visible()</span><br><span class="line">    test.test_hidden()</span><br><span class="line">    test.test_update()</span><br><span class="line">    go()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>神经网络算法</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络算法简介</title>
    <url>/posts/43b3d7df.html</url>
    <content><![CDATA[<h2 id="人工神经网络-Artificial-Neural-Network">人工神经网络(Artificial Neural Network)</h2>
<p>人工神经网络 （Artificial Neural Network，ANN）简称神经网络(NN)，是基于生物学中神经网络的基本原理，在理解和抽象了人脑结构和外界刺激响应机制后，以网络拓扑知识为理论基础，模拟人脑的神经系统对复杂信息的处理机制的一种数学模型，根植于神经科学、数学、思维科学、人工智能、统计学、物理学、计算机科学以及工程科学的一门技术，通常用于解决分类和回归问题。具有并行分布的处理能力、高容错性、智能化和自学习等能力的特征，本质上是一个有大量简单元件相互连接而成的复杂网络，具有高度的非线性，能够进行复杂的逻辑操作和非线性关系实现的系统。</p>
<p>神经网络由大量的节点（或称神经元）之间相互联接构成，每个节点代表一种特定的输出函数，称为激活函数（activation function）；每两个节点间的连接都代表一个对于通过该连接信号的加权值，称之为权重（weight），神经网络就是通过这种方式来模拟人类的记忆。网络的输出则取决于网络的结构、网络的连接方式、权重和激活函数。而网络自身通常都是对自然界某种算法或者函数的逼近，也可能是对一种逻辑策略的表达，是对传统逻辑学演算的进一步延伸。</p>
<p align="center">
<img width="300" align="center" src="/img/images/1.jpg" />
</p>
<p>人工神经网络中，神经元处理单元可表示不同的对象，例如特征、字母、概念，或者一些有意义的抽象模式。网络中处理单元的类型分为三类：输入单元、输出单元和隐单元。输入单元接受外部世界的信号与数据；输出单元实现系统处理结果的输出；隐单元是处在输入和输出单元之间，不能由系统外部观察的单元。神经元间的连接权值反映了单元间的连接强度，信息的表示和处理体现在网络处理单元的连接关系中。</p>
<p>应用领域：神经网络克服了传统人工智能方法对于直觉的缺陷，因而在神经专家系统、模式识别、智能控制、组合优化、预测等领域有成功的应用。</p>
<p>人工神经网络(Artificial Neural Network)算法应用：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>自动编码器(Autoencoder)</p>
</li>
<li class="lvl-2">
<p>反向传播(Backpropagation)</p>
</li>
<li class="lvl-2">
<p>递归神经网络(Recurrent Neural Network)</p>
</li>
<li class="lvl-2">
<p>多层感知器(Multilayer Perceptron)</p>
</li>
<li class="lvl-2">
<p>玻尔兹曼机(Boltzmann Machine)</p>
</li>
<li class="lvl-2">
<p>卷积神经网络(Convolutional Neural Network)</p>
</li>
<li class="lvl-2">
<p>Hopfield网络(Hopfield Network)]()</p>
</li>
<li class="lvl-2">
<p>径向基函数网络(Radial Basis Function Network)</p>
</li>
<li class="lvl-2">
<p>受限玻尔兹曼机(Restricted Boltzmann Machine)</p>
</li>
<li class="lvl-2">
<p>自组织映射(Self-Organizing Map)</p>
</li>
<li class="lvl-2">
<p>尖峰神经网络(Spiking Neural Network)</p>
</li>
</ul>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>神经网络算法</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>脉冲神经网络</title>
    <url>/posts/8e3765f1.html</url>
    <content><![CDATA[<h2 id="脉冲神经网络-Spiking-Neural-Network">脉冲神经网络(Spiking Neural Network)</h2>
<p>脉冲神经网络Spiking neuralnetworks (SNNs)是第三代神经网络模型，其模拟神经元更加接近实际，除此之外，把时间信息的影响也考虑其中。思路是这样的，动态神经网络中的神经元不是在每一次迭代传播中都被激活（而在典型的多层感知机网络中却是），而是在它的膜电位达到某一个特定值才被激活。当一个神经元被激活，它会产生一个信号传递给其他神经元，提高或降低其膜电位。</p>
<p>脉冲神经网络，其模拟神经元更加接近实际，除此之外，把时间信息的影响也考虑其中。思路是这样的，动态神经网络中的神经元不是在每一次迭代传播中都被激活（而在典型的多层感知机网络中却是），而是在它的膜电位达到某一个特定值才被激活。当一个神经元被激活，它会产生一个信号传递给其他神经元，提高或降低其膜电位。在脉冲神经网络中，神经元的当前激活水平（被建模成某种微分方程）通常被认为是当前状态，一个输入脉冲会使当前这个值升高，持续一段时间，然后逐渐衰退。出现了很多编码方式把这些输出脉冲序列解释为一个实际的数字，这些编码方式会同时考虑到脉冲频率和脉冲间隔时间。</p>
<p>借助于神经科学的研究，人们可以精确的建立基于脉冲产生时间神经网络模型。这种新型的神经网络采用脉冲编码(spike coding)，通过获得脉冲发生的精确时间，这种新型的神经网络可以进行获得更多的信息和更强的计算能力。</p>
<p>Alan Lloyd Hodgkin 和 Andrew Huxley在1952年提出了第一个脉冲神经网络模型，这个模型描述了动作电位是怎样产生并传播的。但是，脉冲并不是在神经元之间直接传播的，它需要在突触间隙间交换一种叫“神经递质”的化学物质。这种生物体的复杂性和可变性导致了许多不同的神经元模型的产生。</p>
<p>从信息论的观点来看，找到一种可以解释脉冲，也就是动作电位的模型是个问题。所以，神经科学的一个基本问题就是确定神经元是否通过时间编码来交流。时间编码表明单一的神经元可以取代上百个S型隐藏层节点。</p>
<p>这种神经网络大体上可以和传统的人工神经网络一样被用在信息处理中，而且脉冲神经网络可以对一个虚拟昆虫寻找食物的问题建模，而不需要环境的先验知识。并且，由于它更加接近现实的性能，使它可以用来学习生物神经系统的工作，电生理学的脉冲和脉冲神经网络在电脑上的模拟输出相比，确定了拓扑学和生物神经学的假说的可能性。</p>
<p>在实践中脉冲神经网络和已被证明的理论之间还存在一个主要的不同点。脉冲神经网络已被证明在神经科学系统中有作用，而在工程学中还无建树，一些大规模的神经网络已经被设计来利用脉冲神经网络中发现的脉冲编码，这些网络根据储备池计算的原则，但是现实中，大规模的脉冲神经网络计算由于所需计算资源多而产能小，发展受限，造成了只有很少的大规模脉冲神经网络被用来解决复杂的计算问题，而这些之前都是由第二代神经网络解决的。第二代神经网络模型中难以加入时间，脉冲神经网络（特别当算法定义为离散时间时）相当容易观察其动力学特征。我们很难建立一个具有稳定行为的模型来实现一个特定功能。</p>
<h3 id="应用示例-19">应用示例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> chainer, math</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> chainer <span class="keyword">import</span> cuda</span><br><span class="line"><span class="keyword">from</span> chainer <span class="keyword">import</span> function</span><br><span class="line"><span class="keyword">from</span> chainer.utils <span class="keyword">import</span> type_check</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SELU</span>(function.Function):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, alpha, lam</span>):</span><br><span class="line">		self.alpha = <span class="built_in">float</span>(alpha)</span><br><span class="line">		self.lam = <span class="built_in">float</span>(lam)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">check_type_forward</span>(<span class="params">self, in_types</span>):</span><br><span class="line">		type_check.expect(in_types.size() == <span class="number">1</span>)</span><br><span class="line">		x_type, = in_types</span><br><span class="line">		type_check.expect(x_type.dtype.kind == <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">forward_cpu</span>(<span class="params">self, x</span>):</span><br><span class="line">		y = x[<span class="number">0</span>].copy()</span><br><span class="line">		neg_indices = x[<span class="number">0</span>] &lt;= <span class="number">0</span></span><br><span class="line">		y[neg_indices] = self.alpha * (np.exp(y[neg_indices]) - <span class="number">1</span>)</span><br><span class="line">		y *= self.lam</span><br><span class="line">		<span class="keyword">return</span> y,</span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">forward_gpu</span>(<span class="params">self, x</span>):</span><br><span class="line">		y = cuda.elementwise(</span><br><span class="line">			<span class="string">&#x27;T x, T alpha, T lam&#x27;</span>, <span class="string">&#x27;T y&#x27;</span>,</span><br><span class="line">			<span class="string">&#x27;y = x &gt; 0 ? (T)(lam * x) : (T)(lam * alpha * (exp(x) - 1))&#x27;</span>,</span><br><span class="line">			<span class="string">&#x27;elu_fwd&#x27;</span>)(x[<span class="number">0</span>], self.alpha, self.lam)</span><br><span class="line">		<span class="keyword">return</span> y,</span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">backward_cpu</span>(<span class="params">self, x, gy</span>):</span><br><span class="line">		gx = gy[<span class="number">0</span>].copy()</span><br><span class="line">		neg_indices = x[<span class="number">0</span>] &lt;= <span class="number">0</span></span><br><span class="line">		gx[neg_indices] *= self.alpha * np.exp(x[<span class="number">0</span>][neg_indices])</span><br><span class="line">		gx *= self.lam</span><br><span class="line">		<span class="keyword">return</span> gx,</span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">backward_gpu</span>(<span class="params">self, x, gy</span>):</span><br><span class="line">		gx = cuda.elementwise(</span><br><span class="line">			<span class="string">&#x27;T x, T gy, T alpha, T lam&#x27;</span>, <span class="string">&#x27;T gx&#x27;</span>,</span><br><span class="line">			<span class="string">&#x27;gx = x &gt; 0 ? (T)(lam * gy) : (T)(lam * gy * alpha * exp(x))&#x27;</span>,</span><br><span class="line">			<span class="string">&#x27;elu_bwd&#x27;</span>)(</span><br><span class="line">				x[<span class="number">0</span>], gy[<span class="number">0</span>], self.alpha, self.lam)</span><br><span class="line">		<span class="keyword">return</span> gx,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">selu</span>(<span class="params">x, alpha=<span class="number">1.6732632423543772848170429916717</span>, lam=<span class="number">1.0507009873554804934193349852946</span></span>):</span><br><span class="line">	<span class="keyword">return</span> SELU(alpha, lam)(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dropout_selu</span>(<span class="params">x, ratio=<span class="number">0.1</span>, alpha=-<span class="number">1.7580993408473766</span></span>):</span><br><span class="line">	<span class="keyword">if</span> chainer.config.train == <span class="literal">False</span>:</span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">	q = <span class="number">1.0</span> - ratio</span><br><span class="line"></span><br><span class="line">	xp = cuda.get_array_module(*x)</span><br><span class="line">	<span class="keyword">if</span> xp == np:</span><br><span class="line">		d = np.random.rand(*x[<span class="number">0</span>].shape) &gt;= ratio</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		d = xp.random.rand(*x[<span class="number">0</span>].shape, dtype=np.float32) &gt;= ratio</span><br><span class="line"></span><br><span class="line">	a = math.<span class="built_in">pow</span>(q + alpha ** <span class="number">2</span> * q * (<span class="number">1</span> - q), -<span class="number">0.5</span>)</span><br><span class="line">	b = -a * (<span class="number">1</span> - q) * alpha</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> a * (x * d + alpha * (<span class="number">1</span> - d)) + b</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<a href="https://github.com/KeKe-Li/tutorial">https://github.com/KeKe-Li/tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>机器学习算法</category>
        <category>神经网络算法</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>自动编码器</title>
    <url>/posts/8ed365e4.html</url>
    <content><![CDATA[<h2 id="自动编码器-Autoencoder">自动编码器(Autoencoder)</h2>
<p>自动编码器(Autoencoder)是一种无监督的学习算法，主要用于数据的降维或者特征的抽取，在深度学习中，自动编码器(Autoencoder)可用于在训练阶段开始前，确定权重矩阵的初始值。</p>
<p>神经网络中的权重矩阵可看作是对输入的数据进行特征转换，即先将数据编码为另一种形式，然后在此基础上进行一系列学习。然而，在对权重初始化时，我们并不知道初始的权重值在训练时会起到怎样的作用，也不知道在训练过程中权重会怎样的变化。因此一种较好的思路是，利用初始化生成的权重矩阵进行编码时，我们希望编码后的数据能够较好的保留原始数据的主要特征。那么，如何衡量码后的数据是否保留了较完整的信息呢？答案是：如果编码后的数据能够较为容易地通过解码恢复成原始数据，我们则认为较好的保留了数据信息。</p>
<p>自动编码器(Autoencoder)中：原始input（设为x）经过加权（W、b)、映射（Sigmoid）之后得到y，再对y反向加权映射回来成为z。</p>
<p>通过反复迭代训练两组（W、b），使得误差函数最小，即尽可能保证z近似于x，即完美重构了x。</p>
<p>那么可以说正向第一组权（W、b）是成功的，很好的学习了input中的关键特征，不然也不会重构得如此完美.</p>
<p align="center">
<img width="300" align="center" src="/img/images/252.jpg" />
</p>
<p>这个过程很有趣，首先，它没有使用数据标签来计算误差update参数，所以是无监督学习。</p>
<p>其次，利用类似神经网络的双隐层的方式，简单粗暴地提取了样本的特征。</p>
<p>这个双隐层是有争议的，最初的编码器确实使用了两组（W，b），但是Vincent在2010年的论文中做了研究，发现只要单组W就可以了。</p>
<p>即W’=W^T, W和W’称为Tied Weights。实验证明，W’真的只是在打酱油，完全没有必要去做训练。</p>
<p>逆向重构矩阵让人想起了逆矩阵，若W<sup>-1=W</sup>T的话，W就是个正交矩阵了，即W是可以训成近似正交阵的。</p>
<p>由于W’就是个酱油，训练完之后就没它事了。正向传播用W即可，相当于为input预先编个码，再导入到下一layer去。所以叫自动编码器，而不叫自动编码解码器。</p>
<p>自动编码器相当于创建了一个隐层，一个简单想法就是加在深度网络的开头，作为原始信号的初级filter，起到降维、提取特征的效果。当然，这种做法就有一个问题，AutoEncoder可以看作是PCA的非线性补丁加强版，PCA的取得的效果是建立在降维基础上的。</p>
<p>仔细想想CNN这种结构，随着layer的推进，每层的神经元个数在递增，如果用了AutoEncoder去预训练，岂不是增维了？真的没问题？</p>
<p>相关论文中给出的实验结果认为AutoEncoder的增维效果还不赖，原因可能是非线性网络能力很强，尽管神经元个数增多，但是每个神经元的效果在衰减。</p>
<p>同时，随机梯度算法给了后续监督学习一个良好的开端。整体上，增维是利大于弊的。</p>
<h3 id="应用示例-20">应用示例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextAutoencoder</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Class that encapsulates the encoder-decoder architecture to</span></span><br><span class="line"><span class="string">    reconstruct pieces of text.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, lstm_units, embeddings, go, train=<span class="literal">True</span>,</span></span><br><span class="line"><span class="params">                 train_embeddings=<span class="literal">False</span>, bidirectional=<span class="literal">True</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize the encoder/decoder and creates Tensor objects</span></span><br><span class="line"><span class="string">        :param lstm_units: number of LSTM units</span></span><br><span class="line"><span class="string">        :param embeddings: numpy array with initial embeddings</span></span><br><span class="line"><span class="string">        :param go: index of the GO symbol in the embedding matrix</span></span><br><span class="line"><span class="string">        :param train_embeddings: whether to adjust embeddings during training</span></span><br><span class="line"><span class="string">        :param bidirectional: whether to create a bidirectional autoencoder</span></span><br><span class="line"><span class="string">            (if False, a simple linear LSTM is used)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># EOS and GO share the same symbol. Only GO needs to be embedded, and</span></span><br><span class="line">        <span class="comment"># only EOS exists as a possible network output</span></span><br><span class="line">        self.go = go</span><br><span class="line">        self.eos = go</span><br><span class="line"></span><br><span class="line">        self.bidirectional = bidirectional</span><br><span class="line">        self.vocab_size = embeddings.shape[<span class="number">0</span>]</span><br><span class="line">        self.embedding_size = embeddings.shape[<span class="number">1</span>]</span><br><span class="line">        self.global_step = tf.Variable(<span class="number">0</span>, name=<span class="string">&#x27;global_step&#x27;</span>, trainable=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># the sentence is the object to be memorized</span></span><br><span class="line">        self.sentence = tf.placeholder(tf.int32, [<span class="literal">None</span>, <span class="literal">None</span>], <span class="string">&#x27;sentence&#x27;</span>)</span><br><span class="line">        self.sentence_size = tf.placeholder(tf.int32, [<span class="literal">None</span>],</span><br><span class="line">                                            <span class="string">&#x27;sentence_size&#x27;</span>)</span><br><span class="line">        self.l2_constant = tf.placeholder(tf.float32, name=<span class="string">&#x27;l2_constant&#x27;</span>)</span><br><span class="line">        self.clip_value = tf.placeholder(tf.float32, name=<span class="string">&#x27;clip&#x27;</span>)</span><br><span class="line">        self.learning_rate = tf.placeholder(tf.float32, name=<span class="string">&#x27;learning_rate&#x27;</span>)</span><br><span class="line">        self.dropout_keep = tf.placeholder(tf.float32, name=<span class="string">&#x27;dropout_keep&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.decoder_step_input = tf.placeholder(tf.int32,</span><br><span class="line">                                                 [<span class="literal">None</span>],</span><br><span class="line">                                                 <span class="string">&#x27;prediction_step&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        name = <span class="string">&#x27;decoder_fw_step_state_c&#x27;</span></span><br><span class="line">        self.decoder_fw_step_c = tf.placeholder(tf.float32,</span><br><span class="line">                                                [<span class="literal">None</span>, lstm_units], name)</span><br><span class="line">        name = <span class="string">&#x27;decoder_fw_step_state_h&#x27;</span></span><br><span class="line">        self.decoder_fw_step_h = tf.placeholder(tf.float32,</span><br><span class="line">                                                [<span class="literal">None</span>, lstm_units], name)</span><br><span class="line">        self.decoder_bw_step_c = tf.placeholder(tf.float32,</span><br><span class="line">                                                [<span class="literal">None</span>, lstm_units],</span><br><span class="line">                                                <span class="string">&#x27;decoder_bw_step_state_c&#x27;</span>)</span><br><span class="line">        self.decoder_bw_step_h = tf.placeholder(tf.float32,</span><br><span class="line">                                                [<span class="literal">None</span>, lstm_units],</span><br><span class="line">                                                <span class="string">&#x27;decoder_bw_step_state_h&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;autoencoder&#x27;</span>) <span class="keyword">as</span> self.scope:</span><br><span class="line">            self.embeddings = tf.Variable(embeddings, name=<span class="string">&#x27;embeddings&#x27;</span>,</span><br><span class="line">                                          trainable=train_embeddings)</span><br><span class="line"></span><br><span class="line">            initializer = tf.glorot_normal_initializer()</span><br><span class="line">            self.lstm_fw = tf.nn.rnn_cell.LSTMCell(lstm_units,</span><br><span class="line">                                                   initializer=initializer)</span><br><span class="line">            self.lstm_bw = tf.nn.rnn_cell.LSTMCell(lstm_units,</span><br><span class="line">                                                   initializer=initializer)</span><br><span class="line"></span><br><span class="line">            embedded = tf.nn.embedding_lookup(self.embeddings, self.sentence)</span><br><span class="line">            embedded = tf.nn.dropout(embedded, self.dropout_keep)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># encoding step</span></span><br><span class="line">            <span class="keyword">if</span> bidirectional:</span><br><span class="line">                bdr = tf.nn.bidirectional_dynamic_rnn</span><br><span class="line">                ret = bdr(self.lstm_fw, self.lstm_bw,</span><br><span class="line">                          embedded, dtype=tf.float32,</span><br><span class="line">                          sequence_length=self.sentence_size,</span><br><span class="line">                          scope=self.scope)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ret = tf.nn.dynamic_rnn(self.lstm_fw, embedded,</span><br><span class="line">                                        dtype=tf.float32,</span><br><span class="line">                                        sequence_length=self.sentence_size,</span><br><span class="line">                                        scope=self.scope)</span><br><span class="line">            _, self.encoded_state = ret</span><br><span class="line">            <span class="keyword">if</span> bidirectional:</span><br><span class="line">                encoded_state_fw, encoded_state_bw = self.encoded_state</span><br><span class="line"></span><br><span class="line">                <span class="comment"># set the scope name used inside the decoder.</span></span><br><span class="line">                <span class="comment"># maybe there&#x27;s a more elegant way to do it?</span></span><br><span class="line">                fw_scope_name = self.scope.name + <span class="string">&#x27;/fw&#x27;</span></span><br><span class="line">                bw_scope_name = self.scope.name + <span class="string">&#x27;/bw&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                encoded_state_fw = self.encoded_state</span><br><span class="line">                fw_scope_name = self.scope</span><br><span class="line"></span><br><span class="line">            self.scope.reuse_variables()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># generate a batch of embedded GO</span></span><br><span class="line">            <span class="comment"># sentence_size has the batch dimension</span></span><br><span class="line">            go_batch = self._generate_batch_go(self.sentence_size)</span><br><span class="line">            embedded_eos = tf.nn.embedding_lookup(self.embeddings,</span><br><span class="line">                                                  go_batch)</span><br><span class="line">            embedded_eos = tf.reshape(embedded_eos,</span><br><span class="line">                                      [-<span class="number">1</span>, <span class="number">1</span>, self.embedding_size])</span><br><span class="line">            decoder_input = tf.concat([embedded_eos, embedded], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># decoding step</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># We give the same inputs to the forward and backward LSTMs,</span></span><br><span class="line">            <span class="comment"># but each one has its own hidden state</span></span><br><span class="line">            <span class="comment"># their outputs are concatenated and fed to the softmax layer</span></span><br><span class="line">            <span class="keyword">if</span> bidirectional:</span><br><span class="line">                outputs, _ = tf.nn.bidirectional_dynamic_rnn(</span><br><span class="line">                    self.lstm_fw, self.lstm_bw, decoder_input,</span><br><span class="line">                    self.sentence_size, encoded_state_fw, encoded_state_bw)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># concat fw and bw outputs</span></span><br><span class="line">                outputs = tf.concat(outputs, -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                outputs, _ = tf.nn.dynamic_rnn(</span><br><span class="line">                    self.lstm_fw, decoder_input, self.sentence_size,</span><br><span class="line">                    encoded_state_fw)</span><br><span class="line"></span><br><span class="line">            self.decoder_outputs = outputs</span><br><span class="line"></span><br><span class="line">        <span class="comment"># now project the outputs to the vocabulary</span></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;projection&#x27;</span>) <span class="keyword">as</span> self.projection_scope:</span><br><span class="line">            <span class="comment"># decoder_outputs has shape (batch, max_sentence_size, vocab_size)</span></span><br><span class="line">            self.logits = tf.layers.dense(outputs, self.vocab_size)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># tensors for running a model</span></span><br><span class="line">        embedded_step = tf.nn.embedding_lookup(self.embeddings,</span><br><span class="line">                                               self.decoder_step_input)</span><br><span class="line">        state_fw = tf.nn.rnn_cell.LSTMStateTuple(self.decoder_fw_step_c,</span><br><span class="line">                                                 self.decoder_fw_step_h)</span><br><span class="line">        state_bw = tf.nn.rnn_cell.LSTMStateTuple(self.decoder_bw_step_c,</span><br><span class="line">                                                 self.decoder_bw_step_h)</span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(fw_scope_name, reuse=<span class="literal">True</span>):</span><br><span class="line">            ret_fw = self.lstm_fw(embedded_step, state_fw)</span><br><span class="line">        step_output_fw, self.decoder_fw_step_state = ret_fw</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> bidirectional:</span><br><span class="line">            <span class="keyword">with</span> tf.variable_scope(bw_scope_name, reuse=<span class="literal">True</span>):</span><br><span class="line">                ret_bw = self.lstm_bw(embedded_step, state_bw)</span><br><span class="line">                step_output_bw, self.decoder_bw_step_state = ret_bw</span><br><span class="line">                step_output = tf.concat(axis=<span class="number">1</span>, values=[step_output_fw,</span><br><span class="line">                                                        step_output_bw])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            step_output = step_output_fw</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(self.projection_scope, reuse=<span class="literal">True</span>):</span><br><span class="line">            self.projected_step_output = tf.layers.dense(step_output,</span><br><span class="line">                                                         self.vocab_size)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> train:</span><br><span class="line">            self._create_training_tensors()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_create_training_tensors</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Create member variables related to training.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        eos_batch = self._generate_batch_go(self.sentence_size)</span><br><span class="line">        eos_batch = tf.reshape(eos_batch, [-<span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">        decoder_labels = tf.concat([self.sentence, eos_batch], -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        projection_vars = tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES,</span><br><span class="line">                                            scope=self.projection_scope.name)</span><br><span class="line">        <span class="comment"># a bit ugly, maybe we should improve this?</span></span><br><span class="line">        projection_w = [var <span class="keyword">for</span> var <span class="keyword">in</span> projection_vars</span><br><span class="line">                        <span class="keyword">if</span> <span class="string">&#x27;kernel&#x27;</span> <span class="keyword">in</span> var.name][<span class="number">0</span>]</span><br><span class="line">        projection_b = [var <span class="keyword">for</span> var <span class="keyword">in</span> projection_vars</span><br><span class="line">                        <span class="keyword">if</span> <span class="string">&#x27;bias&#x27;</span> <span class="keyword">in</span> var.name][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># set the importance of each time step</span></span><br><span class="line">        <span class="comment"># 1 if before sentence end or EOS itself; 0 otherwise</span></span><br><span class="line">        max_len = tf.shape(self.sentence)[<span class="number">1</span>]</span><br><span class="line">        mask = tf.sequence_mask(self.sentence_size + <span class="number">1</span>, max_len + <span class="number">1</span>, tf.float32)</span><br><span class="line">        num_actual_labels = tf.reduce_sum(mask)</span><br><span class="line">        projection_w_t = tf.transpose(projection_w)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># reshape to have batch and time steps in the same dimension</span></span><br><span class="line">        decoder_outputs2d = tf.reshape(self.decoder_outputs,</span><br><span class="line">                                       [-<span class="number">1</span>, tf.shape(self.decoder_outputs)[-<span class="number">1</span>]])</span><br><span class="line">        labels = tf.reshape(decoder_labels, [-<span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">        sampled_loss = tf.nn.sampled_softmax_loss(</span><br><span class="line">            projection_w_t, projection_b, labels, decoder_outputs2d, <span class="number">100</span>,</span><br><span class="line">            self.vocab_size)</span><br><span class="line"></span><br><span class="line">        masked_loss = tf.reshape(mask, [-<span class="number">1</span>]) * sampled_loss</span><br><span class="line">        self.loss = tf.reduce_sum(masked_loss) / num_actual_labels</span><br><span class="line"></span><br><span class="line">        optimizer = tf.train.AdamOptimizer(self.learning_rate)</span><br><span class="line">        gradients, v = <span class="built_in">zip</span>(*optimizer.compute_gradients(self.loss))</span><br><span class="line">        gradients, _ = tf.clip_by_global_norm(gradients, self.clip_value)</span><br><span class="line"></span><br><span class="line">        self.train_op = optimizer.apply_gradients(<span class="built_in">zip</span>(gradients, v),</span><br><span class="line">                                                  global_step=self.global_step)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_trainable_variables</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Return all trainable variables inside the model</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self, session, save_path, train_data, valid_data,</span></span><br><span class="line"><span class="params">              batch_size, epochs, learning_rate, dropout_keep,</span></span><br><span class="line"><span class="params">              clip_value, report_interval</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Train the model</span></span><br><span class="line"><span class="string">        :param session: tensorflow session</span></span><br><span class="line"><span class="string">        :param train_data: Dataset object with training data</span></span><br><span class="line"><span class="string">        :param valid_data: Dataset object with validation data</span></span><br><span class="line"><span class="string">        :param batch_size: batch size</span></span><br><span class="line"><span class="string">        :param learning_rate: initial learning rate</span></span><br><span class="line"><span class="string">        :param dropout_keep: the probability that each LSTM input/output is kept</span></span><br><span class="line"><span class="string">        :param epochs: how many epochs to train for</span></span><br><span class="line"><span class="string">        :param clip_value: value to clip tensor norm during training</span></span><br><span class="line"><span class="string">        :param save_path: folder to save the model</span></span><br><span class="line"><span class="string">        :param report_interval: report after that many batches</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        saver = tf.train.Saver(self.get_trainable_variables(),</span><br><span class="line">                               max_to_keep=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        best_loss = <span class="number">10000</span></span><br><span class="line">        accumulated_loss = <span class="number">0</span></span><br><span class="line">        batch_counter = <span class="number">0</span></span><br><span class="line">        num_sents = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># get all data at once. we need all matrices with the same size,</span></span><br><span class="line">        <span class="comment"># or else they don&#x27;t fit the placeholders</span></span><br><span class="line">        <span class="comment"># train_sents, train_sizes = train_data.join_all(self.go,</span></span><br><span class="line">        <span class="comment">#                                                self.num_time_steps,</span></span><br><span class="line">        <span class="comment">#                                                shuffle=True)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># del train_data  # save memory...</span></span><br><span class="line">        valid_sents, valid_sizes = valid_data.join_all(self.go,</span><br><span class="line">                                                       shuffle=<span class="literal">True</span>)</span><br><span class="line">        train_data.reset_epoch_counter()</span><br><span class="line">        feeds = &#123;self.clip_value: clip_value,</span><br><span class="line">                 self.dropout_keep: dropout_keep,</span><br><span class="line">                 self.learning_rate: learning_rate&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> train_data.epoch_counter &lt; epochs:</span><br><span class="line">            batch_counter += <span class="number">1</span></span><br><span class="line">            train_sents, train_sizes = train_data.next_batch(batch_size)</span><br><span class="line">            feeds[self.sentence] = train_sents</span><br><span class="line">            feeds[self.sentence_size] = train_sizes</span><br><span class="line"></span><br><span class="line">            _, loss = session.run([self.train_op, self.loss], feeds)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># multiply by len because some batches may be smaller</span></span><br><span class="line">            <span class="comment"># (due to bucketing), then take the average</span></span><br><span class="line">            accumulated_loss += loss * <span class="built_in">len</span>(train_sents)</span><br><span class="line">            num_sents += <span class="built_in">len</span>(train_sents)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> batch_counter % report_interval == <span class="number">0</span>:</span><br><span class="line">                avg_loss = accumulated_loss / num_sents</span><br><span class="line">                accumulated_loss = <span class="number">0</span></span><br><span class="line">                num_sents = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># we can&#x27;t use all the validation at once, since it would</span></span><br><span class="line">                <span class="comment"># take too much memory. running many small batches would</span></span><br><span class="line">                <span class="comment"># instead take too much time. So l